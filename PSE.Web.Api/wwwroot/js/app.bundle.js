webpackJsonp([1],{

/***/ 139:
/* exports provided: RESOURCE_CACHE_PROVIDER, platformBrowserDynamic, VERSION, ɵINTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS, ɵResourceLoaderImpl */
/* exports used: platformBrowserDynamic */
/*!**************************************************************************************!*\
  !*** ./~/@angular/platform-browser-dynamic/@angular/platform-browser-dynamic.es5.js ***!
  \**************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_compiler__ = __webpack_require__(/*! @angular/compiler */ 168);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(/*! @angular/core */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_common__ = __webpack_require__(/*! @angular/common */ 62);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__ = __webpack_require__(/*! @angular/platform-browser */ 63);\n/* unused harmony export RESOURCE_CACHE_PROVIDER */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return platformBrowserDynamic; });\n/* unused harmony export VERSION */\n/* unused harmony export ɵINTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS */\n/* unused harmony export ɵResourceLoaderImpl */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @license Angular v4.0.2\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\n\n\n\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ResourceLoaderImpl = (function (_super) {\n    __extends(ResourceLoaderImpl, _super);\n    function ResourceLoaderImpl() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ResourceLoaderImpl.prototype.get = function (url) {\n        var resolve;\n        var reject;\n        var promise = new Promise(function (res, rej) {\n            resolve = res;\n            reject = rej;\n        });\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'text';\n        xhr.onload = function () {\n            // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n            // response/responseType properties were introduced in ResourceLoader Level2 spec (supported\n            // by IE10)\n            var response = xhr.response || xhr.responseText;\n            // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n            var status = xhr.status === 1223 ? 204 : xhr.status;\n            // fix status code when it is 0 (0 status is undocumented).\n            // Occurs when accessing file resources or on Android 4.1 stock browser\n            // while retrieving files from application cache.\n            if (status === 0) {\n                status = response ? 200 : 0;\n            }\n            if (200 <= status && status <= 300) {\n                resolve(response);\n            }\n            else {\n                reject(\"Failed to load \" + url);\n            }\n        };\n        xhr.onerror = function () { reject(\"Failed to load \" + url); };\n        xhr.send();\n        return promise;\n    };\n    return ResourceLoaderImpl;\n}(__WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"a\" /* ResourceLoader */]));\nResourceLoaderImpl.decorators = [\n    { type: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"e\" /* Injectable */] },\n];\n/** @nocollapse */\nResourceLoaderImpl.ctorParameters = function () { return []; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS = [\n    __WEBPACK_IMPORTED_MODULE_3__angular_platform_browser__[\"b\" /* ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS */],\n    {\n        provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"Y\" /* COMPILER_OPTIONS */],\n        useValue: { providers: [{ provide: __WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"a\" /* ResourceLoader */], useClass: ResourceLoaderImpl }] },\n        multi: true\n    },\n    { provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"r\" /* PLATFORM_ID */], useValue: __WEBPACK_IMPORTED_MODULE_2__angular_common__[\"b\" /* ɵPLATFORM_BROWSER_ID */] },\n];\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An implementation of ResourceLoader that uses a template cache to avoid doing an actual\n * ResourceLoader.\n *\n * The template cache needs to be built and loaded into window.$templateCache\n * via a separate mechanism.\n */\nvar CachedResourceLoader = (function (_super) {\n    __extends(CachedResourceLoader, _super);\n    function CachedResourceLoader() {\n        var _this = _super.call(this) || this;\n        _this._cache = __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"c\" /* ɵglobal */].$templateCache;\n        if (_this._cache == null) {\n            throw new Error('CachedResourceLoader: Template cache was not found in $templateCache.');\n        }\n        return _this;\n    }\n    CachedResourceLoader.prototype.get = function (url) {\n        if (this._cache.hasOwnProperty(url)) {\n            return Promise.resolve(this._cache[url]);\n        }\n        else {\n            return Promise.reject('CachedResourceLoader: Did not find cached template for ' + url);\n        }\n    };\n    return CachedResourceLoader;\n}(__WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"a\" /* ResourceLoader */]));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n/**\n * @stable\n */\nvar VERSION = new __WEBPACK_IMPORTED_MODULE_1__angular_core__[\"C\" /* Version */]('4.0.2');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @experimental\n */\nvar RESOURCE_CACHE_PROVIDER = [{ provide: __WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"a\" /* ResourceLoader */], useClass: CachedResourceLoader }];\n/**\n * @stable\n */\nvar platformBrowserDynamic = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__angular_core__[\"u\" /* createPlatformFactory */])(__WEBPACK_IMPORTED_MODULE_0__angular_compiler__[\"b\" /* platformCoreDynamic */], 'browserDynamic', INTERNAL_BROWSER_DYNAMIC_PLATFORM_PROVIDERS);\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the platform-browser-dynamic package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n//# sourceMappingURL=platform-browser-dynamic.es5.js.map\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljLmVzNS5qcz9hMWIzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHY0LjAuMlxuICogKGMpIDIwMTAtMjAxNyBHb29nbGUsIEluYy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cbmltcG9ydCB7IFJlc291cmNlTG9hZGVyLCBwbGF0Zm9ybUNvcmVEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvY29tcGlsZXInO1xuaW1wb3J0IHsgQ09NUElMRVJfT1BUSU9OUywgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQsIFZlcnNpb24sIGNyZWF0ZVBsYXRmb3JtRmFjdG9yeSwgybVnbG9iYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IMm1UExBVEZPUk1fQlJPV1NFUl9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyDJtUlOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUmVzb3VyY2VMb2FkZXJJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzb3VyY2VMb2FkZXJJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlc291cmNlTG9hZGVySW1wbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZXNvdXJjZUxvYWRlckltcGwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIHJlc29sdmU7XG4gICAgICAgIHZhciByZWplY3Q7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlVGV4dCBpcyB0aGUgb2xkLXNjaG9vbCB3YXkgb2YgcmV0cmlldmluZyByZXNwb25zZSAoc3VwcG9ydGVkIGJ5IElFOCAmIDkpXG4gICAgICAgICAgICAvLyByZXNwb25zZS9yZXNwb25zZVR5cGUgcHJvcGVydGllcyB3ZXJlIGludHJvZHVjZWQgaW4gUmVzb3VyY2VMb2FkZXIgTGV2ZWwyIHNwZWMgKHN1cHBvcnRlZFxuICAgICAgICAgICAgLy8gYnkgSUUxMClcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHhoci5yZXNwb25zZSB8fCB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgLy8gbm9ybWFsaXplIElFOSBidWcgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTApXG4gICAgICAgICAgICB2YXIgc3RhdHVzID0geGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXM7XG4gICAgICAgICAgICAvLyBmaXggc3RhdHVzIGNvZGUgd2hlbiBpdCBpcyAwICgwIHN0YXR1cyBpcyB1bmRvY3VtZW50ZWQpLlxuICAgICAgICAgICAgLy8gT2NjdXJzIHdoZW4gYWNjZXNzaW5nIGZpbGUgcmVzb3VyY2VzIG9yIG9uIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcbiAgICAgICAgICAgIC8vIHdoaWxlIHJldHJpZXZpbmcgZmlsZXMgZnJvbSBhcHBsaWNhdGlvbiBjYWNoZS5cbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSByZXNwb25zZSA/IDIwMCA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMjAwIDw9IHN0YXR1cyAmJiBzdGF0dXMgPD0gMzAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJGYWlsZWQgdG8gbG9hZCBcIiArIHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKCkgeyByZWplY3QoXCJGYWlsZWQgdG8gbG9hZCBcIiArIHVybCk7IH07XG4gICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc291cmNlTG9hZGVySW1wbDtcbn0oUmVzb3VyY2VMb2FkZXIpKTtcblJlc291cmNlTG9hZGVySW1wbC5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9LFxuXTtcbi8qKiBAbm9jb2xsYXBzZSAqL1xuUmVzb3VyY2VMb2FkZXJJbXBsLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSU5URVJOQUxfQlJPV1NFUl9EWU5BTUlDX1BMQVRGT1JNX1BST1ZJREVSUyA9IFtcbiAgICDJtUlOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTLFxuICAgIHtcbiAgICAgICAgcHJvdmlkZTogQ09NUElMRVJfT1BUSU9OUyxcbiAgICAgICAgdXNlVmFsdWU6IHsgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBSZXNvdXJjZUxvYWRlciwgdXNlQ2xhc3M6IFJlc291cmNlTG9hZGVySW1wbCB9XSB9LFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH0sXG4gICAgeyBwcm92aWRlOiBQTEFURk9STV9JRCwgdXNlVmFsdWU6IMm1UExBVEZPUk1fQlJPV1NFUl9JRCB9LFxuXTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgUmVzb3VyY2VMb2FkZXIgdGhhdCB1c2VzIGEgdGVtcGxhdGUgY2FjaGUgdG8gYXZvaWQgZG9pbmcgYW4gYWN0dWFsXG4gKiBSZXNvdXJjZUxvYWRlci5cbiAqXG4gKiBUaGUgdGVtcGxhdGUgY2FjaGUgbmVlZHMgdG8gYmUgYnVpbHQgYW5kIGxvYWRlZCBpbnRvIHdpbmRvdy4kdGVtcGxhdGVDYWNoZVxuICogdmlhIGEgc2VwYXJhdGUgbWVjaGFuaXNtLlxuICovXG52YXIgQ2FjaGVkUmVzb3VyY2VMb2FkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWNoZWRSZXNvdXJjZUxvYWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWNoZWRSZXNvdXJjZUxvYWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NhY2hlID0gybVnbG9iYWwuJHRlbXBsYXRlQ2FjaGU7XG4gICAgICAgIGlmIChfdGhpcy5fY2FjaGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogVGVtcGxhdGUgY2FjaGUgd2FzIG5vdCBmb3VuZCBpbiAkdGVtcGxhdGVDYWNoZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhY2hlZFJlc291cmNlTG9hZGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZS5oYXNPd25Qcm9wZXJ0eSh1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2NhY2hlW3VybF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYWNoZWRSZXNvdXJjZUxvYWRlcjogRGlkIG5vdCBmaW5kIGNhY2hlZCB0ZW1wbGF0ZSBmb3IgJyArIHVybCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYWNoZWRSZXNvdXJjZUxvYWRlcjtcbn0oUmVzb3VyY2VMb2FkZXIpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoZSBjb21tb24gcGFja2FnZS5cbiAqL1xuLyoqXG4gKiBAc3RhYmxlXG4gKi9cbnZhciBWRVJTSU9OID0gbmV3IFZlcnNpb24oJzQuMC4yJyk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xudmFyIFJFU09VUkNFX0NBQ0hFX1BST1ZJREVSID0gW3sgcHJvdmlkZTogUmVzb3VyY2VMb2FkZXIsIHVzZUNsYXNzOiBDYWNoZWRSZXNvdXJjZUxvYWRlciB9XTtcbi8qKlxuICogQHN0YWJsZVxuICovXG52YXIgcGxhdGZvcm1Ccm93c2VyRHluYW1pYyA9IGNyZWF0ZVBsYXRmb3JtRmFjdG9yeShwbGF0Zm9ybUNvcmVEeW5hbWljLCAnYnJvd3NlckR5bmFtaWMnLCBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoZSBwbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMgcGFja2FnZS5cbiAqL1xuLy8gVGhpcyBmaWxlIG9ubHkgcmVleHBvcnRzIGNvbnRlbnQgb2YgdGhlIGBzcmNgIGZvbGRlci4gS2VlcCBpdCB0aGF0IHdheS5cbmV4cG9ydCB7IFJFU09VUkNFX0NBQ0hFX1BST1ZJREVSLCBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljLCBWRVJTSU9OLCBJTlRFUk5BTF9CUk9XU0VSX0RZTkFNSUNfUExBVEZPUk1fUFJPVklERVJTIGFzIMm1SU5URVJOQUxfQlJPV1NFUl9EWU5BTUlDX1BMQVRGT1JNX1BST1ZJREVSUywgUmVzb3VyY2VMb2FkZXJJbXBsIGFzIMm1UmVzb3VyY2VMb2FkZXJJbXBsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMuZXM1LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYy9AYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyLWR5bmFtaWMuZXM1LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 141:
/* exports provided: AppModule */
/* exports used: AppModule */
/*!***************************************!*\
  !*** ./Angular2App/app/app.module.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(/*! @angular/core */ 11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__ = __webpack_require__(/*! @angular/platform-browser */ 63);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app_component__ = __webpack_require__(/*! ./app.component */ 170);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return AppModule; });\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\n\r\nvar AppModule = (function () {\r\n    function AppModule() {\r\n    }\r\n    return AppModule;\r\n}());\r\nAppModule = __decorate([\r\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"a\" /* NgModule */])({\r\n        imports: [__WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__[\"a\" /* BrowserModule */]],\r\n        declarations: [__WEBPACK_IMPORTED_MODULE_2__app_component__[\"a\" /* AppComponent */]],\r\n        bootstrap: [__WEBPACK_IMPORTED_MODULE_2__app_component__[\"a\" /* AppComponent */]]\r\n    })\r\n], AppModule);\r\n\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vQW5ndWxhcjJBcHAvYXBwL2FwcC5tb2R1bGUudHM/ZThhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ01vZHVsZSB9ICAgICAgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcclxuXHJcbmltcG9ydCB7IEFwcENvbXBvbmVudCB9ICBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICBpbXBvcnRzOiAgICAgIFsgQnJvd3Nlck1vZHVsZSBdLFxyXG4gIGRlY2xhcmF0aW9uczogWyBBcHBDb21wb25lbnQgXSxcclxuICBib290c3RyYXA6ICAgIFsgQXBwQ29tcG9uZW50IF1cclxufSlcclxuZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7IH1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL0FuZ3VsYXIyQXBwL2FwcC9hcHAubW9kdWxlLnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUVBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 168:
/* exports provided: VERSION, TEMPLATE_TRANSFORMS, CompilerConfig, JitCompiler, DirectiveResolver, PipeResolver, NgModuleResolver, DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig, NgModuleCompiler, ViewCompiler, isSyntaxError, syntaxError, TextAst, BoundTextAst, AttrAst, BoundElementPropertyAst, BoundEventAst, ReferenceAst, VariableAst, ElementAst, EmbeddedTemplateAst, BoundDirectivePropertyAst, DirectiveAst, ProviderAst, ProviderAstType, NgContentAst, PropertyBindingType, templateVisitAll, CompileAnimationEntryMetadata, CompileAnimationStateMetadata, CompileAnimationStateDeclarationMetadata, CompileAnimationStateTransitionMetadata, CompileAnimationMetadata, CompileAnimationKeyframesSequenceMetadata, CompileAnimationStyleMetadata, CompileAnimationAnimateMetadata, CompileAnimationWithStepsMetadata, CompileAnimationSequenceMetadata, CompileAnimationGroupMetadata, identifierName, identifierModuleUrl, viewClassName, rendererTypeName, hostViewClassName, dirWrapperClassName, componentFactoryName, CompileSummaryKind, tokenName, tokenReference, CompileStylesheetMetadata, CompileTemplateMetadata, CompileDirectiveMetadata, createHostComponentMeta, CompilePipeMetadata, CompileNgModuleMetadata, TransitiveCompileNgModuleMetadata, ProviderMeta, flatten, sourceUrl, templateSourceUrl, sharedStylesheetJitUrl, ngModuleJitUrl, templateJitUrl, createAotCompiler, AotCompiler, analyzeNgModules, analyzeAndValidateNgModules, extractProgramSymbols, GeneratedFile, StaticReflector, StaticAndDynamicReflectionCapabilities, StaticSymbol, StaticSymbolCache, ResolvedStaticSymbol, StaticSymbolResolver, unescapeIdentifier, AotSummaryResolver, SummaryResolver, COMPILER_PROVIDERS, JitCompilerFactory, platformCoreDynamic, createUrlResolverWithoutPackagePrefix, createOfflineCompileUrlResolver, DEFAULT_PACKAGE_URL_PROVIDER, UrlResolver, getUrlScheme, ResourceLoader, ElementSchemaRegistry, Extractor, I18NHtmlParser, MessageBundle, Serializer, Xliff, Xmb, Xtb, DirectiveNormalizer, ParserError, ParseSpan, AST, Quote, EmptyExpr, ImplicitReceiver, Chain, Conditional, PropertyRead, PropertyWrite, SafePropertyRead, KeyedRead, KeyedWrite, BindingPipe, LiteralPrimitive, LiteralArray, LiteralMap, Interpolation, Binary, PrefixNot, MethodCall, SafeMethodCall, FunctionCall, ASTWithSource, TemplateBinding, RecursiveAstVisitor, AstTransformer, TokenType, Lexer, Token, EOF, isIdentifier, isQuote, SplitInterpolation, TemplateBindingParseResult, Parser, _ParseAST, ERROR_COLLECTOR_TOKEN, CompileMetadataResolver, componentModuleUrl, Text, Expansion, ExpansionCase, Attribute, Element, Comment, visitAll, ParseTreeResult, TreeError, HtmlParser, HtmlTagDefinition, getHtmlTagDefinition, TagContentType, splitNsName, getNsPrefix, mergeNsAndName, NAMED_ENTITIES, ImportResolver, debugOutputAstAsTypeScript, TypeScriptEmitter, ParseLocation, ParseSourceFile, ParseSourceSpan, ParseErrorLevel, ParseError, typeSourceSpan, DomElementSchemaRegistry, CssSelector, SelectorMatcher, SelectorListContext, SelectorContext, StylesCompileDependency, StylesCompileResult, CompiledStylesheet, StyleCompiler, TemplateParseError, TemplateParseResult, TemplateParser, splitClasses, createElementCssSelector, removeSummaryDuplicates */
/* exports used: ResourceLoader, platformCoreDynamic */
/*!******************************************************!*\
  !*** ./~/@angular/compiler/@angular/compiler.es5.js ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(/*! @angular/core */ 11);\n/* unused harmony export VERSION */\n/* unused harmony export TEMPLATE_TRANSFORMS */\n/* unused harmony export CompilerConfig */\n/* unused harmony export JitCompiler */\n/* unused harmony export DirectiveResolver */\n/* unused harmony export PipeResolver */\n/* unused harmony export NgModuleResolver */\n/* unused harmony export DEFAULT_INTERPOLATION_CONFIG */\n/* unused harmony export InterpolationConfig */\n/* unused harmony export NgModuleCompiler */\n/* unused harmony export ViewCompiler */\n/* unused harmony export isSyntaxError */\n/* unused harmony export syntaxError */\n/* unused harmony export TextAst */\n/* unused harmony export BoundTextAst */\n/* unused harmony export AttrAst */\n/* unused harmony export BoundElementPropertyAst */\n/* unused harmony export BoundEventAst */\n/* unused harmony export ReferenceAst */\n/* unused harmony export VariableAst */\n/* unused harmony export ElementAst */\n/* unused harmony export EmbeddedTemplateAst */\n/* unused harmony export BoundDirectivePropertyAst */\n/* unused harmony export DirectiveAst */\n/* unused harmony export ProviderAst */\n/* unused harmony export ProviderAstType */\n/* unused harmony export NgContentAst */\n/* unused harmony export PropertyBindingType */\n/* unused harmony export templateVisitAll */\n/* unused harmony export CompileAnimationEntryMetadata */\n/* unused harmony export CompileAnimationStateMetadata */\n/* unused harmony export CompileAnimationStateDeclarationMetadata */\n/* unused harmony export CompileAnimationStateTransitionMetadata */\n/* unused harmony export CompileAnimationMetadata */\n/* unused harmony export CompileAnimationKeyframesSequenceMetadata */\n/* unused harmony export CompileAnimationStyleMetadata */\n/* unused harmony export CompileAnimationAnimateMetadata */\n/* unused harmony export CompileAnimationWithStepsMetadata */\n/* unused harmony export CompileAnimationSequenceMetadata */\n/* unused harmony export CompileAnimationGroupMetadata */\n/* unused harmony export identifierName */\n/* unused harmony export identifierModuleUrl */\n/* unused harmony export viewClassName */\n/* unused harmony export rendererTypeName */\n/* unused harmony export hostViewClassName */\n/* unused harmony export dirWrapperClassName */\n/* unused harmony export componentFactoryName */\n/* unused harmony export CompileSummaryKind */\n/* unused harmony export tokenName */\n/* unused harmony export tokenReference */\n/* unused harmony export CompileStylesheetMetadata */\n/* unused harmony export CompileTemplateMetadata */\n/* unused harmony export CompileDirectiveMetadata */\n/* unused harmony export createHostComponentMeta */\n/* unused harmony export CompilePipeMetadata */\n/* unused harmony export CompileNgModuleMetadata */\n/* unused harmony export TransitiveCompileNgModuleMetadata */\n/* unused harmony export ProviderMeta */\n/* unused harmony export flatten */\n/* unused harmony export sourceUrl */\n/* unused harmony export templateSourceUrl */\n/* unused harmony export sharedStylesheetJitUrl */\n/* unused harmony export ngModuleJitUrl */\n/* unused harmony export templateJitUrl */\n/* unused harmony export createAotCompiler */\n/* unused harmony export AotCompiler */\n/* unused harmony export analyzeNgModules */\n/* unused harmony export analyzeAndValidateNgModules */\n/* unused harmony export extractProgramSymbols */\n/* unused harmony export GeneratedFile */\n/* unused harmony export StaticReflector */\n/* unused harmony export StaticAndDynamicReflectionCapabilities */\n/* unused harmony export StaticSymbol */\n/* unused harmony export StaticSymbolCache */\n/* unused harmony export ResolvedStaticSymbol */\n/* unused harmony export StaticSymbolResolver */\n/* unused harmony export unescapeIdentifier */\n/* unused harmony export AotSummaryResolver */\n/* unused harmony export SummaryResolver */\n/* unused harmony export COMPILER_PROVIDERS */\n/* unused harmony export JitCompilerFactory */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return platformCoreDynamic; });\n/* unused harmony export createUrlResolverWithoutPackagePrefix */\n/* unused harmony export createOfflineCompileUrlResolver */\n/* unused harmony export DEFAULT_PACKAGE_URL_PROVIDER */\n/* unused harmony export UrlResolver */\n/* unused harmony export getUrlScheme */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ResourceLoader; });\n/* unused harmony export ElementSchemaRegistry */\n/* unused harmony export Extractor */\n/* unused harmony export I18NHtmlParser */\n/* unused harmony export MessageBundle */\n/* unused harmony export Serializer */\n/* unused harmony export Xliff */\n/* unused harmony export Xmb */\n/* unused harmony export Xtb */\n/* unused harmony export DirectiveNormalizer */\n/* unused harmony export ParserError */\n/* unused harmony export ParseSpan */\n/* unused harmony export AST */\n/* unused harmony export Quote */\n/* unused harmony export EmptyExpr */\n/* unused harmony export ImplicitReceiver */\n/* unused harmony export Chain */\n/* unused harmony export Conditional */\n/* unused harmony export PropertyRead */\n/* unused harmony export PropertyWrite */\n/* unused harmony export SafePropertyRead */\n/* unused harmony export KeyedRead */\n/* unused harmony export KeyedWrite */\n/* unused harmony export BindingPipe */\n/* unused harmony export LiteralPrimitive */\n/* unused harmony export LiteralArray */\n/* unused harmony export LiteralMap */\n/* unused harmony export Interpolation */\n/* unused harmony export Binary */\n/* unused harmony export PrefixNot */\n/* unused harmony export MethodCall */\n/* unused harmony export SafeMethodCall */\n/* unused harmony export FunctionCall */\n/* unused harmony export ASTWithSource */\n/* unused harmony export TemplateBinding */\n/* unused harmony export RecursiveAstVisitor */\n/* unused harmony export AstTransformer */\n/* unused harmony export TokenType */\n/* unused harmony export Lexer */\n/* unused harmony export Token */\n/* unused harmony export EOF */\n/* unused harmony export isIdentifier */\n/* unused harmony export isQuote */\n/* unused harmony export SplitInterpolation */\n/* unused harmony export TemplateBindingParseResult */\n/* unused harmony export Parser */\n/* unused harmony export _ParseAST */\n/* unused harmony export ERROR_COLLECTOR_TOKEN */\n/* unused harmony export CompileMetadataResolver */\n/* unused harmony export componentModuleUrl */\n/* unused harmony export Text */\n/* unused harmony export Expansion */\n/* unused harmony export ExpansionCase */\n/* unused harmony export Attribute */\n/* unused harmony export Element */\n/* unused harmony export Comment */\n/* unused harmony export visitAll */\n/* unused harmony export ParseTreeResult */\n/* unused harmony export TreeError */\n/* unused harmony export HtmlParser */\n/* unused harmony export HtmlTagDefinition */\n/* unused harmony export getHtmlTagDefinition */\n/* unused harmony export TagContentType */\n/* unused harmony export splitNsName */\n/* unused harmony export getNsPrefix */\n/* unused harmony export mergeNsAndName */\n/* unused harmony export NAMED_ENTITIES */\n/* unused harmony export ImportResolver */\n/* unused harmony export debugOutputAstAsTypeScript */\n/* unused harmony export TypeScriptEmitter */\n/* unused harmony export ParseLocation */\n/* unused harmony export ParseSourceFile */\n/* unused harmony export ParseSourceSpan */\n/* unused harmony export ParseErrorLevel */\n/* unused harmony export ParseError */\n/* unused harmony export typeSourceSpan */\n/* unused harmony export DomElementSchemaRegistry */\n/* unused harmony export CssSelector */\n/* unused harmony export SelectorMatcher */\n/* unused harmony export SelectorListContext */\n/* unused harmony export SelectorContext */\n/* unused harmony export StylesCompileDependency */\n/* unused harmony export StylesCompileResult */\n/* unused harmony export CompiledStylesheet */\n/* unused harmony export StyleCompiler */\n/* unused harmony export TemplateParseError */\n/* unused harmony export TemplateParseResult */\n/* unused harmony export TemplateParser */\n/* unused harmony export splitClasses */\n/* unused harmony export createElementCssSelector */\n/* unused harmony export removeSummaryDuplicates */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * @license Angular v4.0.2\n * (c) 2010-2017 Google, Inc. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the common package.\n */\n/**\n * \\@stable\n */\nvar VERSION = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"C\" /* Version */]('4.0.2');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A segment of text within the template.\n */\nvar TextAst = (function () {\n    /**\n     * @param {?} value\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function TextAst(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    TextAst.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return TextAst;\n}());\n/**\n * A bound expression within the text of a template.\n */\nvar BoundTextAst = (function () {\n    /**\n     * @param {?} value\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function BoundTextAst(value, ngContentIndex, sourceSpan) {\n        this.value = value;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundTextAst.prototype.visit = function (visitor, context) {\n        return visitor.visitBoundText(this, context);\n    };\n    return BoundTextAst;\n}());\n/**\n * A plain attribute on an element.\n */\nvar AttrAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function AttrAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    AttrAst.prototype.visit = function (visitor, context) { return visitor.visitAttr(this, context); };\n    return AttrAst;\n}());\n/**\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n * `[\\@trigger]=\"stateExp\"`)\n */\nvar BoundElementPropertyAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} type\n     * @param {?} securityContext\n     * @param {?} value\n     * @param {?} unit\n     * @param {?} sourceSpan\n     */\n    function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundElementPropertyAst.prototype.visit = function (visitor, context) {\n        return visitor.visitElementProperty(this, context);\n    };\n    Object.defineProperty(BoundElementPropertyAst.prototype, \"isAnimation\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.type === PropertyBindingType.Animation; },\n        enumerable: true,\n        configurable: true\n    });\n    return BoundElementPropertyAst;\n}());\n/**\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n * `(\\@trigger.phase)=\"callback($event)\"`).\n */\nvar BoundEventAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} target\n     * @param {?} phase\n     * @param {?} handler\n     * @param {?} sourceSpan\n     */\n    function BoundEventAst(name, target, phase, handler, sourceSpan) {\n        this.name = name;\n        this.target = target;\n        this.phase = phase;\n        this.handler = handler;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} name\n     * @param {?} target\n     * @param {?} phase\n     * @return {?}\n     */\n    BoundEventAst.calcFullName = function (name, target, phase) {\n        if (target) {\n            return target + \":\" + name;\n        }\n        else if (phase) {\n            return \"@\" + name + \".\" + phase;\n        }\n        else {\n            return name;\n        }\n    };\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundEventAst.prototype.visit = function (visitor, context) {\n        return visitor.visitEvent(this, context);\n    };\n    Object.defineProperty(BoundEventAst.prototype, \"fullName\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return BoundEventAst.calcFullName(this.name, this.target, this.phase); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BoundEventAst.prototype, \"isAnimation\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return !!this.phase; },\n        enumerable: true,\n        configurable: true\n    });\n    return BoundEventAst;\n}());\n/**\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n */\nvar ReferenceAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function ReferenceAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReferenceAst.prototype.visit = function (visitor, context) {\n        return visitor.visitReference(this, context);\n    };\n    return ReferenceAst;\n}());\n/**\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\n */\nvar VariableAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function VariableAst(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    VariableAst.prototype.visit = function (visitor, context) {\n        return visitor.visitVariable(this, context);\n    };\n    return VariableAst;\n}());\n/**\n * An element declaration in a template.\n */\nvar ElementAst = (function () {\n    /**\n     * @param {?} name\n     * @param {?} attrs\n     * @param {?} inputs\n     * @param {?} outputs\n     * @param {?} references\n     * @param {?} directives\n     * @param {?} providers\n     * @param {?} hasViewContainer\n     * @param {?} queryMatches\n     * @param {?} children\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     * @param {?} endSourceSpan\n     */\n    function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {\n        this.name = name;\n        this.attrs = attrs;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.references = references;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ElementAst.prototype.visit = function (visitor, context) {\n        return visitor.visitElement(this, context);\n    };\n    return ElementAst;\n}());\n/**\n * A `<ng-template>` element included in an Angular template.\n */\nvar EmbeddedTemplateAst = (function () {\n    /**\n     * @param {?} attrs\n     * @param {?} outputs\n     * @param {?} references\n     * @param {?} variables\n     * @param {?} directives\n     * @param {?} providers\n     * @param {?} hasViewContainer\n     * @param {?} queryMatches\n     * @param {?} children\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {\n        this.attrs = attrs;\n        this.outputs = outputs;\n        this.references = references;\n        this.variables = variables;\n        this.directives = directives;\n        this.providers = providers;\n        this.hasViewContainer = hasViewContainer;\n        this.queryMatches = queryMatches;\n        this.children = children;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    EmbeddedTemplateAst.prototype.visit = function (visitor, context) {\n        return visitor.visitEmbeddedTemplate(this, context);\n    };\n    return EmbeddedTemplateAst;\n}());\n/**\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n */\nvar BoundDirectivePropertyAst = (function () {\n    /**\n     * @param {?} directiveName\n     * @param {?} templateName\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {\n        this.directiveName = directiveName;\n        this.templateName = templateName;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {\n        return visitor.visitDirectiveProperty(this, context);\n    };\n    return BoundDirectivePropertyAst;\n}());\n/**\n * A directive declared on an element.\n */\nvar DirectiveAst = (function () {\n    /**\n     * @param {?} directive\n     * @param {?} inputs\n     * @param {?} hostProperties\n     * @param {?} hostEvents\n     * @param {?} contentQueryStartId\n     * @param {?} sourceSpan\n     */\n    function DirectiveAst(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {\n        this.directive = directive;\n        this.inputs = inputs;\n        this.hostProperties = hostProperties;\n        this.hostEvents = hostEvents;\n        this.contentQueryStartId = contentQueryStartId;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    DirectiveAst.prototype.visit = function (visitor, context) {\n        return visitor.visitDirective(this, context);\n    };\n    return DirectiveAst;\n}());\n/**\n * A provider declared on an element\n */\nvar ProviderAst = (function () {\n    /**\n     * @param {?} token\n     * @param {?} multiProvider\n     * @param {?} eager\n     * @param {?} providers\n     * @param {?} providerType\n     * @param {?} lifecycleHooks\n     * @param {?} sourceSpan\n     */\n    function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan) {\n        this.token = token;\n        this.multiProvider = multiProvider;\n        this.eager = eager;\n        this.providers = providers;\n        this.providerType = providerType;\n        this.lifecycleHooks = lifecycleHooks;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ProviderAst.prototype.visit = function (visitor, context) {\n        // No visit method in the visitor for now...\n        return null;\n    };\n    return ProviderAst;\n}());\nvar ProviderAstType = {};\nProviderAstType.PublicService = 0;\nProviderAstType.PrivateService = 1;\nProviderAstType.Component = 2;\nProviderAstType.Directive = 3;\nProviderAstType.Builtin = 4;\nProviderAstType[ProviderAstType.PublicService] = \"PublicService\";\nProviderAstType[ProviderAstType.PrivateService] = \"PrivateService\";\nProviderAstType[ProviderAstType.Component] = \"Component\";\nProviderAstType[ProviderAstType.Directive] = \"Directive\";\nProviderAstType[ProviderAstType.Builtin] = \"Builtin\";\n/**\n * Position where content is to be projected (instance of `<ng-content>` in a template).\n */\nvar NgContentAst = (function () {\n    /**\n     * @param {?} index\n     * @param {?} ngContentIndex\n     * @param {?} sourceSpan\n     */\n    function NgContentAst(index, ngContentIndex, sourceSpan) {\n        this.index = index;\n        this.ngContentIndex = ngContentIndex;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    NgContentAst.prototype.visit = function (visitor, context) {\n        return visitor.visitNgContent(this, context);\n    };\n    return NgContentAst;\n}());\nvar PropertyBindingType = {};\nPropertyBindingType.Property = 0;\nPropertyBindingType.Attribute = 1;\nPropertyBindingType.Class = 2;\nPropertyBindingType.Style = 3;\nPropertyBindingType.Animation = 4;\nPropertyBindingType[PropertyBindingType.Property] = \"Property\";\nPropertyBindingType[PropertyBindingType.Attribute] = \"Attribute\";\nPropertyBindingType[PropertyBindingType.Class] = \"Class\";\nPropertyBindingType[PropertyBindingType.Style] = \"Style\";\nPropertyBindingType[PropertyBindingType.Animation] = \"Animation\";\n/**\n * Visit every node in a list of {\\@link TemplateAst}s with the given {\\@link TemplateAstVisitor}.\n * @param {?} visitor\n * @param {?} asts\n * @param {?=} context\n * @return {?}\n */\nfunction templateVisitAll(visitor, asts, context) {\n    if (context === void 0) { context = null; }\n    var /** @type {?} */ result = [];\n    var /** @type {?} */ visit = visitor.visit ?\n        function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :\n        function (ast) { return ast.visit(visitor, context); };\n    asts.forEach(function (ast) {\n        var /** @type {?} */ astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n/**\n * A token representing the a reference to a static type.\n *\n * This token is unique for a filePath and name and can be used as a hash table key.\n */\nvar StaticSymbol = (function () {\n    /**\n     * @param {?} filePath\n     * @param {?} name\n     * @param {?} members\n     */\n    function StaticSymbol(filePath, name, members) {\n        this.filePath = filePath;\n        this.name = name;\n        this.members = members;\n    }\n    /**\n     * @return {?}\n     */\n    StaticSymbol.prototype.assertNoMembers = function () {\n        if (this.members.length) {\n            throw new Error(\"Illegal state: symbol without members expected, but got \" + JSON.stringify(this) + \".\");\n        }\n    };\n    return StaticSymbol;\n}());\n/**\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\n * same symbol values.\n */\nvar StaticSymbolCache = (function () {\n    function StaticSymbolCache() {\n        this.cache = new Map();\n    }\n    /**\n     * @param {?} declarationFile\n     * @param {?} name\n     * @param {?=} members\n     * @return {?}\n     */\n    StaticSymbolCache.prototype.get = function (declarationFile, name, members) {\n        members = members || [];\n        var /** @type {?} */ memberSuffix = members.length ? \".\" + members.join('.') : '';\n        var /** @type {?} */ key = \"\\\"\" + declarationFile + \"\\\".\" + name + memberSuffix;\n        var /** @type {?} */ result = this.cache.get(key);\n        if (!result) {\n            result = new StaticSymbol(declarationFile, name, members);\n            this.cache.set(key, result);\n        }\n        return result;\n    };\n    return StaticSymbolCache;\n}());\nvar TagContentType = {};\nTagContentType.RAW_TEXT = 0;\nTagContentType.ESCAPABLE_RAW_TEXT = 1;\nTagContentType.PARSABLE_DATA = 2;\nTagContentType[TagContentType.RAW_TEXT] = \"RAW_TEXT\";\nTagContentType[TagContentType.ESCAPABLE_RAW_TEXT] = \"ESCAPABLE_RAW_TEXT\";\nTagContentType[TagContentType.PARSABLE_DATA] = \"PARSABLE_DATA\";\n/**\n * @param {?} elementName\n * @return {?}\n */\nfunction splitNsName(elementName) {\n    if (elementName[0] != ':') {\n        return [null, elementName];\n    }\n    var /** @type {?} */ colonIndex = elementName.indexOf(':', 1);\n    if (colonIndex == -1) {\n        throw new Error(\"Unsupported format \\\"\" + elementName + \"\\\" expecting \\\":namespace:name\\\"\");\n    }\n    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n/**\n * @param {?} fullName\n * @return {?}\n */\nfunction getNsPrefix(fullName) {\n    return fullName === null ? null : splitNsName(fullName)[0];\n}\n/**\n * @param {?} prefix\n * @param {?} localName\n * @return {?}\n */\nfunction mergeNsAndName(prefix, localName) {\n    return prefix ? \":\" + prefix + \":\" + localName : localName;\n}\n// see http://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not exist.\nvar NAMED_ENTITIES = {\n    'Aacute': '\\u00C1',\n    'aacute': '\\u00E1',\n    'Acirc': '\\u00C2',\n    'acirc': '\\u00E2',\n    'acute': '\\u00B4',\n    'AElig': '\\u00C6',\n    'aelig': '\\u00E6',\n    'Agrave': '\\u00C0',\n    'agrave': '\\u00E0',\n    'alefsym': '\\u2135',\n    'Alpha': '\\u0391',\n    'alpha': '\\u03B1',\n    'amp': '&',\n    'and': '\\u2227',\n    'ang': '\\u2220',\n    'apos': '\\u0027',\n    'Aring': '\\u00C5',\n    'aring': '\\u00E5',\n    'asymp': '\\u2248',\n    'Atilde': '\\u00C3',\n    'atilde': '\\u00E3',\n    'Auml': '\\u00C4',\n    'auml': '\\u00E4',\n    'bdquo': '\\u201E',\n    'Beta': '\\u0392',\n    'beta': '\\u03B2',\n    'brvbar': '\\u00A6',\n    'bull': '\\u2022',\n    'cap': '\\u2229',\n    'Ccedil': '\\u00C7',\n    'ccedil': '\\u00E7',\n    'cedil': '\\u00B8',\n    'cent': '\\u00A2',\n    'Chi': '\\u03A7',\n    'chi': '\\u03C7',\n    'circ': '\\u02C6',\n    'clubs': '\\u2663',\n    'cong': '\\u2245',\n    'copy': '\\u00A9',\n    'crarr': '\\u21B5',\n    'cup': '\\u222A',\n    'curren': '\\u00A4',\n    'dagger': '\\u2020',\n    'Dagger': '\\u2021',\n    'darr': '\\u2193',\n    'dArr': '\\u21D3',\n    'deg': '\\u00B0',\n    'Delta': '\\u0394',\n    'delta': '\\u03B4',\n    'diams': '\\u2666',\n    'divide': '\\u00F7',\n    'Eacute': '\\u00C9',\n    'eacute': '\\u00E9',\n    'Ecirc': '\\u00CA',\n    'ecirc': '\\u00EA',\n    'Egrave': '\\u00C8',\n    'egrave': '\\u00E8',\n    'empty': '\\u2205',\n    'emsp': '\\u2003',\n    'ensp': '\\u2002',\n    'Epsilon': '\\u0395',\n    'epsilon': '\\u03B5',\n    'equiv': '\\u2261',\n    'Eta': '\\u0397',\n    'eta': '\\u03B7',\n    'ETH': '\\u00D0',\n    'eth': '\\u00F0',\n    'Euml': '\\u00CB',\n    'euml': '\\u00EB',\n    'euro': '\\u20AC',\n    'exist': '\\u2203',\n    'fnof': '\\u0192',\n    'forall': '\\u2200',\n    'frac12': '\\u00BD',\n    'frac14': '\\u00BC',\n    'frac34': '\\u00BE',\n    'frasl': '\\u2044',\n    'Gamma': '\\u0393',\n    'gamma': '\\u03B3',\n    'ge': '\\u2265',\n    'gt': '>',\n    'harr': '\\u2194',\n    'hArr': '\\u21D4',\n    'hearts': '\\u2665',\n    'hellip': '\\u2026',\n    'Iacute': '\\u00CD',\n    'iacute': '\\u00ED',\n    'Icirc': '\\u00CE',\n    'icirc': '\\u00EE',\n    'iexcl': '\\u00A1',\n    'Igrave': '\\u00CC',\n    'igrave': '\\u00EC',\n    'image': '\\u2111',\n    'infin': '\\u221E',\n    'int': '\\u222B',\n    'Iota': '\\u0399',\n    'iota': '\\u03B9',\n    'iquest': '\\u00BF',\n    'isin': '\\u2208',\n    'Iuml': '\\u00CF',\n    'iuml': '\\u00EF',\n    'Kappa': '\\u039A',\n    'kappa': '\\u03BA',\n    'Lambda': '\\u039B',\n    'lambda': '\\u03BB',\n    'lang': '\\u27E8',\n    'laquo': '\\u00AB',\n    'larr': '\\u2190',\n    'lArr': '\\u21D0',\n    'lceil': '\\u2308',\n    'ldquo': '\\u201C',\n    'le': '\\u2264',\n    'lfloor': '\\u230A',\n    'lowast': '\\u2217',\n    'loz': '\\u25CA',\n    'lrm': '\\u200E',\n    'lsaquo': '\\u2039',\n    'lsquo': '\\u2018',\n    'lt': '<',\n    'macr': '\\u00AF',\n    'mdash': '\\u2014',\n    'micro': '\\u00B5',\n    'middot': '\\u00B7',\n    'minus': '\\u2212',\n    'Mu': '\\u039C',\n    'mu': '\\u03BC',\n    'nabla': '\\u2207',\n    'nbsp': '\\u00A0',\n    'ndash': '\\u2013',\n    'ne': '\\u2260',\n    'ni': '\\u220B',\n    'not': '\\u00AC',\n    'notin': '\\u2209',\n    'nsub': '\\u2284',\n    'Ntilde': '\\u00D1',\n    'ntilde': '\\u00F1',\n    'Nu': '\\u039D',\n    'nu': '\\u03BD',\n    'Oacute': '\\u00D3',\n    'oacute': '\\u00F3',\n    'Ocirc': '\\u00D4',\n    'ocirc': '\\u00F4',\n    'OElig': '\\u0152',\n    'oelig': '\\u0153',\n    'Ograve': '\\u00D2',\n    'ograve': '\\u00F2',\n    'oline': '\\u203E',\n    'Omega': '\\u03A9',\n    'omega': '\\u03C9',\n    'Omicron': '\\u039F',\n    'omicron': '\\u03BF',\n    'oplus': '\\u2295',\n    'or': '\\u2228',\n    'ordf': '\\u00AA',\n    'ordm': '\\u00BA',\n    'Oslash': '\\u00D8',\n    'oslash': '\\u00F8',\n    'Otilde': '\\u00D5',\n    'otilde': '\\u00F5',\n    'otimes': '\\u2297',\n    'Ouml': '\\u00D6',\n    'ouml': '\\u00F6',\n    'para': '\\u00B6',\n    'permil': '\\u2030',\n    'perp': '\\u22A5',\n    'Phi': '\\u03A6',\n    'phi': '\\u03C6',\n    'Pi': '\\u03A0',\n    'pi': '\\u03C0',\n    'piv': '\\u03D6',\n    'plusmn': '\\u00B1',\n    'pound': '\\u00A3',\n    'prime': '\\u2032',\n    'Prime': '\\u2033',\n    'prod': '\\u220F',\n    'prop': '\\u221D',\n    'Psi': '\\u03A8',\n    'psi': '\\u03C8',\n    'quot': '\\u0022',\n    'radic': '\\u221A',\n    'rang': '\\u27E9',\n    'raquo': '\\u00BB',\n    'rarr': '\\u2192',\n    'rArr': '\\u21D2',\n    'rceil': '\\u2309',\n    'rdquo': '\\u201D',\n    'real': '\\u211C',\n    'reg': '\\u00AE',\n    'rfloor': '\\u230B',\n    'Rho': '\\u03A1',\n    'rho': '\\u03C1',\n    'rlm': '\\u200F',\n    'rsaquo': '\\u203A',\n    'rsquo': '\\u2019',\n    'sbquo': '\\u201A',\n    'Scaron': '\\u0160',\n    'scaron': '\\u0161',\n    'sdot': '\\u22C5',\n    'sect': '\\u00A7',\n    'shy': '\\u00AD',\n    'Sigma': '\\u03A3',\n    'sigma': '\\u03C3',\n    'sigmaf': '\\u03C2',\n    'sim': '\\u223C',\n    'spades': '\\u2660',\n    'sub': '\\u2282',\n    'sube': '\\u2286',\n    'sum': '\\u2211',\n    'sup': '\\u2283',\n    'sup1': '\\u00B9',\n    'sup2': '\\u00B2',\n    'sup3': '\\u00B3',\n    'supe': '\\u2287',\n    'szlig': '\\u00DF',\n    'Tau': '\\u03A4',\n    'tau': '\\u03C4',\n    'there4': '\\u2234',\n    'Theta': '\\u0398',\n    'theta': '\\u03B8',\n    'thetasym': '\\u03D1',\n    'thinsp': '\\u2009',\n    'THORN': '\\u00DE',\n    'thorn': '\\u00FE',\n    'tilde': '\\u02DC',\n    'times': '\\u00D7',\n    'trade': '\\u2122',\n    'Uacute': '\\u00DA',\n    'uacute': '\\u00FA',\n    'uarr': '\\u2191',\n    'uArr': '\\u21D1',\n    'Ucirc': '\\u00DB',\n    'ucirc': '\\u00FB',\n    'Ugrave': '\\u00D9',\n    'ugrave': '\\u00F9',\n    'uml': '\\u00A8',\n    'upsih': '\\u03D2',\n    'Upsilon': '\\u03A5',\n    'upsilon': '\\u03C5',\n    'Uuml': '\\u00DC',\n    'uuml': '\\u00FC',\n    'weierp': '\\u2118',\n    'Xi': '\\u039E',\n    'xi': '\\u03BE',\n    'Yacute': '\\u00DD',\n    'yacute': '\\u00FD',\n    'yen': '\\u00A5',\n    'yuml': '\\u00FF',\n    'Yuml': '\\u0178',\n    'Zeta': '\\u0396',\n    'zeta': '\\u03B6',\n    'zwj': '\\u200D',\n    'zwnj': '\\u200C',\n};\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar HtmlTagDefinition = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function HtmlTagDefinition(_a) {\n        var _b = _a === void 0 ? {} : _a, closedByChildren = _b.closedByChildren, requiredParents = _b.requiredParents, implicitNamespacePrefix = _b.implicitNamespacePrefix, _c = _b.contentType, contentType = _c === void 0 ? TagContentType.PARSABLE_DATA : _c, _d = _b.closedByParent, closedByParent = _d === void 0 ? false : _d, _e = _b.isVoid, isVoid = _e === void 0 ? false : _e, _f = _b.ignoreFirstLf, ignoreFirstLf = _f === void 0 ? false : _f;\n        var _this = this;\n        this.closedByChildren = {};\n        this.closedByParent = false;\n        this.canSelfClose = false;\n        if (closedByChildren && closedByChildren.length > 0) {\n            closedByChildren.forEach(function (tagName) { return _this.closedByChildren[tagName] = true; });\n        }\n        this.isVoid = isVoid;\n        this.closedByParent = closedByParent || isVoid;\n        if (requiredParents && requiredParents.length > 0) {\n            this.requiredParents = {};\n            // The first parent is the list is automatically when none of the listed parents are present\n            this.parentToAdd = requiredParents[0];\n            requiredParents.forEach(function (tagName) { return _this.requiredParents[tagName] = true; });\n        }\n        this.implicitNamespacePrefix = implicitNamespacePrefix;\n        this.contentType = contentType;\n        this.ignoreFirstLf = ignoreFirstLf;\n    }\n    /**\n     * @param {?} currentParent\n     * @return {?}\n     */\n    HtmlTagDefinition.prototype.requireExtraParent = function (currentParent) {\n        if (!this.requiredParents) {\n            return false;\n        }\n        if (!currentParent) {\n            return true;\n        }\n        var /** @type {?} */ lcParent = currentParent.toLowerCase();\n        var /** @type {?} */ isParentTemplate = lcParent === 'template' || currentParent === 'ng-template';\n        return !isParentTemplate && this.requiredParents[lcParent] != true;\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    HtmlTagDefinition.prototype.isClosedByChild = function (name) {\n        return this.isVoid || name.toLowerCase() in this.closedByChildren;\n    };\n    return HtmlTagDefinition;\n}());\n// see http://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nvar TAG_DEFINITIONS = {\n    'base': new HtmlTagDefinition({ isVoid: true }),\n    'meta': new HtmlTagDefinition({ isVoid: true }),\n    'area': new HtmlTagDefinition({ isVoid: true }),\n    'embed': new HtmlTagDefinition({ isVoid: true }),\n    'link': new HtmlTagDefinition({ isVoid: true }),\n    'img': new HtmlTagDefinition({ isVoid: true }),\n    'input': new HtmlTagDefinition({ isVoid: true }),\n    'param': new HtmlTagDefinition({ isVoid: true }),\n    'hr': new HtmlTagDefinition({ isVoid: true }),\n    'br': new HtmlTagDefinition({ isVoid: true }),\n    'source': new HtmlTagDefinition({ isVoid: true }),\n    'track': new HtmlTagDefinition({ isVoid: true }),\n    'wbr': new HtmlTagDefinition({ isVoid: true }),\n    'p': new HtmlTagDefinition({\n        closedByChildren: [\n            'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form',\n            'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr',\n            'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'\n        ],\n        closedByParent: true\n    }),\n    'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\n    'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\n    'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\n    'tr': new HtmlTagDefinition({\n        closedByChildren: ['tr'],\n        requiredParents: ['tbody', 'tfoot', 'thead'],\n        closedByParent: true\n    }),\n    'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n    'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n    'col': new HtmlTagDefinition({ requiredParents: ['colgroup'], isVoid: true }),\n    'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\n    'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\n    'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\n    'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\n    'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\n    'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\n    'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n    'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\n    'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\n    'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\n    'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\n    'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n    'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n    'title': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT }),\n    'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\n};\nvar _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction getHtmlTagDefinition(tagName) {\n    return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' +\n    '([-\\\\w]+)|' +\n    '(?:\\\\.([-\\\\w]+))|' +\n    // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n    '(?:\\\\[([-.\\\\w*]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' +\n    // \"[name=\"value\"]\",\n    // \"[name='value']\"\n    '(\\\\))|' +\n    '(\\\\s*,\\\\s*)', // \",\"\n'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nvar CssSelector = (function () {\n    function CssSelector() {\n        this.element = null;\n        this.classNames = [];\n        this.attrs = [];\n        this.notSelectors = [];\n    }\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    CssSelector.parse = function (selector) {\n        var /** @type {?} */ results = [];\n        var /** @type {?} */ _addResult = function (res, cssSel) {\n            if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n                cssSel.attrs.length == 0) {\n                cssSel.element = '*';\n            }\n            res.push(cssSel);\n        };\n        var /** @type {?} */ cssSelector = new CssSelector();\n        var /** @type {?} */ match;\n        var /** @type {?} */ current = cssSelector;\n        var /** @type {?} */ inNot = false;\n        _SELECTOR_REGEXP.lastIndex = 0;\n        while (match = _SELECTOR_REGEXP.exec(selector)) {\n            if (match[1]) {\n                if (inNot) {\n                    throw new Error('Nesting :not is not allowed in a selector');\n                }\n                inNot = true;\n                current = new CssSelector();\n                cssSelector.notSelectors.push(current);\n            }\n            if (match[2]) {\n                current.setElement(match[2]);\n            }\n            if (match[3]) {\n                current.addClassName(match[3]);\n            }\n            if (match[4]) {\n                current.addAttribute(match[4], match[6]);\n            }\n            if (match[7]) {\n                inNot = false;\n                current = cssSelector;\n            }\n            if (match[8]) {\n                if (inNot) {\n                    throw new Error('Multiple selectors in :not are not supported');\n                }\n                _addResult(results, cssSelector);\n                cssSelector = current = new CssSelector();\n            }\n        }\n        _addResult(results, cssSelector);\n        return results;\n    };\n    /**\n     * @return {?}\n     */\n    CssSelector.prototype.isElementSelector = function () {\n        return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n            this.notSelectors.length === 0;\n    };\n    /**\n     * @return {?}\n     */\n    CssSelector.prototype.hasElementSelector = function () { return !!this.element; };\n    /**\n     * @param {?=} element\n     * @return {?}\n     */\n    CssSelector.prototype.setElement = function (element) {\n        if (element === void 0) { element = null; }\n        this.element = element;\n    };\n    /**\n     * Gets a template string for an element that matches the selector.\n     * @return {?}\n     */\n    CssSelector.prototype.getMatchingElementTemplate = function () {\n        var /** @type {?} */ tagName = this.element || 'div';\n        var /** @type {?} */ classAttr = this.classNames.length > 0 ? \" class=\\\"\" + this.classNames.join(' ') + \"\\\"\" : '';\n        var /** @type {?} */ attrs = '';\n        for (var /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n            var /** @type {?} */ attrName = this.attrs[i];\n            var /** @type {?} */ attrValue = this.attrs[i + 1] !== '' ? \"=\\\"\" + this.attrs[i + 1] + \"\\\"\" : '';\n            attrs += \" \" + attrName + attrValue;\n        }\n        return getHtmlTagDefinition(tagName).isVoid ? \"<\" + tagName + classAttr + attrs + \"/>\" :\n            \"<\" + tagName + classAttr + attrs + \"></\" + tagName + \">\";\n    };\n    /**\n     * @param {?} name\n     * @param {?=} value\n     * @return {?}\n     */\n    CssSelector.prototype.addAttribute = function (name, value) {\n        if (value === void 0) { value = ''; }\n        this.attrs.push(name, value && value.toLowerCase() || '');\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };\n    /**\n     * @return {?}\n     */\n    CssSelector.prototype.toString = function () {\n        var /** @type {?} */ res = this.element || '';\n        if (this.classNames) {\n            this.classNames.forEach(function (klass) { return res += \".\" + klass; });\n        }\n        if (this.attrs) {\n            for (var /** @type {?} */ i = 0; i < this.attrs.length; i += 2) {\n                var /** @type {?} */ name = this.attrs[i];\n                var /** @type {?} */ value = this.attrs[i + 1];\n                res += \"[\" + name + (value ? '=' + value : '') + \"]\";\n            }\n        }\n        this.notSelectors.forEach(function (notSelector) { return res += \":not(\" + notSelector + \")\"; });\n        return res;\n    };\n    return CssSelector;\n}());\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nvar SelectorMatcher = (function () {\n    function SelectorMatcher() {\n        this._elementMap = new Map();\n        this._elementPartialMap = new Map();\n        this._classMap = new Map();\n        this._classPartialMap = new Map();\n        this._attrValueMap = new Map();\n        this._attrValuePartialMap = new Map();\n        this._listContexts = [];\n    }\n    /**\n     * @param {?} notSelectors\n     * @return {?}\n     */\n    SelectorMatcher.createNotMatcher = function (notSelectors) {\n        var /** @type {?} */ notMatcher = new SelectorMatcher();\n        notMatcher.addSelectables(notSelectors, null);\n        return notMatcher;\n    };\n    /**\n     * @param {?} cssSelectors\n     * @param {?=} callbackCtxt\n     * @return {?}\n     */\n    SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {\n        var /** @type {?} */ listContext = null;\n        if (cssSelectors.length > 1) {\n            listContext = new SelectorListContext(cssSelectors);\n            this._listContexts.push(listContext);\n        }\n        for (var /** @type {?} */ i = 0; i < cssSelectors.length; i++) {\n            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n        }\n    };\n    /**\n     * Add an object that can be found later on by calling `match`.\n     * @param {?} cssSelector A css selector\n     * @param {?} callbackCtxt An opaque object that will be given to the callback of the `match` function\n     * @param {?} listContext\n     * @return {?}\n     */\n    SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {\n        var /** @type {?} */ matcher = this;\n        var /** @type {?} */ element = cssSelector.element;\n        var /** @type {?} */ classNames = cssSelector.classNames;\n        var /** @type {?} */ attrs = cssSelector.attrs;\n        var /** @type {?} */ selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n        if (element) {\n            var /** @type {?} */ isTerminal = attrs.length === 0 && classNames.length === 0;\n            if (isTerminal) {\n                this._addTerminal(matcher._elementMap, element, selectable);\n            }\n            else {\n                matcher = this._addPartial(matcher._elementPartialMap, element);\n            }\n        }\n        if (classNames) {\n            for (var /** @type {?} */ i = 0; i < classNames.length; i++) {\n                var /** @type {?} */ isTerminal = attrs.length === 0 && i === classNames.length - 1;\n                var /** @type {?} */ className = classNames[i];\n                if (isTerminal) {\n                    this._addTerminal(matcher._classMap, className, selectable);\n                }\n                else {\n                    matcher = this._addPartial(matcher._classPartialMap, className);\n                }\n            }\n        }\n        if (attrs) {\n            for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n                var /** @type {?} */ isTerminal = i === attrs.length - 2;\n                var /** @type {?} */ name = attrs[i];\n                var /** @type {?} */ value = attrs[i + 1];\n                if (isTerminal) {\n                    var /** @type {?} */ terminalMap = matcher._attrValueMap;\n                    var /** @type {?} */ terminalValuesMap = terminalMap.get(name);\n                    if (!terminalValuesMap) {\n                        terminalValuesMap = new Map();\n                        terminalMap.set(name, terminalValuesMap);\n                    }\n                    this._addTerminal(terminalValuesMap, value, selectable);\n                }\n                else {\n                    var /** @type {?} */ partialMap = matcher._attrValuePartialMap;\n                    var /** @type {?} */ partialValuesMap = partialMap.get(name);\n                    if (!partialValuesMap) {\n                        partialValuesMap = new Map();\n                        partialMap.set(name, partialValuesMap);\n                    }\n                    matcher = this._addPartial(partialValuesMap, value);\n                }\n            }\n        }\n    };\n    /**\n     * @param {?} map\n     * @param {?} name\n     * @param {?} selectable\n     * @return {?}\n     */\n    SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {\n        var /** @type {?} */ terminalList = map.get(name);\n        if (!terminalList) {\n            terminalList = [];\n            map.set(name, terminalList);\n        }\n        terminalList.push(selectable);\n    };\n    /**\n     * @param {?} map\n     * @param {?} name\n     * @return {?}\n     */\n    SelectorMatcher.prototype._addPartial = function (map, name) {\n        var /** @type {?} */ matcher = map.get(name);\n        if (!matcher) {\n            matcher = new SelectorMatcher();\n            map.set(name, matcher);\n        }\n        return matcher;\n    };\n    /**\n     * Find the objects that have been added via `addSelectable`\n     * whose css selector is contained in the given css selector.\n     * @param {?} cssSelector A css selector\n     * @param {?} matchedCallback This callback will be called with the object handed into `addSelectable`\n     * @return {?} boolean true if a match was found\n     */\n    SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {\n        var /** @type {?} */ result = false;\n        var /** @type {?} */ element = cssSelector.element;\n        var /** @type {?} */ classNames = cssSelector.classNames;\n        var /** @type {?} */ attrs = cssSelector.attrs;\n        for (var /** @type {?} */ i = 0; i < this._listContexts.length; i++) {\n            this._listContexts[i].alreadyMatched = false;\n        }\n        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n            result;\n        if (classNames) {\n            for (var /** @type {?} */ i = 0; i < classNames.length; i++) {\n                var /** @type {?} */ className = classNames[i];\n                result =\n                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n                result =\n                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n                        result;\n            }\n        }\n        if (attrs) {\n            for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {\n                var /** @type {?} */ name = attrs[i];\n                var /** @type {?} */ value = attrs[i + 1];\n                var /** @type {?} */ terminalValuesMap = this._attrValueMap.get(name);\n                if (value) {\n                    result =\n                        this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n                var /** @type {?} */ partialValuesMap = this._attrValuePartialMap.get(name);\n                if (value) {\n                    result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n            }\n        }\n        return result;\n    };\n    /**\n     * \\@internal\n     * @param {?} map\n     * @param {?} name\n     * @param {?} cssSelector\n     * @param {?} matchedCallback\n     * @return {?}\n     */\n    SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        var /** @type {?} */ selectables = map.get(name) || [];\n        var /** @type {?} */ starSelectables = map.get('*');\n        if (starSelectables) {\n            selectables = selectables.concat(starSelectables);\n        }\n        if (selectables.length === 0) {\n            return false;\n        }\n        var /** @type {?} */ selectable;\n        var /** @type {?} */ result = false;\n        for (var /** @type {?} */ i = 0; i < selectables.length; i++) {\n            selectable = selectables[i];\n            result = selectable.finalize(cssSelector, matchedCallback) || result;\n        }\n        return result;\n    };\n    /**\n     * \\@internal\n     * @param {?} map\n     * @param {?} name\n     * @param {?} cssSelector\n     * @param {?} matchedCallback\n     * @return {?}\n     */\n    SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        var /** @type {?} */ nestedSelector = map.get(name);\n        if (!nestedSelector) {\n            return false;\n        }\n        // TODO(perf): get rid of recursion and measure again\n        // TODO(perf): don't pass the whole selector into the recursion,\n        // but only the not processed parts\n        return nestedSelector.match(cssSelector, matchedCallback);\n    };\n    return SelectorMatcher;\n}());\nvar SelectorListContext = (function () {\n    /**\n     * @param {?} selectors\n     */\n    function SelectorListContext(selectors) {\n        this.selectors = selectors;\n        this.alreadyMatched = false;\n    }\n    return SelectorListContext;\n}());\nvar SelectorContext = (function () {\n    /**\n     * @param {?} selector\n     * @param {?} cbContext\n     * @param {?} listContext\n     */\n    function SelectorContext(selector, cbContext, listContext) {\n        this.selector = selector;\n        this.cbContext = cbContext;\n        this.listContext = listContext;\n        this.notSelectors = selector.notSelectors;\n    }\n    /**\n     * @param {?} cssSelector\n     * @param {?} callback\n     * @return {?}\n     */\n    SelectorContext.prototype.finalize = function (cssSelector, callback) {\n        var /** @type {?} */ result = true;\n        if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n            var /** @type {?} */ notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n            result = !notMatcher.match(cssSelector, null);\n        }\n        if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n            if (this.listContext) {\n                this.listContext.alreadyMatched = true;\n            }\n            callback(this.selector, this.cbContext);\n        }\n        return result;\n    };\n    return SelectorContext;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar MODULE_SUFFIX = '';\nvar DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n/**\n * @param {?} input\n * @return {?}\n */\n/**\n * @param {?} input\n * @return {?}\n */\nfunction dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        return m[1].toUpperCase();\n    });\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nfunction splitAtColon(input, defaultValues) {\n    return _splitAt(input, ':', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nfunction splitAtPeriod(input, defaultValues) {\n    return _splitAt(input, '.', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} character\n * @param {?} defaultValues\n * @return {?}\n */\nfunction _splitAt(input, character, defaultValues) {\n    var /** @type {?} */ characterIndex = input.indexOf(character);\n    if (characterIndex == -1)\n        return defaultValues;\n    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n/**\n * @param {?} value\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nfunction visitValue(value, visitor, context) {\n    if (Array.isArray(value)) {\n        return visitor.visitArray(/** @type {?} */ (value), context);\n    }\n    if (isStrictStringMap(value)) {\n        return visitor.visitStringMap(/** @type {?} */ (value), context);\n    }\n    if (value == null || typeof value == 'string' || typeof value == 'number' ||\n        typeof value == 'boolean') {\n        return visitor.visitPrimitive(value, context);\n    }\n    return visitor.visitOther(value, context);\n}\nvar ValueTransformer = (function () {\n    function ValueTransformer() {\n    }\n    /**\n     * @param {?} arr\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitArray = function (arr, context) {\n        var _this = this;\n        return arr.map(function (value) { return visitValue(value, _this, context); });\n    };\n    /**\n     * @param {?} map\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitStringMap = function (map, context) {\n        var _this = this;\n        var /** @type {?} */ result = {};\n        Object.keys(map).forEach(function (key) { result[key] = visitValue(map[key], _this, context); });\n        return result;\n    };\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitPrimitive = function (value, context) { return value; };\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    ValueTransformer.prototype.visitOther = function (value, context) { return value; };\n    return ValueTransformer;\n}());\nvar SyncAsyncResult = (function () {\n    /**\n     * @param {?} syncResult\n     * @param {?=} asyncResult\n     */\n    function SyncAsyncResult(syncResult, asyncResult) {\n        if (asyncResult === void 0) { asyncResult = null; }\n        this.syncResult = syncResult;\n        this.asyncResult = asyncResult;\n        if (!asyncResult) {\n            this.asyncResult = Promise.resolve(syncResult);\n        }\n    }\n    return SyncAsyncResult;\n}());\n/**\n * @param {?} msg\n * @return {?}\n */\nfunction syntaxError(msg) {\n    var /** @type {?} */ error = Error(msg);\n    ((error))[ERROR_SYNTAX_ERROR] = true;\n    return error;\n}\nvar ERROR_SYNTAX_ERROR = 'ngSyntaxError';\n/**\n * @param {?} error\n * @return {?}\n */\nfunction isSyntaxError(error) {\n    return ((error))[ERROR_SYNTAX_ERROR];\n}\n/**\n * @param {?} s\n * @return {?}\n */\nfunction escapeRegExp(s) {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\nvar STRING_MAP_PROTO = Object.getPrototypeOf({});\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction isStrictStringMap(obj) {\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction utf8Encode(str) {\n    var /** @type {?} */ encoded = '';\n    for (var /** @type {?} */ index = 0; index < str.length; index++) {\n        var /** @type {?} */ codePoint = str.charCodeAt(index);\n        // decode surrogate\n        // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n            var /** @type {?} */ low = str.charCodeAt(index + 1);\n            if (low >= 0xdc00 && low <= 0xdfff) {\n                index++;\n                codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n            }\n        }\n        if (codePoint <= 0x7f) {\n            encoded += String.fromCharCode(codePoint);\n        }\n        else if (codePoint <= 0x7ff) {\n            encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0xffff) {\n            encoded += String.fromCharCode((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0x1fffff) {\n            encoded += String.fromCharCode(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n    }\n    return encoded;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// group 0: \"[prop] or (event) or @trigger\"\n// group 1: \"prop\" from \"[prop]\"\n// group 2: \"event\" from \"(event)\"\n// group 3: \"@trigger\" from \"@trigger\"\nvar HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\nvar CompileAnimationEntryMetadata = (function () {\n    /**\n     * @param {?=} name\n     * @param {?=} definitions\n     */\n    function CompileAnimationEntryMetadata(name, definitions) {\n        if (name === void 0) { name = null; }\n        if (definitions === void 0) { definitions = null; }\n        this.name = name;\n        this.definitions = definitions;\n    }\n    return CompileAnimationEntryMetadata;\n}());\n/**\n * @abstract\n */\nvar CompileAnimationStateMetadata = (function () {\n    function CompileAnimationStateMetadata() {\n    }\n    return CompileAnimationStateMetadata;\n}());\nvar CompileAnimationStateDeclarationMetadata = (function (_super) {\n    __extends(CompileAnimationStateDeclarationMetadata, _super);\n    /**\n     * @param {?} stateNameExpr\n     * @param {?} styles\n     */\n    function CompileAnimationStateDeclarationMetadata(stateNameExpr, styles) {\n        var _this = _super.call(this) || this;\n        _this.stateNameExpr = stateNameExpr;\n        _this.styles = styles;\n        return _this;\n    }\n    return CompileAnimationStateDeclarationMetadata;\n}(CompileAnimationStateMetadata));\nvar CompileAnimationStateTransitionMetadata = (function (_super) {\n    __extends(CompileAnimationStateTransitionMetadata, _super);\n    /**\n     * @param {?} stateChangeExpr\n     * @param {?} steps\n     */\n    function CompileAnimationStateTransitionMetadata(stateChangeExpr, steps) {\n        var _this = _super.call(this) || this;\n        _this.stateChangeExpr = stateChangeExpr;\n        _this.steps = steps;\n        return _this;\n    }\n    return CompileAnimationStateTransitionMetadata;\n}(CompileAnimationStateMetadata));\n/**\n * @abstract\n */\nvar CompileAnimationMetadata = (function () {\n    function CompileAnimationMetadata() {\n    }\n    return CompileAnimationMetadata;\n}());\nvar CompileAnimationKeyframesSequenceMetadata = (function (_super) {\n    __extends(CompileAnimationKeyframesSequenceMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationKeyframesSequenceMetadata(steps) {\n        if (steps === void 0) { steps = []; }\n        var _this = _super.call(this) || this;\n        _this.steps = steps;\n        return _this;\n    }\n    return CompileAnimationKeyframesSequenceMetadata;\n}(CompileAnimationMetadata));\nvar CompileAnimationStyleMetadata = (function (_super) {\n    __extends(CompileAnimationStyleMetadata, _super);\n    /**\n     * @param {?} offset\n     * @param {?=} styles\n     */\n    function CompileAnimationStyleMetadata(offset, styles) {\n        if (styles === void 0) { styles = null; }\n        var _this = _super.call(this) || this;\n        _this.offset = offset;\n        _this.styles = styles;\n        return _this;\n    }\n    return CompileAnimationStyleMetadata;\n}(CompileAnimationMetadata));\nvar CompileAnimationAnimateMetadata = (function (_super) {\n    __extends(CompileAnimationAnimateMetadata, _super);\n    /**\n     * @param {?=} timings\n     * @param {?=} styles\n     */\n    function CompileAnimationAnimateMetadata(timings, styles) {\n        if (timings === void 0) { timings = 0; }\n        if (styles === void 0) { styles = null; }\n        var _this = _super.call(this) || this;\n        _this.timings = timings;\n        _this.styles = styles;\n        return _this;\n    }\n    return CompileAnimationAnimateMetadata;\n}(CompileAnimationMetadata));\n/**\n * @abstract\n */\nvar CompileAnimationWithStepsMetadata = (function (_super) {\n    __extends(CompileAnimationWithStepsMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationWithStepsMetadata(steps) {\n        if (steps === void 0) { steps = null; }\n        var _this = _super.call(this) || this;\n        _this.steps = steps;\n        return _this;\n    }\n    return CompileAnimationWithStepsMetadata;\n}(CompileAnimationMetadata));\nvar CompileAnimationSequenceMetadata = (function (_super) {\n    __extends(CompileAnimationSequenceMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationSequenceMetadata(steps) {\n        if (steps === void 0) { steps = null; }\n        return _super.call(this, steps) || this;\n    }\n    return CompileAnimationSequenceMetadata;\n}(CompileAnimationWithStepsMetadata));\nvar CompileAnimationGroupMetadata = (function (_super) {\n    __extends(CompileAnimationGroupMetadata, _super);\n    /**\n     * @param {?=} steps\n     */\n    function CompileAnimationGroupMetadata(steps) {\n        if (steps === void 0) { steps = null; }\n        return _super.call(this, steps) || this;\n    }\n    return CompileAnimationGroupMetadata;\n}(CompileAnimationWithStepsMetadata));\n/**\n * @param {?} name\n * @return {?}\n */\nfunction _sanitizeIdentifier(name) {\n    return name.replace(/\\W/g, '_');\n}\nvar _anonymousTypeIndex = 0;\n/**\n * @param {?} compileIdentifier\n * @return {?}\n */\nfunction identifierName(compileIdentifier) {\n    if (!compileIdentifier || !compileIdentifier.reference) {\n        return null;\n    }\n    var /** @type {?} */ ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.name;\n    }\n    if (ref['__anonymousType']) {\n        return ref['__anonymousType'];\n    }\n    var /** @type {?} */ identifier = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(ref);\n    if (identifier.indexOf('(') >= 0) {\n        // case: anonymous functions!\n        identifier = \"anonymous_\" + _anonymousTypeIndex++;\n        ref['__anonymousType'] = identifier;\n    }\n    else {\n        identifier = _sanitizeIdentifier(identifier);\n    }\n    return identifier;\n}\n/**\n * @param {?} compileIdentifier\n * @return {?}\n */\nfunction identifierModuleUrl(compileIdentifier) {\n    var /** @type {?} */ ref = compileIdentifier.reference;\n    if (ref instanceof StaticSymbol) {\n        return ref.filePath;\n    }\n    return __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */].importUri(ref);\n}\n/**\n * @param {?} compType\n * @param {?} embeddedTemplateIndex\n * @return {?}\n */\nfunction viewClassName(compType, embeddedTemplateIndex) {\n    return \"View_\" + identifierName({ reference: compType }) + \"_\" + embeddedTemplateIndex;\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nfunction rendererTypeName(compType) {\n    return \"RenderType_\" + identifierName({ reference: compType });\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nfunction hostViewClassName(compType) {\n    return \"HostView_\" + identifierName({ reference: compType });\n}\n/**\n * @param {?} dirType\n * @return {?}\n */\nfunction dirWrapperClassName(dirType) {\n    return \"Wrapper_\" + identifierName({ reference: dirType });\n}\n/**\n * @param {?} compType\n * @return {?}\n */\nfunction componentFactoryName(compType) {\n    return identifierName({ reference: compType }) + \"NgFactory\";\n}\nvar CompileSummaryKind = {};\nCompileSummaryKind.Pipe = 0;\nCompileSummaryKind.Directive = 1;\nCompileSummaryKind.NgModule = 2;\nCompileSummaryKind.Injectable = 3;\nCompileSummaryKind[CompileSummaryKind.Pipe] = \"Pipe\";\nCompileSummaryKind[CompileSummaryKind.Directive] = \"Directive\";\nCompileSummaryKind[CompileSummaryKind.NgModule] = \"NgModule\";\nCompileSummaryKind[CompileSummaryKind.Injectable] = \"Injectable\";\n/**\n * @param {?} token\n * @return {?}\n */\nfunction tokenName(token) {\n    return token.value != null ? _sanitizeIdentifier(token.value) : identifierName(token.identifier);\n}\n/**\n * @param {?} token\n * @return {?}\n */\nfunction tokenReference(token) {\n    if (token.identifier != null) {\n        return token.identifier.reference;\n    }\n    else {\n        return token.value;\n    }\n}\n/**\n * Metadata about a stylesheet\n */\nvar CompileStylesheetMetadata = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompileStylesheetMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, moduleUrl = _b.moduleUrl, styles = _b.styles, styleUrls = _b.styleUrls;\n        this.moduleUrl = moduleUrl;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n    }\n    return CompileStylesheetMetadata;\n}());\n/**\n * Metadata regarding compilation of a template.\n */\nvar CompileTemplateMetadata = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompileTemplateMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, encapsulation = _b.encapsulation, template = _b.template, templateUrl = _b.templateUrl, styles = _b.styles, styleUrls = _b.styleUrls, externalStylesheets = _b.externalStylesheets, animations = _b.animations, ngContentSelectors = _b.ngContentSelectors, interpolation = _b.interpolation, isInline = _b.isInline;\n        this.encapsulation = encapsulation;\n        this.template = template;\n        this.templateUrl = templateUrl;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n        this.externalStylesheets = _normalizeArray(externalStylesheets);\n        this.animations = animations ? flatten(animations) : [];\n        this.ngContentSelectors = ngContentSelectors || [];\n        if (interpolation && interpolation.length != 2) {\n            throw new Error(\"'interpolation' should have a start and an end symbol.\");\n        }\n        this.interpolation = interpolation;\n        this.isInline = isInline;\n    }\n    /**\n     * @return {?}\n     */\n    CompileTemplateMetadata.prototype.toSummary = function () {\n        return {\n            animations: this.animations.map(function (anim) { return anim.name; }),\n            ngContentSelectors: this.ngContentSelectors,\n            encapsulation: this.encapsulation,\n        };\n    };\n    return CompileTemplateMetadata;\n}());\n/**\n * Metadata regarding compilation of a directive.\n */\nvar CompileDirectiveMetadata = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompileDirectiveMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, isHost = _b.isHost, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, hostListeners = _b.hostListeners, hostProperties = _b.hostProperties, hostAttributes = _b.hostAttributes, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template, componentViewType = _b.componentViewType, rendererType = _b.rendererType, componentFactory = _b.componentFactory;\n        this.isHost = !!isHost;\n        this.type = type;\n        this.isComponent = isComponent;\n        this.selector = selector;\n        this.exportAs = exportAs;\n        this.changeDetection = changeDetection;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.hostListeners = hostListeners;\n        this.hostProperties = hostProperties;\n        this.hostAttributes = hostAttributes;\n        this.providers = _normalizeArray(providers);\n        this.viewProviders = _normalizeArray(viewProviders);\n        this.queries = _normalizeArray(queries);\n        this.viewQueries = _normalizeArray(viewQueries);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.template = template;\n        this.componentViewType = componentViewType;\n        this.rendererType = rendererType;\n        this.componentFactory = componentFactory;\n    }\n    /**\n     * @param {?=} __0\n     * @return {?}\n     */\n    CompileDirectiveMetadata.create = function (_a) {\n        var _b = _a === void 0 ? {} : _a, isHost = _b.isHost, type = _b.type, isComponent = _b.isComponent, selector = _b.selector, exportAs = _b.exportAs, changeDetection = _b.changeDetection, inputs = _b.inputs, outputs = _b.outputs, host = _b.host, providers = _b.providers, viewProviders = _b.viewProviders, queries = _b.queries, viewQueries = _b.viewQueries, entryComponents = _b.entryComponents, template = _b.template, componentViewType = _b.componentViewType, rendererType = _b.rendererType, componentFactory = _b.componentFactory;\n        var /** @type {?} */ hostListeners = {};\n        var /** @type {?} */ hostProperties = {};\n        var /** @type {?} */ hostAttributes = {};\n        if (host != null) {\n            Object.keys(host).forEach(function (key) {\n                var /** @type {?} */ value = host[key];\n                var /** @type {?} */ matches = key.match(HOST_REG_EXP);\n                if (matches === null) {\n                    hostAttributes[key] = value;\n                }\n                else if (matches[1] != null) {\n                    hostProperties[matches[1]] = value;\n                }\n                else if (matches[2] != null) {\n                    hostListeners[matches[2]] = value;\n                }\n            });\n        }\n        var /** @type {?} */ inputsMap = {};\n        if (inputs != null) {\n            inputs.forEach(function (bindConfig) {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                var /** @type {?} */ parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                inputsMap[parts[0]] = parts[1];\n            });\n        }\n        var /** @type {?} */ outputsMap = {};\n        if (outputs != null) {\n            outputs.forEach(function (bindConfig) {\n                // canonical syntax: `dirProp: elProp`\n                // if there is no `:`, use dirProp = elProp\n                var /** @type {?} */ parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n                outputsMap[parts[0]] = parts[1];\n            });\n        }\n        return new CompileDirectiveMetadata({\n            isHost: isHost,\n            type: type,\n            isComponent: !!isComponent, selector: selector, exportAs: exportAs, changeDetection: changeDetection,\n            inputs: inputsMap,\n            outputs: outputsMap,\n            hostListeners: hostListeners,\n            hostProperties: hostProperties,\n            hostAttributes: hostAttributes,\n            providers: providers,\n            viewProviders: viewProviders,\n            queries: queries,\n            viewQueries: viewQueries,\n            entryComponents: entryComponents,\n            template: template,\n            componentViewType: componentViewType,\n            rendererType: rendererType,\n            componentFactory: componentFactory,\n        });\n    };\n    /**\n     * @return {?}\n     */\n    CompileDirectiveMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.Directive,\n            type: this.type,\n            isComponent: this.isComponent,\n            selector: this.selector,\n            exportAs: this.exportAs,\n            inputs: this.inputs,\n            outputs: this.outputs,\n            hostListeners: this.hostListeners,\n            hostProperties: this.hostProperties,\n            hostAttributes: this.hostAttributes,\n            providers: this.providers,\n            viewProviders: this.viewProviders,\n            queries: this.queries,\n            viewQueries: this.viewQueries,\n            entryComponents: this.entryComponents,\n            changeDetection: this.changeDetection,\n            template: this.template && this.template.toSummary(),\n            componentViewType: this.componentViewType,\n            rendererType: this.rendererType,\n            componentFactory: this.componentFactory\n        };\n    };\n    return CompileDirectiveMetadata;\n}());\n/**\n * Construct {\\@link CompileDirectiveMetadata} from {\\@link ComponentTypeMetadata} and a selector.\n * @param {?} hostTypeReference\n * @param {?} compMeta\n * @param {?} hostViewType\n * @return {?}\n */\nfunction createHostComponentMeta(hostTypeReference, compMeta, hostViewType) {\n    var /** @type {?} */ template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();\n    return CompileDirectiveMetadata.create({\n        isHost: true,\n        type: { reference: hostTypeReference, diDeps: [], lifecycleHooks: [] },\n        template: new CompileTemplateMetadata({\n            encapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].None,\n            template: template,\n            templateUrl: '',\n            styles: [],\n            styleUrls: [],\n            ngContentSelectors: [],\n            animations: [],\n            isInline: true,\n        }),\n        changeDetection: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_0\" /* ChangeDetectionStrategy */].Default,\n        inputs: [],\n        outputs: [],\n        host: {},\n        isComponent: true,\n        selector: '*',\n        providers: [],\n        viewProviders: [],\n        queries: [],\n        viewQueries: [],\n        componentViewType: hostViewType,\n        rendererType: { id: '__Host__', encapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].None, styles: [], data: {} }\n    });\n}\nvar CompilePipeMetadata = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompilePipeMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, type = _b.type, name = _b.name, pure = _b.pure;\n        this.type = type;\n        this.name = name;\n        this.pure = !!pure;\n    }\n    /**\n     * @return {?}\n     */\n    CompilePipeMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.Pipe,\n            type: this.type,\n            name: this.name,\n            pure: this.pure\n        };\n    };\n    return CompilePipeMetadata;\n}());\n/**\n * Metadata regarding compilation of a module.\n */\nvar CompileNgModuleMetadata = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompileNgModuleMetadata(_a) {\n        var _b = _a === void 0 ? {} : _a, type = _b.type, providers = _b.providers, declaredDirectives = _b.declaredDirectives, exportedDirectives = _b.exportedDirectives, declaredPipes = _b.declaredPipes, exportedPipes = _b.exportedPipes, entryComponents = _b.entryComponents, bootstrapComponents = _b.bootstrapComponents, importedModules = _b.importedModules, exportedModules = _b.exportedModules, schemas = _b.schemas, transitiveModule = _b.transitiveModule, id = _b.id;\n        this.type = type;\n        this.declaredDirectives = _normalizeArray(declaredDirectives);\n        this.exportedDirectives = _normalizeArray(exportedDirectives);\n        this.declaredPipes = _normalizeArray(declaredPipes);\n        this.exportedPipes = _normalizeArray(exportedPipes);\n        this.providers = _normalizeArray(providers);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n        this.importedModules = _normalizeArray(importedModules);\n        this.exportedModules = _normalizeArray(exportedModules);\n        this.schemas = _normalizeArray(schemas);\n        this.id = id;\n        this.transitiveModule = transitiveModule;\n    }\n    /**\n     * @return {?}\n     */\n    CompileNgModuleMetadata.prototype.toSummary = function () {\n        return {\n            summaryKind: CompileSummaryKind.NgModule,\n            type: this.type,\n            entryComponents: this.transitiveModule.entryComponents,\n            providers: this.transitiveModule.providers,\n            modules: this.transitiveModule.modules,\n            exportedDirectives: this.transitiveModule.exportedDirectives,\n            exportedPipes: this.transitiveModule.exportedPipes\n        };\n    };\n    return CompileNgModuleMetadata;\n}());\nvar TransitiveCompileNgModuleMetadata = (function () {\n    function TransitiveCompileNgModuleMetadata() {\n        this.directivesSet = new Set();\n        this.directives = [];\n        this.exportedDirectivesSet = new Set();\n        this.exportedDirectives = [];\n        this.pipesSet = new Set();\n        this.pipes = [];\n        this.exportedPipesSet = new Set();\n        this.exportedPipes = [];\n        this.modulesSet = new Set();\n        this.modules = [];\n        this.entryComponentsSet = new Set();\n        this.entryComponents = [];\n        this.providers = [];\n    }\n    /**\n     * @param {?} provider\n     * @param {?} module\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addProvider = function (provider, module) {\n        this.providers.push({ provider: provider, module: module });\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addDirective = function (id) {\n        if (!this.directivesSet.has(id.reference)) {\n            this.directivesSet.add(id.reference);\n            this.directives.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addExportedDirective = function (id) {\n        if (!this.exportedDirectivesSet.has(id.reference)) {\n            this.exportedDirectivesSet.add(id.reference);\n            this.exportedDirectives.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addPipe = function (id) {\n        if (!this.pipesSet.has(id.reference)) {\n            this.pipesSet.add(id.reference);\n            this.pipes.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addExportedPipe = function (id) {\n        if (!this.exportedPipesSet.has(id.reference)) {\n            this.exportedPipesSet.add(id.reference);\n            this.exportedPipes.push(id);\n        }\n    };\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addModule = function (id) {\n        if (!this.modulesSet.has(id.reference)) {\n            this.modulesSet.add(id.reference);\n            this.modules.push(id);\n        }\n    };\n    /**\n     * @param {?} ec\n     * @return {?}\n     */\n    TransitiveCompileNgModuleMetadata.prototype.addEntryComponent = function (ec) {\n        if (!this.entryComponentsSet.has(ec.componentType)) {\n            this.entryComponentsSet.add(ec.componentType);\n            this.entryComponents.push(ec);\n        }\n    };\n    return TransitiveCompileNgModuleMetadata;\n}());\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction _normalizeArray(obj) {\n    return obj || [];\n}\nvar ProviderMeta = (function () {\n    /**\n     * @param {?} token\n     * @param {?} __1\n     */\n    function ProviderMeta(token, _a) {\n        var useClass = _a.useClass, useValue = _a.useValue, useExisting = _a.useExisting, useFactory = _a.useFactory, deps = _a.deps, multi = _a.multi;\n        this.token = token;\n        this.useClass = useClass;\n        this.useValue = useValue;\n        this.useExisting = useExisting;\n        this.useFactory = useFactory;\n        this.dependencies = deps;\n        this.multi = !!multi;\n    }\n    return ProviderMeta;\n}());\n/**\n * @template T\n * @param {?} list\n * @return {?}\n */\nfunction flatten(list) {\n    return list.reduce(function (flat, item) {\n        var /** @type {?} */ flatItem = Array.isArray(item) ? flatten(item) : item;\n        return ((flat)).concat(flatItem);\n    }, []);\n}\n/**\n * @param {?} url\n * @return {?}\n */\nfunction sourceUrl(url) {\n    // Note: We need 3 \"/\" so that ng shows up as a separate domain\n    // in the chrome dev tools.\n    return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, 'ng:///');\n}\n/**\n * @param {?} ngModuleType\n * @param {?} compMeta\n * @param {?} templateMeta\n * @return {?}\n */\nfunction templateSourceUrl(ngModuleType, compMeta, templateMeta) {\n    var /** @type {?} */ url;\n    if (templateMeta.isInline) {\n        if (compMeta.type.reference instanceof StaticSymbol) {\n            // Note: a .ts file might contain multiple components with inline templates,\n            // so we need to give them unique urls, as these will be used for sourcemaps.\n            url = compMeta.type.reference.filePath + \".\" + compMeta.type.reference.name + \".html\";\n        }\n        else {\n            url = identifierName(ngModuleType) + \"/\" + identifierName(compMeta.type) + \".html\";\n        }\n    }\n    else {\n        url = templateMeta.templateUrl;\n    }\n    // always prepend ng:// to make angular resources easy to find and not clobber\n    // user resources.\n    return sourceUrl(url);\n}\n/**\n * @param {?} meta\n * @param {?} id\n * @return {?}\n */\nfunction sharedStylesheetJitUrl(meta, id) {\n    var /** @type {?} */ pathParts = meta.moduleUrl.split(/\\/\\\\/g);\n    var /** @type {?} */ baseName = pathParts[pathParts.length - 1];\n    return sourceUrl(\"css/\" + id + baseName + \".ngstyle.js\");\n}\n/**\n * @param {?} moduleMeta\n * @return {?}\n */\nfunction ngModuleJitUrl(moduleMeta) {\n    return sourceUrl(identifierName(moduleMeta.type) + \"/module.ngfactory.js\");\n}\n/**\n * @param {?} ngModuleType\n * @param {?} compMeta\n * @return {?}\n */\nfunction templateJitUrl(ngModuleType, compMeta) {\n    return sourceUrl(identifierName(ngModuleType) + \"/\" + identifierName(compMeta.type) + \".ngfactory.js\");\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CompilerConfig = (function () {\n    /**\n     * @param {?=} __0\n     */\n    function CompilerConfig(_a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.defaultEncapsulation, defaultEncapsulation = _c === void 0 ? __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].Emulated : _c, _d = _b.useJit, useJit = _d === void 0 ? true : _d, missingTranslation = _b.missingTranslation, enableLegacyTemplate = _b.enableLegacyTemplate;\n        this.defaultEncapsulation = defaultEncapsulation;\n        this.useJit = useJit;\n        this.missingTranslation = missingTranslation;\n        this.enableLegacyTemplate = enableLegacyTemplate !== false;\n    }\n    return CompilerConfig;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ParserError = (function () {\n    /**\n     * @param {?} message\n     * @param {?} input\n     * @param {?} errLocation\n     * @param {?=} ctxLocation\n     */\n    function ParserError(message, input, errLocation, ctxLocation) {\n        this.input = input;\n        this.errLocation = errLocation;\n        this.ctxLocation = ctxLocation;\n        this.message = \"Parser Error: \" + message + \" \" + errLocation + \" [\" + input + \"] in \" + ctxLocation;\n    }\n    return ParserError;\n}());\nvar ParseSpan = (function () {\n    /**\n     * @param {?} start\n     * @param {?} end\n     */\n    function ParseSpan(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    return ParseSpan;\n}());\nvar AST = (function () {\n    /**\n     * @param {?} span\n     */\n    function AST(span) {\n        this.span = span;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    AST.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return null;\n    };\n    /**\n     * @return {?}\n     */\n    AST.prototype.toString = function () { return 'AST'; };\n    return AST;\n}());\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nvar Quote = (function (_super) {\n    __extends(Quote, _super);\n    /**\n     * @param {?} span\n     * @param {?} prefix\n     * @param {?} uninterpretedExpression\n     * @param {?} location\n     */\n    function Quote(span, prefix, uninterpretedExpression, location) {\n        var _this = _super.call(this, span) || this;\n        _this.prefix = prefix;\n        _this.uninterpretedExpression = uninterpretedExpression;\n        _this.location = location;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Quote.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitQuote(this, context);\n    };\n    /**\n     * @return {?}\n     */\n    Quote.prototype.toString = function () { return 'Quote'; };\n    return Quote;\n}(AST));\nvar EmptyExpr = (function (_super) {\n    __extends(EmptyExpr, _super);\n    function EmptyExpr() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    EmptyExpr.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        // do nothing\n    };\n    return EmptyExpr;\n}(AST));\nvar ImplicitReceiver = (function (_super) {\n    __extends(ImplicitReceiver, _super);\n    function ImplicitReceiver() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    ImplicitReceiver.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitImplicitReceiver(this, context);\n    };\n    return ImplicitReceiver;\n}(AST));\n/**\n * Multiple expressions separated by a semicolon.\n */\nvar Chain = (function (_super) {\n    __extends(Chain, _super);\n    /**\n     * @param {?} span\n     * @param {?} expressions\n     */\n    function Chain(span, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.expressions = expressions;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Chain.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitChain(this, context);\n    };\n    return Chain;\n}(AST));\nvar Conditional = (function (_super) {\n    __extends(Conditional, _super);\n    /**\n     * @param {?} span\n     * @param {?} condition\n     * @param {?} trueExp\n     * @param {?} falseExp\n     */\n    function Conditional(span, condition, trueExp, falseExp) {\n        var _this = _super.call(this, span) || this;\n        _this.condition = condition;\n        _this.trueExp = trueExp;\n        _this.falseExp = falseExp;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Conditional.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitConditional(this, context);\n    };\n    return Conditional;\n}(AST));\nvar PropertyRead = (function (_super) {\n    __extends(PropertyRead, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     */\n    function PropertyRead(span, receiver, name) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    PropertyRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPropertyRead(this, context);\n    };\n    return PropertyRead;\n}(AST));\nvar PropertyWrite = (function (_super) {\n    __extends(PropertyWrite, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} value\n     */\n    function PropertyWrite(span, receiver, name, value) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    PropertyWrite.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPropertyWrite(this, context);\n    };\n    return PropertyWrite;\n}(AST));\nvar SafePropertyRead = (function (_super) {\n    __extends(SafePropertyRead, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     */\n    function SafePropertyRead(span, receiver, name) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    SafePropertyRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitSafePropertyRead(this, context);\n    };\n    return SafePropertyRead;\n}(AST));\nvar KeyedRead = (function (_super) {\n    __extends(KeyedRead, _super);\n    /**\n     * @param {?} span\n     * @param {?} obj\n     * @param {?} key\n     */\n    function KeyedRead(span, obj, key) {\n        var _this = _super.call(this, span) || this;\n        _this.obj = obj;\n        _this.key = key;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    KeyedRead.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitKeyedRead(this, context);\n    };\n    return KeyedRead;\n}(AST));\nvar KeyedWrite = (function (_super) {\n    __extends(KeyedWrite, _super);\n    /**\n     * @param {?} span\n     * @param {?} obj\n     * @param {?} key\n     * @param {?} value\n     */\n    function KeyedWrite(span, obj, key, value) {\n        var _this = _super.call(this, span) || this;\n        _this.obj = obj;\n        _this.key = key;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    KeyedWrite.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitKeyedWrite(this, context);\n    };\n    return KeyedWrite;\n}(AST));\nvar BindingPipe = (function (_super) {\n    __extends(BindingPipe, _super);\n    /**\n     * @param {?} span\n     * @param {?} exp\n     * @param {?} name\n     * @param {?} args\n     */\n    function BindingPipe(span, exp, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.exp = exp;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    BindingPipe.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPipe(this, context);\n    };\n    return BindingPipe;\n}(AST));\nvar LiteralPrimitive = (function (_super) {\n    __extends(LiteralPrimitive, _super);\n    /**\n     * @param {?} span\n     * @param {?} value\n     */\n    function LiteralPrimitive(span, value) {\n        var _this = _super.call(this, span) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    LiteralPrimitive.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralPrimitive(this, context);\n    };\n    return LiteralPrimitive;\n}(AST));\nvar LiteralArray = (function (_super) {\n    __extends(LiteralArray, _super);\n    /**\n     * @param {?} span\n     * @param {?} expressions\n     */\n    function LiteralArray(span, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.expressions = expressions;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    LiteralArray.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralArray(this, context);\n    };\n    return LiteralArray;\n}(AST));\nvar LiteralMap = (function (_super) {\n    __extends(LiteralMap, _super);\n    /**\n     * @param {?} span\n     * @param {?} keys\n     * @param {?} values\n     */\n    function LiteralMap(span, keys, values) {\n        var _this = _super.call(this, span) || this;\n        _this.keys = keys;\n        _this.values = values;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    LiteralMap.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitLiteralMap(this, context);\n    };\n    return LiteralMap;\n}(AST));\nvar Interpolation = (function (_super) {\n    __extends(Interpolation, _super);\n    /**\n     * @param {?} span\n     * @param {?} strings\n     * @param {?} expressions\n     */\n    function Interpolation(span, strings, expressions) {\n        var _this = _super.call(this, span) || this;\n        _this.strings = strings;\n        _this.expressions = expressions;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Interpolation.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitInterpolation(this, context);\n    };\n    return Interpolation;\n}(AST));\nvar Binary = (function (_super) {\n    __extends(Binary, _super);\n    /**\n     * @param {?} span\n     * @param {?} operation\n     * @param {?} left\n     * @param {?} right\n     */\n    function Binary(span, operation, left, right) {\n        var _this = _super.call(this, span) || this;\n        _this.operation = operation;\n        _this.left = left;\n        _this.right = right;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Binary.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitBinary(this, context);\n    };\n    return Binary;\n}(AST));\nvar PrefixNot = (function (_super) {\n    __extends(PrefixNot, _super);\n    /**\n     * @param {?} span\n     * @param {?} expression\n     */\n    function PrefixNot(span, expression) {\n        var _this = _super.call(this, span) || this;\n        _this.expression = expression;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    PrefixNot.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitPrefixNot(this, context);\n    };\n    return PrefixNot;\n}(AST));\nvar MethodCall = (function (_super) {\n    __extends(MethodCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} args\n     */\n    function MethodCall(span, receiver, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    MethodCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitMethodCall(this, context);\n    };\n    return MethodCall;\n}(AST));\nvar SafeMethodCall = (function (_super) {\n    __extends(SafeMethodCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} args\n     */\n    function SafeMethodCall(span, receiver, name, args) {\n        var _this = _super.call(this, span) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    SafeMethodCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitSafeMethodCall(this, context);\n    };\n    return SafeMethodCall;\n}(AST));\nvar FunctionCall = (function (_super) {\n    __extends(FunctionCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} target\n     * @param {?} args\n     */\n    function FunctionCall(span, target, args) {\n        var _this = _super.call(this, span) || this;\n        _this.target = target;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    FunctionCall.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return visitor.visitFunctionCall(this, context);\n    };\n    return FunctionCall;\n}(AST));\nvar ASTWithSource = (function (_super) {\n    __extends(ASTWithSource, _super);\n    /**\n     * @param {?} ast\n     * @param {?} source\n     * @param {?} location\n     * @param {?} errors\n     */\n    function ASTWithSource(ast, source, location, errors) {\n        var _this = _super.call(this, new ParseSpan(0, source == null ? 0 : source.length)) || this;\n        _this.ast = ast;\n        _this.source = source;\n        _this.location = location;\n        _this.errors = errors;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    ASTWithSource.prototype.visit = function (visitor, context) {\n        if (context === void 0) { context = null; }\n        return this.ast.visit(visitor, context);\n    };\n    /**\n     * @return {?}\n     */\n    ASTWithSource.prototype.toString = function () { return this.source + \" in \" + this.location; };\n    return ASTWithSource;\n}(AST));\nvar TemplateBinding = (function () {\n    /**\n     * @param {?} span\n     * @param {?} key\n     * @param {?} keyIsVar\n     * @param {?} name\n     * @param {?} expression\n     */\n    function TemplateBinding(span, key, keyIsVar, name, expression) {\n        this.span = span;\n        this.key = key;\n        this.keyIsVar = keyIsVar;\n        this.name = name;\n        this.expression = expression;\n    }\n    return TemplateBinding;\n}());\nvar RecursiveAstVisitor = (function () {\n    function RecursiveAstVisitor() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {\n        ast.left.visit(this);\n        ast.right.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitChain = function (ast, context) { return this.visitAll(ast.expressions, context); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {\n        ast.condition.visit(this);\n        ast.trueExp.visit(this);\n        ast.falseExp.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {\n        ast.target.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {\n        return this.visitAll(ast.expressions, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {\n        ast.obj.visit(this);\n        ast.key.visit(this);\n        ast.value.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {\n        return this.visitAll(ast.expressions, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) { return this.visitAll(ast.values, context); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {\n        ast.expression.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {\n        ast.receiver.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {\n        ast.receiver.visit(this);\n        ast.value.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {\n        ast.receiver.visit(this);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {\n        ast.receiver.visit(this);\n        return this.visitAll(ast.args, context);\n    };\n    /**\n     * @param {?} asts\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitAll = function (asts, context) {\n        var _this = this;\n        asts.forEach(function (ast) { return ast.visit(_this, context); });\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor.prototype.visitQuote = function (ast, context) { return null; };\n    return RecursiveAstVisitor;\n}());\nvar AstTransformer = (function () {\n    function AstTransformer() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitImplicitReceiver = function (ast, context) { return ast; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitInterpolation = function (ast, context) {\n        return new Interpolation(ast.span, ast.strings, this.visitAll(ast.expressions));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitLiteralPrimitive = function (ast, context) {\n        return new LiteralPrimitive(ast.span, ast.value);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPropertyRead = function (ast, context) {\n        return new PropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPropertyWrite = function (ast, context) {\n        return new PropertyWrite(ast.span, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitSafePropertyRead = function (ast, context) {\n        return new SafePropertyRead(ast.span, ast.receiver.visit(this), ast.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitMethodCall = function (ast, context) {\n        return new MethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitSafeMethodCall = function (ast, context) {\n        return new SafeMethodCall(ast.span, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitFunctionCall = function (ast, context) {\n        return new FunctionCall(ast.span, ast.target.visit(this), this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitLiteralArray = function (ast, context) {\n        return new LiteralArray(ast.span, this.visitAll(ast.expressions));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitLiteralMap = function (ast, context) {\n        return new LiteralMap(ast.span, ast.keys, this.visitAll(ast.values));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitBinary = function (ast, context) {\n        return new Binary(ast.span, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPrefixNot = function (ast, context) {\n        return new PrefixNot(ast.span, ast.expression.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitConditional = function (ast, context) {\n        return new Conditional(ast.span, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitPipe = function (ast, context) {\n        return new BindingPipe(ast.span, ast.exp.visit(this), ast.name, this.visitAll(ast.args));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitKeyedRead = function (ast, context) {\n        return new KeyedRead(ast.span, ast.obj.visit(this), ast.key.visit(this));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitKeyedWrite = function (ast, context) {\n        return new KeyedWrite(ast.span, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n    };\n    /**\n     * @param {?} asts\n     * @return {?}\n     */\n    AstTransformer.prototype.visitAll = function (asts) {\n        var /** @type {?} */ res = new Array(asts.length);\n        for (var /** @type {?} */ i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitChain = function (ast, context) {\n        return new Chain(ast.span, this.visitAll(ast.expressions));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer.prototype.visitQuote = function (ast, context) {\n        return new Quote(ast.span, ast.prefix, ast.uninterpretedExpression, ast.location);\n    };\n    return AstTransformer;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar $EOF = 0;\nvar $TAB = 9;\nvar $LF = 10;\nvar $VTAB = 11;\nvar $FF = 12;\nvar $CR = 13;\nvar $SPACE = 32;\nvar $BANG = 33;\nvar $DQ = 34;\nvar $HASH = 35;\nvar $$ = 36;\nvar $PERCENT = 37;\nvar $AMPERSAND = 38;\nvar $SQ = 39;\nvar $LPAREN = 40;\nvar $RPAREN = 41;\nvar $STAR = 42;\nvar $PLUS = 43;\nvar $COMMA = 44;\nvar $MINUS = 45;\nvar $PERIOD = 46;\nvar $SLASH = 47;\nvar $COLON = 58;\nvar $SEMICOLON = 59;\nvar $LT = 60;\nvar $EQ = 61;\nvar $GT = 62;\nvar $QUESTION = 63;\nvar $0 = 48;\nvar $9 = 57;\nvar $A = 65;\nvar $E = 69;\nvar $F = 70;\nvar $X = 88;\nvar $Z = 90;\nvar $LBRACKET = 91;\nvar $BACKSLASH = 92;\nvar $RBRACKET = 93;\nvar $CARET = 94;\nvar $_ = 95;\nvar $a = 97;\nvar $e = 101;\nvar $f = 102;\nvar $n = 110;\nvar $r = 114;\nvar $t = 116;\nvar $u = 117;\nvar $v = 118;\nvar $x = 120;\nvar $z = 122;\nvar $LBRACE = 123;\nvar $BAR = 124;\nvar $RBRACE = 125;\nvar $NBSP = 160;\nvar $BT = 96;\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isWhitespace(code) {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isDigit(code) {\n    return $0 <= code && code <= $9;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isAsciiLetter(code) {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isAsciiHexDigit(code) {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n/**\n * A replacement for \\@Injectable to be used in the compiler, so that\n * we don't try to evaluate the metadata in the compiler during AoT.\n * This decorator is enough to make the compiler work with the ReflectiveInjector though.\n * \\@Annotation\n * @return {?}\n */\nfunction CompilerInjectable() {\n    return function (x) { return x; };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} identifier\n * @param {?} value\n * @return {?}\n */\nfunction assertArrayOfStrings(identifier, value) {\n    if (!__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"p\" /* isDevMode */])() || value == null) {\n        return;\n    }\n    if (!Array.isArray(value)) {\n        throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n    }\n    for (var /** @type {?} */ i = 0; i < value.length; i += 1) {\n        if (typeof value[i] !== 'string') {\n            throw new Error(\"Expected '\" + identifier + \"' to be an array of strings.\");\n        }\n    }\n}\nvar INTERPOLATION_BLACKLIST_REGEXPS = [\n    /^\\s*$/,\n    /[<>]/,\n    /^[{}]$/,\n    /&(#|[a-z])/i,\n    /^\\/\\//,\n];\n/**\n * @param {?} identifier\n * @param {?} value\n * @return {?}\n */\nfunction assertInterpolationSymbols(identifier, value) {\n    if (value != null && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(\"Expected '\" + identifier + \"' to be an array, [start, end].\");\n    }\n    else if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"p\" /* isDevMode */])() && value != null) {\n        var /** @type {?} */ start_1 = (value[0]);\n        var /** @type {?} */ end_1 = (value[1]);\n        // black list checking\n        INTERPOLATION_BLACKLIST_REGEXPS.forEach(function (regexp) {\n            if (regexp.test(start_1) || regexp.test(end_1)) {\n                throw new Error(\"['\" + start_1 + \"', '\" + end_1 + \"'] contains unusable interpolation symbol.\");\n            }\n        });\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar InterpolationConfig = (function () {\n    /**\n     * @param {?} start\n     * @param {?} end\n     */\n    function InterpolationConfig(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    /**\n     * @param {?} markers\n     * @return {?}\n     */\n    InterpolationConfig.fromArray = function (markers) {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    };\n    ;\n    return InterpolationConfig;\n}());\nvar DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType = {};\nTokenType.Character = 0;\nTokenType.Identifier = 1;\nTokenType.Keyword = 2;\nTokenType.String = 3;\nTokenType.Operator = 4;\nTokenType.Number = 5;\nTokenType.Error = 6;\nTokenType[TokenType.Character] = \"Character\";\nTokenType[TokenType.Identifier] = \"Identifier\";\nTokenType[TokenType.Keyword] = \"Keyword\";\nTokenType[TokenType.String] = \"String\";\nTokenType[TokenType.Operator] = \"Operator\";\nTokenType[TokenType.Number] = \"Number\";\nTokenType[TokenType.Error] = \"Error\";\nvar KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nvar Lexer = (function () {\n    function Lexer() {\n    }\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    Lexer.prototype.tokenize = function (text) {\n        var /** @type {?} */ scanner = new _Scanner(text);\n        var /** @type {?} */ tokens = [];\n        var /** @type {?} */ token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    };\n    return Lexer;\n}());\nLexer.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nLexer.ctorParameters = function () { return []; };\nvar Token = (function () {\n    /**\n     * @param {?} index\n     * @param {?} type\n     * @param {?} numValue\n     * @param {?} strValue\n     */\n    function Token(index, type, numValue, strValue) {\n        this.index = index;\n        this.type = type;\n        this.numValue = numValue;\n        this.strValue = strValue;\n    }\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    Token.prototype.isCharacter = function (code) {\n        return this.type == TokenType.Character && this.numValue == code;\n    };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isNumber = function () { return this.type == TokenType.Number; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isString = function () { return this.type == TokenType.String; };\n    /**\n     * @param {?} operater\n     * @return {?}\n     */\n    Token.prototype.isOperator = function (operater) {\n        return this.type == TokenType.Operator && this.strValue == operater;\n    };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isIdentifier = function () { return this.type == TokenType.Identifier; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeyword = function () { return this.type == TokenType.Keyword; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordLet = function () { return this.type == TokenType.Keyword && this.strValue == 'let'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordAs = function () { return this.type == TokenType.Keyword && this.strValue == 'as'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordNull = function () { return this.type == TokenType.Keyword && this.strValue == 'null'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordUndefined = function () {\n        return this.type == TokenType.Keyword && this.strValue == 'undefined';\n    };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordTrue = function () { return this.type == TokenType.Keyword && this.strValue == 'true'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordFalse = function () { return this.type == TokenType.Keyword && this.strValue == 'false'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isKeywordThis = function () { return this.type == TokenType.Keyword && this.strValue == 'this'; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.isError = function () { return this.type == TokenType.Error; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.toNumber = function () { return this.type == TokenType.Number ? this.numValue : -1; };\n    /**\n     * @return {?}\n     */\n    Token.prototype.toString = function () {\n        switch (this.type) {\n            case TokenType.Character:\n            case TokenType.Identifier:\n            case TokenType.Keyword:\n            case TokenType.Operator:\n            case TokenType.String:\n            case TokenType.Error:\n                return this.strValue;\n            case TokenType.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    };\n    return Token;\n}());\n/**\n * @param {?} index\n * @param {?} code\n * @return {?}\n */\nfunction newCharacterToken(index, code) {\n    return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newIdentifierToken(index, text) {\n    return new Token(index, TokenType.Identifier, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newKeywordToken(index, text) {\n    return new Token(index, TokenType.Keyword, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newOperatorToken(index, text) {\n    return new Token(index, TokenType.Operator, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newStringToken(index, text) {\n    return new Token(index, TokenType.String, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} n\n * @return {?}\n */\nfunction newNumberToken(index, n) {\n    return new Token(index, TokenType.Number, n, '');\n}\n/**\n * @param {?} index\n * @param {?} message\n * @return {?}\n */\nfunction newErrorToken(index, message) {\n    return new Token(index, TokenType.Error, 0, message);\n}\nvar EOF = new Token(-1, TokenType.Character, 0, '');\nvar _Scanner = (function () {\n    /**\n     * @param {?} input\n     */\n    function _Scanner(input) {\n        this.input = input;\n        this.peek = 0;\n        this.index = -1;\n        this.length = input.length;\n        this.advance();\n    }\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.advance = function () {\n        this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n    };\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.scanToken = function () {\n        var /** @type {?} */ input = this.input, /** @type {?} */ length = this.length;\n        var /** @type {?} */ peek = this.peek, /** @type {?} */ index = this.index;\n        // Skip whitespace.\n        while (peek <= $SPACE) {\n            if (++index >= length) {\n                peek = $EOF;\n                break;\n            }\n            else {\n                peek = input.charCodeAt(index);\n            }\n        }\n        this.peek = peek;\n        this.index = index;\n        if (index >= length) {\n            return null;\n        }\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek))\n            return this.scanIdentifier();\n        if (isDigit(peek))\n            return this.scanNumber(index);\n        var /** @type {?} */ start = index;\n        switch (peek) {\n            case $PERIOD:\n                this.advance();\n                return isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, $PERIOD);\n            case $LPAREN:\n            case $RPAREN:\n            case $LBRACE:\n            case $RBRACE:\n            case $LBRACKET:\n            case $RBRACKET:\n            case $COMMA:\n            case $COLON:\n            case $SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case $SQ:\n            case $DQ:\n                return this.scanString();\n            case $HASH:\n            case $PLUS:\n            case $MINUS:\n            case $STAR:\n            case $SLASH:\n            case $PERCENT:\n            case $CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case $QUESTION:\n                return this.scanComplexOperator(start, '?', $PERIOD, '.');\n            case $LT:\n            case $GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n            case $BANG:\n            case $EQ:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n            case $AMPERSAND:\n                return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\n            case $BAR:\n                return this.scanComplexOperator(start, '|', $BAR, '|');\n            case $NBSP:\n                while (isWhitespace(this.peek))\n                    this.advance();\n                return this.scanToken();\n        }\n        this.advance();\n        return this.error(\"Unexpected character [\" + String.fromCharCode(peek) + \"]\", 0);\n    };\n    /**\n     * @param {?} start\n     * @param {?} code\n     * @return {?}\n     */\n    _Scanner.prototype.scanCharacter = function (start, code) {\n        this.advance();\n        return newCharacterToken(start, code);\n    };\n    /**\n     * @param {?} start\n     * @param {?} str\n     * @return {?}\n     */\n    _Scanner.prototype.scanOperator = function (start, str) {\n        this.advance();\n        return newOperatorToken(start, str);\n    };\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param {?} start start index in the expression\n     * @param {?} one first symbol (always part of the operator)\n     * @param {?} twoCode code point for the second symbol\n     * @param {?} two second symbol (part of the operator when the second code point matches)\n     * @param {?=} threeCode code point for the third symbol\n     * @param {?=} three third symbol (part of the operator when provided and matches source expression)\n     * @return {?}\n     */\n    _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {\n        this.advance();\n        var /** @type {?} */ str = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, str);\n    };\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.scanIdentifier = function () {\n        var /** @type {?} */ start = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        var /** @type {?} */ str = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n            newIdentifierToken(start, str);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Scanner.prototype.scanNumber = function (start) {\n        var /** @type {?} */ simple = (this.index === start);\n        this.advance(); // Skip initial digit.\n        while (true) {\n            if (isDigit(this.peek)) {\n            }\n            else if (this.peek == $PERIOD) {\n                simple = false;\n            }\n            else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek))\n                    this.advance();\n                if (!isDigit(this.peek))\n                    return this.error('Invalid exponent', -1);\n                simple = false;\n            }\n            else {\n                break;\n            }\n            this.advance();\n        }\n        var /** @type {?} */ str = this.input.substring(start, this.index);\n        var /** @type {?} */ value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, value);\n    };\n    /**\n     * @return {?}\n     */\n    _Scanner.prototype.scanString = function () {\n        var /** @type {?} */ start = this.index;\n        var /** @type {?} */ quote = this.peek;\n        this.advance(); // Skip initial quote.\n        var /** @type {?} */ buffer = '';\n        var /** @type {?} */ marker = this.index;\n        var /** @type {?} */ input = this.input;\n        while (this.peek != quote) {\n            if (this.peek == $BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                this.advance();\n                var /** @type {?} */ unescapedCode = void 0;\n                // Workaround for TS2.1-introduced type strictness\n                this.peek = this.peek;\n                if (this.peek == $u) {\n                    // 4 character hex code for unicode character.\n                    var /** @type {?} */ hex = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    }\n                    else {\n                        return this.error(\"Invalid unicode escape [\\\\u\" + hex + \"]\", 0);\n                    }\n                    for (var /** @type {?} */ i = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                }\n                else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            }\n            else if (this.peek == $EOF) {\n                return this.error('Unterminated quote', 0);\n            }\n            else {\n                this.advance();\n            }\n        }\n        var /** @type {?} */ last = input.substring(marker, this.index);\n        this.advance(); // Skip terminating quote.\n        return newStringToken(start, buffer + last);\n    };\n    /**\n     * @param {?} message\n     * @param {?} offset\n     * @return {?}\n     */\n    _Scanner.prototype.error = function (message, offset) {\n        var /** @type {?} */ position = this.index + offset;\n        return newErrorToken(position, \"Lexer Error: \" + message + \" at column \" + position + \" in expression [\" + this.input + \"]\");\n    };\n    return _Scanner;\n}());\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierStart(code) {\n    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n        (code == $_) || (code == $$);\n}\n/**\n * @param {?} input\n * @return {?}\n */\nfunction isIdentifier(input) {\n    if (input.length == 0)\n        return false;\n    var /** @type {?} */ scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek))\n        return false;\n    scanner.advance();\n    while (scanner.peek !== $EOF) {\n        if (!isIdentifierPart(scanner.peek))\n            return false;\n        scanner.advance();\n    }\n    return true;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierPart(code) {\n    return isAsciiLetter(code) || isDigit(code) || (code == $_) ||\n        (code == $$);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentStart(code) {\n    return code == $e || code == $E;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentSign(code) {\n    return code == $MINUS || code == $PLUS;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isQuote(code) {\n    return code === $SQ || code === $DQ || code === $BT;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction unescape(code) {\n    switch (code) {\n        case $n:\n            return $LF;\n        case $f:\n            return $FF;\n        case $r:\n            return $CR;\n        case $t:\n            return $TAB;\n        case $v:\n            return $VTAB;\n        default:\n            return code;\n    }\n}\n/**\n * @param {?} text\n * @return {?}\n */\nfunction parseIntAutoRadix(text) {\n    var /** @type {?} */ result = parseInt(text);\n    if (isNaN(result)) {\n        throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar SplitInterpolation = (function () {\n    /**\n     * @param {?} strings\n     * @param {?} expressions\n     * @param {?} offsets\n     */\n    function SplitInterpolation(strings, expressions, offsets) {\n        this.strings = strings;\n        this.expressions = expressions;\n        this.offsets = offsets;\n    }\n    return SplitInterpolation;\n}());\nvar TemplateBindingParseResult = (function () {\n    /**\n     * @param {?} templateBindings\n     * @param {?} warnings\n     * @param {?} errors\n     */\n    function TemplateBindingParseResult(templateBindings, warnings, errors) {\n        this.templateBindings = templateBindings;\n        this.warnings = warnings;\n        this.errors = errors;\n    }\n    return TemplateBindingParseResult;\n}());\n/**\n * @param {?} config\n * @return {?}\n */\nfunction _createInterpolateRegExp(config) {\n    var /** @type {?} */ pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n    return new RegExp(pattern, 'g');\n}\nvar Parser = (function () {\n    /**\n     * @param {?} _lexer\n     */\n    function Parser(_lexer) {\n        this._lexer = _lexer;\n        this.errors = [];\n    }\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseAction = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        var /** @type {?} */ sourceToLex = this._stripComments(input);\n        var /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(input));\n        var /** @type {?} */ ast = new _ParseAST(input, location, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n        return new ASTWithSource(ast, input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseBinding = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n        return new ASTWithSource(ast, input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseSimpleBinding = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n        var /** @type {?} */ errors = SimpleExpressionChecker.check(ast);\n        if (errors.length > 0) {\n            this._reportError(\"Host binding expression cannot contain \" + errors.join(' '), input, location);\n        }\n        return new ASTWithSource(ast, input, location, this.errors);\n    };\n    /**\n     * @param {?} message\n     * @param {?} input\n     * @param {?} errLocation\n     * @param {?=} ctxLocation\n     * @return {?}\n     */\n    Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype._parseBindingAst = function (input, location, interpolationConfig) {\n        // Quotes expressions use 3rd-party expression language. We don't want to use\n        // our lexer or parser for that, so we check for that ahead of time.\n        var /** @type {?} */ quote = this._parseQuote(input, location);\n        if (quote != null) {\n            return quote;\n        }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        var /** @type {?} */ sourceToLex = this._stripComments(input);\n        var /** @type {?} */ tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)\n            .parseChain();\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    Parser.prototype._parseQuote = function (input, location) {\n        if (input == null)\n            return null;\n        var /** @type {?} */ prefixSeparatorIndex = input.indexOf(':');\n        if (prefixSeparatorIndex == -1)\n            return null;\n        var /** @type {?} */ prefix = input.substring(0, prefixSeparatorIndex).trim();\n        if (!isIdentifier(prefix))\n            return null;\n        var /** @type {?} */ uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n        return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n    };\n    /**\n     * @param {?} prefixToken\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    Parser.prototype.parseTemplateBindings = function (prefixToken, input, location) {\n        var /** @type {?} */ tokens = this._lexer.tokenize(input);\n        if (prefixToken) {\n            // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n            var /** @type {?} */ prefixTokens = this._lexer.tokenize(prefixToken).map(function (t) {\n                t.index = 0;\n                return t;\n            });\n            tokens.unshift.apply(tokens, prefixTokens);\n        }\n        return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\n            .parseTemplateBindings();\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.parseInterpolation = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ split = this.splitInterpolation(input, location, interpolationConfig);\n        if (split == null)\n            return null;\n        var /** @type {?} */ expressions = [];\n        for (var /** @type {?} */ i = 0; i < split.expressions.length; ++i) {\n            var /** @type {?} */ expressionText = split.expressions[i];\n            var /** @type {?} */ sourceToLex = this._stripComments(expressionText);\n            var /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(split.expressions[i]));\n            var /** @type {?} */ ast = new _ParseAST(input, location, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length))\n                .parseChain();\n            expressions.push(ast);\n        }\n        return new ASTWithSource(new Interpolation(new ParseSpan(0, input == null ? 0 : input.length), split.strings, expressions), input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype.splitInterpolation = function (input, location, interpolationConfig) {\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n        var /** @type {?} */ parts = input.split(regexp);\n        if (parts.length <= 1) {\n            return null;\n        }\n        var /** @type {?} */ strings = [];\n        var /** @type {?} */ expressions = [];\n        var /** @type {?} */ offsets = [];\n        var /** @type {?} */ offset = 0;\n        for (var /** @type {?} */ i = 0; i < parts.length; i++) {\n            var /** @type {?} */ part = parts[i];\n            if (i % 2 === 0) {\n                // fixed string\n                strings.push(part);\n                offset += part.length;\n            }\n            else if (part.trim().length > 0) {\n                offset += interpolationConfig.start.length;\n                expressions.push(part);\n                offsets.push(offset);\n                offset += part.length + interpolationConfig.end.length;\n            }\n            else {\n                this._reportError('Blank expressions are not allowed in interpolated strings', input, \"at column \" + this._findInterpolationErrorColumn(parts, i, interpolationConfig) + \" in\", location);\n                expressions.push('$implict');\n                offsets.push(offset);\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @return {?}\n     */\n    Parser.prototype.wrapLiteralPrimitive = function (input, location) {\n        return new ASTWithSource(new LiteralPrimitive(new ParseSpan(0, input == null ? 0 : input.length), input), input, location, this.errors);\n    };\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    Parser.prototype._stripComments = function (input) {\n        var /** @type {?} */ i = this._commentStart(input);\n        return i != null ? input.substring(0, i).trim() : input;\n    };\n    /**\n     * @param {?} input\n     * @return {?}\n     */\n    Parser.prototype._commentStart = function (input) {\n        var /** @type {?} */ outerQuote = null;\n        for (var /** @type {?} */ i = 0; i < input.length - 1; i++) {\n            var /** @type {?} */ char = input.charCodeAt(i);\n            var /** @type {?} */ nextChar = input.charCodeAt(i + 1);\n            if (char === $SLASH && nextChar == $SLASH && outerQuote == null)\n                return i;\n            if (outerQuote === char) {\n                outerQuote = null;\n            }\n            else if (outerQuote == null && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype._checkNoInterpolation = function (input, location, interpolationConfig) {\n        var /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n        var /** @type {?} */ parts = input.split(regexp);\n        if (parts.length > 1) {\n            this._reportError(\"Got interpolation (\" + interpolationConfig.start + interpolationConfig.end + \") where expression was expected\", input, \"at column \" + this._findInterpolationErrorColumn(parts, 1, interpolationConfig) + \" in\", location);\n        }\n    };\n    /**\n     * @param {?} parts\n     * @param {?} partInErrIdx\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx, interpolationConfig) {\n        var /** @type {?} */ errLocation = '';\n        for (var /** @type {?} */ j = 0; j < partInErrIdx; j++) {\n            errLocation += j % 2 === 0 ?\n                parts[j] :\n                \"\" + interpolationConfig.start + parts[j] + interpolationConfig.end;\n        }\n        return errLocation.length;\n    };\n    return Parser;\n}());\nParser.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nParser.ctorParameters = function () { return [\n    { type: Lexer, },\n]; };\nvar _ParseAST = (function () {\n    /**\n     * @param {?} input\n     * @param {?} location\n     * @param {?} tokens\n     * @param {?} inputLength\n     * @param {?} parseAction\n     * @param {?} errors\n     * @param {?} offset\n     */\n    function _ParseAST(input, location, tokens, inputLength, parseAction, errors, offset) {\n        this.input = input;\n        this.location = location;\n        this.tokens = tokens;\n        this.inputLength = inputLength;\n        this.parseAction = parseAction;\n        this.errors = errors;\n        this.offset = offset;\n        this.rparensExpected = 0;\n        this.rbracketsExpected = 0;\n        this.rbracesExpected = 0;\n        this.index = 0;\n    }\n    /**\n     * @param {?} offset\n     * @return {?}\n     */\n    _ParseAST.prototype.peek = function (offset) {\n        var /** @type {?} */ i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    };\n    Object.defineProperty(_ParseAST.prototype, \"next\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.peek(0); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"inputIndex\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return (this.index < this.tokens.length) ? this.next.index + this.offset :\n                this.inputLength + this.offset;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _ParseAST.prototype.span = function (start) { return new ParseSpan(start, this.inputIndex); };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.advance = function () { this.index++; };\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    _ParseAST.prototype.optionalCharacter = function (code) {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.peekKeywordLet = function () { return this.next.isKeywordLet(); };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.peekKeywordAs = function () { return this.next.isKeywordAs(); };\n    /**\n     * @param {?} code\n     * @return {?}\n     */\n    _ParseAST.prototype.expectCharacter = function (code) {\n        if (this.optionalCharacter(code))\n            return;\n        this.error(\"Missing expected \" + String.fromCharCode(code));\n    };\n    /**\n     * @param {?} op\n     * @return {?}\n     */\n    _ParseAST.prototype.optionalOperator = function (op) {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * @param {?} operator\n     * @return {?}\n     */\n    _ParseAST.prototype.expectOperator = function (operator) {\n        if (this.optionalOperator(operator))\n            return;\n        this.error(\"Missing expected operator \" + operator);\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.expectIdentifierOrKeyword = function () {\n        var /** @type {?} */ n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            this.error(\"Unexpected token \" + n + \", expected identifier or keyword\");\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {\n        var /** @type {?} */ n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            this.error(\"Unexpected token \" + n + \", expected identifier, keyword, or string\");\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseChain = function () {\n        var /** @type {?} */ exprs = [];\n        var /** @type {?} */ start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            var /** @type {?} */ expr = this.parsePipe();\n            exprs.push(expr);\n            if (this.optionalCharacter($SEMICOLON)) {\n                if (!this.parseAction) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.optionalCharacter($SEMICOLON)) {\n                } // read all semicolons\n            }\n            else if (this.index < this.tokens.length) {\n                this.error(\"Unexpected token '\" + this.next + \"'\");\n            }\n        }\n        if (exprs.length == 0)\n            return new EmptyExpr(this.span(start));\n        if (exprs.length == 1)\n            return exprs[0];\n        return new Chain(this.span(start), exprs);\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parsePipe = function () {\n        var /** @type {?} */ result = this.parseExpression();\n        if (this.optionalOperator('|')) {\n            if (this.parseAction) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n            do {\n                var /** @type {?} */ name = this.expectIdentifierOrKeyword();\n                var /** @type {?} */ args = [];\n                while (this.optionalCharacter($COLON)) {\n                    args.push(this.parseExpression());\n                }\n                result = new BindingPipe(this.span(result.span.start), result, name, args);\n            } while (this.optionalOperator('|'));\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseConditional = function () {\n        var /** @type {?} */ start = this.inputIndex;\n        var /** @type {?} */ result = this.parseLogicalOr();\n        if (this.optionalOperator('?')) {\n            var /** @type {?} */ yes = this.parsePipe();\n            var /** @type {?} */ no = void 0;\n            if (!this.optionalCharacter($COLON)) {\n                var /** @type {?} */ end = this.inputIndex;\n                var /** @type {?} */ expression = this.input.substring(start, end);\n                this.error(\"Conditional expression \" + expression + \" requires all 3 expressions\");\n                no = new EmptyExpr(this.span(start));\n            }\n            else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), result, yes, no);\n        }\n        else {\n            return result;\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseLogicalOr = function () {\n        // '||'\n        var /** @type {?} */ result = this.parseLogicalAnd();\n        while (this.optionalOperator('||')) {\n            var /** @type {?} */ right = this.parseLogicalAnd();\n            result = new Binary(this.span(result.span.start), '||', result, right);\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseLogicalAnd = function () {\n        // '&&'\n        var /** @type {?} */ result = this.parseEquality();\n        while (this.optionalOperator('&&')) {\n            var /** @type {?} */ right = this.parseEquality();\n            result = new Binary(this.span(result.span.start), '&&', result, right);\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseEquality = function () {\n        // '==','!=','===','!=='\n        var /** @type {?} */ result = this.parseRelational();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    var /** @type {?} */ right = this.parseRelational();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseRelational = function () {\n        // '<', '>', '<=', '>='\n        var /** @type {?} */ result = this.parseAdditive();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    var /** @type {?} */ right = this.parseAdditive();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseAdditive = function () {\n        // '+', '-'\n        var /** @type {?} */ result = this.parseMultiplicative();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    var /** @type {?} */ right = this.parseMultiplicative();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseMultiplicative = function () {\n        // '*', '%', '/'\n        var /** @type {?} */ result = this.parsePrefix();\n        while (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    var /** @type {?} */ right = this.parsePrefix();\n                    result = new Binary(this.span(result.span.start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parsePrefix = function () {\n        if (this.next.type == TokenType.Operator) {\n            var /** @type {?} */ start = this.inputIndex;\n            var /** @type {?} */ operator = this.next.strValue;\n            var /** @type {?} */ result = void 0;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    return this.parsePrefix();\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new Binary(this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0), result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), result);\n            }\n        }\n        return this.parseCallChain();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseCallChain = function () {\n        var /** @type {?} */ result = this.parsePrimary();\n        while (true) {\n            if (this.optionalCharacter($PERIOD)) {\n                result = this.parseAccessMemberOrMethodCall(result, false);\n            }\n            else if (this.optionalOperator('?.')) {\n                result = this.parseAccessMemberOrMethodCall(result, true);\n            }\n            else if (this.optionalCharacter($LBRACKET)) {\n                this.rbracketsExpected++;\n                var /** @type {?} */ key = this.parsePipe();\n                this.rbracketsExpected--;\n                this.expectCharacter($RBRACKET);\n                if (this.optionalOperator('=')) {\n                    var /** @type {?} */ value = this.parseConditional();\n                    result = new KeyedWrite(this.span(result.span.start), result, key, value);\n                }\n                else {\n                    result = new KeyedRead(this.span(result.span.start), result, key);\n                }\n            }\n            else if (this.optionalCharacter($LPAREN)) {\n                this.rparensExpected++;\n                var /** @type {?} */ args = this.parseCallArguments();\n                this.rparensExpected--;\n                this.expectCharacter($RPAREN);\n                result = new FunctionCall(this.span(result.span.start), result, args);\n            }\n            else {\n                return result;\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parsePrimary = function () {\n        var /** @type {?} */ start = this.inputIndex;\n        if (this.optionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            var /** @type {?} */ result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter($RPAREN);\n            return result;\n        }\n        else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), null);\n        }\n        else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), void 0);\n        }\n        else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), true);\n        }\n        else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), false);\n        }\n        else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ImplicitReceiver(this.span(start));\n        }\n        else if (this.optionalCharacter($LBRACKET)) {\n            this.rbracketsExpected++;\n            var /** @type {?} */ elements = this.parseExpressionList($RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter($RBRACKET);\n            return new LiteralArray(this.span(start), elements);\n        }\n        else if (this.next.isCharacter($LBRACE)) {\n            return this.parseLiteralMap();\n        }\n        else if (this.next.isIdentifier()) {\n            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n        }\n        else if (this.next.isNumber()) {\n            var /** @type {?} */ value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), value);\n        }\n        else if (this.next.isString()) {\n            var /** @type {?} */ literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), literalValue);\n        }\n        else if (this.index >= this.tokens.length) {\n            this.error(\"Unexpected end of expression: \" + this.input);\n            return new EmptyExpr(this.span(start));\n        }\n        else {\n            this.error(\"Unexpected token \" + this.next);\n            return new EmptyExpr(this.span(start));\n        }\n    };\n    /**\n     * @param {?} terminator\n     * @return {?}\n     */\n    _ParseAST.prototype.parseExpressionList = function (terminator) {\n        var /** @type {?} */ result = [];\n        if (!this.next.isCharacter(terminator)) {\n            do {\n                result.push(this.parsePipe());\n            } while (this.optionalCharacter($COMMA));\n        }\n        return result;\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseLiteralMap = function () {\n        var /** @type {?} */ keys = [];\n        var /** @type {?} */ values = [];\n        var /** @type {?} */ start = this.inputIndex;\n        this.expectCharacter($LBRACE);\n        if (!this.optionalCharacter($RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                var /** @type {?} */ key = this.expectIdentifierOrKeywordOrString();\n                keys.push(key);\n                this.expectCharacter($COLON);\n                values.push(this.parsePipe());\n            } while (this.optionalCharacter($COMMA));\n            this.rbracesExpected--;\n            this.expectCharacter($RBRACE);\n        }\n        return new LiteralMap(this.span(start), keys, values);\n    };\n    /**\n     * @param {?} receiver\n     * @param {?=} isSafe\n     * @return {?}\n     */\n    _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {\n        if (isSafe === void 0) { isSafe = false; }\n        var /** @type {?} */ start = receiver.span.start;\n        var /** @type {?} */ id = this.expectIdentifierOrKeyword();\n        if (this.optionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            var /** @type {?} */ args = this.parseCallArguments();\n            this.expectCharacter($RPAREN);\n            this.rparensExpected--;\n            var /** @type {?} */ span = this.span(start);\n            return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                new MethodCall(span, receiver, id, args);\n        }\n        else {\n            if (isSafe) {\n                if (this.optionalOperator('=')) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                    return new EmptyExpr(this.span(start));\n                }\n                else {\n                    return new SafePropertyRead(this.span(start), receiver, id);\n                }\n            }\n            else {\n                if (this.optionalOperator('=')) {\n                    if (!this.parseAction) {\n                        this.error('Bindings cannot contain assignments');\n                        return new EmptyExpr(this.span(start));\n                    }\n                    var /** @type {?} */ value = this.parseConditional();\n                    return new PropertyWrite(this.span(start), receiver, id, value);\n                }\n                else {\n                    return new PropertyRead(this.span(start), receiver, id);\n                }\n            }\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseCallArguments = function () {\n        if (this.next.isCharacter($RPAREN))\n            return [];\n        var /** @type {?} */ positionals = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.optionalCharacter($COMMA));\n        return (positionals);\n    };\n    /**\n     * An identifier, a keyword, a string with an optional `-` inbetween.\n     * @return {?}\n     */\n    _ParseAST.prototype.expectTemplateBindingKey = function () {\n        var /** @type {?} */ result = '';\n        var /** @type {?} */ operatorFound = false;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.optionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n        return result.toString();\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.parseTemplateBindings = function () {\n        var /** @type {?} */ bindings = [];\n        var /** @type {?} */ prefix = null;\n        var /** @type {?} */ warnings = [];\n        while (this.index < this.tokens.length) {\n            var /** @type {?} */ start = this.inputIndex;\n            var /** @type {?} */ keyIsVar = this.peekKeywordLet();\n            if (keyIsVar) {\n                this.advance();\n            }\n            var /** @type {?} */ rawKey = this.expectTemplateBindingKey();\n            var /** @type {?} */ key = rawKey;\n            if (!keyIsVar) {\n                if (prefix == null) {\n                    prefix = key;\n                }\n                else {\n                    key = prefix + key[0].toUpperCase() + key.substring(1);\n                }\n            }\n            this.optionalCharacter($COLON);\n            var /** @type {?} */ name = null;\n            var /** @type {?} */ expression = null;\n            if (keyIsVar) {\n                if (this.optionalOperator('=')) {\n                    name = this.expectTemplateBindingKey();\n                }\n                else {\n                    name = '\\$implicit';\n                }\n            }\n            else if (this.peekKeywordAs()) {\n                var /** @type {?} */ letStart = this.inputIndex;\n                this.advance(); // consume `as`\n                name = rawKey;\n                key = this.expectTemplateBindingKey(); // read local var name\n                keyIsVar = true;\n            }\n            else if (this.next !== EOF && !this.peekKeywordLet()) {\n                var /** @type {?} */ start_2 = this.inputIndex;\n                var /** @type {?} */ ast = this.parsePipe();\n                var /** @type {?} */ source = this.input.substring(start_2 - this.offset, this.inputIndex - this.offset);\n                expression = new ASTWithSource(ast, source, this.location, this.errors);\n            }\n            bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n            if (this.peekKeywordAs() && !keyIsVar) {\n                var /** @type {?} */ letStart = this.inputIndex;\n                this.advance(); // consume `as`\n                var /** @type {?} */ letName = this.expectTemplateBindingKey(); // read local var name\n                bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, null));\n            }\n            if (!this.optionalCharacter($SEMICOLON)) {\n                this.optionalCharacter($COMMA);\n            }\n        }\n        return new TemplateBindingParseResult(bindings, warnings, this.errors);\n    };\n    /**\n     * @param {?} message\n     * @param {?=} index\n     * @return {?}\n     */\n    _ParseAST.prototype.error = function (message, index) {\n        if (index === void 0) { index = null; }\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    };\n    /**\n     * @param {?=} index\n     * @return {?}\n     */\n    _ParseAST.prototype.locationText = function (index) {\n        if (index === void 0) { index = null; }\n        if (index == null)\n            index = this.index;\n        return (index < this.tokens.length) ? \"at column \" + (this.tokens[index].index + 1) + \" in\" :\n            \"at the end of the expression\";\n    };\n    /**\n     * @return {?}\n     */\n    _ParseAST.prototype.skip = function () {\n        var /** @type {?} */ n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&\n            (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&\n            (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&\n            (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {\n            if (this.next.isError()) {\n                this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    };\n    return _ParseAST;\n}());\nvar SimpleExpressionChecker = (function () {\n    function SimpleExpressionChecker() {\n        this.errors = [];\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    SimpleExpressionChecker.check = function (ast) {\n        var /** @type {?} */ s = new SimpleExpressionChecker();\n        ast.visit(s);\n        return s.errors;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) { this.visitAll(ast.expressions); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) { this.visitAll(ast.values); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitBinary = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitConditional = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitPipe = function (ast, context) { this.errors.push('pipes'); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) { };\n    /**\n     * @param {?} asts\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitAll = function (asts) {\n        var _this = this;\n        return asts.map(function (node) { return node.visit(_this); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitChain = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    SimpleExpressionChecker.prototype.visitQuote = function (ast, context) { };\n    return SimpleExpressionChecker;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ParseLocation = (function () {\n    /**\n     * @param {?} file\n     * @param {?} offset\n     * @param {?} line\n     * @param {?} col\n     */\n    function ParseLocation(file, offset, line, col) {\n        this.file = file;\n        this.offset = offset;\n        this.line = line;\n        this.col = col;\n    }\n    /**\n     * @return {?}\n     */\n    ParseLocation.prototype.toString = function () {\n        return this.offset != null ? this.file.url + \"@\" + this.line + \":\" + this.col : this.file.url;\n    };\n    /**\n     * @param {?} delta\n     * @return {?}\n     */\n    ParseLocation.prototype.moveBy = function (delta) {\n        var /** @type {?} */ source = this.file.content;\n        var /** @type {?} */ len = source.length;\n        var /** @type {?} */ offset = this.offset;\n        var /** @type {?} */ line = this.line;\n        var /** @type {?} */ col = this.col;\n        while (offset > 0 && delta < 0) {\n            offset--;\n            delta++;\n            var /** @type {?} */ ch = source.charCodeAt(offset);\n            if (ch == $LF) {\n                line--;\n                var /** @type {?} */ priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n                col = priorLine > 0 ? offset - priorLine : offset;\n            }\n            else {\n                col--;\n            }\n        }\n        while (offset < len && delta > 0) {\n            var /** @type {?} */ ch = source.charCodeAt(offset);\n            offset++;\n            delta--;\n            if (ch == $LF) {\n                line++;\n                col = 0;\n            }\n            else {\n                col++;\n            }\n        }\n        return new ParseLocation(this.file, offset, line, col);\n    };\n    /**\n     * @param {?} maxChars\n     * @param {?} maxLines\n     * @return {?}\n     */\n    ParseLocation.prototype.getContext = function (maxChars, maxLines) {\n        var /** @type {?} */ content = this.file.content;\n        var /** @type {?} */ startOffset = this.offset;\n        if (startOffset != null) {\n            if (startOffset > content.length - 1) {\n                startOffset = content.length - 1;\n            }\n            var /** @type {?} */ endOffset = startOffset;\n            var /** @type {?} */ ctxChars = 0;\n            var /** @type {?} */ ctxLines = 0;\n            while (ctxChars < maxChars && startOffset > 0) {\n                startOffset--;\n                ctxChars++;\n                if (content[startOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            ctxChars = 0;\n            ctxLines = 0;\n            while (ctxChars < maxChars && endOffset < content.length - 1) {\n                endOffset++;\n                ctxChars++;\n                if (content[endOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            return {\n                before: content.substring(startOffset, this.offset),\n                after: content.substring(this.offset, endOffset + 1),\n            };\n        }\n        return null;\n    };\n    return ParseLocation;\n}());\nvar ParseSourceFile = (function () {\n    /**\n     * @param {?} content\n     * @param {?} url\n     */\n    function ParseSourceFile(content, url) {\n        this.content = content;\n        this.url = url;\n    }\n    return ParseSourceFile;\n}());\nvar ParseSourceSpan = (function () {\n    /**\n     * @param {?} start\n     * @param {?} end\n     * @param {?=} details\n     */\n    function ParseSourceSpan(start, end, details) {\n        if (details === void 0) { details = null; }\n        this.start = start;\n        this.end = end;\n        this.details = details;\n    }\n    /**\n     * @return {?}\n     */\n    ParseSourceSpan.prototype.toString = function () {\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\n    };\n    return ParseSourceSpan;\n}());\nvar ParseErrorLevel = {};\nParseErrorLevel.WARNING = 0;\nParseErrorLevel.ERROR = 1;\nParseErrorLevel[ParseErrorLevel.WARNING] = \"WARNING\";\nParseErrorLevel[ParseErrorLevel.ERROR] = \"ERROR\";\nvar ParseError = (function () {\n    /**\n     * @param {?} span\n     * @param {?} msg\n     * @param {?=} level\n     */\n    function ParseError(span, msg, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this.span = span;\n        this.msg = msg;\n        this.level = level;\n    }\n    /**\n     * @return {?}\n     */\n    ParseError.prototype.toString = function () {\n        var /** @type {?} */ ctx = this.span.start.getContext(100, 3);\n        var /** @type {?} */ contextStr = ctx ? \" (\\\"\" + ctx.before + \"[\" + ParseErrorLevel[this.level] + \" ->]\" + ctx.after + \"\\\")\" : '';\n        var /** @type {?} */ details = this.span.details ? \", \" + this.span.details : '';\n        return \"\" + this.msg + contextStr + \": \" + this.span.start + details;\n    };\n    return ParseError;\n}());\n/**\n * @param {?} kind\n * @param {?} type\n * @return {?}\n */\nfunction typeSourceSpan(kind, type) {\n    var /** @type {?} */ moduleUrl = identifierModuleUrl(type);\n    var /** @type {?} */ sourceFileName = moduleUrl != null ? \"in \" + kind + \" \" + identifierName(type) + \" in \" + moduleUrl :\n        \"in \" + kind + \" \" + identifierName(type);\n    var /** @type {?} */ sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, null, null, null), new ParseLocation(sourceFile, null, null, null));\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Text = (function () {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function Text(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Text.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return Text;\n}());\nvar Expansion = (function () {\n    /**\n     * @param {?} switchValue\n     * @param {?} type\n     * @param {?} cases\n     * @param {?} sourceSpan\n     * @param {?} switchValueSourceSpan\n     */\n    function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan) {\n        this.switchValue = switchValue;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n        this.switchValueSourceSpan = switchValueSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Expansion.prototype.visit = function (visitor, context) { return visitor.visitExpansion(this, context); };\n    return Expansion;\n}());\nvar ExpansionCase = (function () {\n    /**\n     * @param {?} value\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} valueSourceSpan\n     * @param {?} expSourceSpan\n     */\n    function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n        this.value = value;\n        this.expression = expression;\n        this.sourceSpan = sourceSpan;\n        this.valueSourceSpan = valueSourceSpan;\n        this.expSourceSpan = expSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExpansionCase.prototype.visit = function (visitor, context) { return visitor.visitExpansionCase(this, context); };\n    return ExpansionCase;\n}());\nvar Attribute$1 = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?=} valueSpan\n     */\n    function Attribute$1(name, value, sourceSpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.valueSpan = valueSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Attribute$1.prototype.visit = function (visitor, context) { return visitor.visitAttribute(this, context); };\n    return Attribute$1;\n}());\nvar Element = (function () {\n    /**\n     * @param {?} name\n     * @param {?} attrs\n     * @param {?} children\n     * @param {?} sourceSpan\n     * @param {?} startSourceSpan\n     * @param {?} endSourceSpan\n     */\n    function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan) {\n        this.name = name;\n        this.attrs = attrs;\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Element.prototype.visit = function (visitor, context) { return visitor.visitElement(this, context); };\n    return Element;\n}());\nvar Comment = (function () {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function Comment(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Comment.prototype.visit = function (visitor, context) { return visitor.visitComment(this, context); };\n    return Comment;\n}());\n/**\n * @param {?} visitor\n * @param {?} nodes\n * @param {?=} context\n * @return {?}\n */\nfunction visitAll(visitor, nodes, context) {\n    if (context === void 0) { context = null; }\n    var /** @type {?} */ result = [];\n    var /** @type {?} */ visit = visitor.visit ?\n        function (ast) { return visitor.visit(ast, context) || ast.visit(visitor, context); } :\n        function (ast) { return ast.visit(visitor, context); };\n    nodes.forEach(function (ast) {\n        var /** @type {?} */ astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType$1 = {};\nTokenType$1.TAG_OPEN_START = 0;\nTokenType$1.TAG_OPEN_END = 1;\nTokenType$1.TAG_OPEN_END_VOID = 2;\nTokenType$1.TAG_CLOSE = 3;\nTokenType$1.TEXT = 4;\nTokenType$1.ESCAPABLE_RAW_TEXT = 5;\nTokenType$1.RAW_TEXT = 6;\nTokenType$1.COMMENT_START = 7;\nTokenType$1.COMMENT_END = 8;\nTokenType$1.CDATA_START = 9;\nTokenType$1.CDATA_END = 10;\nTokenType$1.ATTR_NAME = 11;\nTokenType$1.ATTR_VALUE = 12;\nTokenType$1.DOC_TYPE = 13;\nTokenType$1.EXPANSION_FORM_START = 14;\nTokenType$1.EXPANSION_CASE_VALUE = 15;\nTokenType$1.EXPANSION_CASE_EXP_START = 16;\nTokenType$1.EXPANSION_CASE_EXP_END = 17;\nTokenType$1.EXPANSION_FORM_END = 18;\nTokenType$1.EOF = 19;\nTokenType$1[TokenType$1.TAG_OPEN_START] = \"TAG_OPEN_START\";\nTokenType$1[TokenType$1.TAG_OPEN_END] = \"TAG_OPEN_END\";\nTokenType$1[TokenType$1.TAG_OPEN_END_VOID] = \"TAG_OPEN_END_VOID\";\nTokenType$1[TokenType$1.TAG_CLOSE] = \"TAG_CLOSE\";\nTokenType$1[TokenType$1.TEXT] = \"TEXT\";\nTokenType$1[TokenType$1.ESCAPABLE_RAW_TEXT] = \"ESCAPABLE_RAW_TEXT\";\nTokenType$1[TokenType$1.RAW_TEXT] = \"RAW_TEXT\";\nTokenType$1[TokenType$1.COMMENT_START] = \"COMMENT_START\";\nTokenType$1[TokenType$1.COMMENT_END] = \"COMMENT_END\";\nTokenType$1[TokenType$1.CDATA_START] = \"CDATA_START\";\nTokenType$1[TokenType$1.CDATA_END] = \"CDATA_END\";\nTokenType$1[TokenType$1.ATTR_NAME] = \"ATTR_NAME\";\nTokenType$1[TokenType$1.ATTR_VALUE] = \"ATTR_VALUE\";\nTokenType$1[TokenType$1.DOC_TYPE] = \"DOC_TYPE\";\nTokenType$1[TokenType$1.EXPANSION_FORM_START] = \"EXPANSION_FORM_START\";\nTokenType$1[TokenType$1.EXPANSION_CASE_VALUE] = \"EXPANSION_CASE_VALUE\";\nTokenType$1[TokenType$1.EXPANSION_CASE_EXP_START] = \"EXPANSION_CASE_EXP_START\";\nTokenType$1[TokenType$1.EXPANSION_CASE_EXP_END] = \"EXPANSION_CASE_EXP_END\";\nTokenType$1[TokenType$1.EXPANSION_FORM_END] = \"EXPANSION_FORM_END\";\nTokenType$1[TokenType$1.EOF] = \"EOF\";\nvar Token$1 = (function () {\n    /**\n     * @param {?} type\n     * @param {?} parts\n     * @param {?} sourceSpan\n     */\n    function Token$1(type, parts, sourceSpan) {\n        this.type = type;\n        this.parts = parts;\n        this.sourceSpan = sourceSpan;\n    }\n    return Token$1;\n}());\nvar TokenError = (function (_super) {\n    __extends(TokenError, _super);\n    /**\n     * @param {?} errorMsg\n     * @param {?} tokenType\n     * @param {?} span\n     */\n    function TokenError(errorMsg, tokenType, span) {\n        var _this = _super.call(this, span, errorMsg) || this;\n        _this.tokenType = tokenType;\n        return _this;\n    }\n    return TokenError;\n}(ParseError));\nvar TokenizeResult = (function () {\n    /**\n     * @param {?} tokens\n     * @param {?} errors\n     */\n    function TokenizeResult(tokens, errors) {\n        this.tokens = tokens;\n        this.errors = errors;\n    }\n    return TokenizeResult;\n}());\n/**\n * @param {?} source\n * @param {?} url\n * @param {?} getTagDefinition\n * @param {?=} tokenizeExpansionForms\n * @param {?=} interpolationConfig\n * @return {?}\n */\nfunction tokenize(source, url, getTagDefinition, tokenizeExpansionForms, interpolationConfig) {\n    if (tokenizeExpansionForms === void 0) { tokenizeExpansionForms = false; }\n    if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n    return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms, interpolationConfig)\n        .tokenize();\n}\nvar _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n/**\n * @param {?} charCode\n * @return {?}\n */\nfunction _unexpectedCharacterErrorMsg(charCode) {\n    var /** @type {?} */ char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n    return \"Unexpected character \\\"\" + char + \"\\\"\";\n}\n/**\n * @param {?} entitySrc\n * @return {?}\n */\nfunction _unknownEntityErrorMsg(entitySrc) {\n    return \"Unknown entity \\\"\" + entitySrc + \"\\\" - use the \\\"&#<decimal>;\\\" or  \\\"&#x<hex>;\\\" syntax\";\n}\nvar _ControlFlowError = (function () {\n    /**\n     * @param {?} error\n     */\n    function _ControlFlowError(error) {\n        this.error = error;\n    }\n    return _ControlFlowError;\n}());\nvar _Tokenizer = (function () {\n    /**\n     * @param {?} _file The html source\n     * @param {?} _getTagDefinition\n     * @param {?} _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)\n     * @param {?=} _interpolationConfig\n     */\n    function _Tokenizer(_file, _getTagDefinition, _tokenizeIcu, _interpolationConfig) {\n        if (_interpolationConfig === void 0) { _interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        this._file = _file;\n        this._getTagDefinition = _getTagDefinition;\n        this._tokenizeIcu = _tokenizeIcu;\n        this._interpolationConfig = _interpolationConfig;\n        this._peek = -1;\n        this._nextPeek = -1;\n        this._index = -1;\n        this._line = 0;\n        this._column = -1;\n        this._expansionCaseStack = [];\n        this._inInterpolation = false;\n        this.tokens = [];\n        this.errors = [];\n        this._input = _file.content;\n        this._length = _file.content.length;\n        this._advance();\n    }\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    _Tokenizer.prototype._processCarriageReturns = function (content) {\n        // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n        // In order to keep the original position in the source, we can not\n        // pre-process it.\n        // Instead CRs are processed right before instantiating the tokens.\n        return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype.tokenize = function () {\n        while (this._peek !== $EOF) {\n            var /** @type {?} */ start = this._getLocation();\n            try {\n                if (this._attemptCharCode($LT)) {\n                    if (this._attemptCharCode($BANG)) {\n                        if (this._attemptCharCode($LBRACKET)) {\n                            this._consumeCdata(start);\n                        }\n                        else if (this._attemptCharCode($MINUS)) {\n                            this._consumeComment(start);\n                        }\n                        else {\n                            this._consumeDocType(start);\n                        }\n                    }\n                    else if (this._attemptCharCode($SLASH)) {\n                        this._consumeTagClose(start);\n                    }\n                    else {\n                        this._consumeTagOpen(start);\n                    }\n                }\n                else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n                    this._consumeText();\n                }\n            }\n            catch (e) {\n                if (e instanceof _ControlFlowError) {\n                    this.errors.push(e.error);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        this._beginToken(TokenType$1.EOF);\n        this._endToken([]);\n        return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n    };\n    /**\n     * \\@internal\n     * @return {?}\n     */\n    _Tokenizer.prototype._tokenizeExpansionForm = function () {\n        if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n            this._consumeExpansionFormStart();\n            return true;\n        }\n        if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {\n            this._consumeExpansionCaseStart();\n            return true;\n        }\n        if (this._peek === $RBRACE) {\n            if (this._isInExpansionCase()) {\n                this._consumeExpansionCaseEnd();\n                return true;\n            }\n            if (this._isInExpansionForm()) {\n                this._consumeExpansionFormEnd();\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._getLocation = function () {\n        return new ParseLocation(this._file, this._index, this._line, this._column);\n    };\n    /**\n     * @param {?=} start\n     * @param {?=} end\n     * @return {?}\n     */\n    _Tokenizer.prototype._getSpan = function (start, end) {\n        if (start === void 0) { start = this._getLocation(); }\n        if (end === void 0) { end = this._getLocation(); }\n        return new ParseSourceSpan(start, end);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._beginToken = function (type, start) {\n        if (start === void 0) { start = this._getLocation(); }\n        this._currentTokenStart = start;\n        this._currentTokenType = type;\n    };\n    /**\n     * @param {?} parts\n     * @param {?=} end\n     * @return {?}\n     */\n    _Tokenizer.prototype._endToken = function (parts, end) {\n        if (end === void 0) { end = this._getLocation(); }\n        var /** @type {?} */ token = new Token$1(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));\n        this.tokens.push(token);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return token;\n    };\n    /**\n     * @param {?} msg\n     * @param {?} span\n     * @return {?}\n     */\n    _Tokenizer.prototype._createError = function (msg, span) {\n        if (this._isInExpansionForm()) {\n            msg += \" (Do you have an unescaped \\\"{\\\" in your template? Use \\\"{{ '{' }}\\\") to escape it.)\";\n        }\n        var /** @type {?} */ error = new TokenError(msg, this._currentTokenType, span);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return new _ControlFlowError(error);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._advance = function () {\n        if (this._index >= this._length) {\n            throw this._createError(_unexpectedCharacterErrorMsg($EOF), this._getSpan());\n        }\n        if (this._peek === $LF) {\n            this._line++;\n            this._column = 0;\n        }\n        else if (this._peek !== $LF && this._peek !== $CR) {\n            this._column++;\n        }\n        this._index++;\n        this._peek = this._index >= this._length ? $EOF : this._input.charCodeAt(this._index);\n        this._nextPeek =\n            this._index + 1 >= this._length ? $EOF : this._input.charCodeAt(this._index + 1);\n    };\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptCharCode = function (charCode) {\n        if (this._peek === charCode) {\n            this._advance();\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {\n        if (compareCharCodeCaseInsensitive(this._peek, charCode)) {\n            this._advance();\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} charCode\n     * @return {?}\n     */\n    _Tokenizer.prototype._requireCharCode = function (charCode) {\n        var /** @type {?} */ location = this._getLocation();\n        if (!this._attemptCharCode(charCode)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));\n        }\n    };\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptStr = function (chars) {\n        var /** @type {?} */ len = chars.length;\n        if (this._index + len > this._length) {\n            return false;\n        }\n        var /** @type {?} */ initialPosition = this._savePosition();\n        for (var /** @type {?} */ i = 0; i < len; i++) {\n            if (!this._attemptCharCode(chars.charCodeAt(i))) {\n                // If attempting to parse the string fails, we want to reset the parser\n                // to where it was before the attempt\n                this._restorePosition(initialPosition);\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {\n        for (var /** @type {?} */ i = 0; i < chars.length; i++) {\n            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * @param {?} chars\n     * @return {?}\n     */\n    _Tokenizer.prototype._requireStr = function (chars) {\n        var /** @type {?} */ location = this._getLocation();\n        if (!this._attemptStr(chars)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));\n        }\n    };\n    /**\n     * @param {?} predicate\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {\n        while (!predicate(this._peek)) {\n            this._advance();\n        }\n    };\n    /**\n     * @param {?} predicate\n     * @param {?} len\n     * @return {?}\n     */\n    _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {\n        var /** @type {?} */ start = this._getLocation();\n        this._attemptCharCodeUntilFn(predicate);\n        if (this._index - start.offset < len) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));\n        }\n    };\n    /**\n     * @param {?} char\n     * @return {?}\n     */\n    _Tokenizer.prototype._attemptUntilChar = function (char) {\n        while (this._peek !== char) {\n            this._advance();\n        }\n    };\n    /**\n     * @param {?} decodeEntities\n     * @return {?}\n     */\n    _Tokenizer.prototype._readChar = function (decodeEntities) {\n        if (decodeEntities && this._peek === $AMPERSAND) {\n            return this._decodeEntity();\n        }\n        else {\n            var /** @type {?} */ index = this._index;\n            this._advance();\n            return this._input[index];\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._decodeEntity = function () {\n        var /** @type {?} */ start = this._getLocation();\n        this._advance();\n        if (this._attemptCharCode($HASH)) {\n            var /** @type {?} */ isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n            var /** @type {?} */ numberStart = this._getLocation().offset;\n            this._attemptCharCodeUntilFn(isDigitEntityEnd);\n            if (this._peek != $SEMICOLON) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n            }\n            this._advance();\n            var /** @type {?} */ strNum = this._input.substring(numberStart, this._index - 1);\n            try {\n                var /** @type {?} */ charCode = parseInt(strNum, isHex ? 16 : 10);\n                return String.fromCharCode(charCode);\n            }\n            catch (e) {\n                var /** @type {?} */ entity = this._input.substring(start.offset + 1, this._index - 1);\n                throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));\n            }\n        }\n        else {\n            var /** @type {?} */ startPosition = this._savePosition();\n            this._attemptCharCodeUntilFn(isNamedEntityEnd);\n            if (this._peek != $SEMICOLON) {\n                this._restorePosition(startPosition);\n                return '&';\n            }\n            this._advance();\n            var /** @type {?} */ name = this._input.substring(start.offset + 1, this._index - 1);\n            var /** @type {?} */ char = NAMED_ENTITIES[name];\n            if (!char) {\n                throw this._createError(_unknownEntityErrorMsg(name), this._getSpan(start));\n            }\n            return char;\n        }\n    };\n    /**\n     * @param {?} decodeEntities\n     * @param {?} firstCharOfEnd\n     * @param {?} attemptEndRest\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeRawText = function (decodeEntities, firstCharOfEnd, attemptEndRest) {\n        var /** @type {?} */ tagCloseStart;\n        var /** @type {?} */ textStart = this._getLocation();\n        this._beginToken(decodeEntities ? TokenType$1.ESCAPABLE_RAW_TEXT : TokenType$1.RAW_TEXT, textStart);\n        var /** @type {?} */ parts = [];\n        while (true) {\n            tagCloseStart = this._getLocation();\n            if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {\n                break;\n            }\n            if (this._index > tagCloseStart.offset) {\n                // add the characters consumed by the previous if statement to the output\n                parts.push(this._input.substring(tagCloseStart.offset, this._index));\n            }\n            while (this._peek !== firstCharOfEnd) {\n                parts.push(this._readChar(decodeEntities));\n            }\n        }\n        return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeComment = function (start) {\n        var _this = this;\n        this._beginToken(TokenType$1.COMMENT_START, start);\n        this._requireCharCode($MINUS);\n        this._endToken([]);\n        var /** @type {?} */ textToken = this._consumeRawText(false, $MINUS, function () { return _this._attemptStr('->'); });\n        this._beginToken(TokenType$1.COMMENT_END, textToken.sourceSpan.end);\n        this._endToken([]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeCdata = function (start) {\n        var _this = this;\n        this._beginToken(TokenType$1.CDATA_START, start);\n        this._requireStr('CDATA[');\n        this._endToken([]);\n        var /** @type {?} */ textToken = this._consumeRawText(false, $RBRACKET, function () { return _this._attemptStr(']>'); });\n        this._beginToken(TokenType$1.CDATA_END, textToken.sourceSpan.end);\n        this._endToken([]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeDocType = function (start) {\n        this._beginToken(TokenType$1.DOC_TYPE, start);\n        this._attemptUntilChar($GT);\n        this._advance();\n        this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumePrefixAndName = function () {\n        var /** @type {?} */ nameOrPrefixStart = this._index;\n        var /** @type {?} */ prefix = null;\n        while (this._peek !== $COLON && !isPrefixEnd(this._peek)) {\n            this._advance();\n        }\n        var /** @type {?} */ nameStart;\n        if (this._peek === $COLON) {\n            this._advance();\n            prefix = this._input.substring(nameOrPrefixStart, this._index - 1);\n            nameStart = this._index;\n        }\n        else {\n            nameStart = nameOrPrefixStart;\n        }\n        this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);\n        var /** @type {?} */ name = this._input.substring(nameStart, this._index);\n        return [prefix, name];\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagOpen = function (start) {\n        var /** @type {?} */ savedPos = this._savePosition();\n        var /** @type {?} */ tagName;\n        var /** @type {?} */ lowercaseTagName;\n        try {\n            if (!isAsciiLetter(this._peek)) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n            }\n            var /** @type {?} */ nameStart = this._index;\n            this._consumeTagOpenStart(start);\n            tagName = this._input.substring(nameStart, this._index);\n            lowercaseTagName = tagName.toLowerCase();\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            while (this._peek !== $SLASH && this._peek !== $GT) {\n                this._consumeAttributeName();\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n                if (this._attemptCharCode($EQ)) {\n                    this._attemptCharCodeUntilFn(isNotWhitespace);\n                    this._consumeAttributeValue();\n                }\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n            }\n            this._consumeTagOpenEnd();\n        }\n        catch (e) {\n            if (e instanceof _ControlFlowError) {\n                // When the start tag is invalid, assume we want a \"<\"\n                this._restorePosition(savedPos);\n                // Back to back text tokens are merged at the end\n                this._beginToken(TokenType$1.TEXT, start);\n                this._endToken(['<']);\n                return;\n            }\n            throw e;\n        }\n        var /** @type {?} */ contentTokenType = this._getTagDefinition(tagName).contentType;\n        if (contentTokenType === TagContentType.RAW_TEXT) {\n            this._consumeRawTextWithTagClose(lowercaseTagName, false);\n        }\n        else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n            this._consumeRawTextWithTagClose(lowercaseTagName, true);\n        }\n    };\n    /**\n     * @param {?} lowercaseTagName\n     * @param {?} decodeEntities\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeRawTextWithTagClose = function (lowercaseTagName, decodeEntities) {\n        var _this = this;\n        var /** @type {?} */ textToken = this._consumeRawText(decodeEntities, $LT, function () {\n            if (!_this._attemptCharCode($SLASH))\n                return false;\n            _this._attemptCharCodeUntilFn(isNotWhitespace);\n            if (!_this._attemptStrCaseInsensitive(lowercaseTagName))\n                return false;\n            _this._attemptCharCodeUntilFn(isNotWhitespace);\n            return _this._attemptCharCode($GT);\n        });\n        this._beginToken(TokenType$1.TAG_CLOSE, textToken.sourceSpan.end);\n        this._endToken([null, lowercaseTagName]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagOpenStart = function (start) {\n        this._beginToken(TokenType$1.TAG_OPEN_START, start);\n        var /** @type {?} */ parts = this._consumePrefixAndName();\n        this._endToken(parts);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeAttributeName = function () {\n        this._beginToken(TokenType$1.ATTR_NAME);\n        var /** @type {?} */ prefixAndName = this._consumePrefixAndName();\n        this._endToken(prefixAndName);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeAttributeValue = function () {\n        this._beginToken(TokenType$1.ATTR_VALUE);\n        var /** @type {?} */ value;\n        if (this._peek === $SQ || this._peek === $DQ) {\n            var /** @type {?} */ quoteChar = this._peek;\n            this._advance();\n            var /** @type {?} */ parts = [];\n            while (this._peek !== quoteChar) {\n                parts.push(this._readChar(true));\n            }\n            value = parts.join('');\n            this._advance();\n        }\n        else {\n            var /** @type {?} */ valueStart = this._index;\n            this._requireCharCodeUntilFn(isNameEnd, 1);\n            value = this._input.substring(valueStart, this._index);\n        }\n        this._endToken([this._processCarriageReturns(value)]);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagOpenEnd = function () {\n        var /** @type {?} */ tokenType = this._attemptCharCode($SLASH) ? TokenType$1.TAG_OPEN_END_VOID : TokenType$1.TAG_OPEN_END;\n        this._beginToken(tokenType);\n        this._requireCharCode($GT);\n        this._endToken([]);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeTagClose = function (start) {\n        this._beginToken(TokenType$1.TAG_CLOSE, start);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        var /** @type {?} */ prefixAndName = this._consumePrefixAndName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode($GT);\n        this._endToken(prefixAndName);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionFormStart = function () {\n        this._beginToken(TokenType$1.EXPANSION_FORM_START, this._getLocation());\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.push(TokenType$1.EXPANSION_FORM_START);\n        this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());\n        var /** @type {?} */ condition = this._readUntil($COMMA);\n        this._endToken([condition], this._getLocation());\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType$1.RAW_TEXT, this._getLocation());\n        var /** @type {?} */ type = this._readUntil($COMMA);\n        this._endToken([type], this._getLocation());\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionCaseStart = function () {\n        this._beginToken(TokenType$1.EXPANSION_CASE_VALUE, this._getLocation());\n        var /** @type {?} */ value = this._readUntil($LBRACE).trim();\n        this._endToken([value], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(TokenType$1.EXPANSION_CASE_EXP_START, this._getLocation());\n        this._requireCharCode($LBRACE);\n        this._endToken([], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.push(TokenType$1.EXPANSION_CASE_EXP_START);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionCaseEnd = function () {\n        this._beginToken(TokenType$1.EXPANSION_CASE_EXP_END, this._getLocation());\n        this._requireCharCode($RBRACE);\n        this._endToken([], this._getLocation());\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.pop();\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeExpansionFormEnd = function () {\n        this._beginToken(TokenType$1.EXPANSION_FORM_END, this._getLocation());\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.pop();\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._consumeText = function () {\n        var /** @type {?} */ start = this._getLocation();\n        this._beginToken(TokenType$1.TEXT, start);\n        var /** @type {?} */ parts = [];\n        do {\n            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n                parts.push(this._interpolationConfig.start);\n                this._inInterpolation = true;\n            }\n            else if (this._interpolationConfig && this._inInterpolation &&\n                this._attemptStr(this._interpolationConfig.end)) {\n                parts.push(this._interpolationConfig.end);\n                this._inInterpolation = false;\n            }\n            else {\n                parts.push(this._readChar(true));\n            }\n        } while (!this._isTextEnd());\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._isTextEnd = function () {\n        if (this._peek === $LT || this._peek === $EOF) {\n            return true;\n        }\n        if (this._tokenizeIcu && !this._inInterpolation) {\n            if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n                // start of an expansion form\n                return true;\n            }\n            if (this._peek === $RBRACE && this._isInExpansionCase()) {\n                // end of and expansion case\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._savePosition = function () {\n        return [this._peek, this._index, this._column, this._line, this.tokens.length];\n    };\n    /**\n     * @param {?} char\n     * @return {?}\n     */\n    _Tokenizer.prototype._readUntil = function (char) {\n        var /** @type {?} */ start = this._index;\n        this._attemptUntilChar(char);\n        return this._input.substring(start, this._index);\n    };\n    /**\n     * @param {?} position\n     * @return {?}\n     */\n    _Tokenizer.prototype._restorePosition = function (position) {\n        this._peek = position[0];\n        this._index = position[1];\n        this._column = position[2];\n        this._line = position[3];\n        var /** @type {?} */ nbTokens = position[4];\n        if (nbTokens < this.tokens.length) {\n            // remove any extra tokens\n            this.tokens = this.tokens.slice(0, nbTokens);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._isInExpansionCase = function () {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType$1.EXPANSION_CASE_EXP_START;\n    };\n    /**\n     * @return {?}\n     */\n    _Tokenizer.prototype._isInExpansionForm = function () {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                TokenType$1.EXPANSION_FORM_START;\n    };\n    return _Tokenizer;\n}());\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNotWhitespace(code) {\n    return !isWhitespace(code) || code === $EOF;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNameEnd(code) {\n    return isWhitespace(code) || code === $GT || code === $SLASH ||\n        code === $SQ || code === $DQ || code === $EQ;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isPrefixEnd(code) {\n    return (code < $a || $z < code) && (code < $A || $Z < code) &&\n        (code < $0 || code > $9);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isDigitEntityEnd(code) {\n    return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isNamedEntityEnd(code) {\n    return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);\n}\n/**\n * @param {?} input\n * @param {?} offset\n * @param {?} interpolationConfig\n * @return {?}\n */\nfunction isExpansionFormStart(input, offset, interpolationConfig) {\n    var /** @type {?} */ isInterpolationStart = interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;\n    return input.charCodeAt(offset) == $LBRACE && !isInterpolationStart;\n}\n/**\n * @param {?} peek\n * @return {?}\n */\nfunction isExpansionCaseStart(peek) {\n    return peek === $EQ || isAsciiLetter(peek);\n}\n/**\n * @param {?} code1\n * @param {?} code2\n * @return {?}\n */\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction toUpperCaseCharCode(code) {\n    return code >= $a && code <= $z ? code - $a + $A : code;\n}\n/**\n * @param {?} srcTokens\n * @return {?}\n */\nfunction mergeTextTokens(srcTokens) {\n    var /** @type {?} */ dstTokens = [];\n    var /** @type {?} */ lastDstToken;\n    for (var /** @type {?} */ i = 0; i < srcTokens.length; i++) {\n        var /** @type {?} */ token = srcTokens[i];\n        if (lastDstToken && lastDstToken.type == TokenType$1.TEXT && token.type == TokenType$1.TEXT) {\n            lastDstToken.parts[0] += token.parts[0];\n            lastDstToken.sourceSpan.end = token.sourceSpan.end;\n        }\n        else {\n            lastDstToken = token;\n            dstTokens.push(lastDstToken);\n        }\n    }\n    return dstTokens;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TreeError = (function (_super) {\n    __extends(TreeError, _super);\n    /**\n     * @param {?} elementName\n     * @param {?} span\n     * @param {?} msg\n     */\n    function TreeError(elementName, span, msg) {\n        var _this = _super.call(this, span, msg) || this;\n        _this.elementName = elementName;\n        return _this;\n    }\n    /**\n     * @param {?} elementName\n     * @param {?} span\n     * @param {?} msg\n     * @return {?}\n     */\n    TreeError.create = function (elementName, span, msg) {\n        return new TreeError(elementName, span, msg);\n    };\n    return TreeError;\n}(ParseError));\nvar ParseTreeResult = (function () {\n    /**\n     * @param {?} rootNodes\n     * @param {?} errors\n     */\n    function ParseTreeResult(rootNodes, errors) {\n        this.rootNodes = rootNodes;\n        this.errors = errors;\n    }\n    return ParseTreeResult;\n}());\nvar Parser$1 = (function () {\n    /**\n     * @param {?} getTagDefinition\n     */\n    function Parser$1(getTagDefinition) {\n        this.getTagDefinition = getTagDefinition;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    Parser$1.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ tokensAndErrors = tokenize(source, url, this.getTagDefinition, parseExpansionForms, interpolationConfig);\n        var /** @type {?} */ treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();\n        return new ParseTreeResult(treeAndErrors.rootNodes, ((tokensAndErrors.errors)).concat(treeAndErrors.errors));\n    };\n    return Parser$1;\n}());\nvar _TreeBuilder = (function () {\n    /**\n     * @param {?} tokens\n     * @param {?} getTagDefinition\n     */\n    function _TreeBuilder(tokens, getTagDefinition) {\n        this.tokens = tokens;\n        this.getTagDefinition = getTagDefinition;\n        this._index = -1;\n        this._rootNodes = [];\n        this._errors = [];\n        this._elementStack = [];\n        this._advance();\n    }\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype.build = function () {\n        while (this._peek.type !== TokenType$1.EOF) {\n            if (this._peek.type === TokenType$1.TAG_OPEN_START) {\n                this._consumeStartTag(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.TAG_CLOSE) {\n                this._consumeEndTag(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.CDATA_START) {\n                this._closeVoidElement();\n                this._consumeCdata(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.COMMENT_START) {\n                this._closeVoidElement();\n                this._consumeComment(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.TEXT || this._peek.type === TokenType$1.RAW_TEXT ||\n                this._peek.type === TokenType$1.ESCAPABLE_RAW_TEXT) {\n                this._closeVoidElement();\n                this._consumeText(this._advance());\n            }\n            else if (this._peek.type === TokenType$1.EXPANSION_FORM_START) {\n                this._consumeExpansion(this._advance());\n            }\n            else {\n                // Skip all other tokens...\n                this._advance();\n            }\n        }\n        return new ParseTreeResult(this._rootNodes, this._errors);\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._advance = function () {\n        var /** @type {?} */ prev = this._peek;\n        if (this._index < this.tokens.length - 1) {\n            // Note: there is always an EOF token at the end\n            this._index++;\n        }\n        this._peek = this.tokens[this._index];\n        return prev;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    _TreeBuilder.prototype._advanceIf = function (type) {\n        if (this._peek.type === type) {\n            return this._advance();\n        }\n        return null;\n    };\n    /**\n     * @param {?} startToken\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeCdata = function (startToken) {\n        this._consumeText(this._advance());\n        this._advanceIf(TokenType$1.CDATA_END);\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeComment = function (token) {\n        var /** @type {?} */ text = this._advanceIf(TokenType$1.RAW_TEXT);\n        this._advanceIf(TokenType$1.COMMENT_END);\n        var /** @type {?} */ value = text != null ? text.parts[0].trim() : null;\n        this._addToParent(new Comment(value, token.sourceSpan));\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeExpansion = function (token) {\n        var /** @type {?} */ switchValue = this._advance();\n        var /** @type {?} */ type = this._advance();\n        var /** @type {?} */ cases = [];\n        // read =\n        while (this._peek.type === TokenType$1.EXPANSION_CASE_VALUE) {\n            var /** @type {?} */ expCase = this._parseExpansionCase();\n            if (!expCase)\n                return; // error\n            cases.push(expCase);\n        }\n        // read the final }\n        if (this._peek.type !== TokenType$1.EXPANSION_FORM_END) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n            return;\n        }\n        var /** @type {?} */ sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n        this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n        this._advance();\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._parseExpansionCase = function () {\n        var /** @type {?} */ value = this._advance();\n        // read {\n        if (this._peek.type !== TokenType$1.EXPANSION_CASE_EXP_START) {\n            this._errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '{'.\"));\n            return null;\n        }\n        // read until }\n        var /** @type {?} */ start = this._advance();\n        var /** @type {?} */ exp = this._collectExpansionExpTokens(start);\n        if (!exp)\n            return null;\n        var /** @type {?} */ end = this._advance();\n        exp.push(new Token$1(TokenType$1.EOF, [], end.sourceSpan));\n        // parse everything in between { and }\n        var /** @type {?} */ parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();\n        if (parsedExp.errors.length > 0) {\n            this._errors = this._errors.concat(/** @type {?} */ (parsedExp.errors));\n            return null;\n        }\n        var /** @type {?} */ sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n        var /** @type {?} */ expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n        return new ExpansionCase(value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n    };\n    /**\n     * @param {?} start\n     * @return {?}\n     */\n    _TreeBuilder.prototype._collectExpansionExpTokens = function (start) {\n        var /** @type {?} */ exp = [];\n        var /** @type {?} */ expansionFormStack = [TokenType$1.EXPANSION_CASE_EXP_START];\n        while (true) {\n            if (this._peek.type === TokenType$1.EXPANSION_FORM_START ||\n                this._peek.type === TokenType$1.EXPANSION_CASE_EXP_START) {\n                expansionFormStack.push(this._peek.type);\n            }\n            if (this._peek.type === TokenType$1.EXPANSION_CASE_EXP_END) {\n                if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_CASE_EXP_START)) {\n                    expansionFormStack.pop();\n                    if (expansionFormStack.length == 0)\n                        return exp;\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                    return null;\n                }\n            }\n            if (this._peek.type === TokenType$1.EXPANSION_FORM_END) {\n                if (lastOnStack(expansionFormStack, TokenType$1.EXPANSION_FORM_START)) {\n                    expansionFormStack.pop();\n                }\n                else {\n                    this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                    return null;\n                }\n            }\n            if (this._peek.type === TokenType$1.EOF) {\n                this._errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n                return null;\n            }\n            exp.push(this._advance());\n        }\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeText = function (token) {\n        var /** @type {?} */ text = token.parts[0];\n        if (text.length > 0 && text[0] == '\\n') {\n            var /** @type {?} */ parent = this._getParentElement();\n            if (parent != null && parent.children.length == 0 &&\n                this.getTagDefinition(parent.name).ignoreFirstLf) {\n                text = text.substring(1);\n            }\n        }\n        if (text.length > 0) {\n            this._addToParent(new Text(text, token.sourceSpan));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._closeVoidElement = function () {\n        if (this._elementStack.length > 0) {\n            var /** @type {?} */ el = this._elementStack[this._elementStack.length - 1];\n            if (this.getTagDefinition(el.name).isVoid) {\n                this._elementStack.pop();\n            }\n        }\n    };\n    /**\n     * @param {?} startTagToken\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeStartTag = function (startTagToken) {\n        var /** @type {?} */ prefix = startTagToken.parts[0];\n        var /** @type {?} */ name = startTagToken.parts[1];\n        var /** @type {?} */ attrs = [];\n        while (this._peek.type === TokenType$1.ATTR_NAME) {\n            attrs.push(this._consumeAttr(this._advance()));\n        }\n        var /** @type {?} */ fullName = this._getElementFullName(prefix, name, this._getParentElement());\n        var /** @type {?} */ selfClosing = false;\n        // Note: There could have been a tokenizer error\n        // so that we don't get a token for the end tag...\n        if (this._peek.type === TokenType$1.TAG_OPEN_END_VOID) {\n            this._advance();\n            selfClosing = true;\n            var /** @type {?} */ tagDef = this.getTagDefinition(fullName);\n            if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n                this._errors.push(TreeError.create(fullName, startTagToken.sourceSpan, \"Only void and foreign elements can be self closed \\\"\" + startTagToken.parts[1] + \"\\\"\"));\n            }\n        }\n        else if (this._peek.type === TokenType$1.TAG_OPEN_END) {\n            this._advance();\n            selfClosing = false;\n        }\n        var /** @type {?} */ end = this._peek.sourceSpan.start;\n        var /** @type {?} */ span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n        var /** @type {?} */ el = new Element(fullName, attrs, [], span, span, null);\n        this._pushElement(el);\n        if (selfClosing) {\n            this._popElement(fullName);\n            el.endSourceSpan = span;\n        }\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _TreeBuilder.prototype._pushElement = function (el) {\n        if (this._elementStack.length > 0) {\n            var /** @type {?} */ parentEl = this._elementStack[this._elementStack.length - 1];\n            if (this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n                this._elementStack.pop();\n            }\n        }\n        var /** @type {?} */ tagDef = this.getTagDefinition(el.name);\n        var _a = this._getParentElementSkippingContainers(), parent = _a.parent, container = _a.container;\n        if (parent && tagDef.requireExtraParent(parent.name)) {\n            var /** @type {?} */ newParent = new Element(tagDef.parentToAdd, [], [], el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n            this._insertBeforeContainer(parent, container, newParent);\n        }\n        this._addToParent(el);\n        this._elementStack.push(el);\n    };\n    /**\n     * @param {?} endTagToken\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeEndTag = function (endTagToken) {\n        var /** @type {?} */ fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n        if (this._getParentElement()) {\n            this._getParentElement().endSourceSpan = endTagToken.sourceSpan;\n        }\n        if (this.getTagDefinition(fullName).isVoid) {\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, \"Void elements do not have end tags \\\"\" + endTagToken.parts[1] + \"\\\"\"));\n        }\n        else if (!this._popElement(fullName)) {\n            var /** @type {?} */ errMsg = \"Unexpected closing tag \\\"\" + fullName + \"\\\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags\";\n            this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n        }\n    };\n    /**\n     * @param {?} fullName\n     * @return {?}\n     */\n    _TreeBuilder.prototype._popElement = function (fullName) {\n        for (var /** @type {?} */ stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n            var /** @type {?} */ el = this._elementStack[stackIndex];\n            if (el.name == fullName) {\n                this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n                return true;\n            }\n            if (!this.getTagDefinition(el.name).closedByParent) {\n                return false;\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {?} attrName\n     * @return {?}\n     */\n    _TreeBuilder.prototype._consumeAttr = function (attrName) {\n        var /** @type {?} */ fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n        var /** @type {?} */ end = attrName.sourceSpan.end;\n        var /** @type {?} */ value = '';\n        var /** @type {?} */ valueSpan;\n        if (this._peek.type === TokenType$1.ATTR_VALUE) {\n            var /** @type {?} */ valueToken = this._advance();\n            value = valueToken.parts[0];\n            end = valueToken.sourceSpan.end;\n            valueSpan = valueToken.sourceSpan;\n        }\n        return new Attribute$1(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n    };\n    /**\n     * @return {?}\n     */\n    _TreeBuilder.prototype._getParentElement = function () {\n        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n    };\n    /**\n     * Returns the parent in the DOM and the container.\n     *\n     * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n     * @return {?}\n     */\n    _TreeBuilder.prototype._getParentElementSkippingContainers = function () {\n        var /** @type {?} */ container = null;\n        for (var /** @type {?} */ i = this._elementStack.length - 1; i >= 0; i--) {\n            if (this._elementStack[i].name !== 'ng-container') {\n                return { parent: this._elementStack[i], container: container };\n            }\n            container = this._elementStack[i];\n        }\n        return { parent: this._elementStack[this._elementStack.length - 1], container: container };\n    };\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    _TreeBuilder.prototype._addToParent = function (node) {\n        var /** @type {?} */ parent = this._getParentElement();\n        if (parent != null) {\n            parent.children.push(node);\n        }\n        else {\n            this._rootNodes.push(node);\n        }\n    };\n    /**\n     * Insert a node between the parent and the container.\n     * When no container is given, the node is appended as a child of the parent.\n     * Also updates the element stack accordingly.\n     *\n     * \\@internal\n     * @param {?} parent\n     * @param {?} container\n     * @param {?} node\n     * @return {?}\n     */\n    _TreeBuilder.prototype._insertBeforeContainer = function (parent, container, node) {\n        if (!container) {\n            this._addToParent(node);\n            this._elementStack.push(node);\n        }\n        else {\n            if (parent) {\n                // replace the container with the new node in the children\n                var /** @type {?} */ index = parent.children.indexOf(container);\n                parent.children[index] = node;\n            }\n            else {\n                this._rootNodes.push(node);\n            }\n            node.children.push(container);\n            this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n        }\n    };\n    /**\n     * @param {?} prefix\n     * @param {?} localName\n     * @param {?} parentElement\n     * @return {?}\n     */\n    _TreeBuilder.prototype._getElementFullName = function (prefix, localName, parentElement) {\n        if (prefix == null) {\n            prefix = this.getTagDefinition(localName).implicitNamespacePrefix;\n            if (prefix == null && parentElement != null) {\n                prefix = getNsPrefix(parentElement.name);\n            }\n        }\n        return mergeNsAndName(prefix, localName);\n    };\n    return _TreeBuilder;\n}());\n/**\n * @param {?} stack\n * @param {?} element\n * @return {?}\n */\nfunction lastOnStack(stack, element) {\n    return stack.length > 0 && stack[stack.length - 1] === element;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar Message = (function () {\n    /**\n     * @param {?} nodes message AST\n     * @param {?} placeholders maps placeholder names to static content\n     * @param {?} placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n     * @param {?} meaning\n     * @param {?} description\n     * @param {?} id\n     */\n    function Message(nodes, placeholders, placeholderToMessage, meaning, description, id) {\n        this.nodes = nodes;\n        this.placeholders = placeholders;\n        this.placeholderToMessage = placeholderToMessage;\n        this.meaning = meaning;\n        this.description = description;\n        this.id = id;\n    }\n    return Message;\n}());\nvar Text$1 = (function () {\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function Text$1(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Text$1.prototype.visit = function (visitor, context) { return visitor.visitText(this, context); };\n    return Text$1;\n}());\nvar Container = (function () {\n    /**\n     * @param {?} children\n     * @param {?} sourceSpan\n     */\n    function Container(children, sourceSpan) {\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Container.prototype.visit = function (visitor, context) { return visitor.visitContainer(this, context); };\n    return Container;\n}());\nvar Icu = (function () {\n    /**\n     * @param {?} expression\n     * @param {?} type\n     * @param {?} cases\n     * @param {?} sourceSpan\n     */\n    function Icu(expression, type, cases, sourceSpan) {\n        this.expression = expression;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Icu.prototype.visit = function (visitor, context) { return visitor.visitIcu(this, context); };\n    return Icu;\n}());\nvar TagPlaceholder = (function () {\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} startName\n     * @param {?} closeName\n     * @param {?} children\n     * @param {?} isVoid\n     * @param {?} sourceSpan\n     */\n    function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {\n        this.tag = tag;\n        this.attrs = attrs;\n        this.startName = startName;\n        this.closeName = closeName;\n        this.children = children;\n        this.isVoid = isVoid;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    TagPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitTagPlaceholder(this, context); };\n    return TagPlaceholder;\n}());\nvar Placeholder = (function () {\n    /**\n     * @param {?} value\n     * @param {?} name\n     * @param {?} sourceSpan\n     */\n    function Placeholder(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    Placeholder.prototype.visit = function (visitor, context) { return visitor.visitPlaceholder(this, context); };\n    return Placeholder;\n}());\nvar IcuPlaceholder = (function () {\n    /**\n     * @param {?} value\n     * @param {?} name\n     * @param {?} sourceSpan\n     */\n    function IcuPlaceholder(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?=} context\n     * @return {?}\n     */\n    IcuPlaceholder.prototype.visit = function (visitor, context) { return visitor.visitIcuPlaceholder(this, context); };\n    return IcuPlaceholder;\n}());\nvar CloneVisitor = (function () {\n    function CloneVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ children = container.children.map(function (n) { return n.visit(_this, context); });\n        return new Container(children, container.sourceSpan);\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ cases = {};\n        Object.keys(icu.cases).forEach(function (key) { return cases[key] = icu.cases[key].visit(_this, context); });\n        var /** @type {?} */ msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n        msg.expressionPlaceholder = icu.expressionPlaceholder;\n        return msg;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var /** @type {?} */ children = ph.children.map(function (n) { return n.visit(_this, context); });\n        return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    CloneVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    };\n    return CloneVisitor;\n}());\nvar RecurseVisitor = (function () {\n    function RecurseVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitText = function (text, context) { };\n    ;\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        container.children.forEach(function (child) { return child.visit(_this); });\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        Object.keys(icu.cases).forEach(function (k) { icu.cases[k].visit(_this); });\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        ph.children.forEach(function (child) { return child.visit(_this); });\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitPlaceholder = function (ph, context) { };\n    ;\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    RecurseVisitor.prototype.visitIcuPlaceholder = function (ph, context) { };\n    ;\n    return RecurseVisitor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TAG_TO_PLACEHOLDER_NAMES = {\n    'A': 'LINK',\n    'B': 'BOLD_TEXT',\n    'BR': 'LINE_BREAK',\n    'EM': 'EMPHASISED_TEXT',\n    'H1': 'HEADING_LEVEL1',\n    'H2': 'HEADING_LEVEL2',\n    'H3': 'HEADING_LEVEL3',\n    'H4': 'HEADING_LEVEL4',\n    'H5': 'HEADING_LEVEL5',\n    'H6': 'HEADING_LEVEL6',\n    'HR': 'HORIZONTAL_RULE',\n    'I': 'ITALIC_TEXT',\n    'LI': 'LIST_ITEM',\n    'LINK': 'MEDIA_LINK',\n    'OL': 'ORDERED_LIST',\n    'P': 'PARAGRAPH',\n    'Q': 'QUOTATION',\n    'S': 'STRIKETHROUGH_TEXT',\n    'SMALL': 'SMALL_TEXT',\n    'SUB': 'SUBSTRIPT',\n    'SUP': 'SUPERSCRIPT',\n    'TBODY': 'TABLE_BODY',\n    'TD': 'TABLE_CELL',\n    'TFOOT': 'TABLE_FOOTER',\n    'TH': 'TABLE_HEADER_CELL',\n    'THEAD': 'TABLE_HEADER',\n    'TR': 'TABLE_ROW',\n    'TT': 'MONOSPACED_TEXT',\n    'U': 'UNDERLINED_TEXT',\n    'UL': 'UNORDERED_LIST',\n};\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n *\n * \\@internal\n */\nvar PlaceholderRegistry = (function () {\n    function PlaceholderRegistry() {\n        this._placeHolderNameCounts = {};\n        this._signatureToName = {};\n    }\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} isVoid\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getStartTagPlaceholderName = function (tag, attrs, isVoid) {\n        var /** @type {?} */ signature = this._hashTag(tag, attrs, isVoid);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var /** @type {?} */ upperTag = tag.toUpperCase();\n        var /** @type {?} */ baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n        var /** @type {?} */ name = this._generateUniqueName(isVoid ? baseName : \"START_\" + baseName);\n        this._signatureToName[signature] = name;\n        return name;\n    };\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getCloseTagPlaceholderName = function (tag) {\n        var /** @type {?} */ signature = this._hashClosingTag(tag);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var /** @type {?} */ upperTag = tag.toUpperCase();\n        var /** @type {?} */ baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\" + upperTag;\n        var /** @type {?} */ name = this._generateUniqueName(\"CLOSE_\" + baseName);\n        this._signatureToName[signature] = name;\n        return name;\n    };\n    /**\n     * @param {?} name\n     * @param {?} content\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getPlaceholderName = function (name, content) {\n        var /** @type {?} */ upperName = name.toUpperCase();\n        var /** @type {?} */ signature = \"PH: \" + upperName + \"=\" + content;\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        var /** @type {?} */ uniqueName = this._generateUniqueName(upperName);\n        this._signatureToName[signature] = uniqueName;\n        return uniqueName;\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype.getUniquePlaceholder = function (name) {\n        return this._generateUniqueName(name.toUpperCase());\n    };\n    /**\n     * @param {?} tag\n     * @param {?} attrs\n     * @param {?} isVoid\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype._hashTag = function (tag, attrs, isVoid) {\n        var /** @type {?} */ start = \"<\" + tag;\n        var /** @type {?} */ strAttrs = Object.keys(attrs).sort().map(function (name) { return \" \" + name + \"=\" + attrs[name]; }).join('');\n        var /** @type {?} */ end = isVoid ? '/>' : \"></\" + tag + \">\";\n        return start + strAttrs + end;\n    };\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype._hashClosingTag = function (tag) { return this._hashTag(\"/\" + tag, {}, false); };\n    /**\n     * @param {?} base\n     * @return {?}\n     */\n    PlaceholderRegistry.prototype._generateUniqueName = function (base) {\n        var /** @type {?} */ seen = this._placeHolderNameCounts.hasOwnProperty(base);\n        if (!seen) {\n            this._placeHolderNameCounts[base] = 1;\n            return base;\n        }\n        var /** @type {?} */ id = this._placeHolderNameCounts[base];\n        this._placeHolderNameCounts[base] = id + 1;\n        return base + \"_\" + id;\n    };\n    return PlaceholderRegistry;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _expParser = new Parser(new Lexer());\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n * @param {?} interpolationConfig\n * @return {?}\n */\nfunction createI18nMessageFactory(interpolationConfig) {\n    var /** @type {?} */ visitor = new _I18nVisitor(_expParser, interpolationConfig);\n    return function (nodes, meaning, description, id) { return visitor.toI18nMessage(nodes, meaning, description, id); };\n}\nvar _I18nVisitor = (function () {\n    /**\n     * @param {?} _expressionParser\n     * @param {?} _interpolationConfig\n     */\n    function _I18nVisitor(_expressionParser, _interpolationConfig) {\n        this._expressionParser = _expressionParser;\n        this._interpolationConfig = _interpolationConfig;\n    }\n    /**\n     * @param {?} nodes\n     * @param {?} meaning\n     * @param {?} description\n     * @param {?} id\n     * @return {?}\n     */\n    _I18nVisitor.prototype.toI18nMessage = function (nodes, meaning, description, id) {\n        this._isIcu = nodes.length == 1 && nodes[0] instanceof Expansion;\n        this._icuDepth = 0;\n        this._placeholderRegistry = new PlaceholderRegistry();\n        this._placeholderToContent = {};\n        this._placeholderToMessage = {};\n        var /** @type {?} */ i18nodes = visitAll(this, nodes, {});\n        return new Message(i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description, id);\n    };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitElement = function (el, context) {\n        var /** @type {?} */ children = visitAll(this, el.children);\n        var /** @type {?} */ attrs = {};\n        el.attrs.forEach(function (attr) {\n            // Do not visit the attributes, translatable ones are top-level ASTs\n            attrs[attr.name] = attr.value;\n        });\n        var /** @type {?} */ isVoid = getHtmlTagDefinition(el.name).isVoid;\n        var /** @type {?} */ startPhName = this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n        this._placeholderToContent[startPhName] = el.sourceSpan.toString();\n        var /** @type {?} */ closePhName = '';\n        if (!isVoid) {\n            closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);\n            this._placeholderToContent[closePhName] = \"</\" + el.name + \">\";\n        }\n        return new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitAttribute = function (attribute, context) {\n        return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitText = function (text, context) {\n        return this._visitTextWithInterpolation(text.value, text.sourceSpan);\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitComment = function (comment, context) { return null; };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitExpansion = function (icu, context) {\n        var _this = this;\n        this._icuDepth++;\n        var /** @type {?} */ i18nIcuCases = {};\n        var /** @type {?} */ i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n        icu.cases.forEach(function (caze) {\n            i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) { return node.visit(_this, {}); }), caze.expSourceSpan);\n        });\n        this._icuDepth--;\n        if (this._isIcu || this._icuDepth > 0) {\n            // Returns an ICU node when:\n            // - the message (vs a part of the message) is an ICU message, or\n            // - the ICU message is nested.\n            var /** @type {?} */ expPh = this._placeholderRegistry.getUniquePlaceholder(\"VAR_\" + icu.type);\n            i18nIcu.expressionPlaceholder = expPh;\n            this._placeholderToContent[expPh] = icu.switchValue;\n            return i18nIcu;\n        }\n        // Else returns a placeholder\n        // ICU placeholders should not be replaced with their original content but with the their\n        // translations. We need to create a new visitor (they are not re-entrant) to compute the\n        // message id.\n        // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n        var /** @type {?} */ phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n        var /** @type {?} */ visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);\n        this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], '', '', '');\n        return new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    _I18nVisitor.prototype.visitExpansionCase = function (icuCase, context) {\n        throw new Error('Unreachable code');\n    };\n    /**\n     * @param {?} text\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    _I18nVisitor.prototype._visitTextWithInterpolation = function (text, sourceSpan) {\n        var /** @type {?} */ splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);\n        if (!splitInterpolation) {\n            // No expression, return a single text\n            return new Text$1(text, sourceSpan);\n        }\n        // Return a group of text + expressions\n        var /** @type {?} */ nodes = [];\n        var /** @type {?} */ container = new Container(nodes, sourceSpan);\n        var _a = this._interpolationConfig, sDelimiter = _a.start, eDelimiter = _a.end;\n        for (var /** @type {?} */ i = 0; i < splitInterpolation.strings.length - 1; i++) {\n            var /** @type {?} */ expression = splitInterpolation.expressions[i];\n            var /** @type {?} */ baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';\n            var /** @type {?} */ phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);\n            if (splitInterpolation.strings[i].length) {\n                // No need to add empty strings\n                nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));\n            }\n            nodes.push(new Placeholder(expression, phName, sourceSpan));\n            this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n        }\n        // The last index contains no expression\n        var /** @type {?} */ lastStringIdx = splitInterpolation.strings.length - 1;\n        if (splitInterpolation.strings[lastStringIdx].length) {\n            nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));\n        }\n        return container;\n    };\n    return _I18nVisitor;\n}());\nvar _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction _extractPlaceholderName(input) {\n    return input.split(_CUSTOM_PH_EXP)[2];\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An i18n error.\n */\nvar I18nError = (function (_super) {\n    __extends(I18nError, _super);\n    /**\n     * @param {?} span\n     * @param {?} msg\n     */\n    function I18nError(span, msg) {\n        return _super.call(this, span, msg) || this;\n    }\n    return I18nError;\n}(ParseError));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _I18N_ATTR = 'i18n';\nvar _I18N_ATTR_PREFIX = 'i18n-';\nvar _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nvar MEANING_SEPARATOR = '|';\nvar ID_SEPARATOR = '@@';\n/**\n * Extract translatable messages from an html AST\n * @param {?} nodes\n * @param {?} interpolationConfig\n * @param {?} implicitTags\n * @param {?} implicitAttrs\n * @return {?}\n */\nfunction extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n    var /** @type {?} */ visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.extract(nodes, interpolationConfig);\n}\n/**\n * @param {?} nodes\n * @param {?} translations\n * @param {?} interpolationConfig\n * @param {?} implicitTags\n * @param {?} implicitAttrs\n * @return {?}\n */\nfunction mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n    var /** @type {?} */ visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.merge(nodes, translations, interpolationConfig);\n}\nvar ExtractionResult = (function () {\n    /**\n     * @param {?} messages\n     * @param {?} errors\n     */\n    function ExtractionResult(messages, errors) {\n        this.messages = messages;\n        this.errors = errors;\n    }\n    return ExtractionResult;\n}());\nvar _VisitorMode = {};\n_VisitorMode.Extract = 0;\n_VisitorMode.Merge = 1;\n_VisitorMode[_VisitorMode.Extract] = \"Extract\";\n_VisitorMode[_VisitorMode.Merge] = \"Merge\";\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * \\@internal\n */\nvar _Visitor = (function () {\n    /**\n     * @param {?} _implicitTags\n     * @param {?} _implicitAttrs\n     */\n    function _Visitor(_implicitTags, _implicitAttrs) {\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n    }\n    /**\n     * Extracts the messages from the tree\n     * @param {?} nodes\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _Visitor.prototype.extract = function (nodes, interpolationConfig) {\n        var _this = this;\n        this._init(_VisitorMode.Extract, interpolationConfig);\n        nodes.forEach(function (node) { return node.visit(_this, null); });\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ExtractionResult(this._messages, this._errors);\n    };\n    /**\n     * Returns a tree where all translatable nodes are translated\n     * @param {?} nodes\n     * @param {?} translations\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _Visitor.prototype.merge = function (nodes, translations, interpolationConfig) {\n        this._init(_VisitorMode.Merge, interpolationConfig);\n        this._translations = translations;\n        // Construct a single fake root element\n        var /** @type {?} */ wrapper = new Element('wrapper', [], nodes, null, null, null);\n        var /** @type {?} */ translatedNode = wrapper.visit(this, null);\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ParseTreeResult(translatedNode.children, this._errors);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitExpansionCase = function (icuCase, context) {\n        // Parse cases for translatable html attributes\n        var /** @type {?} */ expression = visitAll(this, icuCase.expression, context);\n        if (this._mode === _VisitorMode.Merge) {\n            return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n        }\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitExpansion = function (icu, context) {\n        this._mayBeAddBlockChildren(icu);\n        var /** @type {?} */ wasInIcu = this._inIcu;\n        if (!this._inIcu) {\n            // nested ICU messages should not be extracted but top-level translated as a whole\n            if (this._isInTranslatableSection) {\n                this._addMessage([icu]);\n            }\n            this._inIcu = true;\n        }\n        var /** @type {?} */ cases = visitAll(this, icu.cases, context);\n        if (this._mode === _VisitorMode.Merge) {\n            icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n        }\n        this._inIcu = wasInIcu;\n        return icu;\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitComment = function (comment, context) {\n        var /** @type {?} */ isOpening = _isOpeningComment(comment);\n        if (isOpening && this._isInTranslatableSection) {\n            this._reportError(comment, 'Could not start a block inside a translatable section');\n            return;\n        }\n        var /** @type {?} */ isClosing = _isClosingComment(comment);\n        if (isClosing && !this._inI18nBlock) {\n            this._reportError(comment, 'Trying to close an unopened block');\n            return;\n        }\n        if (!this._inI18nNode && !this._inIcu) {\n            if (!this._inI18nBlock) {\n                if (isOpening) {\n                    this._inI18nBlock = true;\n                    this._blockStartDepth = this._depth;\n                    this._blockChildren = [];\n                    this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n                    this._openTranslatableSection(comment);\n                }\n            }\n            else {\n                if (isClosing) {\n                    if (this._depth == this._blockStartDepth) {\n                        this._closeTranslatableSection(comment, this._blockChildren);\n                        this._inI18nBlock = false;\n                        var /** @type {?} */ message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);\n                        // merge attributes in sections\n                        var /** @type {?} */ nodes = this._translateMessage(comment, message);\n                        return visitAll(this, nodes);\n                    }\n                    else {\n                        this._reportError(comment, 'I18N blocks should not cross element boundaries');\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitText = function (text, context) {\n        if (this._isInTranslatableSection) {\n            this._mayBeAddBlockChildren(text);\n        }\n        return text;\n    };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitElement = function (el, context) {\n        var _this = this;\n        this._mayBeAddBlockChildren(el);\n        this._depth++;\n        var /** @type {?} */ wasInI18nNode = this._inI18nNode;\n        var /** @type {?} */ wasInImplicitNode = this._inImplicitNode;\n        var /** @type {?} */ childNodes = [];\n        var /** @type {?} */ translatedChildNodes;\n        // Extract:\n        // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n        // - ICU messages\n        var /** @type {?} */ i18nAttr = _getI18nAttr(el);\n        var /** @type {?} */ i18nMeta = i18nAttr ? i18nAttr.value : '';\n        var /** @type {?} */ isImplicit = this._implicitTags.some(function (tag) { return el.name === tag; }) && !this._inIcu &&\n            !this._isInTranslatableSection;\n        var /** @type {?} */ isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n        this._inImplicitNode = wasInImplicitNode || isImplicit;\n        if (!this._isInTranslatableSection && !this._inIcu) {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._inI18nNode = true;\n                var /** @type {?} */ message = this._addMessage(el.children, i18nMeta);\n                translatedChildNodes = this._translateMessage(el, message);\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                var /** @type {?} */ isTranslatable = i18nAttr || isTopLevelImplicit;\n                if (isTranslatable)\n                    this._openTranslatableSection(el);\n                visitAll(this, el.children);\n                if (isTranslatable)\n                    this._closeTranslatableSection(el, el.children);\n            }\n        }\n        else {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                // Descend into child nodes for extraction\n                visitAll(this, el.children);\n            }\n        }\n        if (this._mode === _VisitorMode.Merge) {\n            var /** @type {?} */ visitNodes = translatedChildNodes || el.children;\n            visitNodes.forEach(function (child) {\n                var /** @type {?} */ visited = child.visit(_this, context);\n                if (visited && !_this._isInTranslatableSection) {\n                    // Do not add the children from translatable sections (= i18n blocks here)\n                    // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n                    childNodes = childNodes.concat(visited);\n                }\n            });\n        }\n        this._visitAttributesOf(el);\n        this._depth--;\n        this._inI18nNode = wasInI18nNode;\n        this._inImplicitNode = wasInImplicitNode;\n        if (this._mode === _VisitorMode.Merge) {\n            var /** @type {?} */ translatedAttrs = this._translateAttributes(el);\n            return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor.prototype.visitAttribute = function (attribute, context) {\n        throw new Error('unreachable code');\n    };\n    /**\n     * @param {?} mode\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    _Visitor.prototype._init = function (mode, interpolationConfig) {\n        this._mode = mode;\n        this._inI18nBlock = false;\n        this._inI18nNode = false;\n        this._depth = 0;\n        this._inIcu = false;\n        this._msgCountAtSectionStart = void 0;\n        this._errors = [];\n        this._messages = [];\n        this._inImplicitNode = false;\n        this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _Visitor.prototype._visitAttributesOf = function (el) {\n        var _this = this;\n        var /** @type {?} */ explicitAttrNameToValue = {};\n        var /** @type {?} */ implicitAttrNames = this._implicitAttrs[el.name] || [];\n        el.attrs.filter(function (attr) { return attr.name.startsWith(_I18N_ATTR_PREFIX); })\n            .forEach(function (attr) { return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            attr.value; });\n        el.attrs.forEach(function (attr) {\n            if (attr.name in explicitAttrNameToValue) {\n                _this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n            }\n            else if (implicitAttrNames.some(function (name) { return attr.name === name; })) {\n                _this._addMessage([attr]);\n            }\n        });\n    };\n    /**\n     * @param {?} ast\n     * @param {?=} msgMeta\n     * @return {?}\n     */\n    _Visitor.prototype._addMessage = function (ast, msgMeta) {\n        if (ast.length == 0 ||\n            ast.length == 1 && ast[0] instanceof Attribute$1 && !((ast[0])).value) {\n            // Do not create empty messages\n            return;\n        }\n        var _a = _parseMessageMeta(msgMeta), meaning = _a.meaning, description = _a.description, id = _a.id;\n        var /** @type {?} */ message = this._createI18nMessage(ast, meaning, description, id);\n        this._messages.push(message);\n        return message;\n    };\n    /**\n     * @param {?} el\n     * @param {?} message\n     * @return {?}\n     */\n    _Visitor.prototype._translateMessage = function (el, message) {\n        if (message && this._mode === _VisitorMode.Merge) {\n            var /** @type {?} */ nodes = this._translations.get(message);\n            if (nodes) {\n                return nodes;\n            }\n            this._reportError(el, \"Translation unavailable for message id=\\\"\" + this._translations.digest(message) + \"\\\"\");\n        }\n        return [];\n    };\n    /**\n     * @param {?} el\n     * @return {?}\n     */\n    _Visitor.prototype._translateAttributes = function (el) {\n        var _this = this;\n        var /** @type {?} */ attributes = el.attrs;\n        var /** @type {?} */ i18nParsedMessageMeta = {};\n        attributes.forEach(function (attr) {\n            if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                    _parseMessageMeta(attr.value);\n            }\n        });\n        var /** @type {?} */ translatedAttributes = [];\n        attributes.forEach(function (attr) {\n            if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                // strip i18n specific attributes\n                return;\n            }\n            if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n                var _a = i18nParsedMessageMeta[attr.name], meaning = _a.meaning, description = _a.description, id = _a.id;\n                var /** @type {?} */ message = _this._createI18nMessage([attr], meaning, description, id);\n                var /** @type {?} */ nodes = _this._translations.get(message);\n                if (nodes) {\n                    if (nodes.length == 0) {\n                        translatedAttributes.push(new Attribute$1(attr.name, '', attr.sourceSpan));\n                    }\n                    else if (nodes[0] instanceof Text) {\n                        var /** @type {?} */ value = ((nodes[0])).value;\n                        translatedAttributes.push(new Attribute$1(attr.name, value, attr.sourceSpan));\n                    }\n                    else {\n                        _this._reportError(el, \"Unexpected translation for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n                    }\n                }\n                else {\n                    _this._reportError(el, \"Translation unavailable for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n                }\n            }\n            else {\n                translatedAttributes.push(attr);\n            }\n        });\n        return translatedAttributes;\n    };\n    /**\n     * Add the node as a child of the block when:\n     * - we are in a block,\n     * - we are not inside a ICU message (those are handled separately),\n     * - the node is a \"direct child\" of the block\n     * @param {?} node\n     * @return {?}\n     */\n    _Visitor.prototype._mayBeAddBlockChildren = function (node) {\n        if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n            this._blockChildren.push(node);\n        }\n    };\n    /**\n     * Marks the start of a section, see `_closeTranslatableSection`\n     * @param {?} node\n     * @return {?}\n     */\n    _Visitor.prototype._openTranslatableSection = function (node) {\n        if (this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section start');\n        }\n        else {\n            this._msgCountAtSectionStart = this._messages.length;\n        }\n    };\n    Object.defineProperty(_Visitor.prototype, \"_isInTranslatableSection\", {\n        /**\n         * A translatable section could be:\n         * - the content of translatable element,\n         * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n         * @return {?}\n         */\n        get: function () {\n            return this._msgCountAtSectionStart !== void 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Terminates a section.\n     *\n     * If a section has only one significant children (comments not significant) then we should not\n     * keep the message from this children:\n     *\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n     * - one for the <p> content with meaning and description,\n     * - another one for the ICU message.\n     *\n     * In this case the last message is discarded as it contains less information (the AST is\n     * otherwise identical).\n     *\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\n     * ICU message here)\n     * @param {?} node\n     * @param {?} directChildren\n     * @return {?}\n     */\n    _Visitor.prototype._closeTranslatableSection = function (node, directChildren) {\n        if (!this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section end');\n            return;\n        }\n        var /** @type {?} */ startIndex = this._msgCountAtSectionStart;\n        var /** @type {?} */ significantChildren = directChildren.reduce(function (count, node) { return count + (node instanceof Comment ? 0 : 1); }, 0);\n        if (significantChildren == 1) {\n            for (var /** @type {?} */ i = this._messages.length - 1; i >= startIndex; i--) {\n                var /** @type {?} */ ast = this._messages[i].nodes;\n                if (!(ast.length == 1 && ast[0] instanceof Text$1)) {\n                    this._messages.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        this._msgCountAtSectionStart = void 0;\n    };\n    /**\n     * @param {?} node\n     * @param {?} msg\n     * @return {?}\n     */\n    _Visitor.prototype._reportError = function (node, msg) {\n        this._errors.push(new I18nError(node.sourceSpan, msg));\n    };\n    return _Visitor;\n}());\n/**\n * @param {?} n\n * @return {?}\n */\nfunction _isOpeningComment(n) {\n    return n instanceof Comment && n.value && n.value.startsWith('i18n');\n}\n/**\n * @param {?} n\n * @return {?}\n */\nfunction _isClosingComment(n) {\n    return n instanceof Comment && n.value && n.value === '/i18n';\n}\n/**\n * @param {?} p\n * @return {?}\n */\nfunction _getI18nAttr(p) {\n    return p.attrs.find(function (attr) { return attr.name === _I18N_ATTR; }) || null;\n}\n/**\n * @param {?} i18n\n * @return {?}\n */\nfunction _parseMessageMeta(i18n) {\n    if (!i18n)\n        return { meaning: '', description: '', id: '' };\n    var /** @type {?} */ idIndex = i18n.indexOf(ID_SEPARATOR);\n    var /** @type {?} */ descIndex = i18n.indexOf(MEANING_SEPARATOR);\n    var _a = (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''], meaningAndDesc = _a[0], id = _a[1];\n    var _b = (descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc], meaning = _b[0], description = _b[1];\n    return { meaning: meaning, description: description, id: id };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XmlTagDefinition = (function () {\n    function XmlTagDefinition() {\n        this.closedByParent = false;\n        this.contentType = TagContentType.PARSABLE_DATA;\n        this.isVoid = false;\n        this.ignoreFirstLf = false;\n        this.canSelfClose = true;\n    }\n    /**\n     * @param {?} currentParent\n     * @return {?}\n     */\n    XmlTagDefinition.prototype.requireExtraParent = function (currentParent) { return false; };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    XmlTagDefinition.prototype.isClosedByChild = function (name) { return false; };\n    return XmlTagDefinition;\n}());\nvar _TAG_DEFINITION = new XmlTagDefinition();\n/**\n * @param {?} tagName\n * @return {?}\n */\nfunction getXmlTagDefinition(tagName) {\n    return _TAG_DEFINITION;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar XmlParser = (function (_super) {\n    __extends(XmlParser, _super);\n    function XmlParser() {\n        return _super.call(this, getXmlTagDefinition) || this;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @return {?}\n     */\n    XmlParser.prototype.parse = function (source, url, parseExpansionForms) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        return _super.prototype.parse.call(this, source, url, parseExpansionForms, null);\n    };\n    return XmlParser;\n}(Parser$1));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} message\n * @return {?}\n */\nfunction digest(message) {\n    return message.id || sha1(serializeNodes(message.nodes).join('') + (\"[\" + message.meaning + \"]\"));\n}\n/**\n * @param {?} message\n * @return {?}\n */\nfunction decimalDigest(message) {\n    if (message.id) {\n        return message.id;\n    }\n    var /** @type {?} */ visitor = new _SerializerIgnoreIcuExpVisitor();\n    var /** @type {?} */ parts = message.nodes.map(function (a) { return a.visit(visitor, null); });\n    return computeMsgId(parts.join(''), message.meaning);\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * \\@internal\n */\nvar _SerializerVisitor = (function () {\n    function _SerializerVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitText = function (text, context) { return text.value; };\n    /**\n     * @param {?} container\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return \"[\" + container.children.map(function (child) { return child.visit(_this); }).join(', ') + \"]\";\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        return \"{\" + icu.expression + \", \" + icu.type + \", \" + strCases.join(', ') + \"}\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        return ph.isVoid ?\n            \"<ph tag name=\\\"\" + ph.startName + \"\\\"/>\" :\n            \"<ph tag name=\\\"\" + ph.startName + \"\\\">\" + ph.children.map(function (child) { return child.visit(_this); }).join(', ') + \"</ph name=\\\"\" + ph.closeName + \"\\\">\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return ph.value ? \"<ph name=\\\"\" + ph.name + \"\\\">\" + ph.value + \"</ph>\" : \"<ph name=\\\"\" + ph.name + \"\\\"/>\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _SerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return \"<ph icu name=\\\"\" + ph.name + \"\\\">\" + ph.value.visit(this) + \"</ph>\";\n    };\n    return _SerializerVisitor;\n}());\nvar serializerVisitor = new _SerializerVisitor();\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction serializeNodes(nodes) {\n    return nodes.map(function (a) { return a.visit(serializerVisitor, null); });\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * \\@internal\n */\nvar _SerializerIgnoreIcuExpVisitor = (function (_super) {\n    __extends(_SerializerIgnoreIcuExpVisitor, _super);\n    function _SerializerIgnoreIcuExpVisitor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _SerializerIgnoreIcuExpVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ strCases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        // Do not take the expression into account\n        return \"{\" + icu.type + \", \" + strCases.join(', ') + \"}\";\n    };\n    return _SerializerIgnoreIcuExpVisitor;\n}(_SerializerVisitor));\n/**\n * Compute the SHA1 of the given string\n *\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n * @param {?} str\n * @return {?}\n */\nfunction sha1(str) {\n    var /** @type {?} */ utf8 = utf8Encode(str);\n    var /** @type {?} */ words32 = stringToWords32(utf8, Endian.Big);\n    var /** @type {?} */ len = utf8.length * 8;\n    var /** @type {?} */ w = new Array(80);\n    var _a = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0], a = _a[0], b = _a[1], c = _a[2], d = _a[3], e = _a[4];\n    words32[len >> 5] |= 0x80 << (24 - len % 32);\n    words32[((len + 64 >> 9) << 4) + 15] = len;\n    for (var /** @type {?} */ i = 0; i < words32.length; i += 16) {\n        var _b = [a, b, c, d, e], h0 = _b[0], h1 = _b[1], h2 = _b[2], h3 = _b[3], h4 = _b[4];\n        for (var /** @type {?} */ j = 0; j < 80; j++) {\n            if (j < 16) {\n                w[j] = words32[i + j];\n            }\n            else {\n                w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n            }\n            var _c = fk(j, b, c, d), f = _c[0], k = _c[1];\n            var /** @type {?} */ temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n            _d = [d, c, rol32(b, 30), a, temp], e = _d[0], d = _d[1], c = _d[2], b = _d[3], a = _d[4];\n        }\n        _e = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)], a = _e[0], b = _e[1], c = _e[2], d = _e[3], e = _e[4];\n    }\n    return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n    var _d, _e;\n}\n/**\n * @param {?} index\n * @param {?} b\n * @param {?} c\n * @param {?} d\n * @return {?}\n */\nfunction fk(index, b, c, d) {\n    if (index < 20) {\n        return [(b & c) | (~b & d), 0x5a827999];\n    }\n    if (index < 40) {\n        return [b ^ c ^ d, 0x6ed9eba1];\n    }\n    if (index < 60) {\n        return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n    }\n    return [b ^ c ^ d, 0xca62c1d6];\n}\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n * @param {?} str\n * @return {?}\n */\nfunction fingerprint(str) {\n    var /** @type {?} */ utf8 = utf8Encode(str);\n    var _a = [hash32(utf8, 0), hash32(utf8, 102072)], hi = _a[0], lo = _a[1];\n    if (hi == 0 && (lo == 0 || lo == 1)) {\n        hi = hi ^ 0x130f9bef;\n        lo = lo ^ -0x6b5f56d8;\n    }\n    return [hi, lo];\n}\n/**\n * @param {?} msg\n * @param {?} meaning\n * @return {?}\n */\nfunction computeMsgId(msg, meaning) {\n    var _a = fingerprint(msg), hi = _a[0], lo = _a[1];\n    if (meaning) {\n        var _b = fingerprint(meaning), him = _b[0], lom = _b[1];\n        _c = add64(rol64([hi, lo], 1), [him, lom]), hi = _c[0], lo = _c[1];\n    }\n    return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n    var _c;\n}\n/**\n * @param {?} str\n * @param {?} c\n * @return {?}\n */\nfunction hash32(str, c) {\n    var _a = [0x9e3779b9, 0x9e3779b9], a = _a[0], b = _a[1];\n    var /** @type {?} */ i;\n    var /** @type {?} */ len = str.length;\n    for (i = 0; i + 12 <= len; i += 12) {\n        a = add32(a, wordAt(str, i, Endian.Little));\n        b = add32(b, wordAt(str, i + 4, Endian.Little));\n        c = add32(c, wordAt(str, i + 8, Endian.Little));\n        _b = mix([a, b, c]), a = _b[0], b = _b[1], c = _b[2];\n    }\n    a = add32(a, wordAt(str, i, Endian.Little));\n    b = add32(b, wordAt(str, i + 4, Endian.Little));\n    // the first byte of c is reserved for the length\n    c = add32(c, len);\n    c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n    return mix([a, b, c])[2];\n    var _b;\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction mix(_a) {\n    var a = _a[0], b = _a[1], c = _a[2];\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 13;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 8;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 13;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 12;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 16;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 5;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 3;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 10;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 15;\n    return [a, b, c];\n}\nvar Endian = {};\nEndian.Little = 0;\nEndian.Big = 1;\nEndian[Endian.Little] = \"Little\";\nEndian[Endian.Big] = \"Big\";\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction add32(a, b) {\n    return add32to64(a, b)[1];\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction add32to64(a, b) {\n    var /** @type {?} */ low = (a & 0xffff) + (b & 0xffff);\n    var /** @type {?} */ high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n    return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n/**\n * @param {?} __0\n * @param {?} __1\n * @return {?}\n */\nfunction add64(_a, _b) {\n    var ah = _a[0], al = _a[1];\n    var bh = _b[0], bl = _b[1];\n    var _c = add32to64(al, bl), carry = _c[0], l = _c[1];\n    var /** @type {?} */ h = add32(add32(ah, bh), carry);\n    return [h, l];\n}\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nfunction sub32(a, b) {\n    var /** @type {?} */ low = (a & 0xffff) - (b & 0xffff);\n    var /** @type {?} */ high = (a >> 16) - (b >> 16) + (low >> 16);\n    return (high << 16) | (low & 0xffff);\n}\n/**\n * @param {?} a\n * @param {?} count\n * @return {?}\n */\nfunction rol32(a, count) {\n    return (a << count) | (a >>> (32 - count));\n}\n/**\n * @param {?} __0\n * @param {?} count\n * @return {?}\n */\nfunction rol64(_a, count) {\n    var hi = _a[0], lo = _a[1];\n    var /** @type {?} */ h = (hi << count) | (lo >>> (32 - count));\n    var /** @type {?} */ l = (lo << count) | (hi >>> (32 - count));\n    return [h, l];\n}\n/**\n * @param {?} str\n * @param {?} endian\n * @return {?}\n */\nfunction stringToWords32(str, endian) {\n    var /** @type {?} */ words32 = Array((str.length + 3) >>> 2);\n    for (var /** @type {?} */ i = 0; i < words32.length; i++) {\n        words32[i] = wordAt(str, i * 4, endian);\n    }\n    return words32;\n}\n/**\n * @param {?} str\n * @param {?} index\n * @return {?}\n */\nfunction byteAt(str, index) {\n    return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n}\n/**\n * @param {?} str\n * @param {?} index\n * @param {?} endian\n * @return {?}\n */\nfunction wordAt(str, index, endian) {\n    var /** @type {?} */ word = 0;\n    if (endian === Endian.Big) {\n        for (var /** @type {?} */ i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << (24 - 8 * i);\n        }\n    }\n    else {\n        for (var /** @type {?} */ i = 0; i < 4; i++) {\n            word += byteAt(str, index + i) << 8 * i;\n        }\n    }\n    return word;\n}\n/**\n * @param {?} words32\n * @return {?}\n */\nfunction words32ToByteString(words32) {\n    return words32.reduce(function (str, word) { return str + word32ToByteString(word); }, '');\n}\n/**\n * @param {?} word\n * @return {?}\n */\nfunction word32ToByteString(word) {\n    var /** @type {?} */ str = '';\n    for (var /** @type {?} */ i = 0; i < 4; i++) {\n        str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);\n    }\n    return str;\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction byteStringToHexString(str) {\n    var /** @type {?} */ hex = '';\n    for (var /** @type {?} */ i = 0; i < str.length; i++) {\n        var /** @type {?} */ b = byteAt(str, i);\n        hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n    }\n    return hex.toLowerCase();\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction byteStringToDecString(str) {\n    var /** @type {?} */ decimal = '';\n    var /** @type {?} */ toThePower = '1';\n    for (var /** @type {?} */ i = str.length - 1; i >= 0; i--) {\n        decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n        toThePower = numberTimesBigInt(256, toThePower);\n    }\n    return decimal.split('').reverse().join('');\n}\n/**\n * @param {?} x\n * @param {?} y\n * @return {?}\n */\nfunction addBigInt(x, y) {\n    var /** @type {?} */ sum = '';\n    var /** @type {?} */ len = Math.max(x.length, y.length);\n    for (var /** @type {?} */ i = 0, /** @type {?} */ carry = 0; i < len || carry; i++) {\n        var /** @type {?} */ tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n        if (tmpSum >= 10) {\n            carry = 1;\n            sum += tmpSum - 10;\n        }\n        else {\n            carry = 0;\n            sum += tmpSum;\n        }\n    }\n    return sum;\n}\n/**\n * @param {?} num\n * @param {?} b\n * @return {?}\n */\nfunction numberTimesBigInt(num, b) {\n    var /** @type {?} */ product = '';\n    var /** @type {?} */ bToThePower = b;\n    for (; num !== 0; num = num >>> 1) {\n        if (num & 1)\n            product = addBigInt(product, bToThePower);\n        bToThePower = addBigInt(bToThePower, bToThePower);\n    }\n    return product;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar Serializer = (function () {\n    function Serializer() {\n    }\n    /**\n     * @abstract\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Serializer.prototype.write = function (messages, locale) { };\n    /**\n     * @abstract\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Serializer.prototype.load = function (content, url) { };\n    /**\n     * @abstract\n     * @param {?} message\n     * @return {?}\n     */\n    Serializer.prototype.digest = function (message) { };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Serializer.prototype.createNameMapper = function (message) { return null; };\n    return Serializer;\n}());\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nvar SimplePlaceholderMapper = (function (_super) {\n    __extends(SimplePlaceholderMapper, _super);\n    /**\n     * @param {?} message\n     * @param {?} mapName\n     */\n    function SimplePlaceholderMapper(message, mapName) {\n        var _this = _super.call(this) || this;\n        _this.mapName = mapName;\n        _this.internalToPublic = {};\n        _this.publicToNextId = {};\n        _this.publicToInternal = {};\n        message.nodes.forEach(function (node) { return node.visit(_this); });\n        return _this;\n    }\n    /**\n     * @param {?} internalName\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.toPublicName = function (internalName) {\n        return this.internalToPublic.hasOwnProperty(internalName) ?\n            this.internalToPublic[internalName] :\n            null;\n    };\n    /**\n     * @param {?} publicName\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.toInternalName = function (publicName) {\n        return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n            null;\n    };\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitText = function (text, context) { return null; };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitTagPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.startName);\n        _super.prototype.visitTagPlaceholder.call(this, ph, context);\n        this.visitPlaceholderName(ph.closeName);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitPlaceholder = function (ph, context) { this.visitPlaceholderName(ph.name); };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitIcuPlaceholder = function (ph, context) {\n        this.visitPlaceholderName(ph.name);\n    };\n    /**\n     * @param {?} internalName\n     * @return {?}\n     */\n    SimplePlaceholderMapper.prototype.visitPlaceholderName = function (internalName) {\n        if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n            return;\n        }\n        var /** @type {?} */ publicName = this.mapName(internalName);\n        if (this.publicToInternal.hasOwnProperty(publicName)) {\n            // Create a new XMB when it has already been used\n            var /** @type {?} */ nextId = this.publicToNextId[publicName];\n            this.publicToNextId[publicName] = nextId + 1;\n            publicName = publicName + \"_\" + nextId;\n        }\n        else {\n            this.publicToNextId[publicName] = 1;\n        }\n        this.internalToPublic[internalName] = publicName;\n        this.publicToInternal[publicName] = internalName;\n    };\n    return SimplePlaceholderMapper;\n}(RecurseVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _Visitor$1 = (function () {\n    function _Visitor$1() {\n    }\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitTag = function (tag) {\n        var _this = this;\n        var /** @type {?} */ strAttrs = this._serializeAttributes(tag.attrs);\n        if (tag.children.length == 0) {\n            return \"<\" + tag.name + strAttrs + \"/>\";\n        }\n        var /** @type {?} */ strChildren = tag.children.map(function (node) { return node.visit(_this); });\n        return \"<\" + tag.name + strAttrs + \">\" + strChildren.join('') + \"</\" + tag.name + \">\";\n    };\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitText = function (text) { return text.value; };\n    /**\n     * @param {?} decl\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitDeclaration = function (decl) {\n        return \"<?xml\" + this._serializeAttributes(decl.attrs) + \" ?>\";\n    };\n    /**\n     * @param {?} attrs\n     * @return {?}\n     */\n    _Visitor$1.prototype._serializeAttributes = function (attrs) {\n        var /** @type {?} */ strAttrs = Object.keys(attrs).map(function (name) { return name + \"=\\\"\" + attrs[name] + \"\\\"\"; }).join(' ');\n        return strAttrs.length > 0 ? ' ' + strAttrs : '';\n    };\n    /**\n     * @param {?} doctype\n     * @return {?}\n     */\n    _Visitor$1.prototype.visitDoctype = function (doctype) {\n        return \"<!DOCTYPE \" + doctype.rootTag + \" [\\n\" + doctype.dtd + \"\\n]>\";\n    };\n    return _Visitor$1;\n}());\nvar _visitor = new _Visitor$1();\n/**\n * @param {?} nodes\n * @return {?}\n */\nfunction serialize(nodes) {\n    return nodes.map(function (node) { return node.visit(_visitor); }).join('');\n}\nvar Declaration = (function () {\n    /**\n     * @param {?} unescapedAttrs\n     */\n    function Declaration(unescapedAttrs) {\n        var _this = this;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach(function (k) {\n            _this.attrs[k] = _escapeXml(unescapedAttrs[k]);\n        });\n    }\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Declaration.prototype.visit = function (visitor) { return visitor.visitDeclaration(this); };\n    return Declaration;\n}());\nvar Doctype = (function () {\n    /**\n     * @param {?} rootTag\n     * @param {?} dtd\n     */\n    function Doctype(rootTag, dtd) {\n        this.rootTag = rootTag;\n        this.dtd = dtd;\n    }\n    ;\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Doctype.prototype.visit = function (visitor) { return visitor.visitDoctype(this); };\n    return Doctype;\n}());\nvar Tag = (function () {\n    /**\n     * @param {?} name\n     * @param {?=} unescapedAttrs\n     * @param {?=} children\n     */\n    function Tag(name, unescapedAttrs, children) {\n        if (unescapedAttrs === void 0) { unescapedAttrs = {}; }\n        if (children === void 0) { children = []; }\n        var _this = this;\n        this.name = name;\n        this.children = children;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach(function (k) {\n            _this.attrs[k] = _escapeXml(unescapedAttrs[k]);\n        });\n    }\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Tag.prototype.visit = function (visitor) { return visitor.visitTag(this); };\n    return Tag;\n}());\nvar Text$2 = (function () {\n    /**\n     * @param {?} unescapedValue\n     */\n    function Text$2(unescapedValue) {\n        this.value = _escapeXml(unescapedValue);\n    }\n    ;\n    /**\n     * @param {?} visitor\n     * @return {?}\n     */\n    Text$2.prototype.visit = function (visitor) { return visitor.visitText(this); };\n    return Text$2;\n}());\nvar CR = (function (_super) {\n    __extends(CR, _super);\n    /**\n     * @param {?=} ws\n     */\n    function CR(ws) {\n        if (ws === void 0) { ws = 0; }\n        return _super.call(this, \"\\n\" + new Array(ws + 1).join(' ')) || this;\n    }\n    return CR;\n}(Text$2));\nvar _ESCAPED_CHARS = [\n    [/&/g, '&amp;'],\n    [/\"/g, '&quot;'],\n    [/'/g, '&apos;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;'],\n];\n/**\n * @param {?} text\n * @return {?}\n */\nfunction _escapeXml(text) {\n    return _ESCAPED_CHARS.reduce(function (text, entry) { return text.replace(entry[0], entry[1]); }, text);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _VERSION = '1.2';\nvar _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nvar _DEFAULT_SOURCE_LANG = 'en';\nvar _PLACEHOLDER_TAG = 'x';\nvar _FILE_TAG = 'file';\nvar _SOURCE_TAG = 'source';\nvar _TARGET_TAG = 'target';\nvar _UNIT_TAG = 'trans-unit';\nvar Xliff = (function (_super) {\n    __extends(Xliff, _super);\n    function Xliff() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xliff.prototype.write = function (messages, locale) {\n        var /** @type {?} */ visitor = new _WriteVisitor();\n        var /** @type {?} */ transUnits = [];\n        messages.forEach(function (message) {\n            var /** @type {?} */ transUnit = new Tag(_UNIT_TAG, { id: message.id, datatype: 'html' });\n            transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(8), new Tag(_TARGET_TAG));\n            if (message.description) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$2(message.description)]));\n            }\n            if (message.meaning) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$2(message.meaning)]));\n            }\n            transUnit.children.push(new CR(6));\n            transUnits.push(new CR(6), transUnit);\n        });\n        var /** @type {?} */ body = new Tag('body', {}, transUnits.concat([new CR(4)]));\n        var /** @type {?} */ file = new Tag('file', {\n            'source-language': locale || _DEFAULT_SOURCE_LANG,\n            datatype: 'plaintext',\n            original: 'ng2.template',\n        }, [new CR(4), body, new CR(2)]);\n        var /** @type {?} */ xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xliff.prototype.load = function (content, url) {\n        // xliff to xml nodes\n        var /** @type {?} */ xliffParser = new XliffParser();\n        var _a = xliffParser.parse(content, url), locale = _a.locale, mlNodesByMsgId = _a.mlNodesByMsgId, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var /** @type {?} */ i18nNodesByMsgId = {};\n        var /** @type {?} */ converter = new XmlToI18n();\n        Object.keys(mlNodesByMsgId).forEach(function (msgId) {\n            var _a = converter.convert(mlNodesByMsgId[msgId]), i18nNodes = _a.i18nNodes, e = _a.errors;\n            errors.push.apply(errors, e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(\"xliff parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: locale, i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xliff.prototype.digest = function (message) { return digest(message); };\n    return Xliff;\n}(Serializer));\nvar _WriteVisitor = (function () {\n    function _WriteVisitor() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n        return nodes;\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitIcu = function (icu, context) {\n        if (this._isInIcu) {\n            // nested ICU is not supported\n            throw new Error('xliff does not support nested ICU messages');\n        }\n        this._isInIcu = true;\n        // TODO(vicb): support ICU messages\n        // https://lists.oasis-open.org/archives/xliff/201201/msg00028.html\n        // http://docs.oasis-open.org/xliff/v1.2/xliff-profile-po/xliff-profile-po-1.2-cd02.html\n        var /** @type {?} */ nodes = [];\n        this._isInIcu = false;\n        return nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var /** @type {?} */ ctype = getCtypeForTag(ph.tag);\n        var /** @type {?} */ startTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.startName, ctype: ctype });\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        var /** @type {?} */ closeTagPh = new Tag(_PLACEHOLDER_TAG, { id: ph.closeName, ctype: ctype });\n        return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _WriteVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG, { id: ph.name })];\n    };\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    _WriteVisitor.prototype.serialize = function (nodes) {\n        var _this = this;\n        this._isInIcu = false;\n        return [].concat.apply([], nodes.map(function (node) { return node.visit(_this); }));\n    };\n    return _WriteVisitor;\n}());\nvar XliffParser = (function () {\n    function XliffParser() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xliff\n     * @param {?} url\n     * @return {?}\n     */\n    XliffParser.prototype.parse = function (xliff, url) {\n        this._unitMlNodes = [];\n        this._mlNodesByMsgId = {};\n        var /** @type {?} */ xml = new XmlParser().parse(xliff, url, false);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            mlNodesByMsgId: this._mlNodesByMsgId,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _UNIT_TAG:\n                this._unitMlNodes = null;\n                var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _UNIT_TAG + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ id = idAttr.value;\n                    if (this._mlNodesByMsgId.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (this._unitMlNodes) {\n                            this._mlNodesByMsgId[id] = this._unitMlNodes;\n                        }\n                        else {\n                            this._addError(element, \"Message \" + id + \" misses a translation\");\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG:\n                // ignore source message\n                break;\n            case _TARGET_TAG:\n                this._unitMlNodes = element.children;\n                break;\n            case _FILE_TAG:\n                var /** @type {?} */ localeAttr = element.attrs.find(function (attr) { return attr.name === 'target-language'; });\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                visitAll(this, element.children, null);\n                break;\n            default:\n                // TODO(vicb): assert file structure, xliff version\n                // For now only recurse on unhandled nodes\n                visitAll(this, element.children, null);\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitText = function (text, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitExpansion = function (expansion, context) { };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    XliffParser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XliffParser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XliffParser;\n}());\nvar XmlToI18n = (function () {\n    function XmlToI18n() {\n    }\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    XmlToI18n.prototype.convert = function (nodes) {\n        this._errors = [];\n        return {\n            i18nNodes: visitAll(this, nodes),\n            errors: this._errors,\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitElement = function (el, context) {\n        if (el.name === _PLACEHOLDER_TAG) {\n            var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'id'; });\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, \"<\" + _PLACEHOLDER_TAG + \"> misses the \\\"id\\\" attribute\");\n        }\n        else {\n            this._addError(el, \"Unexpected tag\");\n        }\n    };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitExpansion = function (icu, context) { };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XmlToI18n.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n;\n}());\n/**\n * @param {?} tag\n * @return {?}\n */\nfunction getCtypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n            return 'lb';\n        case 'img':\n            return 'image';\n        default:\n            return \"x-\" + tag;\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _MESSAGES_TAG = 'messagebundle';\nvar _MESSAGE_TAG = 'msg';\nvar _PLACEHOLDER_TAG$1 = 'ph';\nvar _EXEMPLE_TAG = 'ex';\nvar _DOCTYPE = \"<!ELEMENT messagebundle (msg)*>\\n<!ATTLIST messagebundle class CDATA #IMPLIED>\\n\\n<!ELEMENT msg (#PCDATA|ph|source)*>\\n<!ATTLIST msg id CDATA #IMPLIED>\\n<!ATTLIST msg seq CDATA #IMPLIED>\\n<!ATTLIST msg name CDATA #IMPLIED>\\n<!ATTLIST msg desc CDATA #IMPLIED>\\n<!ATTLIST msg meaning CDATA #IMPLIED>\\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\\n<!ATTLIST msg xml:space (default|preserve) \\\"default\\\">\\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\\n\\n<!ELEMENT source (#PCDATA)>\\n\\n<!ELEMENT ph (#PCDATA|ex)*>\\n<!ATTLIST ph name CDATA #REQUIRED>\\n\\n<!ELEMENT ex (#PCDATA)>\";\nvar Xmb = (function (_super) {\n    __extends(Xmb, _super);\n    function Xmb() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xmb.prototype.write = function (messages, locale) {\n        var /** @type {?} */ exampleVisitor = new ExampleVisitor();\n        var /** @type {?} */ visitor = new _Visitor$2();\n        var /** @type {?} */ rootNode = new Tag(_MESSAGES_TAG);\n        messages.forEach(function (message) {\n            var /** @type {?} */ attrs = { id: message.id };\n            if (message.description) {\n                attrs['desc'] = message.description;\n            }\n            if (message.meaning) {\n                attrs['meaning'] = message.meaning;\n            }\n            rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, visitor.serialize(message.nodes)));\n        });\n        rootNode.children.push(new CR());\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }),\n            new CR(),\n            new Doctype(_MESSAGES_TAG, _DOCTYPE),\n            new CR(),\n            exampleVisitor.addDefaultExamples(rootNode),\n            new CR(),\n        ]);\n    };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xmb.prototype.load = function (content, url) {\n        throw new Error('Unsupported');\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xmb.prototype.digest = function (message) { return digest$1(message); };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xmb.prototype.createNameMapper = function (message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    };\n    return Xmb;\n}(Serializer));\nvar _Visitor$2 = (function () {\n    function _Visitor$2() {\n    }\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitText = function (text, context) { return [new Text$2(text.value)]; };\n    /**\n     * @param {?} container\n     * @param {?} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [];\n        container.children.forEach(function (node) { return nodes.push.apply(nodes, node.visit(_this)); });\n        return nodes;\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ nodes = [new Text$2(\"{\" + icu.expressionPlaceholder + \", \" + icu.type + \", \")];\n        Object.keys(icu.cases).forEach(function (c) {\n            nodes.push.apply(nodes, [new Text$2(c + \" {\")].concat(icu.cases[c].visit(_this), [new Text$2(\"} \")]));\n        });\n        nodes.push(new Text$2(\"}\"));\n        return nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitTagPlaceholder = function (ph, context) {\n        var /** @type {?} */ startEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2(\"<\" + ph.tag + \">\")]);\n        var /** @type {?} */ startTagPh = new Tag(_PLACEHOLDER_TAG$1, { name: ph.startName }, [startEx]);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        var /** @type {?} */ closeEx = new Tag(_EXEMPLE_TAG, {}, [new Text$2(\"</\" + ph.tag + \">\")]);\n        var /** @type {?} */ closeTagPh = new Tag(_PLACEHOLDER_TAG$1, { name: ph.closeName }, [closeEx]);\n        return [startTagPh].concat(this.serialize(ph.children), [closeTagPh]);\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$1, { name: ph.name })];\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    _Visitor$2.prototype.visitIcuPlaceholder = function (ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$1, { name: ph.name })];\n    };\n    /**\n     * @param {?} nodes\n     * @return {?}\n     */\n    _Visitor$2.prototype.serialize = function (nodes) {\n        var _this = this;\n        return [].concat.apply([], nodes.map(function (node) { return node.visit(_this); }));\n    };\n    return _Visitor$2;\n}());\n/**\n * @param {?} message\n * @return {?}\n */\nfunction digest$1(message) {\n    return decimalDigest(message);\n}\nvar ExampleVisitor = (function () {\n    function ExampleVisitor() {\n    }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    ExampleVisitor.prototype.addDefaultExamples = function (node) {\n        node.visit(this);\n        return node;\n    };\n    /**\n     * @param {?} tag\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitTag = function (tag) {\n        var _this = this;\n        if (tag.name === _PLACEHOLDER_TAG$1) {\n            if (!tag.children || tag.children.length == 0) {\n                var /** @type {?} */ exText = new Text$2(tag.attrs['name'] || '...');\n                tag.children = [new Tag(_EXEMPLE_TAG, {}, [exText])];\n            }\n        }\n        else if (tag.children) {\n            tag.children.forEach(function (node) { return node.visit(_this); });\n        }\n    };\n    /**\n     * @param {?} text\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitText = function (text) { };\n    /**\n     * @param {?} decl\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitDeclaration = function (decl) { };\n    /**\n     * @param {?} doctype\n     * @return {?}\n     */\n    ExampleVisitor.prototype.visitDoctype = function (doctype) { };\n    return ExampleVisitor;\n}());\n/**\n * @param {?} internalName\n * @return {?}\n */\nfunction toPublicName(internalName) {\n    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _TRANSLATIONS_TAG = 'translationbundle';\nvar _TRANSLATION_TAG = 'translation';\nvar _PLACEHOLDER_TAG$2 = 'ph';\nvar Xtb = (function (_super) {\n    __extends(Xtb, _super);\n    function Xtb() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} messages\n     * @param {?} locale\n     * @return {?}\n     */\n    Xtb.prototype.write = function (messages, locale) { throw new Error('Unsupported'); };\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @return {?}\n     */\n    Xtb.prototype.load = function (content, url) {\n        // xtb to xml nodes\n        var /** @type {?} */ xtbParser = new XtbParser();\n        var _a = xtbParser.parse(content, url), locale = _a.locale, msgIdToHtml = _a.msgIdToHtml, errors = _a.errors;\n        // xml nodes to i18n nodes\n        var /** @type {?} */ i18nNodesByMsgId = {};\n        var /** @type {?} */ converter = new XmlToI18n$1();\n        // Because we should be able to load xtb files that rely on features not supported by angular,\n        // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n        // converted\n        Object.keys(msgIdToHtml).forEach(function (msgId) {\n            var /** @type {?} */ valueFn = function () {\n                var _a = converter.convert(msgIdToHtml[msgId], url), i18nNodes = _a.i18nNodes, errors = _a.errors;\n                if (errors.length) {\n                    throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n                }\n                return i18nNodes;\n            };\n            createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n        });\n        if (errors.length) {\n            throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n        }\n        return { locale: locale, i18nNodesByMsgId: i18nNodesByMsgId };\n    };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xtb.prototype.digest = function (message) { return digest$1(message); };\n    /**\n     * @param {?} message\n     * @return {?}\n     */\n    Xtb.prototype.createNameMapper = function (message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    };\n    return Xtb;\n}(Serializer));\n/**\n * @param {?} messages\n * @param {?} id\n * @param {?} valueFn\n * @return {?}\n */\nfunction createLazyProperty(messages, id, valueFn) {\n    Object.defineProperty(messages, id, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            var /** @type {?} */ value = valueFn();\n            Object.defineProperty(messages, id, { enumerable: true, value: value });\n            return value;\n        },\n        set: function (_) { throw new Error('Could not overwrite an XTB translation'); },\n    });\n}\nvar XtbParser = (function () {\n    function XtbParser() {\n        this._locale = null;\n    }\n    /**\n     * @param {?} xtb\n     * @param {?} url\n     * @return {?}\n     */\n    XtbParser.prototype.parse = function (xtb, url) {\n        this._bundleDepth = 0;\n        this._msgIdToHtml = {};\n        // We can not parse the ICU messages at this point as some messages might not originate\n        // from Angular that could not be lex'd.\n        var /** @type {?} */ xml = new XmlParser().parse(xtb, url, false);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    };\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitElement = function (element, context) {\n        switch (element.name) {\n            case _TRANSLATIONS_TAG:\n                this._bundleDepth++;\n                if (this._bundleDepth > 1) {\n                    this._addError(element, \"<\" + _TRANSLATIONS_TAG + \"> elements can not be nested\");\n                }\n                var /** @type {?} */ langAttr = element.attrs.find(function (attr) { return attr.name === 'lang'; });\n                if (langAttr) {\n                    this._locale = langAttr.value;\n                }\n                visitAll(this, element.children, null);\n                this._bundleDepth--;\n                break;\n            case _TRANSLATION_TAG:\n                var /** @type {?} */ idAttr = element.attrs.find(function (attr) { return attr.name === 'id'; });\n                if (!idAttr) {\n                    this._addError(element, \"<\" + _TRANSLATION_TAG + \"> misses the \\\"id\\\" attribute\");\n                }\n                else {\n                    var /** @type {?} */ id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, \"Duplicated translations for msg \" + id);\n                    }\n                    else {\n                        var /** @type {?} */ innerTextStart = element.startSourceSpan.end.offset;\n                        var /** @type {?} */ innerTextEnd = element.endSourceSpan.start.offset;\n                        var /** @type {?} */ content = element.startSourceSpan.start.file.content;\n                        var /** @type {?} */ innerText = content.slice(innerTextStart, innerTextEnd);\n                        this._msgIdToHtml[id] = innerText;\n                    }\n                }\n                break;\n            default:\n                this._addError(element, 'Unexpected tag');\n        }\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitText = function (text, context) { };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitExpansion = function (expansion, context) { };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    XtbParser.prototype.visitExpansionCase = function (expansionCase, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XtbParser.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XtbParser;\n}());\nvar XmlToI18n$1 = (function () {\n    function XmlToI18n$1() {\n    }\n    /**\n     * @param {?} message\n     * @param {?} url\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.convert = function (message, url) {\n        var /** @type {?} */ xmlIcu = new XmlParser().parse(message, url, true);\n        this._errors = xmlIcu.errors;\n        var /** @type {?} */ i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            visitAll(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitText = function (text, context) { return new Text$1(text.value, text.sourceSpan); };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitExpansion = function (icu, context) {\n        var /** @type {?} */ caseMap = {};\n        visitAll(this, icu.cases).forEach(function (c) {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitExpansionCase = function (icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll(this, icuCase.expression),\n        };\n    };\n    /**\n     * @param {?} el\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitElement = function (el, context) {\n        if (el.name === _PLACEHOLDER_TAG$2) {\n            var /** @type {?} */ nameAttr = el.attrs.find(function (attr) { return attr.name === 'name'; });\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, \"<\" + _PLACEHOLDER_TAG$2 + \"> misses the \\\"name\\\" attribute\");\n        }\n        else {\n            this._addError(el, \"Unexpected tag\");\n        }\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitComment = function (comment, context) { };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    XmlToI18n$1.prototype.visitAttribute = function (attribute, context) { };\n    /**\n     * @param {?} node\n     * @param {?} message\n     * @return {?}\n     */\n    XmlToI18n$1.prototype._addError = function (node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    };\n    return XmlToI18n$1;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar HtmlParser = (function (_super) {\n    __extends(HtmlParser, _super);\n    function HtmlParser() {\n        return _super.call(this, getHtmlTagDefinition) || this;\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    HtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        return _super.prototype.parse.call(this, source, url, parseExpansionForms, interpolationConfig);\n    };\n    return HtmlParser;\n}(Parser$1));\nHtmlParser.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nHtmlParser.ctorParameters = function () { return []; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for translated messages\n */\nvar TranslationBundle = (function () {\n    /**\n     * @param {?=} _i18nNodesByMsgId\n     * @param {?=} locale\n     * @param {?=} digest\n     * @param {?=} mapperFactory\n     * @param {?=} missingTranslationStrategy\n     * @param {?=} console\n     */\n    function TranslationBundle(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console) {\n        if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }\n        if (missingTranslationStrategy === void 0) { missingTranslationStrategy = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_1\" /* MissingTranslationStrategy */].Warning; }\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this.digest = digest;\n        this.mapperFactory = mapperFactory;\n        this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n    }\n    /**\n     * @param {?} content\n     * @param {?} url\n     * @param {?} serializer\n     * @param {?} missingTranslationStrategy\n     * @param {?=} console\n     * @return {?}\n     */\n    TranslationBundle.load = function (content, url, serializer, missingTranslationStrategy, console) {\n        var _a = serializer.load(content, url), locale = _a.locale, i18nNodesByMsgId = _a.i18nNodesByMsgId;\n        var /** @type {?} */ digestFn = function (m) { return serializer.digest(m); };\n        var /** @type {?} */ mapperFactory = function (m) { return serializer.createNameMapper(m); };\n        return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n    };\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    TranslationBundle.prototype.get = function (srcMsg) {\n        var /** @type {?} */ html = this._i18nToHtml.convert(srcMsg);\n        if (html.errors.length) {\n            throw new Error(html.errors.join('\\n'));\n        }\n        return html.nodes;\n    };\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    TranslationBundle.prototype.has = function (srcMsg) { return this.digest(srcMsg) in this._i18nNodesByMsgId; };\n    return TranslationBundle;\n}());\nvar I18nToHtmlVisitor = (function () {\n    /**\n     * @param {?=} _i18nNodesByMsgId\n     * @param {?=} _locale\n     * @param {?=} _digest\n     * @param {?=} _mapperFactory\n     * @param {?=} _missingTranslationStrategy\n     * @param {?=} _console\n     */\n    function I18nToHtmlVisitor(_i18nNodesByMsgId, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n        if (_i18nNodesByMsgId === void 0) { _i18nNodesByMsgId = {}; }\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this._locale = _locale;\n        this._digest = _digest;\n        this._mapperFactory = _mapperFactory;\n        this._missingTranslationStrategy = _missingTranslationStrategy;\n        this._console = _console;\n        this._contextStack = [];\n        this._errors = [];\n    }\n    /**\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.convert = function (srcMsg) {\n        this._contextStack.length = 0;\n        this._errors.length = 0;\n        // i18n to text\n        var /** @type {?} */ text = this._convertToText(srcMsg);\n        // text to html\n        var /** @type {?} */ url = srcMsg.nodes[0].sourceSpan.start.file.url;\n        var /** @type {?} */ html = new HtmlParser().parse(text, url, true);\n        return {\n            nodes: html.rootNodes,\n            errors: this._errors.concat(html.errors),\n        };\n    };\n    /**\n     * @param {?} text\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitText = function (text, context) { return text.value; };\n    /**\n     * @param {?} container\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitContainer = function (container, context) {\n        var _this = this;\n        return container.children.map(function (n) { return n.visit(_this); }).join('');\n    };\n    /**\n     * @param {?} icu\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitIcu = function (icu, context) {\n        var _this = this;\n        var /** @type {?} */ cases = Object.keys(icu.cases).map(function (k) { return k + \" {\" + icu.cases[k].visit(_this) + \"}\"; });\n        // TODO(vicb): Once all format switch to using expression placeholders\n        // we should throw when the placeholder is not in the source message\n        var /** @type {?} */ exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\n            this._srcMsg.placeholders[icu.expression] :\n            icu.expression;\n        return \"{\" + exp + \", \" + icu.type + \", \" + cases.join(' ') + \"}\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitPlaceholder = function (ph, context) {\n        var /** @type {?} */ phName = this._mapper(ph.name);\n        if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n            return this._srcMsg.placeholders[phName];\n        }\n        if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n            return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n        }\n        this._addError(ph, \"Unknown placeholder \\\"\" + ph.name + \"\\\"\");\n        return '';\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n        var _this = this;\n        var /** @type {?} */ tag = \"\" + ph.tag;\n        var /** @type {?} */ attrs = Object.keys(ph.attrs).map(function (name) { return name + \"=\\\"\" + ph.attrs[name] + \"\\\"\"; }).join(' ');\n        if (ph.isVoid) {\n            return \"<\" + tag + \" \" + attrs + \"/>\";\n        }\n        var /** @type {?} */ children = ph.children.map(function (c) { return c.visit(_this); }).join('');\n        return \"<\" + tag + \" \" + attrs + \">\" + children + \"</\" + tag + \">\";\n    };\n    /**\n     * @param {?} ph\n     * @param {?=} context\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n        // An ICU placeholder references the source message to be serialized\n        return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n    };\n    /**\n     * Convert a source message to a translated text string:\n     * - text nodes are replaced with their translation,\n     * - placeholders are replaced with their content,\n     * - ICU nodes are converted to ICU expressions.\n     * @param {?} srcMsg\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype._convertToText = function (srcMsg) {\n        var _this = this;\n        var /** @type {?} */ id = this._digest(srcMsg);\n        var /** @type {?} */ mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n        var /** @type {?} */ nodes;\n        this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });\n        this._srcMsg = srcMsg;\n        if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n            // When there is a translation use its nodes as the source\n            // And create a mapper to convert serialized placeholder names to internal names\n            nodes = this._i18nNodesByMsgId[id];\n            this._mapper = function (name) { return mapper ? mapper.toInternalName(name) : name; };\n        }\n        else {\n            // When no translation has been found\n            // - report an error / a warning / nothing,\n            // - use the nodes from the original message\n            // - placeholders are already internal and need no mapper\n            if (this._missingTranslationStrategy === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_1\" /* MissingTranslationStrategy */].Error) {\n                var /** @type {?} */ ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n                this._addError(srcMsg.nodes[0], \"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n            }\n            else if (this._console &&\n                this._missingTranslationStrategy === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_1\" /* MissingTranslationStrategy */].Warning) {\n                var /** @type {?} */ ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n                this._console.warn(\"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n            }\n            nodes = srcMsg.nodes;\n            this._mapper = function (name) { return name; };\n        }\n        var /** @type {?} */ text = nodes.map(function (node) { return node.visit(_this); }).join('');\n        var /** @type {?} */ context = this._contextStack.pop();\n        this._srcMsg = context.msg;\n        this._mapper = context.mapper;\n        return text;\n    };\n    /**\n     * @param {?} el\n     * @param {?} msg\n     * @return {?}\n     */\n    I18nToHtmlVisitor.prototype._addError = function (el, msg) {\n        this._errors.push(new I18nError(el.sourceSpan, msg));\n    };\n    return I18nToHtmlVisitor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar I18NHtmlParser = (function () {\n    /**\n     * @param {?} _htmlParser\n     * @param {?=} translations\n     * @param {?=} translationsFormat\n     * @param {?=} missingTranslation\n     * @param {?=} console\n     */\n    function I18NHtmlParser(_htmlParser, translations, translationsFormat, missingTranslation, console) {\n        if (missingTranslation === void 0) { missingTranslation = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_1\" /* MissingTranslationStrategy */].Warning; }\n        this._htmlParser = _htmlParser;\n        if (translations) {\n            var serializer = createSerializer(translationsFormat);\n            this._translationBundle =\n                TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n        }\n    }\n    /**\n     * @param {?} source\n     * @param {?} url\n     * @param {?=} parseExpansionForms\n     * @param {?=} interpolationConfig\n     * @return {?}\n     */\n    I18NHtmlParser.prototype.parse = function (source, url, parseExpansionForms, interpolationConfig) {\n        if (parseExpansionForms === void 0) { parseExpansionForms = false; }\n        if (interpolationConfig === void 0) { interpolationConfig = DEFAULT_INTERPOLATION_CONFIG; }\n        var /** @type {?} */ parseResult = this._htmlParser.parse(source, url, parseExpansionForms, interpolationConfig);\n        if (!this._translationBundle) {\n            // Do not enable i18n when no translation bundle is provided\n            return parseResult;\n        }\n        if (parseResult.errors.length) {\n            return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n        }\n        return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\n    };\n    return I18NHtmlParser;\n}());\n/**\n * @param {?=} format\n * @return {?}\n */\nfunction createSerializer(format) {\n    format = (format || 'xlf').toLowerCase();\n    switch (format) {\n        case 'xmb':\n            return new Xmb();\n        case 'xtb':\n            return new Xtb();\n        case 'xliff':\n        case 'xlf':\n        default:\n            return new Xliff();\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CORE = assetUrl('core');\nvar Identifiers = (function () {\n    function Identifiers() {\n    }\n    return Identifiers;\n}());\nIdentifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {\n    name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_2\" /* ANALYZE_FOR_ENTRY_COMPONENTS */]\n};\nIdentifiers.ElementRef = { name: 'ElementRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"K\" /* ElementRef */] };\nIdentifiers.NgModuleRef = { name: 'NgModuleRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"N\" /* NgModuleRef */] };\nIdentifiers.ViewContainerRef = { name: 'ViewContainerRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"P\" /* ViewContainerRef */] };\nIdentifiers.ChangeDetectorRef = { name: 'ChangeDetectorRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"X\" /* ChangeDetectorRef */] };\nIdentifiers.QueryList = { name: 'QueryList', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_3\" /* QueryList */] };\nIdentifiers.TemplateRef = { name: 'TemplateRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Q\" /* TemplateRef */] };\nIdentifiers.CodegenComponentFactoryResolver = {\n    name: 'ɵCodegenComponentFactoryResolver',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_4\" /* ɵCodegenComponentFactoryResolver */]\n};\nIdentifiers.ComponentFactoryResolver = {\n    name: 'ComponentFactoryResolver',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"O\" /* ComponentFactoryResolver */]\n};\nIdentifiers.ComponentFactory = { name: 'ComponentFactory', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_5\" /* ComponentFactory */] };\nIdentifiers.ComponentRef = { name: 'ComponentRef', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_6\" /* ComponentRef */] };\nIdentifiers.NgModuleFactory = { name: 'NgModuleFactory', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_7\" /* NgModuleFactory */] };\nIdentifiers.NgModuleInjector = {\n    name: 'ɵNgModuleInjector',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_8\" /* ɵNgModuleInjector */],\n};\nIdentifiers.RegisterModuleFactoryFn = {\n    name: 'ɵregisterModuleFactory',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_9\" /* ɵregisterModuleFactory */],\n};\nIdentifiers.Injector = { name: 'Injector', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_10\" /* Injector */] };\nIdentifiers.ViewEncapsulation = { name: 'ViewEncapsulation', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */] };\nIdentifiers.ChangeDetectionStrategy = {\n    name: 'ChangeDetectionStrategy',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_0\" /* ChangeDetectionStrategy */]\n};\nIdentifiers.SecurityContext = {\n    name: 'SecurityContext',\n    moduleUrl: CORE,\n    runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */],\n};\nIdentifiers.LOCALE_ID = { name: 'LOCALE_ID', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"E\" /* LOCALE_ID */] };\nIdentifiers.TRANSLATIONS_FORMAT = { name: 'TRANSLATIONS_FORMAT', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_11\" /* TRANSLATIONS_FORMAT */] };\nIdentifiers.inlineInterpolate = { name: 'ɵinlineInterpolate', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_12\" /* ɵinlineInterpolate */] };\nIdentifiers.interpolate = { name: 'ɵinterpolate', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_13\" /* ɵinterpolate */] };\nIdentifiers.EMPTY_ARRAY = { name: 'ɵEMPTY_ARRAY', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_14\" /* ɵEMPTY_ARRAY */] };\nIdentifiers.EMPTY_MAP = { name: 'ɵEMPTY_MAP', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_15\" /* ɵEMPTY_MAP */] };\nIdentifiers.Renderer = { name: 'Renderer', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"L\" /* Renderer */] };\nIdentifiers.viewDef = { name: 'ɵvid', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_16\" /* ɵvid */] };\nIdentifiers.elementDef = { name: 'ɵeld', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_17\" /* ɵeld */] };\nIdentifiers.anchorDef = { name: 'ɵand', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_18\" /* ɵand */] };\nIdentifiers.textDef = { name: 'ɵted', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_19\" /* ɵted */] };\nIdentifiers.directiveDef = { name: 'ɵdid', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_20\" /* ɵdid */] };\nIdentifiers.providerDef = { name: 'ɵprd', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_21\" /* ɵprd */] };\nIdentifiers.queryDef = { name: 'ɵqud', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_22\" /* ɵqud */] };\nIdentifiers.pureArrayDef = { name: 'ɵpad', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_23\" /* ɵpad */] };\nIdentifiers.pureObjectDef = { name: 'ɵpod', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_24\" /* ɵpod */] };\nIdentifiers.purePipeDef = { name: 'ɵppd', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_25\" /* ɵppd */] };\nIdentifiers.pipeDef = { name: 'ɵpid', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_26\" /* ɵpid */] };\nIdentifiers.nodeValue = { name: 'ɵnov', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_27\" /* ɵnov */] };\nIdentifiers.ngContentDef = { name: 'ɵncd', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_28\" /* ɵncd */] };\nIdentifiers.unwrapValue = { name: 'ɵunv', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_29\" /* ɵunv */] };\nIdentifiers.createRendererType2 = { name: 'ɵcrt', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_30\" /* ɵcrt */] };\nIdentifiers.RendererType2 = {\n    name: 'RendererType2',\n    moduleUrl: CORE,\n    // type only\n    runtime: null\n};\nIdentifiers.ViewDefinition = {\n    name: 'ɵViewDefinition',\n    moduleUrl: CORE,\n    // type only\n    runtime: null\n};\nIdentifiers.createComponentFactory = { name: 'ɵccf', moduleUrl: CORE, runtime: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_31\" /* ɵccf */] };\n/**\n * @param {?} pkg\n * @param {?=} path\n * @param {?=} type\n * @return {?}\n */\nfunction assetUrl(pkg, path, type) {\n    if (path === void 0) { path = null; }\n    if (type === void 0) { type = 'src'; }\n    if (path == null) {\n        return \"@angular/\" + pkg;\n    }\n    else {\n        return \"@angular/\" + pkg + \"/\" + type + \"/\" + path;\n    }\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction resolveIdentifier(identifier) {\n    var /** @type {?} */ name = identifier.name;\n    return __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */].resolveIdentifier(name, identifier.moduleUrl, null, identifier.runtime);\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction createIdentifier(identifier) {\n    return { reference: resolveIdentifier(identifier) };\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction identifierToken(identifier) {\n    return { identifier: identifier };\n}\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction createIdentifierToken(identifier) {\n    return identifierToken(createIdentifier(identifier));\n}\n/**\n * @param {?} enumType\n * @param {?} name\n * @return {?}\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// http://cldr.unicode.org/index/cldr-spec/plural-rules\nvar PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];\n/**\n * Expands special forms into elements.\n *\n * For example,\n *\n * ```\n * { messages.length, plural,\n *   =0 {zero}\n *   =1 {one}\n *   other {more than one}\n * }\n * ```\n *\n * will be expanded into\n *\n * ```\n * <ng-container [ngPlural]=\"messages.length\">\n *   <ng-template ngPluralCase=\"=0\">zero</ng-template>\n *   <ng-template ngPluralCase=\"=1\">one</ng-template>\n *   <ng-template ngPluralCase=\"other\">more than one</ng-template>\n * </ng-container>\n * ```\n * @param {?} nodes\n * @return {?}\n */\nfunction expandNodes(nodes) {\n    var /** @type {?} */ expander = new _Expander();\n    return new ExpansionResult(visitAll(expander, nodes), expander.isExpanded, expander.errors);\n}\nvar ExpansionResult = (function () {\n    /**\n     * @param {?} nodes\n     * @param {?} expanded\n     * @param {?} errors\n     */\n    function ExpansionResult(nodes, expanded, errors) {\n        this.nodes = nodes;\n        this.expanded = expanded;\n        this.errors = errors;\n    }\n    return ExpansionResult;\n}());\nvar ExpansionError = (function (_super) {\n    __extends(ExpansionError, _super);\n    /**\n     * @param {?} span\n     * @param {?} errorMsg\n     */\n    function ExpansionError(span, errorMsg) {\n        return _super.call(this, span, errorMsg) || this;\n    }\n    return ExpansionError;\n}(ParseError));\n/**\n * Expand expansion forms (plural, select) to directives\n *\n * \\@internal\n */\nvar _Expander = (function () {\n    function _Expander() {\n        this.isExpanded = false;\n        this.errors = [];\n    }\n    /**\n     * @param {?} element\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitElement = function (element, context) {\n        return new Element(element.name, element.attrs, visitAll(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitAttribute = function (attribute, context) { return attribute; };\n    /**\n     * @param {?} text\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitText = function (text, context) { return text; };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitComment = function (comment, context) { return comment; };\n    /**\n     * @param {?} icu\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitExpansion = function (icu, context) {\n        this.isExpanded = true;\n        return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :\n            _expandDefaultForm(icu, this.errors);\n    };\n    /**\n     * @param {?} icuCase\n     * @param {?} context\n     * @return {?}\n     */\n    _Expander.prototype.visitExpansionCase = function (icuCase, context) {\n        throw new Error('Should not be reached');\n    };\n    return _Expander;\n}());\n/**\n * @param {?} ast\n * @param {?} errors\n * @return {?}\n */\nfunction _expandPluralForm(ast, errors) {\n    var /** @type {?} */ children = ast.cases.map(function (c) {\n        if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\\d+$/)) {\n            errors.push(new ExpansionError(c.valueSourceSpan, \"Plural cases should be \\\"=<number>\\\" or one of \" + PLURAL_CASES.join(\", \")));\n        }\n        var /** @type {?} */ expansionResult = expandNodes(c.expression);\n        errors.push.apply(errors, expansionResult.errors);\n        return new Element(\"ng-template\", [new Attribute$1('ngPluralCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    var /** @type {?} */ switchAttr = new Attribute$1('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);\n    return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n/**\n * @param {?} ast\n * @param {?} errors\n * @return {?}\n */\nfunction _expandDefaultForm(ast, errors) {\n    var /** @type {?} */ children = ast.cases.map(function (c) {\n        var /** @type {?} */ expansionResult = expandNodes(c.expression);\n        errors.push.apply(errors, expansionResult.errors);\n        if (c.value === 'other') {\n            // other is the default case when no values match\n            return new Element(\"ng-template\", [new Attribute$1('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n        }\n        return new Element(\"ng-template\", [new Attribute$1('ngSwitchCase', \"\" + c.value, c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    });\n    var /** @type {?} */ switchAttr = new Attribute$1('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);\n    return new Element('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ProviderError = (function (_super) {\n    __extends(ProviderError, _super);\n    /**\n     * @param {?} message\n     * @param {?} span\n     */\n    function ProviderError(message, span) {\n        return _super.call(this, span, message) || this;\n    }\n    return ProviderError;\n}(ParseError));\nvar ProviderViewContext = (function () {\n    /**\n     * @param {?} component\n     */\n    function ProviderViewContext(component) {\n        var _this = this;\n        this.component = component;\n        this.errors = [];\n        this.viewQueries = _getViewQueries(component);\n        this.viewProviders = new Map();\n        component.viewProviders.forEach(function (provider) {\n            if (_this.viewProviders.get(tokenReference(provider.token)) == null) {\n                _this.viewProviders.set(tokenReference(provider.token), true);\n            }\n        });\n    }\n    return ProviderViewContext;\n}());\nvar ProviderElementContext = (function () {\n    /**\n     * @param {?} viewContext\n     * @param {?} _parent\n     * @param {?} _isViewRoot\n     * @param {?} _directiveAsts\n     * @param {?} attrs\n     * @param {?} refs\n     * @param {?} isTemplate\n     * @param {?} contentQueryStartId\n     * @param {?} _sourceSpan\n     */\n    function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {\n        var _this = this;\n        this.viewContext = viewContext;\n        this._parent = _parent;\n        this._isViewRoot = _isViewRoot;\n        this._directiveAsts = _directiveAsts;\n        this._sourceSpan = _sourceSpan;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._hasViewContainer = false;\n        this._queriedTokens = new Map();\n        this._attrs = {};\n        attrs.forEach(function (attrAst) { return _this._attrs[attrAst.name] = attrAst.value; });\n        var directivesMeta = _directiveAsts.map(function (directiveAst) { return directiveAst.directive; });\n        this._allProviders =\n            _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n        this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._addQueryReadsTo(provider.token, provider.token, _this._queriedTokens);\n        });\n        if (isTemplate) {\n            var templateRefId = createIdentifierToken(Identifiers.TemplateRef);\n            this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n        }\n        refs.forEach(function (refAst) {\n            var defaultQueryValue = refAst.value || createIdentifierToken(Identifiers.ElementRef);\n            _this._addQueryReadsTo({ value: refAst.name }, defaultQueryValue, _this._queriedTokens);\n        });\n        if (this._queriedTokens.get(resolveIdentifier(Identifiers.ViewContainerRef))) {\n            this._hasViewContainer = true;\n        }\n        // create the providers that we know are eager first\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            var eager = provider.eager || _this._queriedTokens.get(tokenReference(provider.token));\n            if (eager) {\n                _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n            }\n        });\n    }\n    /**\n     * @return {?}\n     */\n    ProviderElementContext.prototype.afterElement = function () {\n        var _this = this;\n        // collect lazy providers\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n        });\n    };\n    Object.defineProperty(ProviderElementContext.prototype, \"transformProviders\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return Array.from(this._transformedProviders.values());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"transformedDirectiveAsts\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ sortedProviderTypes = this.transformProviders.map(function (provider) { return provider.token.identifier; });\n            var /** @type {?} */ sortedDirectives = this._directiveAsts.slice();\n            sortedDirectives.sort(function (dir1, dir2) { return sortedProviderTypes.indexOf(dir1.directive.type) -\n                sortedProviderTypes.indexOf(dir2.directive.type); });\n            return sortedDirectives;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"transformedHasViewContainer\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._hasViewContainer; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"queryMatches\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ allMatches = [];\n            this._queriedTokens.forEach(function (matches) { allMatches.push.apply(allMatches, matches); });\n            return allMatches;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} token\n     * @param {?} defaultValue\n     * @param {?} queryReadTokens\n     * @return {?}\n     */\n    ProviderElementContext.prototype._addQueryReadsTo = function (token, defaultValue, queryReadTokens) {\n        this._getQueriesFor(token).forEach(function (query) {\n            var /** @type {?} */ queryValue = query.meta.read || defaultValue;\n            var /** @type {?} */ tokenRef = tokenReference(queryValue);\n            var /** @type {?} */ queryMatches = queryReadTokens.get(tokenRef);\n            if (!queryMatches) {\n                queryMatches = [];\n                queryReadTokens.set(tokenRef, queryMatches);\n            }\n            queryMatches.push({ queryId: query.queryId, value: queryValue });\n        });\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getQueriesFor = function (token) {\n        var /** @type {?} */ result = [];\n        var /** @type {?} */ currentEl = this;\n        var /** @type {?} */ distance = 0;\n        var /** @type {?} */ queries;\n        while (currentEl !== null) {\n            queries = currentEl._contentQueries.get(tokenReference(token));\n            if (queries) {\n                result.push.apply(result, queries.filter(function (query) { return query.meta.descendants || distance <= 1; }));\n            }\n            if (currentEl._directiveAsts.length > 0) {\n                distance++;\n            }\n            currentEl = currentEl._parent;\n        }\n        queries = this.viewContext.viewQueries.get(tokenReference(token));\n        if (queries) {\n            result.push.apply(result, queries);\n        }\n        return result;\n    };\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} token\n     * @param {?} eager\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {\n        var _this = this;\n        var /** @type {?} */ resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider || ((requestingProviderType === ProviderAstType.Directive ||\n            requestingProviderType === ProviderAstType.PublicService) &&\n            resolvedProvider.providerType === ProviderAstType.PrivateService) ||\n            ((requestingProviderType === ProviderAstType.PrivateService ||\n                requestingProviderType === ProviderAstType.PublicService) &&\n                resolvedProvider.providerType === ProviderAstType.Builtin)) {\n            return null;\n        }\n        var /** @type {?} */ transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this.viewContext.errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + tokenName(token), this._sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        var /** @type {?} */ transformedProviders = resolvedProvider.providers.map(function (provider) {\n            var /** @type {?} */ transformedUseValue = provider.useValue;\n            var /** @type {?} */ transformedUseExisting = provider.useExisting;\n            var /** @type {?} */ transformedDeps;\n            if (provider.useExisting != null) {\n                var /** @type {?} */ existingDiDep = _this._getDependency(resolvedProvider.providerType, { token: provider.useExisting }, eager);\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = null;\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });\n            }\n            else if (provider.useClass) {\n                var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(resolvedProvider.providerType, dep, eager); });\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    };\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} dep\n     * @param {?=} eager\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {\n        if (eager === void 0) { eager = null; }\n        if (dep.isAttribute) {\n            var /** @type {?} */ attrValue = this._attrs[dep.token.value];\n            return { isValue: true, value: attrValue == null ? null : attrValue };\n        }\n        if (dep.token != null) {\n            // access builtints\n            if ((requestingProviderType === ProviderAstType.Directive ||\n                requestingProviderType === ProviderAstType.Component)) {\n                if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Renderer) ||\n                    tokenReference(dep.token) === resolveIdentifier(Identifiers.ElementRef) ||\n                    tokenReference(dep.token) === resolveIdentifier(Identifiers.ChangeDetectorRef) ||\n                    tokenReference(dep.token) === resolveIdentifier(Identifiers.TemplateRef)) {\n                    return dep;\n                }\n                if (tokenReference(dep.token) === resolveIdentifier(Identifiers.ViewContainerRef)) {\n                    this._hasViewContainer = true;\n                }\n            }\n            // access the injector\n            if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Injector)) {\n                return dep;\n            }\n            // access providers\n            if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n                return dep;\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {?} requestingProviderType\n     * @param {?} dep\n     * @param {?=} eager\n     * @return {?}\n     */\n    ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {\n        if (eager === void 0) { eager = null; }\n        var /** @type {?} */ currElement = this;\n        var /** @type {?} */ currEager = eager;\n        var /** @type {?} */ result = null;\n        if (!dep.isSkipSelf) {\n            result = this._getLocalDependency(requestingProviderType, dep, eager);\n        }\n        if (dep.isSelf) {\n            if (!result && dep.isOptional) {\n                result = { isValue: true, value: null };\n            }\n        }\n        else {\n            // check parent elements\n            while (!result && currElement._parent) {\n                var /** @type {?} */ prevElement = currElement;\n                currElement = currElement._parent;\n                if (prevElement._isViewRoot) {\n                    currEager = false;\n                }\n                result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\n            }\n            // check @Host restriction\n            if (!result) {\n                if (!dep.isHost || this.viewContext.component.isHost ||\n                    this.viewContext.component.type.reference === tokenReference(dep.token) ||\n                    this.viewContext.viewProviders.get(tokenReference(dep.token)) != null) {\n                    result = dep;\n                }\n                else {\n                    result = dep.isOptional ? result = { isValue: true, value: null } : null;\n                }\n            }\n        }\n        if (!result) {\n            this.viewContext.errors.push(new ProviderError(\"No provider for \" + tokenName(dep.token), this._sourceSpan));\n        }\n        return result;\n    };\n    return ProviderElementContext;\n}());\nvar NgModuleProviderAnalyzer = (function () {\n    /**\n     * @param {?} ngModule\n     * @param {?} extraProviders\n     * @param {?} sourceSpan\n     */\n    function NgModuleProviderAnalyzer(ngModule, extraProviders, sourceSpan) {\n        var _this = this;\n        this._transformedProviders = new Map();\n        this._seenProviders = new Map();\n        this._errors = [];\n        this._allProviders = new Map();\n        ngModule.transitiveModule.modules.forEach(function (ngModuleType) {\n            var ngModuleProvider = { token: { identifier: ngModuleType }, useClass: ngModuleType };\n            _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders);\n        });\n        _resolveProviders(ngModule.transitiveModule.providers.map(function (entry) { return entry.provider; }).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders);\n    }\n    /**\n     * @return {?}\n     */\n    NgModuleProviderAnalyzer.prototype.parse = function () {\n        var _this = this;\n        Array.from(this._allProviders.values()).forEach(function (provider) {\n            _this._getOrCreateLocalProvider(provider.token, provider.eager);\n        });\n        if (this._errors.length > 0) {\n            var /** @type {?} */ errorString = this._errors.join('\\n');\n            throw new Error(\"Provider parse errors:\\n\" + errorString);\n        }\n        return Array.from(this._transformedProviders.values());\n    };\n    /**\n     * @param {?} token\n     * @param {?} eager\n     * @return {?}\n     */\n    NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function (token, eager) {\n        var _this = this;\n        var /** @type {?} */ resolvedProvider = this._allProviders.get(tokenReference(token));\n        if (!resolvedProvider) {\n            return null;\n        }\n        var /** @type {?} */ transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n        if (transformedProviderAst) {\n            return transformedProviderAst;\n        }\n        if (this._seenProviders.get(tokenReference(token)) != null) {\n            this._errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + tokenName(token), resolvedProvider.sourceSpan));\n            return null;\n        }\n        this._seenProviders.set(tokenReference(token), true);\n        var /** @type {?} */ transformedProviders = resolvedProvider.providers.map(function (provider) {\n            var /** @type {?} */ transformedUseValue = provider.useValue;\n            var /** @type {?} */ transformedUseExisting = provider.useExisting;\n            var /** @type {?} */ transformedDeps;\n            if (provider.useExisting != null) {\n                var /** @type {?} */ existingDiDep = _this._getDependency({ token: provider.useExisting }, eager, resolvedProvider.sourceSpan);\n                if (existingDiDep.token != null) {\n                    transformedUseExisting = existingDiDep.token;\n                }\n                else {\n                    transformedUseExisting = null;\n                    transformedUseValue = existingDiDep.value;\n                }\n            }\n            else if (provider.useFactory) {\n                var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n            }\n            else if (provider.useClass) {\n                var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n                transformedDeps =\n                    deps.map(function (dep) { return _this._getDependency(dep, eager, resolvedProvider.sourceSpan); });\n            }\n            return _transformProvider(provider, {\n                useExisting: transformedUseExisting,\n                useValue: transformedUseValue,\n                deps: transformedDeps\n            });\n        });\n        transformedProviderAst =\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n        return transformedProviderAst;\n    };\n    /**\n     * @param {?} dep\n     * @param {?=} eager\n     * @param {?=} requestorSourceSpan\n     * @return {?}\n     */\n    NgModuleProviderAnalyzer.prototype._getDependency = function (dep, eager, requestorSourceSpan) {\n        if (eager === void 0) { eager = null; }\n        var /** @type {?} */ foundLocal = false;\n        if (!dep.isSkipSelf && dep.token != null) {\n            // access the injector\n            if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Injector) ||\n                tokenReference(dep.token) === resolveIdentifier(Identifiers.ComponentFactoryResolver)) {\n                foundLocal = true;\n            }\n            else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n                foundLocal = true;\n            }\n        }\n        var /** @type {?} */ result = dep;\n        if (dep.isSelf && !foundLocal) {\n            if (dep.isOptional) {\n                result = { isValue: true, value: null };\n            }\n            else {\n                this._errors.push(new ProviderError(\"No provider for \" + tokenName(dep.token), requestorSourceSpan));\n            }\n        }\n        return result;\n    };\n    return NgModuleProviderAnalyzer;\n}());\n/**\n * @param {?} provider\n * @param {?} __1\n * @return {?}\n */\nfunction _transformProvider(provider, _a) {\n    var useExisting = _a.useExisting, useValue = _a.useValue, deps = _a.deps;\n    return {\n        token: provider.token,\n        useClass: provider.useClass,\n        useExisting: useExisting,\n        useFactory: provider.useFactory,\n        useValue: useValue,\n        deps: deps,\n        multi: provider.multi\n    };\n}\n/**\n * @param {?} provider\n * @param {?} __1\n * @return {?}\n */\nfunction _transformProviderAst(provider, _a) {\n    var eager = _a.eager, providers = _a.providers;\n    return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan);\n}\n/**\n * @param {?} directives\n * @param {?} sourceSpan\n * @param {?} targetErrors\n * @return {?}\n */\nfunction _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {\n    var /** @type {?} */ providersByToken = new Map();\n    directives.forEach(function (directive) {\n        var /** @type {?} */ dirProvider = { token: { identifier: directive.type }, useClass: directive.type };\n        _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken);\n    });\n    // Note: directives need to be able to overwrite providers of a component!\n    var /** @type {?} */ directivesWithComponentFirst = directives.filter(function (dir) { return dir.isComponent; }).concat(directives.filter(function (dir) { return !dir.isComponent; }));\n    directivesWithComponentFirst.forEach(function (directive) {\n        _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken);\n        _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken);\n    });\n    return providersByToken;\n}\n/**\n * @param {?} providers\n * @param {?} providerType\n * @param {?} eager\n * @param {?} sourceSpan\n * @param {?} targetErrors\n * @param {?} targetProvidersByToken\n * @return {?}\n */\nfunction _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken) {\n    providers.forEach(function (provider) {\n        var /** @type {?} */ resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\n        if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n            targetErrors.push(new ProviderError(\"Mixing multi and non multi provider is not possible for token \" + tokenName(resolvedProvider.token), sourceSpan));\n        }\n        if (!resolvedProvider) {\n            var /** @type {?} */ lifecycleHooks = provider.token.identifier &&\n                ((provider.token.identifier)).lifecycleHooks ?\n                ((provider.token.identifier)).lifecycleHooks :\n                [];\n            var /** @type {?} */ isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n            resolvedProvider = new ProviderAst(provider.token, provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan);\n            targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\n        }\n        else {\n            if (!provider.multi) {\n                resolvedProvider.providers.length = 0;\n            }\n            resolvedProvider.providers.push(provider);\n        }\n    });\n}\n/**\n * @param {?} component\n * @return {?}\n */\nfunction _getViewQueries(component) {\n    // Note: queries start with id 1 so we can use the number in a Bloom filter!\n    var /** @type {?} */ viewQueryId = 1;\n    var /** @type {?} */ viewQueries = new Map();\n    if (component.viewQueries) {\n        component.viewQueries.forEach(function (query) { return _addQueryToTokenMap(viewQueries, { meta: query, queryId: viewQueryId++ }); });\n    }\n    return viewQueries;\n}\n/**\n * @param {?} contentQueryStartId\n * @param {?} directives\n * @return {?}\n */\nfunction _getContentQueries(contentQueryStartId, directives) {\n    var /** @type {?} */ contentQueryId = contentQueryStartId;\n    var /** @type {?} */ contentQueries = new Map();\n    directives.forEach(function (directive, directiveIndex) {\n        if (directive.queries) {\n            directive.queries.forEach(function (query) { return _addQueryToTokenMap(contentQueries, { meta: query, queryId: contentQueryId++ }); });\n        }\n    });\n    return contentQueries;\n}\n/**\n * @param {?} map\n * @param {?} query\n * @return {?}\n */\nfunction _addQueryToTokenMap(map, query) {\n    query.meta.selectors.forEach(function (token) {\n        var /** @type {?} */ entry = map.get(tokenReference(token));\n        if (!entry) {\n            entry = [];\n            map.set(tokenReference(token), entry);\n        }\n        entry.push(query);\n    });\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar ElementSchemaRegistry = (function () {\n    function ElementSchemaRegistry() {\n    }\n    /**\n     * @abstract\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) { };\n    /**\n     * @abstract\n     * @param {?} tagName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) { };\n    /**\n     * @abstract\n     * @param {?} elementName\n     * @param {?} propName\n     * @param {?} isAttribute\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.securityContext = function (elementName, propName, isAttribute) { };\n    /**\n     * @abstract\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.allKnownElementNames = function () { };\n    /**\n     * @abstract\n     * @param {?} propName\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.getMappedPropName = function (propName) { };\n    /**\n     * @abstract\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { };\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.validateProperty = function (name) { };\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.validateAttribute = function (name) { };\n    /**\n     * @abstract\n     * @param {?} propName\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) { };\n    /**\n     * @abstract\n     * @param {?} camelCaseProp\n     * @param {?} userProvidedProp\n     * @param {?} val\n     * @return {?}\n     */\n    ElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) { };\n    return ElementSchemaRegistry;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar StyleWithImports = (function () {\n    /**\n     * @param {?} style\n     * @param {?} styleUrls\n     */\n    function StyleWithImports(style$$1, styleUrls) {\n        this.style = style$$1;\n        this.styleUrls = styleUrls;\n    }\n    return StyleWithImports;\n}());\n/**\n * @param {?} url\n * @return {?}\n */\nfunction isStyleUrlResolvable(url) {\n    if (url == null || url.length === 0 || url[0] == '/')\n        return false;\n    var /** @type {?} */ schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n/**\n * Rewrites stylesheets by resolving and removing the \\@import urls that\n * are either relative or don't have a `package:` scheme\n * @param {?} resolver\n * @param {?} baseUrl\n * @param {?} cssText\n * @return {?}\n */\nfunction extractStyleUrls(resolver, baseUrl, cssText) {\n    var /** @type {?} */ foundUrls = [];\n    var /** @type {?} */ modifiedCssText = cssText.replace(CSS_COMMENT_REGEXP, '').replace(CSS_IMPORT_REGEXP, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var /** @type {?} */ url = m[1] || m[2];\n        if (!isStyleUrlResolvable(url)) {\n            // Do not attempt to resolve non-package absolute URLs with URI scheme\n            return m[0];\n        }\n        foundUrls.push(resolver.resolve(baseUrl, url));\n        return '';\n    });\n    return new StyleWithImports(modifiedCssText, foundUrls);\n}\nvar CSS_IMPORT_REGEXP = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\nvar CSS_COMMENT_REGEXP = /\\/\\*.+?\\*\\//g;\nvar URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar PROPERTY_PARTS_SEPARATOR = '.';\nvar ATTRIBUTE_PREFIX = 'attr';\nvar CLASS_PREFIX = 'class';\nvar STYLE_PREFIX = 'style';\nvar ANIMATE_PROP_PREFIX = 'animate-';\nvar BoundPropertyType = {};\nBoundPropertyType.DEFAULT = 0;\nBoundPropertyType.LITERAL_ATTR = 1;\nBoundPropertyType.ANIMATION = 2;\nBoundPropertyType[BoundPropertyType.DEFAULT] = \"DEFAULT\";\nBoundPropertyType[BoundPropertyType.LITERAL_ATTR] = \"LITERAL_ATTR\";\nBoundPropertyType[BoundPropertyType.ANIMATION] = \"ANIMATION\";\n/**\n * Represents a parsed property.\n */\nvar BoundProperty = (function () {\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} type\n     * @param {?} sourceSpan\n     */\n    function BoundProperty(name, expression, type, sourceSpan) {\n        this.name = name;\n        this.expression = expression;\n        this.type = type;\n        this.sourceSpan = sourceSpan;\n    }\n    Object.defineProperty(BoundProperty.prototype, \"isLiteral\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.type === BoundPropertyType.LITERAL_ATTR; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BoundProperty.prototype, \"isAnimation\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.type === BoundPropertyType.ANIMATION; },\n        enumerable: true,\n        configurable: true\n    });\n    return BoundProperty;\n}());\n/**\n * Parses bindings in templates and in the directive host area.\n */\nvar BindingParser = (function () {\n    /**\n     * @param {?} _exprParser\n     * @param {?} _interpolationConfig\n     * @param {?} _schemaRegistry\n     * @param {?} pipes\n     * @param {?} _targetErrors\n     */\n    function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, _targetErrors) {\n        var _this = this;\n        this._exprParser = _exprParser;\n        this._interpolationConfig = _interpolationConfig;\n        this._schemaRegistry = _schemaRegistry;\n        this._targetErrors = _targetErrors;\n        this.pipesByName = new Map();\n        this._usedPipes = new Map();\n        pipes.forEach(function (pipe) { return _this.pipesByName.set(pipe.name, pipe); });\n    }\n    /**\n     * @return {?}\n     */\n    BindingParser.prototype.getUsedPipes = function () { return Array.from(this._usedPipes.values()); };\n    /**\n     * @param {?} dirMeta\n     * @param {?} elementSelector\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype.createDirectiveHostPropertyAsts = function (dirMeta, elementSelector, sourceSpan) {\n        var _this = this;\n        if (dirMeta.hostProperties) {\n            var /** @type {?} */ boundProps_1 = [];\n            Object.keys(dirMeta.hostProperties).forEach(function (propName) {\n                var /** @type {?} */ expression = dirMeta.hostProperties[propName];\n                if (typeof expression === 'string') {\n                    _this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps_1);\n                }\n                else {\n                    _this._reportError(\"Value of the host property binding \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                }\n            });\n            return boundProps_1.map(function (prop) { return _this.createElementPropertyAst(elementSelector, prop); });\n        }\n    };\n    /**\n     * @param {?} dirMeta\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype.createDirectiveHostEventAsts = function (dirMeta, sourceSpan) {\n        var _this = this;\n        if (dirMeta.hostListeners) {\n            var /** @type {?} */ targetEventAsts_1 = [];\n            Object.keys(dirMeta.hostListeners).forEach(function (propName) {\n                var /** @type {?} */ expression = dirMeta.hostListeners[propName];\n                if (typeof expression === 'string') {\n                    _this.parseEvent(propName, expression, sourceSpan, [], targetEventAsts_1);\n                }\n                else {\n                    _this._reportError(\"Value of the host listener \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n                }\n            });\n            return targetEventAsts_1;\n        }\n    };\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype.parseInterpolation = function (value, sourceSpan) {\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ ast = this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    };\n    /**\n     * @param {?} prefixToken\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @param {?} targetVars\n     * @return {?}\n     */\n    BindingParser.prototype.parseInlineTemplateBinding = function (prefixToken, value, sourceSpan, targetMatchableAttrs, targetProps, targetVars) {\n        var /** @type {?} */ bindings = this._parseTemplateBindings(prefixToken, value, sourceSpan);\n        for (var /** @type {?} */ i = 0; i < bindings.length; i++) {\n            var /** @type {?} */ binding = bindings[i];\n            if (binding.keyIsVar) {\n                targetVars.push(new VariableAst(binding.key, binding.name, sourceSpan));\n            }\n            else if (binding.expression) {\n                this._parsePropertyAst(binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);\n            }\n            else {\n                targetMatchableAttrs.push([binding.key, '']);\n                this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);\n            }\n        }\n    };\n    /**\n     * @param {?} prefixToken\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._parseTemplateBindings = function (prefixToken, value, sourceSpan) {\n        var _this = this;\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ bindingsResult = this._exprParser.parseTemplateBindings(prefixToken, value, sourceInfo);\n            this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n            bindingsResult.templateBindings.forEach(function (binding) {\n                if (binding.expression) {\n                    _this._checkPipes(binding.expression, sourceSpan);\n                }\n            });\n            bindingsResult.warnings.forEach(function (warning) { _this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n            return bindingsResult.templateBindings;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return [];\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype.parseLiteralAttr = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {\n        if (_isAnimationLabel(name)) {\n            name = name.substring(1);\n            if (value) {\n                this._reportError(\"Assigning animation triggers via @prop=\\\"exp\\\" attributes with an expression is invalid.\" +\n                    \" Use property bindings (e.g. [@prop]=\\\"exp\\\") or use an attribute without a value (e.g. @prop) instead.\", sourceSpan, ParseErrorLevel.ERROR);\n            }\n            this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            targetProps.push(new BoundProperty(name, this._exprParser.wrapLiteralPrimitive(value, ''), BoundPropertyType.LITERAL_ATTR, sourceSpan));\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} isHost\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype.parsePropertyBinding = function (name, expression, isHost, sourceSpan, targetMatchableAttrs, targetProps) {\n        var /** @type {?} */ isAnimationProp = false;\n        if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n            isAnimationProp = true;\n            name = name.substring(ANIMATE_PROP_PREFIX.length);\n        }\n        else if (_isAnimationLabel(name)) {\n            isAnimationProp = true;\n            name = name.substring(1);\n        }\n        if (isAnimationProp) {\n            this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            this._parsePropertyAst(name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan, targetMatchableAttrs, targetProps);\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype.parsePropertyInterpolation = function (name, value, sourceSpan, targetMatchableAttrs, targetProps) {\n        var /** @type {?} */ expr = this.parseInterpolation(value, sourceSpan);\n        if (expr) {\n            this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} name\n     * @param {?} ast\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype._parsePropertyAst = function (name, ast, sourceSpan, targetMatchableAttrs, targetProps) {\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new BoundProperty(name, ast, BoundPropertyType.DEFAULT, sourceSpan));\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @return {?}\n     */\n    BindingParser.prototype._parseAnimation = function (name, expression, sourceSpan, targetMatchableAttrs, targetProps) {\n        // This will occur when a @trigger is not paired with an expression.\n        // For animations it is valid to not have an expression since */void\n        // states will be applied by angular when the element is attached/detached\n        var /** @type {?} */ ast = this._parseBinding(expression || 'null', false, sourceSpan);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new BoundProperty(name, ast, BoundPropertyType.ANIMATION, sourceSpan));\n    };\n    /**\n     * @param {?} value\n     * @param {?} isHostBinding\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._parseBinding = function (value, isHostBinding, sourceSpan) {\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ ast = isHostBinding ?\n                this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :\n                this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    };\n    /**\n     * @param {?} elementSelector\n     * @param {?} boundProp\n     * @return {?}\n     */\n    BindingParser.prototype.createElementPropertyAst = function (elementSelector, boundProp) {\n        if (boundProp.isAnimation) {\n            return new BoundElementPropertyAst(boundProp.name, PropertyBindingType.Animation, __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].NONE, boundProp.expression, null, boundProp.sourceSpan);\n        }\n        var /** @type {?} */ unit = null;\n        var /** @type {?} */ bindingType;\n        var /** @type {?} */ boundPropertyName = null;\n        var /** @type {?} */ parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n        var /** @type {?} */ securityContexts;\n        // Check check for special cases (prefix style, attr, class)\n        if (parts.length > 1) {\n            if (parts[0] == ATTRIBUTE_PREFIX) {\n                boundPropertyName = parts[1];\n                this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n                var /** @type {?} */ nsSeparatorIdx = boundPropertyName.indexOf(':');\n                if (nsSeparatorIdx > -1) {\n                    var /** @type {?} */ ns = boundPropertyName.substring(0, nsSeparatorIdx);\n                    var /** @type {?} */ name = boundPropertyName.substring(nsSeparatorIdx + 1);\n                    boundPropertyName = mergeNsAndName(ns, name);\n                }\n                bindingType = PropertyBindingType.Attribute;\n            }\n            else if (parts[0] == CLASS_PREFIX) {\n                boundPropertyName = parts[1];\n                bindingType = PropertyBindingType.Class;\n                securityContexts = [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].NONE];\n            }\n            else if (parts[0] == STYLE_PREFIX) {\n                unit = parts.length > 2 ? parts[2] : null;\n                boundPropertyName = parts[1];\n                bindingType = PropertyBindingType.Style;\n                securityContexts = [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].STYLE];\n            }\n        }\n        // If not a special case, use the full property name\n        if (boundPropertyName === null) {\n            boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);\n            securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, false);\n            bindingType = PropertyBindingType.Property;\n            this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);\n        }\n        return new BoundElementPropertyAst(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan);\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    BindingParser.prototype.parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        if (_isAnimationLabel(name)) {\n            name = name.substr(1);\n            this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);\n        }\n        else {\n            this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    BindingParser.prototype._parseAnimationEvent = function (name, expression, sourceSpan, targetEvents) {\n        var /** @type {?} */ matches = splitAtPeriod(name, [name, '']);\n        var /** @type {?} */ eventName = matches[0];\n        var /** @type {?} */ phase = matches[1].toLowerCase();\n        if (phase) {\n            switch (phase) {\n                case 'start':\n                case 'done':\n                    var /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n                    targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));\n                    break;\n                default:\n                    this._reportError(\"The provided animation output phase value \\\"\" + phase + \"\\\" for \\\"@\" + eventName + \"\\\" is not supported (use start or done)\", sourceSpan);\n                    break;\n            }\n        }\n        else {\n            this._reportError(\"The animation trigger output event (@\" + eventName + \") is missing its phase value name (start or done are currently supported)\", sourceSpan);\n        }\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    BindingParser.prototype._parseEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        // long format: 'target: eventName'\n        var _a = splitAtColon(name, [null, name]), target = _a[0], eventName = _a[1];\n        var /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));\n        // Don't detect directives for event names for now,\n        // so don't add the event name to the matchableAttrs\n    };\n    /**\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._parseAction = function (value, sourceSpan) {\n        var /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n        try {\n            var /** @type {?} */ ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);\n            if (ast) {\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            }\n            if (!ast || ast.ast instanceof EmptyExpr) {\n                this._reportError(\"Empty expressions are not allowed\", sourceSpan);\n                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n            }\n            this._checkPipes(ast, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(\"\" + e, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n        }\n    };\n    /**\n     * @param {?} message\n     * @param {?} sourceSpan\n     * @param {?=} level\n     * @return {?}\n     */\n    BindingParser.prototype._reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    };\n    /**\n     * @param {?} errors\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._reportExpressionParserErrors = function (errors, sourceSpan) {\n        for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\n            var error = errors_1[_i];\n            this._reportError(error.message, sourceSpan);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    BindingParser.prototype._checkPipes = function (ast, sourceSpan) {\n        var _this = this;\n        if (ast) {\n            var /** @type {?} */ collector = new PipeCollector();\n            ast.visit(collector);\n            collector.pipes.forEach(function (ast, pipeName) {\n                var /** @type {?} */ pipeMeta = _this.pipesByName.get(pipeName);\n                if (!pipeMeta) {\n                    _this._reportError(\"The pipe '\" + pipeName + \"' could not be found\", new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n                }\n                else {\n                    _this._usedPipes.set(pipeName, pipeMeta);\n                }\n            });\n        }\n    };\n    /**\n     * @param {?} propName the name of the property / attribute\n     * @param {?} sourceSpan\n     * @param {?} isAttr true when binding to an attribute\n     * @return {?}\n     */\n    BindingParser.prototype._validatePropertyOrAttributeName = function (propName, sourceSpan, isAttr) {\n        var /** @type {?} */ report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n            this._schemaRegistry.validateProperty(propName);\n        if (report.error) {\n            this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);\n        }\n    };\n    return BindingParser;\n}());\nvar PipeCollector = (function (_super) {\n    __extends(PipeCollector, _super);\n    function PipeCollector() {\n        var _this = _super.apply(this, arguments) || this;\n        _this.pipes = new Map();\n        return _this;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    PipeCollector.prototype.visitPipe = function (ast, context) {\n        this.pipes.set(ast.name, ast);\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    };\n    return PipeCollector;\n}(RecursiveAstVisitor));\n/**\n * @param {?} name\n * @return {?}\n */\nfunction _isAnimationLabel(name) {\n    return name[0] == '@';\n}\n/**\n * @param {?} registry\n * @param {?} selector\n * @param {?} propName\n * @param {?} isAttribute\n * @return {?}\n */\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n    var /** @type {?} */ ctxs = [];\n    CssSelector.parse(selector).forEach(function (selector) {\n        var /** @type {?} */ elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n        var /** @type {?} */ notElementNames = new Set(selector.notSelectors.filter(function (selector) { return selector.isElementSelector(); })\n            .map(function (selector) { return selector.element; }));\n        var /** @type {?} */ possibleElementNames = elementNames.filter(function (elementName) { return !notElementNames.has(elementName); });\n        ctxs.push.apply(ctxs, possibleElementNames.map(function (elementName) { return registry.securityContext(elementName, propName, isAttribute); }));\n    });\n    return ctxs.length === 0 ? [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].NONE] : Array.from(new Set(ctxs)).sort();\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar NG_CONTENT_SELECT_ATTR = 'select';\nvar NG_CONTENT_ELEMENT = 'ng-content';\nvar LINK_ELEMENT = 'link';\nvar LINK_STYLE_REL_ATTR = 'rel';\nvar LINK_STYLE_HREF_ATTR = 'href';\nvar LINK_STYLE_REL_VALUE = 'stylesheet';\nvar STYLE_ELEMENT = 'style';\nvar SCRIPT_ELEMENT = 'script';\nvar NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nvar NG_PROJECT_AS = 'ngProjectAs';\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction preparseElement(ast) {\n    var /** @type {?} */ selectAttr = null;\n    var /** @type {?} */ hrefAttr = null;\n    var /** @type {?} */ relAttr = null;\n    var /** @type {?} */ nonBindable = false;\n    var /** @type {?} */ projectAs = null;\n    ast.attrs.forEach(function (attr) {\n        var /** @type {?} */ lcAttrName = attr.name.toLowerCase();\n        if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n            selectAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n            hrefAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n            relAttr = attr.value;\n        }\n        else if (attr.name == NG_NON_BINDABLE_ATTR) {\n            nonBindable = true;\n        }\n        else if (attr.name == NG_PROJECT_AS) {\n            if (attr.value.length > 0) {\n                projectAs = attr.value;\n            }\n        }\n    });\n    selectAttr = normalizeNgContentSelect(selectAttr);\n    var /** @type {?} */ nodeName = ast.name.toLowerCase();\n    var /** @type {?} */ type = PreparsedElementType.OTHER;\n    if (splitNsName(nodeName)[1] == NG_CONTENT_ELEMENT) {\n        type = PreparsedElementType.NG_CONTENT;\n    }\n    else if (nodeName == STYLE_ELEMENT) {\n        type = PreparsedElementType.STYLE;\n    }\n    else if (nodeName == SCRIPT_ELEMENT) {\n        type = PreparsedElementType.SCRIPT;\n    }\n    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n        type = PreparsedElementType.STYLESHEET;\n    }\n    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\nvar PreparsedElementType = {};\nPreparsedElementType.NG_CONTENT = 0;\nPreparsedElementType.STYLE = 1;\nPreparsedElementType.STYLESHEET = 2;\nPreparsedElementType.SCRIPT = 3;\nPreparsedElementType.OTHER = 4;\nPreparsedElementType[PreparsedElementType.NG_CONTENT] = \"NG_CONTENT\";\nPreparsedElementType[PreparsedElementType.STYLE] = \"STYLE\";\nPreparsedElementType[PreparsedElementType.STYLESHEET] = \"STYLESHEET\";\nPreparsedElementType[PreparsedElementType.SCRIPT] = \"SCRIPT\";\nPreparsedElementType[PreparsedElementType.OTHER] = \"OTHER\";\nvar PreparsedElement = (function () {\n    /**\n     * @param {?} type\n     * @param {?} selectAttr\n     * @param {?} hrefAttr\n     * @param {?} nonBindable\n     * @param {?} projectAs\n     */\n    function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n        this.type = type;\n        this.selectAttr = selectAttr;\n        this.hrefAttr = hrefAttr;\n        this.nonBindable = nonBindable;\n        this.projectAs = projectAs;\n    }\n    return PreparsedElement;\n}());\n/**\n * @param {?} selectAttr\n * @return {?}\n */\nfunction normalizeNgContentSelect(selectAttr) {\n    if (selectAttr === null || selectAttr.length === 0) {\n        return '*';\n    }\n    return selectAttr;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n// Group 1 = \"bind-\"\nvar KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nvar KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nvar KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nvar KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nvar KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nvar KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nvar IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nvar IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nvar IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nvar IDENT_EVENT_IDX = 10;\nvar NG_TEMPLATE_ELEMENT = 'ng-template';\n// deprecated in 4.x\nvar TEMPLATE_ELEMENT = 'template';\n// deprecated in 4.x\nvar TEMPLATE_ATTR = 'template';\nvar TEMPLATE_ATTR_PREFIX = '*';\nvar CLASS_ATTR = 'class';\nvar TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\nvar TEMPLATE_ELEMENT_DEPRECATION_WARNING = 'The <template> element is deprecated. Use <ng-template> instead';\nvar TEMPLATE_ATTR_DEPRECATION_WARNING = 'The template attribute is deprecated. Use an ng-template element instead.';\nvar warningCounts = {};\n/**\n * @param {?} warnings\n * @return {?}\n */\nfunction warnOnlyOnce(warnings) {\n    return function (error) {\n        if (warnings.indexOf(error.msg) !== -1) {\n            warningCounts[error.msg] = (warningCounts[error.msg] || 0) + 1;\n            return warningCounts[error.msg] <= 1;\n        }\n        return true;\n    };\n}\n/**\n * Provides an array of {@link TemplateAstVisitor}s which will be used to transform\n * parsed templates before compilation is invoked, allowing custom expression syntax\n * and other advanced transformations.\n *\n * This is currently an internal-only feature and not meant for general use.\n */\nvar TEMPLATE_TRANSFORMS = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"d\" /* InjectionToken */]('TemplateTransforms');\nvar TemplateParseError = (function (_super) {\n    __extends(TemplateParseError, _super);\n    /**\n     * @param {?} message\n     * @param {?} span\n     * @param {?} level\n     */\n    function TemplateParseError(message, span, level) {\n        return _super.call(this, span, message, level) || this;\n    }\n    return TemplateParseError;\n}(ParseError));\nvar TemplateParseResult = (function () {\n    /**\n     * @param {?=} templateAst\n     * @param {?=} usedPipes\n     * @param {?=} errors\n     */\n    function TemplateParseResult(templateAst, usedPipes, errors) {\n        this.templateAst = templateAst;\n        this.usedPipes = usedPipes;\n        this.errors = errors;\n    }\n    return TemplateParseResult;\n}());\nvar TemplateParser = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _exprParser\n     * @param {?} _schemaRegistry\n     * @param {?} _htmlParser\n     * @param {?} _console\n     * @param {?} transforms\n     */\n    function TemplateParser(_config, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {\n        this._config = _config;\n        this._exprParser = _exprParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._htmlParser = _htmlParser;\n        this._console = _console;\n        this.transforms = transforms;\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @param {?} templateUrl\n     * @return {?}\n     */\n    TemplateParser.prototype.parse = function (component, template, directives, pipes, schemas, templateUrl) {\n        var /** @type {?} */ result = this.tryParse(component, template, directives, pipes, schemas, templateUrl);\n        var /** @type {?} */ warnings = result.errors.filter(function (error) { return error.level === ParseErrorLevel.WARNING; }).filter(warnOnlyOnce([\n            TEMPLATE_ATTR_DEPRECATION_WARNING, TEMPLATE_ELEMENT_DEPRECATION_WARNING\n        ]));\n        var /** @type {?} */ errors = result.errors.filter(function (error) { return error.level === ParseErrorLevel.ERROR; });\n        if (warnings.length > 0) {\n            this._console.warn(\"Template parse warnings:\\n\" + warnings.join('\\n'));\n        }\n        if (errors.length > 0) {\n            var /** @type {?} */ errorString = errors.join('\\n');\n            throw syntaxError(\"Template parse errors:\\n\" + errorString);\n        }\n        return { template: result.templateAst, pipes: result.usedPipes };\n    };\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @param {?} templateUrl\n     * @return {?}\n     */\n    TemplateParser.prototype.tryParse = function (component, template, directives, pipes, schemas, templateUrl) {\n        return this.tryParseHtml(this.expandHtml(this._htmlParser.parse(template, templateUrl, true, this.getInterpolationConfig(component))), component, template, directives, pipes, schemas, templateUrl);\n    };\n    /**\n     * @param {?} htmlAstWithErrors\n     * @param {?} component\n     * @param {?} template\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} schemas\n     * @param {?} templateUrl\n     * @return {?}\n     */\n    TemplateParser.prototype.tryParseHtml = function (htmlAstWithErrors, component, template, directives, pipes, schemas, templateUrl) {\n        var /** @type {?} */ result;\n        var /** @type {?} */ errors = htmlAstWithErrors.errors;\n        var /** @type {?} */ usedPipes = [];\n        if (htmlAstWithErrors.rootNodes.length > 0) {\n            var /** @type {?} */ uniqDirectives = removeSummaryDuplicates(directives);\n            var /** @type {?} */ uniqPipes = removeSummaryDuplicates(pipes);\n            var /** @type {?} */ providerViewContext = new ProviderViewContext(component);\n            var /** @type {?} */ interpolationConfig = void 0;\n            if (component.template && component.template.interpolation) {\n                interpolationConfig = {\n                    start: component.template.interpolation[0],\n                    end: component.template.interpolation[1]\n                };\n            }\n            var /** @type {?} */ bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);\n            var /** @type {?} */ parseVisitor = new TemplateParseVisitor(this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);\n            result = visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n            errors.push.apply(errors, providerViewContext.errors);\n            usedPipes.push.apply(usedPipes, bindingParser.getUsedPipes());\n        }\n        else {\n            result = [];\n        }\n        this._assertNoReferenceDuplicationOnTemplate(result, errors);\n        if (errors.length > 0) {\n            return new TemplateParseResult(result, usedPipes, errors);\n        }\n        if (this.transforms) {\n            this.transforms.forEach(function (transform) { result = templateVisitAll(transform, result); });\n        }\n        return new TemplateParseResult(result, usedPipes, errors);\n    };\n    /**\n     * @param {?} htmlAstWithErrors\n     * @param {?=} forced\n     * @return {?}\n     */\n    TemplateParser.prototype.expandHtml = function (htmlAstWithErrors, forced) {\n        if (forced === void 0) { forced = false; }\n        var /** @type {?} */ errors = htmlAstWithErrors.errors;\n        if (errors.length == 0 || forced) {\n            // Transform ICU messages to angular directives\n            var /** @type {?} */ expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n            errors.push.apply(errors, expandedHtmlAst.errors);\n            htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n        }\n        return htmlAstWithErrors;\n    };\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    TemplateParser.prototype.getInterpolationConfig = function (component) {\n        if (component.template) {\n            return InterpolationConfig.fromArray(component.template.interpolation);\n        }\n    };\n    /**\n     * \\@internal\n     * @param {?} result\n     * @param {?} errors\n     * @return {?}\n     */\n    TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function (result, errors) {\n        var /** @type {?} */ existingReferences = [];\n        result.filter(function (element) { return !!((element)).references; })\n            .forEach(function (element) { return ((element)).references.forEach(function (reference) {\n            var /** @type {?} */ name = reference.name;\n            if (existingReferences.indexOf(name) < 0) {\n                existingReferences.push(name);\n            }\n            else {\n                var /** @type {?} */ error = new TemplateParseError(\"Reference \\\"#\" + name + \"\\\" is defined several times\", reference.sourceSpan, ParseErrorLevel.ERROR);\n                errors.push(error);\n            }\n        }); });\n    };\n    return TemplateParser;\n}());\nTemplateParser.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nTemplateParser.ctorParameters = function () { return [\n    { type: CompilerConfig, },\n    { type: Parser, },\n    { type: ElementSchemaRegistry, },\n    { type: I18NHtmlParser, },\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */], },\n    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */] }, { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */], args: [TEMPLATE_TRANSFORMS,] },] },\n]; };\nvar TemplateParseVisitor = (function () {\n    /**\n     * @param {?} config\n     * @param {?} providerViewContext\n     * @param {?} directives\n     * @param {?} _bindingParser\n     * @param {?} _schemaRegistry\n     * @param {?} _schemas\n     * @param {?} _targetErrors\n     */\n    function TemplateParseVisitor(config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {\n        var _this = this;\n        this.config = config;\n        this.providerViewContext = providerViewContext;\n        this._bindingParser = _bindingParser;\n        this._schemaRegistry = _schemaRegistry;\n        this._schemas = _schemas;\n        this._targetErrors = _targetErrors;\n        this.selectorMatcher = new SelectorMatcher();\n        this.directivesIndex = new Map();\n        this.ngContentCount = 0;\n        // Note: queries start with id 1 so we can use the number in a Bloom filter!\n        this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n        directives.forEach(function (directive, index) {\n            var selector = CssSelector.parse(directive.selector);\n            _this.selectorMatcher.addSelectables(selector, directive);\n            _this.directivesIndex.set(directive, index);\n        });\n    }\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitExpansion = function (expansion, context) { return null; };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return null; };\n    /**\n     * @param {?} text\n     * @param {?} parent\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitText = function (text, parent) {\n        var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);\n        var /** @type {?} */ expr = this._bindingParser.parseInterpolation(text.value, text.sourceSpan);\n        return expr ? new BoundTextAst(expr, ngContentIndex, text.sourceSpan) :\n            new TextAst(text.value, ngContentIndex, text.sourceSpan);\n    };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitAttribute = function (attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitComment = function (comment, context) { return null; };\n    /**\n     * @param {?} element\n     * @param {?} parent\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype.visitElement = function (element, parent) {\n        var _this = this;\n        var /** @type {?} */ queryStartIndex = this.contentQueryStartId;\n        var /** @type {?} */ nodeName = element.name;\n        var /** @type {?} */ preparsedElement = preparseElement(element);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE) {\n            // Skipping <script> for security reasons\n            // Skipping <style> as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n            // Skipping stylesheets with either relative urls or package scheme as we already processed\n            // them in the StyleCompiler\n            return null;\n        }\n        var /** @type {?} */ matchableAttrs = [];\n        var /** @type {?} */ elementOrDirectiveProps = [];\n        var /** @type {?} */ elementOrDirectiveRefs = [];\n        var /** @type {?} */ elementVars = [];\n        var /** @type {?} */ events = [];\n        var /** @type {?} */ templateElementOrDirectiveProps = [];\n        var /** @type {?} */ templateMatchableAttrs = [];\n        var /** @type {?} */ templateElementVars = [];\n        var /** @type {?} */ hasInlineTemplates = false;\n        var /** @type {?} */ attrs = [];\n        var /** @type {?} */ isTemplateElement = isTemplate(element, this.config.enableLegacyTemplate, function (m, span) { return _this._reportError(m, span, ParseErrorLevel.WARNING); });\n        element.attrs.forEach(function (attr) {\n            var /** @type {?} */ hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);\n            var /** @type {?} */ templateBindingsSource;\n            var /** @type {?} */ prefixToken;\n            var /** @type {?} */ normalizedName = _this._normalizeAttributeName(attr.name);\n            if (_this.config.enableLegacyTemplate && normalizedName == TEMPLATE_ATTR) {\n                _this._reportError(TEMPLATE_ATTR_DEPRECATION_WARNING, attr.sourceSpan, ParseErrorLevel.WARNING);\n                templateBindingsSource = attr.value;\n            }\n            else if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n                templateBindingsSource = attr.value;\n                prefixToken = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length) + ':';\n            }\n            var /** @type {?} */ hasTemplateBinding = templateBindingsSource != null;\n            if (hasTemplateBinding) {\n                if (hasInlineTemplates) {\n                    _this._reportError(\"Can't have multiple template bindings on one element. Use only one attribute named 'template' or prefixed with *\", attr.sourceSpan);\n                }\n                hasInlineTemplates = true;\n                _this._bindingParser.parseInlineTemplateBinding(prefixToken, templateBindingsSource, attr.sourceSpan, templateMatchableAttrs, templateElementOrDirectiveProps, templateElementVars);\n            }\n            if (!hasBinding && !hasTemplateBinding) {\n                // don't include the bindings as attributes as well in the AST\n                attrs.push(_this.visitAttribute(attr, null));\n                matchableAttrs.push([attr.name, attr.value]);\n            }\n        });\n        var /** @type {?} */ elementCssSelector = createElementCssSelector(nodeName, matchableAttrs);\n        var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector), directiveMetas = _a.directives, matchElement = _a.matchElement;\n        var /** @type {?} */ references = [];\n        var /** @type {?} */ boundDirectivePropNames = new Set();\n        var /** @type {?} */ directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);\n        var /** @type {?} */ elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);\n        var /** @type {?} */ isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n        var /** @type {?} */ providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, element.sourceSpan);\n        var /** @type {?} */ children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));\n        providerContext.afterElement();\n        // Override the actual selector when the `ngProjectAs` attribute is provided\n        var /** @type {?} */ projectionSelector = preparsedElement.projectAs != null ?\n            CssSelector.parse(preparsedElement.projectAs)[0] :\n            elementCssSelector;\n        var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(projectionSelector);\n        var /** @type {?} */ parsedElement;\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n            if (element.children && !element.children.every(_isEmptyTextNode)) {\n                this._reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n            }\n            parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n        }\n        else if (isTemplateElement) {\n            this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n            this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);\n            parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n        }\n        else {\n            this._assertElementExists(matchElement, element);\n            this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);\n            var /** @type {?} */ ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n            parsedElement = new ElementAst(nodeName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan, element.endSourceSpan);\n        }\n        if (hasInlineTemplates) {\n            var /** @type {?} */ templateQueryStartIndex = this.contentQueryStartId;\n            var /** @type {?} */ templateSelector = createElementCssSelector(TEMPLATE_ELEMENT, templateMatchableAttrs);\n            var templateDirectiveMetas = this._parseDirectives(this.selectorMatcher, templateSelector).directives;\n            var /** @type {?} */ templateBoundDirectivePropNames = new Set();\n            var /** @type {?} */ templateDirectiveAsts = this._createDirectiveAsts(true, element.name, templateDirectiveMetas, templateElementOrDirectiveProps, [], element.sourceSpan, [], templateBoundDirectivePropNames);\n            var /** @type {?} */ templateElementProps = this._createElementPropertyAsts(element.name, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);\n            var /** @type {?} */ templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);\n            templateProviderContext.afterElement();\n            parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, element.sourceSpan);\n        }\n        return parsedElement;\n    };\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} attr\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetProps\n     * @param {?} targetEvents\n     * @param {?} targetRefs\n     * @param {?} targetVars\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {\n        var /** @type {?} */ name = this._normalizeAttributeName(attr.name);\n        var /** @type {?} */ value = attr.value;\n        var /** @type {?} */ srcSpan = attr.sourceSpan;\n        var /** @type {?} */ bindParts = name.match(BIND_NAME_REGEXP);\n        var /** @type {?} */ hasBinding = false;\n        if (bindParts !== null) {\n            hasBinding = true;\n            if (bindParts[KW_BIND_IDX] != null) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[KW_LET_IDX]) {\n                if (isTemplateElement) {\n                    var /** @type {?} */ identifier = bindParts[IDENT_KW_IDX];\n                    this._parseVariable(identifier, value, srcSpan, targetVars);\n                }\n                else {\n                    this._reportError(\"\\\"let-\\\" is only supported on template elements.\", srcSpan);\n                }\n            }\n            else if (bindParts[KW_REF_IDX]) {\n                var /** @type {?} */ identifier = bindParts[IDENT_KW_IDX];\n                this._parseReference(identifier, value, srcSpan, targetRefs);\n            }\n            else if (bindParts[KW_ON_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[KW_BINDON_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[KW_AT_IDX]) {\n                this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n                this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n            else if (bindParts[IDENT_PROPERTY_IDX]) {\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n            }\n            else if (bindParts[IDENT_EVENT_IDX]) {\n                this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, targetMatchableAttrs, targetEvents);\n            }\n        }\n        else {\n            hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, targetMatchableAttrs, targetProps);\n        }\n        if (!hasBinding) {\n            this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n        }\n        return hasBinding;\n    };\n    /**\n     * @param {?} attrName\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {\n        return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n    };\n    /**\n     * @param {?} identifier\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetVars\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n        }\n        targetVars.push(new VariableAst(identifier, value, sourceSpan));\n    };\n    /**\n     * @param {?} identifier\n     * @param {?} value\n     * @param {?} sourceSpan\n     * @param {?} targetRefs\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {\n        if (identifier.indexOf('-') > -1) {\n            this._reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n        }\n        targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n    };\n    /**\n     * @param {?} name\n     * @param {?} expression\n     * @param {?} sourceSpan\n     * @param {?} targetMatchableAttrs\n     * @param {?} targetEvents\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, targetMatchableAttrs, targetEvents) {\n        this._bindingParser.parseEvent(name + \"Change\", expression + \"=$event\", sourceSpan, targetMatchableAttrs, targetEvents);\n    };\n    /**\n     * @param {?} selectorMatcher\n     * @param {?} elementCssSelector\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {\n        var _this = this;\n        // Need to sort the directives so that we get consistent results throughout,\n        // as selectorMatcher uses Maps inside.\n        // Also deduplicate directives as they might match more than one time!\n        var /** @type {?} */ directives = new Array(this.directivesIndex.size);\n        // Whether any directive selector matches on the element name\n        var /** @type {?} */ matchElement = false;\n        selectorMatcher.match(elementCssSelector, function (selector, directive) {\n            directives[_this.directivesIndex.get(directive)] = directive;\n            matchElement = matchElement || selector.hasElementSelector();\n        });\n        return {\n            directives: directives.filter(function (dir) { return !!dir; }),\n            matchElement: matchElement,\n        };\n    };\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} elementName\n     * @param {?} directives\n     * @param {?} props\n     * @param {?} elementOrDirectiveRefs\n     * @param {?} elementSourceSpan\n     * @param {?} targetReferences\n     * @param {?} targetBoundDirectivePropNames\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {\n        var _this = this;\n        var /** @type {?} */ matchedReferences = new Set();\n        var /** @type {?} */ component = null;\n        var /** @type {?} */ directiveAsts = directives.map(function (directive) {\n            var /** @type {?} */ sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, \"Directive \" + identifierName(directive.type));\n            if (directive.isComponent) {\n                component = directive;\n            }\n            var /** @type {?} */ directiveProperties = [];\n            var /** @type {?} */ hostProperties = _this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan);\n            // Note: We need to check the host properties here as well,\n            // as we don't know the element name in the DirectiveWrapperCompiler yet.\n            hostProperties = _this._checkPropertiesInSchema(elementName, hostProperties);\n            var /** @type {?} */ hostEvents = _this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);\n            _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n            elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n                if ((elOrDirRef.value.length === 0 && directive.isComponent) ||\n                    (directive.exportAs == elOrDirRef.value)) {\n                    targetReferences.push(new ReferenceAst(elOrDirRef.name, identifierToken(directive.type), elOrDirRef.sourceSpan));\n                    matchedReferences.add(elOrDirRef.name);\n                }\n            });\n            var /** @type {?} */ contentQueryStartId = _this.contentQueryStartId;\n            _this.contentQueryStartId += directive.queries.length;\n            return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);\n        });\n        elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n            if (elOrDirRef.value.length > 0) {\n                if (!matchedReferences.has(elOrDirRef.name)) {\n                    _this._reportError(\"There is no directive with \\\"exportAs\\\" set to \\\"\" + elOrDirRef.value + \"\\\"\", elOrDirRef.sourceSpan);\n                }\n            }\n            else if (!component) {\n                var /** @type {?} */ refToken = null;\n                if (isTemplateElement) {\n                    refToken = createIdentifierToken(Identifiers.TemplateRef);\n                }\n                targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.sourceSpan));\n            }\n        });\n        return directiveAsts;\n    };\n    /**\n     * @param {?} directiveProperties\n     * @param {?} boundProps\n     * @param {?} targetBoundDirectiveProps\n     * @param {?} targetBoundDirectivePropNames\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {\n        if (directiveProperties) {\n            var /** @type {?} */ boundPropsByName_1 = new Map();\n            boundProps.forEach(function (boundProp) {\n                var /** @type {?} */ prevValue = boundPropsByName_1.get(boundProp.name);\n                if (!prevValue || prevValue.isLiteral) {\n                    // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n                    boundPropsByName_1.set(boundProp.name, boundProp);\n                }\n            });\n            Object.keys(directiveProperties).forEach(function (dirProp) {\n                var /** @type {?} */ elProp = directiveProperties[dirProp];\n                var /** @type {?} */ boundProp = boundPropsByName_1.get(elProp);\n                // Bindings are optional, so this binding only needs to be set up if an expression is given.\n                if (boundProp) {\n                    targetBoundDirectivePropNames.add(boundProp.name);\n                    if (!isEmptyExpression(boundProp.expression)) {\n                        targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n                    }\n                }\n            });\n        }\n    };\n    /**\n     * @param {?} elementName\n     * @param {?} props\n     * @param {?} boundDirectivePropNames\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, boundDirectivePropNames) {\n        var _this = this;\n        var /** @type {?} */ boundElementProps = [];\n        props.forEach(function (prop) {\n            if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n                boundElementProps.push(_this._bindingParser.createElementPropertyAst(elementName, prop));\n            }\n        });\n        return this._checkPropertiesInSchema(elementName, boundElementProps);\n    };\n    /**\n     * @param {?} directives\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._findComponentDirectives = function (directives) {\n        return directives.filter(function (directive) { return directive.directive.isComponent; });\n    };\n    /**\n     * @param {?} directives\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {\n        return this._findComponentDirectives(directives)\n            .map(function (directive) { return identifierName(directive.directive.type); });\n    };\n    /**\n     * @param {?} directives\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {\n        var /** @type {?} */ componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 1) {\n            this._reportError(\"More than one component matched on this element.\\n\" +\n                \"Make sure that only one component's selector can match a given element.\\n\" +\n                (\"Conflicting components: \" + componentTypeNames.join(',')), sourceSpan);\n        }\n    };\n    /**\n     * Make sure that non-angular tags conform to the schemas.\n     *\n     * Note: An element is considered an angular tag when at least one directive selector matches the\n     * tag name.\n     *\n     * @param {?} matchElement Whether any directive has matched on the tag name\n     * @param {?} element the html element\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertElementExists = function (matchElement, element) {\n        var /** @type {?} */ elName = element.name.replace(/^:xhtml:/, '');\n        if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n            var /** @type {?} */ errorMsg = \"'\" + elName + \"' is not a known element:\\n\";\n            errorMsg +=\n                \"1. If '\" + elName + \"' is an Angular component, then verify that it is part of this module.\\n\";\n            if (elName.indexOf('-') > -1) {\n                errorMsg +=\n                    \"2. If '\" + elName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\";\n            }\n            else {\n                errorMsg +=\n                    \"2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n            }\n            this._reportError(errorMsg, element.sourceSpan);\n        }\n    };\n    /**\n     * @param {?} directives\n     * @param {?} elementProps\n     * @param {?} sourceSpan\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {\n        var _this = this;\n        var /** @type {?} */ componentTypeNames = this._findComponentDirectiveNames(directives);\n        if (componentTypeNames.length > 0) {\n            this._reportError(\"Components on an embedded template: \" + componentTypeNames.join(','), sourceSpan);\n        }\n        elementProps.forEach(function (prop) {\n            _this._reportError(\"Property binding \" + prop.name + \" not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", sourceSpan);\n        });\n    };\n    /**\n     * @param {?} directives\n     * @param {?} events\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {\n        var _this = this;\n        var /** @type {?} */ allDirectiveEvents = new Set();\n        directives.forEach(function (directive) {\n            Object.keys(directive.directive.outputs).forEach(function (k) {\n                var /** @type {?} */ eventName = directive.directive.outputs[k];\n                allDirectiveEvents.add(eventName);\n            });\n        });\n        events.forEach(function (event) {\n            if (event.target != null || !allDirectiveEvents.has(event.name)) {\n                _this._reportError(\"Event binding \" + event.fullName + \" not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", event.sourceSpan);\n            }\n        });\n    };\n    /**\n     * @param {?} elementName\n     * @param {?} boundProps\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._checkPropertiesInSchema = function (elementName, boundProps) {\n        var _this = this;\n        // Note: We can't filter out empty expressions before this method,\n        // as we still want to validate them!\n        return boundProps.filter(function (boundProp) {\n            if (boundProp.type === PropertyBindingType.Property &&\n                !_this._schemaRegistry.hasProperty(elementName, boundProp.name, _this._schemas)) {\n                var /** @type {?} */ errorMsg = \"Can't bind to '\" + boundProp.name + \"' since it isn't a known property of '\" + elementName + \"'.\";\n                if (elementName.startsWith('ng-')) {\n                    errorMsg +=\n                        \"\\n1. If '\" + boundProp.name + \"' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.\" +\n                            \"\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n                }\n                else if (elementName.indexOf('-') > -1) {\n                    errorMsg +=\n                        \"\\n1. If '\" + elementName + \"' is an Angular component and it has '\" + boundProp.name + \"' input, then verify that it is part of this module.\" +\n                            (\"\\n2. If '\" + elementName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\") +\n                            \"\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n                }\n                _this._reportError(errorMsg, boundProp.sourceSpan);\n            }\n            return !isEmptyExpression(boundProp.value);\n        });\n    };\n    /**\n     * @param {?} message\n     * @param {?} sourceSpan\n     * @param {?=} level\n     * @return {?}\n     */\n    TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {\n        if (level === void 0) { level = ParseErrorLevel.ERROR; }\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    };\n    return TemplateParseVisitor;\n}());\nvar NonBindableVisitor = (function () {\n    function NonBindableVisitor() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} parent\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitElement = function (ast, parent) {\n        var /** @type {?} */ preparsedElement = preparseElement(ast);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE ||\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\n            // Skipping <script> for security reasons\n            // Skipping <style> and stylesheets as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        var /** @type {?} */ attrNameAndValues = ast.attrs.map(function (attr) { return [attr.name, attr.value]; });\n        var /** @type {?} */ selector = createElementCssSelector(ast.name, attrNameAndValues);\n        var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(selector);\n        var /** @type {?} */ children = visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n        return new ElementAst(ast.name, visitAll(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n    };\n    /**\n     * @param {?} comment\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitComment = function (comment, context) { return null; };\n    /**\n     * @param {?} attribute\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitAttribute = function (attribute, context) {\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n    /**\n     * @param {?} text\n     * @param {?} parent\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitText = function (text, parent) {\n        var /** @type {?} */ ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR);\n        return new TextAst(text.value, ngContentIndex, text.sourceSpan);\n    };\n    /**\n     * @param {?} expansion\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitExpansion = function (expansion, context) { return expansion; };\n    /**\n     * @param {?} expansionCase\n     * @param {?} context\n     * @return {?}\n     */\n    NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase, context) { return expansionCase; };\n    return NonBindableVisitor;\n}());\nvar ElementOrDirectiveRef = (function () {\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?} sourceSpan\n     */\n    function ElementOrDirectiveRef(name, value, sourceSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    return ElementOrDirectiveRef;\n}());\n/**\n * @param {?} classAttrValue\n * @return {?}\n */\nfunction splitClasses(classAttrValue) {\n    return classAttrValue.trim().split(/\\s+/g);\n}\nvar ElementContext = (function () {\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} _ngContentIndexMatcher\n     * @param {?} _wildcardNgContentIndex\n     * @param {?} providerContext\n     */\n    function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {\n        this.isTemplateElement = isTemplateElement;\n        this._ngContentIndexMatcher = _ngContentIndexMatcher;\n        this._wildcardNgContentIndex = _wildcardNgContentIndex;\n        this.providerContext = providerContext;\n    }\n    /**\n     * @param {?} isTemplateElement\n     * @param {?} directives\n     * @param {?} providerContext\n     * @return {?}\n     */\n    ElementContext.create = function (isTemplateElement, directives, providerContext) {\n        var /** @type {?} */ matcher = new SelectorMatcher();\n        var /** @type {?} */ wildcardNgContentIndex = null;\n        var /** @type {?} */ component = directives.find(function (directive) { return directive.directive.isComponent; });\n        if (component) {\n            var /** @type {?} */ ngContentSelectors = component.directive.template.ngContentSelectors;\n            for (var /** @type {?} */ i = 0; i < ngContentSelectors.length; i++) {\n                var /** @type {?} */ selector = ngContentSelectors[i];\n                if (selector === '*') {\n                    wildcardNgContentIndex = i;\n                }\n                else {\n                    matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n                }\n            }\n        }\n        return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n    };\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    ElementContext.prototype.findNgContentIndex = function (selector) {\n        var /** @type {?} */ ngContentIndices = [];\n        this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) { ngContentIndices.push(ngContentIndex); });\n        ngContentIndices.sort();\n        if (this._wildcardNgContentIndex != null) {\n            ngContentIndices.push(this._wildcardNgContentIndex);\n        }\n        return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n    };\n    return ElementContext;\n}());\n/**\n * @param {?} elementName\n * @param {?} attributes\n * @return {?}\n */\nfunction createElementCssSelector(elementName, attributes) {\n    var /** @type {?} */ cssSelector = new CssSelector();\n    var /** @type {?} */ elNameNoNs = splitNsName(elementName)[1];\n    cssSelector.setElement(elNameNoNs);\n    for (var /** @type {?} */ i = 0; i < attributes.length; i++) {\n        var /** @type {?} */ attrName = attributes[i][0];\n        var /** @type {?} */ attrNameNoNs = splitNsName(attrName)[1];\n        var /** @type {?} */ attrValue = attributes[i][1];\n        cssSelector.addAttribute(attrNameNoNs, attrValue);\n        if (attrName.toLowerCase() == CLASS_ATTR) {\n            var /** @type {?} */ classes = splitClasses(attrValue);\n            classes.forEach(function (className) { return cssSelector.addClassName(className); });\n        }\n    }\n    return cssSelector;\n}\nvar EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\nvar NON_BINDABLE_VISITOR = new NonBindableVisitor();\n/**\n * @param {?} node\n * @return {?}\n */\nfunction _isEmptyTextNode(node) {\n    return node instanceof Text && node.value.trim().length == 0;\n}\n/**\n * @template T\n * @param {?} items\n * @return {?}\n */\nfunction removeSummaryDuplicates(items) {\n    var /** @type {?} */ map = new Map();\n    items.forEach(function (item) {\n        if (!map.get(item.type.reference)) {\n            map.set(item.type.reference, item);\n        }\n    });\n    return Array.from(map.values());\n}\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction isEmptyExpression(ast) {\n    if (ast instanceof ASTWithSource) {\n        ast = ast.ast;\n    }\n    return ast instanceof EmptyExpr;\n}\n/**\n * @param {?} el\n * @param {?} enableLegacyTemplate\n * @param {?} reportDeprecation\n * @return {?}\n */\nfunction isTemplate(el, enableLegacyTemplate, reportDeprecation) {\n    var /** @type {?} */ tagNoNs = splitNsName(el.name)[1];\n    // `<ng-template>` is an angular construct and is lower case\n    if (tagNoNs === NG_TEMPLATE_ELEMENT)\n        return true;\n    // `<template>` is HTML and case insensitive\n    if (tagNoNs.toLowerCase() === TEMPLATE_ELEMENT) {\n        if (enableLegacyTemplate && tagNoNs.toLowerCase() === TEMPLATE_ELEMENT) {\n            reportDeprecation(TEMPLATE_ELEMENT_DEPRECATION_WARNING, el.sourceSpan);\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * An interface for retrieving documents by URL that the compiler uses\n * to load templates.\n */\nvar ResourceLoader = (function () {\n    function ResourceLoader() {\n    }\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    ResourceLoader.prototype.get = function (url) { return null; };\n    return ResourceLoader;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a {\\@link UrlResolver} with no package prefix.\n * @return {?}\n */\nfunction createUrlResolverWithoutPackagePrefix() {\n    return new UrlResolver();\n}\n/**\n * @return {?}\n */\nfunction createOfflineCompileUrlResolver() {\n    return new UrlResolver('.');\n}\n/**\n * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.\n */\nvar DEFAULT_PACKAGE_URL_PROVIDER = {\n    provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_33\" /* PACKAGE_ROOT_URL */],\n    useValue: '/'\n};\n/**\n * Used by the {\\@link Compiler} when resolving HTML and CSS template URLs.\n *\n * This class can be overridden by the application developer to create custom behavior.\n *\n * See {\\@link Compiler}\n *\n * ## Example\n *\n * {\\@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}\n *\n * \\@security When compiling templates at runtime, you must\n * ensure that the entire template comes from a trusted source.\n * Attacker-controlled data introduced by a template could expose your\n * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).\n */\nvar UrlResolver = (function () {\n    /**\n     * @param {?=} _packagePrefix\n     */\n    function UrlResolver(_packagePrefix) {\n        if (_packagePrefix === void 0) { _packagePrefix = null; }\n        this._packagePrefix = _packagePrefix;\n    }\n    /**\n     * Resolves the `url` given the `baseUrl`:\n     * - when the `url` is null, the `baseUrl` is returned,\n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n     * `baseUrl` and `url`,\n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n     * returned as is (ignoring the `baseUrl`)\n     * @param {?} baseUrl\n     * @param {?} url\n     * @return {?}\n     */\n    UrlResolver.prototype.resolve = function (baseUrl, url) {\n        var /** @type {?} */ resolvedUrl = url;\n        if (baseUrl != null && baseUrl.length > 0) {\n            resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\n        }\n        var /** @type {?} */ resolvedParts = _split(resolvedUrl);\n        var /** @type {?} */ prefix = this._packagePrefix;\n        if (prefix != null && resolvedParts != null &&\n            resolvedParts[_ComponentIndex.Scheme] == 'package') {\n            var /** @type {?} */ path = resolvedParts[_ComponentIndex.Path];\n            prefix = prefix.replace(/\\/+$/, '');\n            path = path.replace(/^\\/+/, '');\n            return prefix + \"/\" + path;\n        }\n        return resolvedUrl;\n    };\n    return UrlResolver;\n}());\nUrlResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nUrlResolver.ctorParameters = function () { return [\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */], args: [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_33\" /* PACKAGE_ROOT_URL */],] },] },\n]; };\n/**\n * Extract the scheme of a URL.\n * @param {?} url\n * @return {?}\n */\nfunction getUrlScheme(url) {\n    var /** @type {?} */ match = _split(url);\n    return (match && match[_ComponentIndex.Scheme]) || '';\n}\n/**\n * Builds a URI string from already-encoded parts.\n *\n * No encoding is performed.  Any component may be omitted as either null or\n * undefined.\n *\n * @param {?=} opt_scheme The scheme such as 'http'.\n * @param {?=} opt_userInfo The user name before the '\\@'.\n * @param {?=} opt_domain The domain such as 'www.google.com', already\n *     URI-encoded.\n * @param {?=} opt_port The port number.\n * @param {?=} opt_path The path, already URI-encoded.  If it is not\n *     empty, it must begin with a slash.\n * @param {?=} opt_queryData The URI-encoded query data.\n * @param {?=} opt_fragment The URI-encoded fragment identifier.\n * @return {?} The fully combined URI.\n */\nfunction _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    var /** @type {?} */ out = [];\n    if (opt_scheme != null) {\n        out.push(opt_scheme + ':');\n    }\n    if (opt_domain != null) {\n        out.push('//');\n        if (opt_userInfo != null) {\n            out.push(opt_userInfo + '@');\n        }\n        out.push(opt_domain);\n        if (opt_port != null) {\n            out.push(':' + opt_port);\n        }\n    }\n    if (opt_path != null) {\n        out.push(opt_path);\n    }\n    if (opt_queryData != null) {\n        out.push('?' + opt_queryData);\n    }\n    if (opt_fragment != null) {\n        out.push('#' + opt_fragment);\n    }\n    return out.join('');\n}\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {\\@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * \\@internal\n */\nvar _splitRe = new RegExp('^' +\n    '(?:' +\n    '([^:/?#.]+)' +\n    // used by other URL parts such as :,\n    // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n    '(?:([^/?#]*)@)?' +\n    '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' +\n    // digits, dashes, dots, percent\n    // escapes, and unicode characters.\n    '(?::([0-9]+))?' +\n    ')?' +\n    '([^?#]+)?' +\n    '(?:\\\\?([^#]*))?' +\n    '(?:#(.*))?' +\n    '$');\nvar _ComponentIndex = {};\n_ComponentIndex.Scheme = 1;\n_ComponentIndex.UserInfo = 2;\n_ComponentIndex.Domain = 3;\n_ComponentIndex.Port = 4;\n_ComponentIndex.Path = 5;\n_ComponentIndex.QueryData = 6;\n_ComponentIndex.Fragment = 7;\n_ComponentIndex[_ComponentIndex.Scheme] = \"Scheme\";\n_ComponentIndex[_ComponentIndex.UserInfo] = \"UserInfo\";\n_ComponentIndex[_ComponentIndex.Domain] = \"Domain\";\n_ComponentIndex[_ComponentIndex.Port] = \"Port\";\n_ComponentIndex[_ComponentIndex.Path] = \"Path\";\n_ComponentIndex[_ComponentIndex.QueryData] = \"QueryData\";\n_ComponentIndex[_ComponentIndex.Fragment] = \"Fragment\";\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n * </pre>\n *\n * @param {?} uri The URI string to examine.\n * @return {?} Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\nfunction _split(uri) {\n    return uri.match(_splitRe);\n}\n/**\n * Removes dot segments in given path component, as described in\n * RFC 3986, section 5.2.4.\n *\n * @param {?} path A non-empty path component.\n * @return {?} Path component with removed dot segments.\n */\nfunction _removeDotSegments(path) {\n    if (path == '/')\n        return '/';\n    var /** @type {?} */ leadingSlash = path[0] == '/' ? '/' : '';\n    var /** @type {?} */ trailingSlash = path[path.length - 1] === '/' ? '/' : '';\n    var /** @type {?} */ segments = path.split('/');\n    var /** @type {?} */ out = [];\n    var /** @type {?} */ up = 0;\n    for (var /** @type {?} */ pos = 0; pos < segments.length; pos++) {\n        var /** @type {?} */ segment = segments[pos];\n        switch (segment) {\n            case '':\n            case '.':\n                break;\n            case '..':\n                if (out.length > 0) {\n                    out.pop();\n                }\n                else {\n                    up++;\n                }\n                break;\n            default:\n                out.push(segment);\n        }\n    }\n    if (leadingSlash == '') {\n        while (up-- > 0) {\n            out.unshift('..');\n        }\n        if (out.length === 0)\n            out.push('.');\n    }\n    return leadingSlash + out.join('/') + trailingSlash;\n}\n/**\n * Takes an array of the parts from split and canonicalizes the path part\n * and then joins all the parts.\n * @param {?} parts\n * @return {?}\n */\nfunction _joinAndCanonicalizePath(parts) {\n    var /** @type {?} */ path = parts[_ComponentIndex.Path];\n    path = path == null ? '' : _removeDotSegments(path);\n    parts[_ComponentIndex.Path] = path;\n    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);\n}\n/**\n * Resolves a URL.\n * @param {?} base The URL acting as the base URL.\n * @param {?} url\n * @return {?}\n */\nfunction _resolveUrl(base, url) {\n    var /** @type {?} */ parts = _split(encodeURI(url));\n    var /** @type {?} */ baseParts = _split(base);\n    if (parts[_ComponentIndex.Scheme] != null) {\n        return _joinAndCanonicalizePath(parts);\n    }\n    else {\n        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\n    }\n    for (var /** @type {?} */ i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\n        if (parts[i] == null) {\n            parts[i] = baseParts[i];\n        }\n    }\n    if (parts[_ComponentIndex.Path][0] == '/') {\n        return _joinAndCanonicalizePath(parts);\n    }\n    var /** @type {?} */ path = baseParts[_ComponentIndex.Path];\n    if (path == null)\n        path = '/';\n    var /** @type {?} */ index = path.lastIndexOf('/');\n    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\n    parts[_ComponentIndex.Path] = path;\n    return _joinAndCanonicalizePath(parts);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar DirectiveNormalizer = (function () {\n    /**\n     * @param {?} _resourceLoader\n     * @param {?} _urlResolver\n     * @param {?} _htmlParser\n     * @param {?} _config\n     */\n    function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {\n        this._resourceLoader = _resourceLoader;\n        this._urlResolver = _urlResolver;\n        this._htmlParser = _htmlParser;\n        this._config = _config;\n        this._resourceLoaderCache = new Map();\n    }\n    /**\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.clearCache = function () { this._resourceLoaderCache.clear(); };\n    /**\n     * @param {?} normalizedDirective\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.clearCacheFor = function (normalizedDirective) {\n        var _this = this;\n        if (!normalizedDirective.isComponent) {\n            return;\n        }\n        this._resourceLoaderCache.delete(normalizedDirective.template.templateUrl);\n        normalizedDirective.template.externalStylesheets.forEach(function (stylesheet) { _this._resourceLoaderCache.delete(stylesheet.moduleUrl); });\n    };\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype._fetch = function (url) {\n        var /** @type {?} */ result = this._resourceLoaderCache.get(url);\n        if (!result) {\n            result = this._resourceLoader.get(url);\n            this._resourceLoaderCache.set(url, result);\n        }\n        return result;\n    };\n    /**\n     * @param {?} prenormData\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeTemplate = function (prenormData) {\n        var _this = this;\n        var /** @type {?} */ normalizedTemplateSync = null;\n        var /** @type {?} */ normalizedTemplateAsync;\n        if (prenormData.template != null) {\n            if (prenormData.templateUrl != null) {\n                throw syntaxError(\"'\" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(prenormData.componentType) + \"' component cannot define both template and templateUrl\");\n            }\n            if (typeof prenormData.template !== 'string') {\n                throw syntaxError(\"The template specified for component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(prenormData.componentType) + \" is not a string\");\n            }\n            normalizedTemplateSync = this.normalizeTemplateSync(prenormData);\n            normalizedTemplateAsync = Promise.resolve(normalizedTemplateSync);\n        }\n        else if (prenormData.templateUrl) {\n            if (typeof prenormData.templateUrl !== 'string') {\n                throw syntaxError(\"The templateUrl specified for component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(prenormData.componentType) + \" is not a string\");\n            }\n            normalizedTemplateAsync = this.normalizeTemplateAsync(prenormData);\n        }\n        else {\n            throw syntaxError(\"No template specified for component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(prenormData.componentType));\n        }\n        if (normalizedTemplateSync && normalizedTemplateSync.styleUrls.length === 0) {\n            // sync case\n            return new SyncAsyncResult(normalizedTemplateSync);\n        }\n        else {\n            // async case\n            return new SyncAsyncResult(null, normalizedTemplateAsync.then(function (normalizedTemplate) { return _this.normalizeExternalStylesheets(normalizedTemplate); }));\n        }\n    };\n    /**\n     * @param {?} prenomData\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeTemplateSync = function (prenomData) {\n        return this.normalizeLoadedTemplate(prenomData, prenomData.template, prenomData.moduleUrl);\n    };\n    /**\n     * @param {?} prenomData\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeTemplateAsync = function (prenomData) {\n        var _this = this;\n        var /** @type {?} */ templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl);\n        return this._fetch(templateUrl)\n            .then(function (value) { return _this.normalizeLoadedTemplate(prenomData, value, templateUrl); });\n    };\n    /**\n     * @param {?} prenormData\n     * @param {?} template\n     * @param {?} templateAbsUrl\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeLoadedTemplate = function (prenormData, template, templateAbsUrl) {\n        var /** @type {?} */ isInline = !!prenormData.template;\n        var /** @type {?} */ interpolationConfig = InterpolationConfig.fromArray(prenormData.interpolation);\n        var /** @type {?} */ rootNodesAndErrors = this._htmlParser.parse(template, templateSourceUrl({ reference: prenormData.ngModuleType }, { type: { reference: prenormData.componentType } }, { isInline: isInline, templateUrl: templateAbsUrl }), true, interpolationConfig);\n        if (rootNodesAndErrors.errors.length > 0) {\n            var /** @type {?} */ errorString = rootNodesAndErrors.errors.join('\\n');\n            throw syntaxError(\"Template parse errors:\\n\" + errorString);\n        }\n        var /** @type {?} */ templateMetadataStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({\n            styles: prenormData.styles,\n            styleUrls: prenormData.styleUrls,\n            moduleUrl: prenormData.moduleUrl\n        }));\n        var /** @type {?} */ visitor = new TemplatePreparseVisitor();\n        visitAll(visitor, rootNodesAndErrors.rootNodes);\n        var /** @type {?} */ templateStyles = this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));\n        var /** @type {?} */ encapsulation = prenormData.encapsulation;\n        if (encapsulation == null) {\n            encapsulation = this._config.defaultEncapsulation;\n        }\n        var /** @type {?} */ styles = templateMetadataStyles.styles.concat(templateStyles.styles);\n        var /** @type {?} */ styleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);\n        if (encapsulation === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].Emulated && styles.length === 0 &&\n            styleUrls.length === 0) {\n            encapsulation = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].None;\n        }\n        return new CompileTemplateMetadata({\n            encapsulation: encapsulation,\n            template: template,\n            templateUrl: templateAbsUrl, styles: styles, styleUrls: styleUrls,\n            ngContentSelectors: visitor.ngContentSelectors,\n            animations: prenormData.animations,\n            interpolation: prenormData.interpolation, isInline: isInline\n        });\n    };\n    /**\n     * @param {?} templateMeta\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeExternalStylesheets = function (templateMeta) {\n        return this._loadMissingExternalStylesheets(templateMeta.styleUrls)\n            .then(function (externalStylesheets) { return new CompileTemplateMetadata({\n            encapsulation: templateMeta.encapsulation,\n            template: templateMeta.template,\n            templateUrl: templateMeta.templateUrl,\n            styles: templateMeta.styles,\n            styleUrls: templateMeta.styleUrls,\n            externalStylesheets: externalStylesheets,\n            ngContentSelectors: templateMeta.ngContentSelectors,\n            animations: templateMeta.animations,\n            interpolation: templateMeta.interpolation,\n            isInline: templateMeta.isInline,\n        }); });\n    };\n    /**\n     * @param {?} styleUrls\n     * @param {?=} loadedStylesheets\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype._loadMissingExternalStylesheets = function (styleUrls, loadedStylesheets) {\n        var _this = this;\n        if (loadedStylesheets === void 0) { loadedStylesheets = new Map(); }\n        return Promise\n            .all(styleUrls.filter(function (styleUrl) { return !loadedStylesheets.has(styleUrl); })\n            .map(function (styleUrl) { return _this._fetch(styleUrl).then(function (loadedStyle) {\n            var /** @type {?} */ stylesheet = _this.normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));\n            loadedStylesheets.set(styleUrl, stylesheet);\n            return _this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);\n        }); }))\n            .then(function (_) { return Array.from(loadedStylesheets.values()); });\n    };\n    /**\n     * @param {?} stylesheet\n     * @return {?}\n     */\n    DirectiveNormalizer.prototype.normalizeStylesheet = function (stylesheet) {\n        var _this = this;\n        var /** @type {?} */ allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)\n            .map(function (url) { return _this._urlResolver.resolve(stylesheet.moduleUrl, url); });\n        var /** @type {?} */ allStyles = stylesheet.styles.map(function (style$$1) {\n            var /** @type {?} */ styleWithImports = extractStyleUrls(_this._urlResolver, stylesheet.moduleUrl, style$$1);\n            allStyleUrls.push.apply(allStyleUrls, styleWithImports.styleUrls);\n            return styleWithImports.style;\n        });\n        return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: stylesheet.moduleUrl });\n    };\n    return DirectiveNormalizer;\n}());\nDirectiveNormalizer.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nDirectiveNormalizer.ctorParameters = function () { return [\n    { type: ResourceLoader, },\n    { type: UrlResolver, },\n    { type: HtmlParser, },\n    { type: CompilerConfig, },\n]; };\nvar TemplatePreparseVisitor = (function () {\n    function TemplatePreparseVisitor() {\n        this.ngContentSelectors = [];\n        this.styles = [];\n        this.styleUrls = [];\n        this.ngNonBindableStackCount = 0;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitElement = function (ast, context) {\n        var /** @type {?} */ preparsedElement = preparseElement(ast);\n        switch (preparsedElement.type) {\n            case PreparsedElementType.NG_CONTENT:\n                if (this.ngNonBindableStackCount === 0) {\n                    this.ngContentSelectors.push(preparsedElement.selectAttr);\n                }\n                break;\n            case PreparsedElementType.STYLE:\n                var /** @type {?} */ textContent_1 = '';\n                ast.children.forEach(function (child) {\n                    if (child instanceof Text) {\n                        textContent_1 += child.value;\n                    }\n                });\n                this.styles.push(textContent_1);\n                break;\n            case PreparsedElementType.STYLESHEET:\n                this.styleUrls.push(preparsedElement.hrefAttr);\n                break;\n            default:\n                break;\n        }\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount++;\n        }\n        visitAll(this, ast.children);\n        if (preparsedElement.nonBindable) {\n            this.ngNonBindableStackCount--;\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitExpansion = function (ast, context) { visitAll(this, ast.cases); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitExpansionCase = function (ast, context) {\n        visitAll(this, ast.expression);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitComment = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitAttribute = function (ast, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    TemplatePreparseVisitor.prototype.visitText = function (ast, context) { return null; };\n    return TemplatePreparseVisitor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __assign = (undefined && undefined.__assign) || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n    }\n    return t;\n};\nvar DirectiveResolver = (function () {\n    /**\n     * @param {?=} _reflector\n     */\n    function DirectiveResolver(_reflector) {\n        if (_reflector === void 0) { _reflector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */]; }\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    DirectiveResolver.prototype.isDirective = function (type) {\n        var /** @type {?} */ typeMetadata = this._reflector.annotations(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(type));\n        return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n    };\n    /**\n     * Return {\\@link Directive} for a given `Type`.\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    DirectiveResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ typeMetadata = this._reflector.annotations(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(type));\n        if (typeMetadata) {\n            var /** @type {?} */ metadata = findLast(typeMetadata, isDirectiveMetadata);\n            if (metadata) {\n                var /** @type {?} */ propertyMetadata = this._reflector.propMetadata(type);\n                return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(\"No Directive annotation found on \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(type));\n        }\n        return null;\n    };\n    /**\n     * @param {?} dm\n     * @param {?} propertyMetadata\n     * @param {?} directiveType\n     * @return {?}\n     */\n    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, directiveType) {\n        var /** @type {?} */ inputs = [];\n        var /** @type {?} */ outputs = [];\n        var /** @type {?} */ host = {};\n        var /** @type {?} */ queries = {};\n        Object.keys(propertyMetadata).forEach(function (propName) {\n            var /** @type {?} */ input = findLast(propertyMetadata[propName], function (a) { return a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"M\" /* Input */]; });\n            if (input) {\n                if (input.bindingPropertyName) {\n                    inputs.push(propName + \": \" + input.bindingPropertyName);\n                }\n                else {\n                    inputs.push(propName);\n                }\n            }\n            var /** @type {?} */ output = findLast(propertyMetadata[propName], function (a) { return a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_35\" /* Output */]; });\n            if (output) {\n                if (output.bindingPropertyName) {\n                    outputs.push(propName + \": \" + output.bindingPropertyName);\n                }\n                else {\n                    outputs.push(propName);\n                }\n            }\n            var /** @type {?} */ hostBindings = propertyMetadata[propName].filter(function (a) { return a && a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_36\" /* HostBinding */]; });\n            hostBindings.forEach(function (hostBinding) {\n                if (hostBinding.hostPropertyName) {\n                    var /** @type {?} */ startWith = hostBinding.hostPropertyName[0];\n                    if (startWith === '(') {\n                        throw new Error(\"@HostBinding can not bind to events. Use @HostListener instead.\");\n                    }\n                    else if (startWith === '[') {\n                        throw new Error(\"@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.\");\n                    }\n                    host[\"[\" + hostBinding.hostPropertyName + \"]\"] = propName;\n                }\n                else {\n                    host[\"[\" + propName + \"]\"] = propName;\n                }\n            });\n            var /** @type {?} */ hostListeners = propertyMetadata[propName].filter(function (a) { return a && a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* HostListener */]; });\n            hostListeners.forEach(function (hostListener) {\n                var /** @type {?} */ args = hostListener.args || [];\n                host[\"(\" + hostListener.eventName + \")\"] = propName + \"(\" + args.join(',') + \")\";\n            });\n            var /** @type {?} */ query = findLast(propertyMetadata[propName], function (a) { return a instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_38\" /* Query */]; });\n            if (query) {\n                queries[propName] = query;\n            }\n        });\n        return this._merge(dm, inputs, outputs, host, queries, directiveType);\n    };\n    /**\n     * @param {?} def\n     * @return {?}\n     */\n    DirectiveResolver.prototype._extractPublicName = function (def) { return splitAtColon(def, [null, def])[1].trim(); };\n    /**\n     * @param {?} bindings\n     * @return {?}\n     */\n    DirectiveResolver.prototype._dedupeBindings = function (bindings) {\n        var /** @type {?} */ names = new Set();\n        var /** @type {?} */ reversedResult = [];\n        // go last to first to allow later entries to overwrite previous entries\n        for (var /** @type {?} */ i = bindings.length - 1; i >= 0; i--) {\n            var /** @type {?} */ binding = bindings[i];\n            var /** @type {?} */ name = this._extractPublicName(binding);\n            if (!names.has(name)) {\n                names.add(name);\n                reversedResult.push(binding);\n            }\n        }\n        return reversedResult.reverse();\n    };\n    /**\n     * @param {?} directive\n     * @param {?} inputs\n     * @param {?} outputs\n     * @param {?} host\n     * @param {?} queries\n     * @param {?} directiveType\n     * @return {?}\n     */\n    DirectiveResolver.prototype._merge = function (directive, inputs, outputs, host, queries, directiveType) {\n        var /** @type {?} */ mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n        var /** @type {?} */ mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n        var /** @type {?} */ mergedHost = directive.host ? __assign({}, directive.host, host) : host;\n        var /** @type {?} */ mergedQueries = directive.queries ? __assign({}, directive.queries, queries) : queries;\n        if (directive instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */]) {\n            return new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */]({\n                selector: directive.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: directive.exportAs,\n                moduleId: directive.moduleId,\n                queries: mergedQueries,\n                changeDetection: directive.changeDetection,\n                providers: directive.providers,\n                viewProviders: directive.viewProviders,\n                entryComponents: directive.entryComponents,\n                template: directive.template,\n                templateUrl: directive.templateUrl,\n                styles: directive.styles,\n                styleUrls: directive.styleUrls,\n                encapsulation: directive.encapsulation,\n                animations: directive.animations,\n                interpolation: directive.interpolation\n            });\n        }\n        else {\n            return new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"H\" /* Directive */]({\n                selector: directive.selector,\n                inputs: mergedInputs,\n                outputs: mergedOutputs,\n                host: mergedHost,\n                exportAs: directive.exportAs,\n                queries: mergedQueries,\n                providers: directive.providers\n            });\n        }\n    };\n    return DirectiveResolver;\n}());\nDirectiveResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nDirectiveResolver.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵReflectorReader */], },\n]; };\n/**\n * @param {?} type\n * @return {?}\n */\nfunction isDirectiveMetadata(type) {\n    return type instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"H\" /* Directive */];\n}\n/**\n * @template T\n * @param {?} arr\n * @param {?} condition\n * @return {?}\n */\nfunction findLast(arr, condition) {\n    for (var /** @type {?} */ i = arr.length - 1; i >= 0; i--) {\n        if (condition(arr[i])) {\n            return arr[i];\n        }\n    }\n    return null;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar STRIP_SRC_FILE_SUFFIXES = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\nvar NG_FACTORY = /\\.ngfactory\\./;\n/**\n * @param {?} filePath\n * @return {?}\n */\nfunction ngfactoryFilePath(filePath) {\n    var /** @type {?} */ urlWithSuffix = splitTypescriptSuffix(filePath);\n    return urlWithSuffix[0] + \".ngfactory\" + urlWithSuffix[1];\n}\n/**\n * @param {?} filePath\n * @return {?}\n */\nfunction stripNgFactory(filePath) {\n    return filePath.replace(NG_FACTORY, '.');\n}\n/**\n * @param {?} filePath\n * @return {?}\n */\nfunction isNgFactoryFile(filePath) {\n    return NG_FACTORY.test(filePath);\n}\n/**\n * @param {?} path\n * @return {?}\n */\nfunction splitTypescriptSuffix(path) {\n    if (path.endsWith('.d.ts')) {\n        return [path.slice(0, -5), '.ts'];\n    }\n    var /** @type {?} */ lastDot = path.lastIndexOf('.');\n    if (lastDot !== -1) {\n        return [path.substring(0, lastDot), path.substring(lastDot)];\n    }\n    return [path, ''];\n}\n/**\n * @param {?} fileName\n * @return {?}\n */\nfunction summaryFileName(fileName) {\n    var /** @type {?} */ fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');\n    return fileNameWithoutSuffix + \".ngsummary.json\";\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} hook\n * @param {?} token\n * @return {?}\n */\nfunction hasLifecycleHook(hook, token) {\n    return __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */].hasLifecycleHook(token, getHookName(hook));\n}\n/**\n * @param {?} hook\n * @return {?}\n */\nfunction getHookName(hook) {\n    switch (hook) {\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnInit:\n            return 'ngOnInit';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnDestroy:\n            return 'ngOnDestroy';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].DoCheck:\n            return 'ngDoCheck';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnChanges:\n            return 'ngOnChanges';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterContentInit:\n            return 'ngAfterContentInit';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterContentChecked:\n            return 'ngAfterContentChecked';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterViewInit:\n            return 'ngAfterViewInit';\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterViewChecked:\n            return 'ngAfterViewChecked';\n    }\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction _isNgModuleMetadata(obj) {\n    return obj instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"a\" /* NgModule */];\n}\n/**\n * Resolves types to {\\@link NgModule}.\n */\nvar NgModuleResolver = (function () {\n    /**\n     * @param {?=} _reflector\n     */\n    function NgModuleResolver(_reflector) {\n        if (_reflector === void 0) { _reflector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */]; }\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    NgModuleResolver.prototype.isNgModule = function (type) { return this._reflector.annotations(type).some(_isNgModuleMetadata); };\n    /**\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    NgModuleResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ ngModuleMeta = findLast(this._reflector.annotations(type), _isNgModuleMetadata);\n        if (ngModuleMeta) {\n            return ngModuleMeta;\n        }\n        else {\n            if (throwIfNotFound) {\n                throw new Error(\"No NgModule metadata found for '\" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(type) + \"'.\");\n            }\n            return null;\n        }\n    };\n    return NgModuleResolver;\n}());\nNgModuleResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nNgModuleResolver.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵReflectorReader */], },\n]; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} type\n * @return {?}\n */\nfunction _isPipeMetadata(type) {\n    return type instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* Pipe */];\n}\n/**\n * Resolve a `Type` for {\\@link Pipe}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {\\@link Compiler}\n */\nvar PipeResolver = (function () {\n    /**\n     * @param {?=} _reflector\n     */\n    function PipeResolver(_reflector) {\n        if (_reflector === void 0) { _reflector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */]; }\n        this._reflector = _reflector;\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    PipeResolver.prototype.isPipe = function (type) {\n        var /** @type {?} */ typeMetadata = this._reflector.annotations(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(type));\n        return typeMetadata && typeMetadata.some(_isPipeMetadata);\n    };\n    /**\n     * Return {\\@link Pipe} for a given `Type`.\n     * @param {?} type\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    PipeResolver.prototype.resolve = function (type, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ metas = this._reflector.annotations(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(type));\n        if (metas) {\n            var /** @type {?} */ annotation = findLast(metas, _isPipeMetadata);\n            if (annotation) {\n                return annotation;\n            }\n        }\n        if (throwIfNotFound) {\n            throw new Error(\"No Pipe decorator found on \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(type));\n        }\n        return null;\n    };\n    return PipeResolver;\n}());\nPipeResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nPipeResolver.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵReflectorReader */], },\n]; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar SummaryResolver = (function () {\n    function SummaryResolver() {\n    }\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    SummaryResolver.prototype.isLibraryFile = function (fileName) { return false; };\n    ;\n    /**\n     * @param {?} fileName\n     * @return {?}\n     */\n    SummaryResolver.prototype.getLibraryFileName = function (fileName) { return null; };\n    /**\n     * @param {?} reference\n     * @return {?}\n     */\n    SummaryResolver.prototype.resolveSummary = function (reference) { return null; };\n    ;\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    SummaryResolver.prototype.getSymbolsOf = function (filePath) { return []; };\n    /**\n     * @param {?} reference\n     * @return {?}\n     */\n    SummaryResolver.prototype.getImportAs = function (reference) { return reference; };\n    return SummaryResolver;\n}());\nSummaryResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nSummaryResolver.ctorParameters = function () { return []; };\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ERROR_COLLECTOR_TOKEN = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"d\" /* InjectionToken */]('ErrorCollector');\nvar CompileMetadataResolver = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _ngModuleResolver\n     * @param {?} _directiveResolver\n     * @param {?} _pipeResolver\n     * @param {?} _summaryResolver\n     * @param {?} _schemaRegistry\n     * @param {?} _directiveNormalizer\n     * @param {?} _console\n     * @param {?} _staticSymbolCache\n     * @param {?=} _reflector\n     * @param {?=} _errorCollector\n     */\n    function CompileMetadataResolver(_config, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {\n        if (_reflector === void 0) { _reflector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */]; }\n        this._config = _config;\n        this._ngModuleResolver = _ngModuleResolver;\n        this._directiveResolver = _directiveResolver;\n        this._pipeResolver = _pipeResolver;\n        this._summaryResolver = _summaryResolver;\n        this._schemaRegistry = _schemaRegistry;\n        this._directiveNormalizer = _directiveNormalizer;\n        this._console = _console;\n        this._staticSymbolCache = _staticSymbolCache;\n        this._reflector = _reflector;\n        this._errorCollector = _errorCollector;\n        this._nonNormalizedDirectiveCache = new Map();\n        this._directiveCache = new Map();\n        this._summaryCache = new Map();\n        this._pipeCache = new Map();\n        this._ngModuleCache = new Map();\n        this._ngModuleOfTypes = new Map();\n    }\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.clearCacheFor = function (type) {\n        var /** @type {?} */ dirMeta = this._directiveCache.get(type);\n        this._directiveCache.delete(type);\n        this._nonNormalizedDirectiveCache.delete(type);\n        this._summaryCache.delete(type);\n        this._pipeCache.delete(type);\n        this._ngModuleOfTypes.delete(type);\n        // Clear all of the NgModule as they contain transitive information!\n        this._ngModuleCache.clear();\n        if (dirMeta) {\n            this._directiveNormalizer.clearCacheFor(dirMeta);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.clearCache = function () {\n        this._directiveCache.clear();\n        this._nonNormalizedDirectiveCache.clear();\n        this._summaryCache.clear();\n        this._pipeCache.clear();\n        this._ngModuleCache.clear();\n        this._ngModuleOfTypes.clear();\n        this._directiveNormalizer.clearCache();\n    };\n    /**\n     * @param {?} baseType\n     * @param {?} name\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._createProxyClass = function (baseType, name) {\n        var /** @type {?} */ delegate = null;\n        var /** @type {?} */ proxyClass = (function () {\n            if (!delegate) {\n                throw new Error(\"Illegal state: Class \" + name + \" for type \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(baseType) + \" is not compiled yet!\");\n            }\n            return delegate.apply(this, arguments);\n        });\n        proxyClass.setDelegate = function (d) {\n            delegate = d;\n            ((proxyClass)).prototype = d.prototype;\n        };\n        // Make stringify work correctly\n        ((proxyClass)).overriddenName = name;\n        return proxyClass;\n    };\n    /**\n     * @param {?} dirType\n     * @param {?} name\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getGeneratedClass = function (dirType, name) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);\n        }\n        else {\n            return this._createProxyClass(dirType, name);\n        }\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getComponentViewClass = function (dirType) {\n        return this.getGeneratedClass(dirType, viewClassName(dirType, 0));\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getHostComponentViewClass = function (dirType) {\n        return this.getGeneratedClass(dirType, hostViewClassName(dirType));\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getHostComponentType = function (dirType) {\n        var /** @type {?} */ name = identifierName({ reference: dirType }) + \"_Host\";\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(dirType.filePath, name);\n        }\n        else {\n            var /** @type {?} */ HostClass = (function HostClass() { });\n            HostClass.overriddenName = name;\n            return HostClass;\n        }\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getRendererType = function (dirType) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), rendererTypeName(dirType));\n        }\n        else {\n            // returning an object as proxy,\n            // that we fill later during runtime compilation.\n            return ({});\n        }\n    };\n    /**\n     * @param {?} selector\n     * @param {?} dirType\n     * @param {?} inputs\n     * @param {?} outputs\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getComponentFactory = function (selector, dirType, inputs, outputs) {\n        if (dirType instanceof StaticSymbol) {\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), componentFactoryName(dirType));\n        }\n        else {\n            var /** @type {?} */ hostView = this.getHostComponentViewClass(dirType);\n            // Note: ngContentSelectors will be filled later once the template is\n            // loaded.\n            return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_31\" /* ɵccf */])(selector, dirType, /** @type {?} */ (hostView), inputs, outputs, []);\n        }\n    };\n    /**\n     * @param {?} factory\n     * @param {?} ngContentSelectors\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.initComponentFactory = function (factory, ngContentSelectors) {\n        if (!(factory instanceof StaticSymbol)) {\n            (_a = factory.ngContentSelectors).push.apply(_a, ngContentSelectors);\n        }\n        var _a;\n    };\n    /**\n     * @param {?} type\n     * @param {?} kind\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._loadSummary = function (type, kind) {\n        var /** @type {?} */ typeSummary = this._summaryCache.get(type);\n        if (!typeSummary) {\n            var /** @type {?} */ summary = this._summaryResolver.resolveSummary(type);\n            typeSummary = summary ? summary.type : null;\n            this._summaryCache.set(type, typeSummary);\n        }\n        return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;\n    };\n    /**\n     * @param {?} ngModuleType\n     * @param {?} directiveType\n     * @param {?} isSync\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._loadDirectiveMetadata = function (ngModuleType, directiveType, isSync) {\n        var _this = this;\n        if (this._directiveCache.has(directiveType)) {\n            return;\n        }\n        directiveType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(directiveType);\n        var _a = this.getNonNormalizedDirectiveMetadata(directiveType), annotation = _a.annotation, metadata = _a.metadata;\n        var /** @type {?} */ createDirectiveMetadata = function (templateMetadata) {\n            var /** @type {?} */ normalizedDirMeta = new CompileDirectiveMetadata({\n                type: metadata.type,\n                isComponent: metadata.isComponent,\n                selector: metadata.selector,\n                exportAs: metadata.exportAs,\n                changeDetection: metadata.changeDetection,\n                inputs: metadata.inputs,\n                outputs: metadata.outputs,\n                hostListeners: metadata.hostListeners,\n                hostProperties: metadata.hostProperties,\n                hostAttributes: metadata.hostAttributes,\n                providers: metadata.providers,\n                viewProviders: metadata.viewProviders,\n                queries: metadata.queries,\n                viewQueries: metadata.viewQueries,\n                entryComponents: metadata.entryComponents,\n                componentViewType: metadata.componentViewType,\n                rendererType: metadata.rendererType,\n                componentFactory: metadata.componentFactory,\n                template: templateMetadata\n            });\n            if (templateMetadata) {\n                _this.initComponentFactory(metadata.componentFactory, templateMetadata.ngContentSelectors);\n            }\n            _this._directiveCache.set(directiveType, normalizedDirMeta);\n            _this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());\n            return normalizedDirMeta;\n        };\n        if (metadata.isComponent) {\n            var /** @type {?} */ templateMeta = this._directiveNormalizer.normalizeTemplate({\n                ngModuleType: ngModuleType,\n                componentType: directiveType,\n                moduleUrl: componentModuleUrl(this._reflector, directiveType, annotation),\n                encapsulation: metadata.template.encapsulation,\n                template: metadata.template.template,\n                templateUrl: metadata.template.templateUrl,\n                styles: metadata.template.styles,\n                styleUrls: metadata.template.styleUrls,\n                animations: metadata.template.animations,\n                interpolation: metadata.template.interpolation\n            });\n            if (templateMeta.syncResult) {\n                createDirectiveMetadata(templateMeta.syncResult);\n                return null;\n            }\n            else {\n                if (isSync) {\n                    this._reportError(componentStillLoadingError(directiveType), directiveType);\n                    return null;\n                }\n                return templateMeta.asyncResult.then(createDirectiveMetadata);\n            }\n        }\n        else {\n            // directive\n            createDirectiveMetadata(null);\n            return null;\n        }\n    };\n    /**\n     * @param {?} directiveType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getNonNormalizedDirectiveMetadata = function (directiveType) {\n        var _this = this;\n        directiveType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(directiveType);\n        if (!directiveType) {\n            return null;\n        }\n        var /** @type {?} */ cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);\n        if (cacheEntry) {\n            return cacheEntry;\n        }\n        var /** @type {?} */ dirMeta = this._directiveResolver.resolve(directiveType, false);\n        if (!dirMeta) {\n            return null;\n        }\n        var /** @type {?} */ nonNormalizedTemplateMetadata;\n        if (dirMeta instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */]) {\n            // component\n            assertArrayOfStrings('styles', dirMeta.styles);\n            assertArrayOfStrings('styleUrls', dirMeta.styleUrls);\n            assertInterpolationSymbols('interpolation', dirMeta.interpolation);\n            var /** @type {?} */ animations = dirMeta.animations;\n            nonNormalizedTemplateMetadata = new CompileTemplateMetadata({\n                encapsulation: dirMeta.encapsulation,\n                template: dirMeta.template,\n                templateUrl: dirMeta.templateUrl,\n                styles: dirMeta.styles,\n                styleUrls: dirMeta.styleUrls,\n                animations: animations,\n                interpolation: dirMeta.interpolation,\n                isInline: !!dirMeta.template\n            });\n        }\n        var /** @type {?} */ changeDetectionStrategy = null;\n        var /** @type {?} */ viewProviders = [];\n        var /** @type {?} */ entryComponentMetadata = [];\n        var /** @type {?} */ selector = dirMeta.selector;\n        if (dirMeta instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */]) {\n            // Component\n            changeDetectionStrategy = dirMeta.changeDetection;\n            if (dirMeta.viewProviders) {\n                viewProviders = this._getProvidersMetadata(dirMeta.viewProviders, entryComponentMetadata, \"viewProviders for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n            }\n            if (dirMeta.entryComponents) {\n                entryComponentMetadata = flattenAndDedupeArray(dirMeta.entryComponents)\n                    .map(function (type) { return _this._getEntryComponentMetadata(type); })\n                    .concat(entryComponentMetadata);\n            }\n            if (!selector) {\n                selector = this._schemaRegistry.getDefaultComponentElementName();\n            }\n        }\n        else {\n            // Directive\n            if (!selector) {\n                this._reportError(syntaxError(\"Directive \" + stringifyType(directiveType) + \" has no selector, please add it!\"), directiveType);\n                selector = 'error';\n            }\n        }\n        var /** @type {?} */ providers = [];\n        if (dirMeta.providers != null) {\n            providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, \"providers for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n        }\n        var /** @type {?} */ queries = [];\n        var /** @type {?} */ viewQueries = [];\n        if (dirMeta.queries != null) {\n            queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);\n            viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);\n        }\n        var /** @type {?} */ metadata = CompileDirectiveMetadata.create({\n            selector: selector,\n            exportAs: dirMeta.exportAs,\n            isComponent: !!nonNormalizedTemplateMetadata,\n            type: this._getTypeMetadata(directiveType),\n            template: nonNormalizedTemplateMetadata,\n            changeDetection: changeDetectionStrategy,\n            inputs: dirMeta.inputs,\n            outputs: dirMeta.outputs,\n            host: dirMeta.host,\n            providers: providers,\n            viewProviders: viewProviders,\n            queries: queries,\n            viewQueries: viewQueries,\n            entryComponents: entryComponentMetadata,\n            componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) :\n                undefined,\n            rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : undefined,\n            componentFactory: undefined\n        });\n        if (nonNormalizedTemplateMetadata) {\n            metadata.componentFactory =\n                this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);\n        }\n        cacheEntry = { metadata: metadata, annotation: dirMeta };\n        this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);\n        return cacheEntry;\n    };\n    /**\n     * Gets the metadata for the given directive.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     * @param {?} directiveType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType) {\n        var /** @type {?} */ dirMeta = this._directiveCache.get(directiveType);\n        if (!dirMeta) {\n            this._reportError(syntaxError(\"Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive \" + stringifyType(directiveType) + \".\"), directiveType);\n        }\n        return dirMeta;\n    };\n    /**\n     * @param {?} dirType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getDirectiveSummary = function (dirType) {\n        var /** @type {?} */ dirSummary = (this._loadSummary(dirType, CompileSummaryKind.Directive));\n        if (!dirSummary) {\n            this._reportError(syntaxError(\"Illegal state: Could not load the summary for directive \" + stringifyType(dirType) + \".\"), dirType);\n        }\n        return dirSummary;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isDirective = function (type) { return this._directiveResolver.isDirective(type); };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isPipe = function (type) { return this._pipeResolver.isPipe(type); };\n    /**\n     * @param {?} moduleType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getNgModuleSummary = function (moduleType) {\n        var /** @type {?} */ moduleSummary = (this._loadSummary(moduleType, CompileSummaryKind.NgModule));\n        if (!moduleSummary) {\n            var /** @type {?} */ moduleMeta = this.getNgModuleMetadata(moduleType, false);\n            moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;\n            if (moduleSummary) {\n                this._summaryCache.set(moduleType, moduleSummary);\n            }\n        }\n        return moduleSummary;\n    };\n    /**\n     * Loads the declared directives and pipes of an NgModule.\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.loadNgModuleDirectiveAndPipeMetadata = function (moduleType, isSync, throwIfNotFound) {\n        var _this = this;\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);\n        var /** @type {?} */ loading = [];\n        if (ngModule) {\n            ngModule.declaredDirectives.forEach(function (id) {\n                var /** @type {?} */ promise = _this._loadDirectiveMetadata(moduleType, id.reference, isSync);\n                if (promise) {\n                    loading.push(promise);\n                }\n            });\n            ngModule.declaredPipes.forEach(function (id) { return _this._loadPipeMetadata(id.reference); });\n        }\n        return Promise.all(loading);\n    };\n    /**\n     * @param {?} moduleType\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getNgModuleMetadata = function (moduleType, throwIfNotFound) {\n        var _this = this;\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        moduleType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(moduleType);\n        var /** @type {?} */ compileMeta = this._ngModuleCache.get(moduleType);\n        if (compileMeta) {\n            return compileMeta;\n        }\n        var /** @type {?} */ meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\n        if (!meta) {\n            return null;\n        }\n        var /** @type {?} */ declaredDirectives = [];\n        var /** @type {?} */ exportedNonModuleIdentifiers = [];\n        var /** @type {?} */ declaredPipes = [];\n        var /** @type {?} */ importedModules = [];\n        var /** @type {?} */ exportedModules = [];\n        var /** @type {?} */ providers = [];\n        var /** @type {?} */ entryComponents = [];\n        var /** @type {?} */ bootstrapComponents = [];\n        var /** @type {?} */ schemas = [];\n        if (meta.imports) {\n            flattenAndDedupeArray(meta.imports).forEach(function (importedType) {\n                var /** @type {?} */ importedModuleType;\n                if (isValidType(importedType)) {\n                    importedModuleType = importedType;\n                }\n                else if (importedType && importedType.ngModule) {\n                    var /** @type {?} */ moduleWithProviders = importedType;\n                    importedModuleType = moduleWithProviders.ngModule;\n                    if (moduleWithProviders.providers) {\n                        providers.push.apply(providers, _this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(importedModuleType) + \"'\", [], importedType));\n                    }\n                }\n                if (importedModuleType) {\n                    if (_this._checkSelfImport(moduleType, importedModuleType))\n                        return;\n                    var /** @type {?} */ importedModuleSummary = _this.getNgModuleSummary(importedModuleType);\n                    if (!importedModuleSummary) {\n                        _this._reportError(syntaxError(\"Unexpected \" + _this._getTypeDescriptor(importedType) + \" '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'. Please add a @NgModule annotation.\"), moduleType);\n                        return;\n                    }\n                    importedModules.push(importedModuleSummary);\n                }\n                else {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n            });\n        }\n        if (meta.exports) {\n            flattenAndDedupeArray(meta.exports).forEach(function (exportedType) {\n                if (!isValidType(exportedType)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(exportedType) + \"' exported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                var /** @type {?} */ exportedModuleSummary = _this.getNgModuleSummary(exportedType);\n                if (exportedModuleSummary) {\n                    exportedModules.push(exportedModuleSummary);\n                }\n                else {\n                    exportedNonModuleIdentifiers.push(_this._getIdentifierMetadata(exportedType));\n                }\n            });\n        }\n        // Note: This will be modified later, so we rely on\n        // getting a new instance every time!\n        var /** @type {?} */ transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\n        if (meta.declarations) {\n            flattenAndDedupeArray(meta.declarations).forEach(function (declaredType) {\n                if (!isValidType(declaredType)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                var /** @type {?} */ declaredIdentifier = _this._getIdentifierMetadata(declaredType);\n                if (_this._directiveResolver.isDirective(declaredType)) {\n                    transitiveModule.addDirective(declaredIdentifier);\n                    declaredDirectives.push(declaredIdentifier);\n                    _this._addTypeToModule(declaredType, moduleType);\n                }\n                else if (_this._pipeResolver.isPipe(declaredType)) {\n                    transitiveModule.addPipe(declaredIdentifier);\n                    transitiveModule.pipes.push(declaredIdentifier);\n                    declaredPipes.push(declaredIdentifier);\n                    _this._addTypeToModule(declaredType, moduleType);\n                }\n                else {\n                    _this._reportError(syntaxError(\"Unexpected \" + _this._getTypeDescriptor(declaredType) + \" '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'. Please add a @Pipe/@Directive/@Component annotation.\"), moduleType);\n                    return;\n                }\n            });\n        }\n        var /** @type {?} */ exportedDirectives = [];\n        var /** @type {?} */ exportedPipes = [];\n        exportedNonModuleIdentifiers.forEach(function (exportedId) {\n            if (transitiveModule.directivesSet.has(exportedId.reference)) {\n                exportedDirectives.push(exportedId);\n                transitiveModule.addExportedDirective(exportedId);\n            }\n            else if (transitiveModule.pipesSet.has(exportedId.reference)) {\n                exportedPipes.push(exportedId);\n                transitiveModule.addExportedPipe(exportedId);\n            }\n            else {\n                _this._reportError(syntaxError(\"Can't export \" + _this._getTypeDescriptor(exportedId.reference) + \" \" + stringifyType(exportedId.reference) + \" from \" + stringifyType(moduleType) + \" as it was neither declared nor imported!\"), moduleType);\n                return;\n            }\n        });\n        // The providers of the module have to go last\n        // so that they overwrite any other provider we already added.\n        if (meta.providers) {\n            providers.push.apply(providers, this._getProvidersMetadata(meta.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(moduleType) + \"'\", [], moduleType));\n        }\n        if (meta.entryComponents) {\n            entryComponents.push.apply(entryComponents, flattenAndDedupeArray(meta.entryComponents)\n                .map(function (type) { return _this._getEntryComponentMetadata(type); }));\n        }\n        if (meta.bootstrap) {\n            flattenAndDedupeArray(meta.bootstrap).forEach(function (type) {\n                if (!isValidType(type)) {\n                    _this._reportError(syntaxError(\"Unexpected value '\" + stringifyType(type) + \"' used in the bootstrap property of module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n                    return;\n                }\n                bootstrapComponents.push(_this._getIdentifierMetadata(type));\n            });\n        }\n        entryComponents.push.apply(entryComponents, bootstrapComponents.map(function (type) { return _this._getEntryComponentMetadata(type.reference); }));\n        if (meta.schemas) {\n            schemas.push.apply(schemas, flattenAndDedupeArray(meta.schemas));\n        }\n        compileMeta = new CompileNgModuleMetadata({\n            type: this._getTypeMetadata(moduleType),\n            providers: providers,\n            entryComponents: entryComponents,\n            bootstrapComponents: bootstrapComponents,\n            schemas: schemas,\n            declaredDirectives: declaredDirectives,\n            exportedDirectives: exportedDirectives,\n            declaredPipes: declaredPipes,\n            exportedPipes: exportedPipes,\n            importedModules: importedModules,\n            exportedModules: exportedModules,\n            transitiveModule: transitiveModule,\n            id: meta.id,\n        });\n        entryComponents.forEach(function (id) { return transitiveModule.addEntryComponent(id); });\n        providers.forEach(function (provider) { return transitiveModule.addProvider(provider, compileMeta.type); });\n        transitiveModule.addModule(compileMeta.type);\n        this._ngModuleCache.set(moduleType, compileMeta);\n        return compileMeta;\n    };\n    /**\n     * @param {?} moduleType\n     * @param {?} importedModuleType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._checkSelfImport = function (moduleType, importedModuleType) {\n        if (moduleType === importedModuleType) {\n            this._reportError(syntaxError(\"'\" + stringifyType(moduleType) + \"' module can't import itself\"), moduleType);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTypeDescriptor = function (type) {\n        if (this._directiveResolver.isDirective(type)) {\n            return 'directive';\n        }\n        if (this._pipeResolver.isPipe(type)) {\n            return 'pipe';\n        }\n        if (this._ngModuleResolver.isNgModule(type)) {\n            return 'module';\n        }\n        if (((type)).provide) {\n            return 'provider';\n        }\n        return 'value';\n    };\n    /**\n     * @param {?} type\n     * @param {?} moduleType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._addTypeToModule = function (type, moduleType) {\n        var /** @type {?} */ oldModule = this._ngModuleOfTypes.get(type);\n        if (oldModule && oldModule !== moduleType) {\n            this._reportError(syntaxError(\"Type \" + stringifyType(type) + \" is part of the declarations of 2 modules: \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \"! \" +\n                (\"Please consider moving \" + stringifyType(type) + \" to a higher module that imports \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \". \") +\n                (\"You can also create a new NgModule that exports and includes \" + stringifyType(type) + \" then import that NgModule in \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \".\")), moduleType);\n            return;\n        }\n        this._ngModuleOfTypes.set(type, moduleType);\n    };\n    /**\n     * @param {?} importedModules\n     * @param {?} exportedModules\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function (importedModules, exportedModules) {\n        // collect `providers` / `entryComponents` from all imported and all exported modules\n        var /** @type {?} */ result = new TransitiveCompileNgModuleMetadata();\n        var /** @type {?} */ modulesByToken = new Map();\n        importedModules.concat(exportedModules).forEach(function (modSummary) {\n            modSummary.modules.forEach(function (mod) { return result.addModule(mod); });\n            modSummary.entryComponents.forEach(function (comp) { return result.addEntryComponent(comp); });\n            var /** @type {?} */ addedTokens = new Set();\n            modSummary.providers.forEach(function (entry) {\n                var /** @type {?} */ tokenRef = tokenReference(entry.provider.token);\n                var /** @type {?} */ prevModules = modulesByToken.get(tokenRef);\n                if (!prevModules) {\n                    prevModules = new Set();\n                    modulesByToken.set(tokenRef, prevModules);\n                }\n                var /** @type {?} */ moduleRef = entry.module.reference;\n                // Note: the providers of one module may still contain multiple providers\n                // per token (e.g. for multi providers), and we need to preserve these.\n                if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {\n                    prevModules.add(moduleRef);\n                    addedTokens.add(tokenRef);\n                    result.addProvider(entry.provider, entry.module);\n                }\n            });\n        });\n        exportedModules.forEach(function (modSummary) {\n            modSummary.exportedDirectives.forEach(function (id) { return result.addExportedDirective(id); });\n            modSummary.exportedPipes.forEach(function (id) { return result.addExportedPipe(id); });\n        });\n        importedModules.forEach(function (modSummary) {\n            modSummary.exportedDirectives.forEach(function (id) { return result.addDirective(id); });\n            modSummary.exportedPipes.forEach(function (id) { return result.addPipe(id); });\n        });\n        return result;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getIdentifierMetadata = function (type) {\n        type = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(type);\n        return { reference: type };\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.isInjectable = function (type) {\n        var /** @type {?} */ annotations = this._reflector.annotations(type);\n        // Note: We need an exact check here as @Component / @Directive / ... inherit\n        // from @CompilerInjectable!\n        return annotations.some(function (ann) { return ann.constructor === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"e\" /* Injectable */]; });\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getInjectableSummary = function (type) {\n        return {\n            summaryKind: CompileSummaryKind.Injectable,\n            type: this._getTypeMetadata(type, null, false)\n        };\n    };\n    /**\n     * @param {?} type\n     * @param {?=} dependencies\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getInjectableMetadata = function (type, dependencies) {\n        if (dependencies === void 0) { dependencies = null; }\n        var /** @type {?} */ typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);\n        if (typeSummary) {\n            return typeSummary.type;\n        }\n        return this._getTypeMetadata(type, dependencies);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} dependencies\n     * @param {?=} throwOnUnknownDeps\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTypeMetadata = function (type, dependencies, throwOnUnknownDeps) {\n        if (dependencies === void 0) { dependencies = null; }\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var /** @type {?} */ identifier = this._getIdentifierMetadata(type);\n        return {\n            reference: identifier.reference,\n            diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),\n            lifecycleHooks: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_41\" /* ɵLIFECYCLE_HOOKS_VALUES */].filter(function (hook) { return hasLifecycleHook(hook, identifier.reference); }),\n        };\n    };\n    /**\n     * @param {?} factory\n     * @param {?=} dependencies\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getFactoryMetadata = function (factory, dependencies) {\n        if (dependencies === void 0) { dependencies = null; }\n        factory = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(factory);\n        return { reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies) };\n    };\n    /**\n     * Gets the metadata for the given pipe.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType) {\n        var /** @type {?} */ pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            this._reportError(syntaxError(\"Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n        }\n        return pipeMeta;\n    };\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getPipeSummary = function (pipeType) {\n        var /** @type {?} */ pipeSummary = (this._loadSummary(pipeType, CompileSummaryKind.Pipe));\n        if (!pipeSummary) {\n            this._reportError(syntaxError(\"Illegal state: Could not load the summary for pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n        }\n        return pipeSummary;\n    };\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getOrLoadPipeMetadata = function (pipeType) {\n        var /** @type {?} */ pipeMeta = this._pipeCache.get(pipeType);\n        if (!pipeMeta) {\n            pipeMeta = this._loadPipeMetadata(pipeType);\n        }\n        return pipeMeta;\n    };\n    /**\n     * @param {?} pipeType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._loadPipeMetadata = function (pipeType) {\n        pipeType = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(pipeType);\n        var /** @type {?} */ pipeAnnotation = this._pipeResolver.resolve(pipeType);\n        var /** @type {?} */ pipeMeta = new CompilePipeMetadata({\n            type: this._getTypeMetadata(pipeType),\n            name: pipeAnnotation.name,\n            pure: pipeAnnotation.pure\n        });\n        this._pipeCache.set(pipeType, pipeMeta);\n        this._summaryCache.set(pipeType, pipeMeta.toSummary());\n        return pipeMeta;\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @param {?} dependencies\n     * @param {?=} throwOnUnknownDeps\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getDependenciesMetadata = function (typeOrFunc, dependencies, throwOnUnknownDeps) {\n        var _this = this;\n        if (throwOnUnknownDeps === void 0) { throwOnUnknownDeps = true; }\n        var /** @type {?} */ hasUnknownDeps = false;\n        var /** @type {?} */ params = dependencies || this._reflector.parameters(typeOrFunc) || [];\n        var /** @type {?} */ dependenciesMetadata = params.map(function (param) {\n            var /** @type {?} */ isAttribute = false;\n            var /** @type {?} */ isHost = false;\n            var /** @type {?} */ isSelf = false;\n            var /** @type {?} */ isSkipSelf = false;\n            var /** @type {?} */ isOptional = false;\n            var /** @type {?} */ token = null;\n            if (Array.isArray(param)) {\n                param.forEach(function (paramEntry) {\n                    if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"R\" /* Host */]) {\n                        isHost = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_42\" /* Self */]) {\n                        isSelf = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"B\" /* SkipSelf */]) {\n                        isSkipSelf = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */]) {\n                        isOptional = true;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"S\" /* Attribute */]) {\n                        isAttribute = true;\n                        token = paramEntry.attributeName;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */]) {\n                        token = paramEntry.token;\n                    }\n                    else if (paramEntry instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"d\" /* InjectionToken */]) {\n                        token = paramEntry;\n                    }\n                    else if (isValidType(paramEntry) && token == null) {\n                        token = paramEntry;\n                    }\n                });\n            }\n            else {\n                token = param;\n            }\n            if (token == null) {\n                hasUnknownDeps = true;\n                return null;\n            }\n            return {\n                isAttribute: isAttribute,\n                isHost: isHost,\n                isSelf: isSelf,\n                isSkipSelf: isSkipSelf,\n                isOptional: isOptional,\n                token: _this._getTokenMetadata(token)\n            };\n        });\n        if (hasUnknownDeps) {\n            var /** @type {?} */ depsTokens = dependenciesMetadata.map(function (dep) { return dep ? stringifyType(dep.token) : '?'; }).join(', ');\n            var /** @type {?} */ message = \"Can't resolve all parameters for \" + stringifyType(typeOrFunc) + \": (\" + depsTokens + \").\";\n            if (throwOnUnknownDeps) {\n                this._reportError(syntaxError(message), typeOrFunc);\n            }\n            else {\n                this._console.warn(\"Warning: \" + message + \" This will become an error in Angular v5.x\");\n            }\n        }\n        return dependenciesMetadata;\n    };\n    /**\n     * @param {?} token\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getTokenMetadata = function (token) {\n        token = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(token);\n        var /** @type {?} */ compileToken;\n        if (typeof token === 'string') {\n            compileToken = { value: token };\n        }\n        else {\n            compileToken = { identifier: { reference: token } };\n        }\n        return compileToken;\n    };\n    /**\n     * @param {?} providers\n     * @param {?} targetEntryComponents\n     * @param {?=} debugInfo\n     * @param {?=} compileProviders\n     * @param {?=} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getProvidersMetadata = function (providers, targetEntryComponents, debugInfo, compileProviders, type) {\n        var _this = this;\n        if (compileProviders === void 0) { compileProviders = []; }\n        providers.forEach(function (provider, providerIdx) {\n            if (Array.isArray(provider)) {\n                _this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);\n            }\n            else {\n                provider = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(provider);\n                var /** @type {?} */ providerMeta = void 0;\n                if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {\n                    _this._validateProvider(provider);\n                    providerMeta = new ProviderMeta(provider.provide, provider);\n                }\n                else if (isValidType(provider)) {\n                    providerMeta = new ProviderMeta(provider, { useClass: provider });\n                }\n                else if (provider === void 0) {\n                    _this._reportError(syntaxError(\"Encountered undefined provider! Usually this means you have a circular dependencies (might be caused by using 'barrel' index.ts files.\"));\n                    return;\n                }\n                else {\n                    var /** @type {?} */ providersInfo = ((providers.reduce(function (soFar, seenProvider, seenProviderIdx) {\n                        if (seenProviderIdx < providerIdx) {\n                            soFar.push(\"\" + stringifyType(seenProvider));\n                        }\n                        else if (seenProviderIdx == providerIdx) {\n                            soFar.push(\"?\" + stringifyType(seenProvider) + \"?\");\n                        }\n                        else if (seenProviderIdx == providerIdx + 1) {\n                            soFar.push('...');\n                        }\n                        return soFar;\n                    }, [])))\n                        .join(', ');\n                    _this._reportError(syntaxError(\"Invalid \" + (debugInfo ? debugInfo : 'provider') + \" - only instances of Provider and Type are allowed, got: [\" + providersInfo + \"]\"), type);\n                    return;\n                }\n                if (providerMeta.token === resolveIdentifier(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {\n                    targetEntryComponents.push.apply(targetEntryComponents, _this._getEntryComponentsFromProvider(providerMeta, type));\n                }\n                else {\n                    compileProviders.push(_this.getProviderMetadata(providerMeta));\n                }\n            }\n        });\n        return compileProviders;\n    };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._validateProvider = function (provider) {\n        if (provider.hasOwnProperty('useClass') && provider.useClass == null) {\n            this._reportError(syntaxError(\"Invalid provider for \" + stringifyType(provider.provide) + \". useClass cannot be \" + provider.useClass + \".\\n           Usually it happens when:\\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\\n           2. Class was used before it was declared. Use forwardRef in this case.\"));\n        }\n    };\n    /**\n     * @param {?} provider\n     * @param {?=} type\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function (provider, type) {\n        var _this = this;\n        var /** @type {?} */ components = [];\n        var /** @type {?} */ collectedIdentifiers = [];\n        if (provider.useFactory || provider.useExisting || provider.useClass) {\n            this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!\"), type);\n            return [];\n        }\n        if (!provider.multi) {\n            this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!\"), type);\n            return [];\n        }\n        extractIdentifiers(provider.useValue, collectedIdentifiers);\n        collectedIdentifiers.forEach(function (identifier) {\n            var /** @type {?} */ entry = _this._getEntryComponentMetadata(identifier.reference, false);\n            if (entry) {\n                components.push(entry);\n            }\n        });\n        return components;\n    };\n    /**\n     * @param {?} dirType\n     * @param {?=} throwIfNotFound\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getEntryComponentMetadata = function (dirType, throwIfNotFound) {\n        if (throwIfNotFound === void 0) { throwIfNotFound = true; }\n        var /** @type {?} */ dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);\n        if (dirMeta && dirMeta.metadata.isComponent) {\n            return { componentType: dirType, componentFactory: dirMeta.metadata.componentFactory };\n        }\n        var /** @type {?} */ dirSummary = (this._loadSummary(dirType, CompileSummaryKind.Directive));\n        if (dirSummary && dirSummary.isComponent) {\n            return { componentType: dirType, componentFactory: dirSummary.componentFactory };\n        }\n        if (throwIfNotFound) {\n            throw syntaxError(dirType.name + \" cannot be used as an entry component.\");\n        }\n    };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {\n        var /** @type {?} */ compileDeps;\n        var /** @type {?} */ compileTypeMetadata = null;\n        var /** @type {?} */ compileFactoryMetadata = null;\n        var /** @type {?} */ token = this._getTokenMetadata(provider.token);\n        if (provider.useClass) {\n            compileTypeMetadata = this._getInjectableMetadata(provider.useClass, provider.dependencies);\n            compileDeps = compileTypeMetadata.diDeps;\n            if (provider.token === provider.useClass) {\n                // use the compileTypeMetadata as it contains information about lifecycleHooks...\n                token = { identifier: compileTypeMetadata };\n            }\n        }\n        else if (provider.useFactory) {\n            compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);\n            compileDeps = compileFactoryMetadata.diDeps;\n        }\n        return {\n            token: token,\n            useClass: compileTypeMetadata,\n            useValue: provider.useValue,\n            useFactory: compileFactoryMetadata,\n            useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : null,\n            deps: compileDeps,\n            multi: provider.multi\n        };\n    };\n    /**\n     * @param {?} queries\n     * @param {?} isViewQuery\n     * @param {?} directiveType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getQueriesMetadata = function (queries, isViewQuery, directiveType) {\n        var _this = this;\n        var /** @type {?} */ res = [];\n        Object.keys(queries).forEach(function (propertyName) {\n            var /** @type {?} */ query = queries[propertyName];\n            if (query.isViewQuery === isViewQuery) {\n                res.push(_this._getQueryMetadata(query, propertyName, directiveType));\n            }\n        });\n        return res;\n    };\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._queryVarBindings = function (selector) { return selector.split(/\\s*,\\s*/); };\n    /**\n     * @param {?} q\n     * @param {?} propertyName\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._getQueryMetadata = function (q, propertyName, typeOrFunc) {\n        var _this = this;\n        var /** @type {?} */ selectors;\n        if (typeof q.selector === 'string') {\n            selectors =\n                this._queryVarBindings(q.selector).map(function (varName) { return _this._getTokenMetadata(varName); });\n        }\n        else {\n            if (!q.selector) {\n                this._reportError(syntaxError(\"Can't construct a query for the property \\\"\" + propertyName + \"\\\" of \\\"\" + stringifyType(typeOrFunc) + \"\\\" since the query selector wasn't defined.\"), typeOrFunc);\n                selectors = [];\n            }\n            else {\n                selectors = [this._getTokenMetadata(q.selector)];\n            }\n        }\n        return {\n            selectors: selectors,\n            first: q.first,\n            descendants: q.descendants, propertyName: propertyName,\n            read: q.read ? this._getTokenMetadata(q.read) : null\n        };\n    };\n    /**\n     * @param {?} error\n     * @param {?=} type\n     * @param {?=} otherType\n     * @return {?}\n     */\n    CompileMetadataResolver.prototype._reportError = function (error, type, otherType) {\n        if (this._errorCollector) {\n            this._errorCollector(error, type);\n            if (otherType) {\n                this._errorCollector(error, otherType);\n            }\n        }\n        else {\n            throw error;\n        }\n    };\n    return CompileMetadataResolver;\n}());\nCompileMetadataResolver.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nCompileMetadataResolver.ctorParameters = function () { return [\n    { type: CompilerConfig, },\n    { type: NgModuleResolver, },\n    { type: DirectiveResolver, },\n    { type: PipeResolver, },\n    { type: SummaryResolver, },\n    { type: ElementSchemaRegistry, },\n    { type: DirectiveNormalizer, },\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */], },\n    { type: StaticSymbolCache, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */] },] },\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵReflectorReader */], },\n    { type: undefined, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */] }, { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */], args: [ERROR_COLLECTOR_TOKEN,] },] },\n]; };\n/**\n * @param {?} tree\n * @param {?=} out\n * @return {?}\n */\nfunction flattenArray(tree, out) {\n    if (out === void 0) { out = []; }\n    if (tree) {\n        for (var /** @type {?} */ i = 0; i < tree.length; i++) {\n            var /** @type {?} */ item = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_34\" /* resolveForwardRef */])(tree[i]);\n            if (Array.isArray(item)) {\n                flattenArray(item, out);\n            }\n            else {\n                out.push(item);\n            }\n        }\n    }\n    return out;\n}\n/**\n * @param {?} array\n * @return {?}\n */\nfunction dedupeArray(array) {\n    if (array) {\n        return Array.from(new Set(array));\n    }\n    return [];\n}\n/**\n * @param {?} tree\n * @return {?}\n */\nfunction flattenAndDedupeArray(tree) {\n    return dedupeArray(flattenArray(tree));\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction isValidType(value) {\n    return (value instanceof StaticSymbol) || (value instanceof __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_43\" /* Type */]);\n}\n/**\n * @param {?} reflector\n * @param {?} type\n * @param {?} cmpMetadata\n * @return {?}\n */\nfunction componentModuleUrl(reflector, type, cmpMetadata) {\n    if (type instanceof StaticSymbol) {\n        return reflector.resourceUri(type);\n    }\n    var /** @type {?} */ moduleId = cmpMetadata.moduleId;\n    if (typeof moduleId === 'string') {\n        var /** @type {?} */ scheme = getUrlScheme(moduleId);\n        return scheme ? moduleId : \"package:\" + moduleId + MODULE_SUFFIX;\n    }\n    else if (moduleId !== null && moduleId !== void 0) {\n        throw syntaxError(\"moduleId should be a string in \\\"\" + stringifyType(type) + \"\\\". See https://goo.gl/wIDDiL for more information.\\n\" +\n            \"If you're using Webpack you should inline the template and the styles, see https://goo.gl/X2J8zc.\");\n    }\n    return reflector.importUri(type);\n}\n/**\n * @param {?} value\n * @param {?} targetIdentifiers\n * @return {?}\n */\nfunction extractIdentifiers(value, targetIdentifiers) {\n    visitValue(value, new _CompileValueConverter(), targetIdentifiers);\n}\nvar _CompileValueConverter = (function (_super) {\n    __extends(_CompileValueConverter, _super);\n    function _CompileValueConverter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} value\n     * @param {?} targetIdentifiers\n     * @return {?}\n     */\n    _CompileValueConverter.prototype.visitOther = function (value, targetIdentifiers) {\n        targetIdentifiers.push({ reference: value });\n    };\n    return _CompileValueConverter;\n}(ValueTransformer));\n/**\n * @param {?} type\n * @return {?}\n */\nfunction stringifyType(type) {\n    if (type instanceof StaticSymbol) {\n        return type.name + \" in \" + type.filePath;\n    }\n    else {\n        return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(type);\n    }\n}\n/**\n * Indicates that a component is still being loaded in a synchronous compile.\n * @param {?} compType\n * @return {?}\n */\nfunction componentStillLoadingError(compType) {\n    var /** @type {?} */ error = Error(\"Can't compile synchronously as \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(compType) + \" is still being loaded!\");\n    ((error))[__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_44\" /* ɵERROR_COMPONENT_TYPE */]] = compType;\n    return error;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TypeModifier = {};\nTypeModifier.Const = 0;\nTypeModifier[TypeModifier.Const] = \"Const\";\n/**\n * @abstract\n */\nvar Type$1 = (function () {\n    /**\n     * @param {?=} modifiers\n     */\n    function Type$1(modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n    }\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Type$1.prototype.visitType = function (visitor, context) { };\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    Type$1.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };\n    return Type$1;\n}());\nvar BuiltinTypeName = {};\nBuiltinTypeName.Dynamic = 0;\nBuiltinTypeName.Bool = 1;\nBuiltinTypeName.String = 2;\nBuiltinTypeName.Int = 3;\nBuiltinTypeName.Number = 4;\nBuiltinTypeName.Function = 5;\nBuiltinTypeName.Inferred = 6;\nBuiltinTypeName[BuiltinTypeName.Dynamic] = \"Dynamic\";\nBuiltinTypeName[BuiltinTypeName.Bool] = \"Bool\";\nBuiltinTypeName[BuiltinTypeName.String] = \"String\";\nBuiltinTypeName[BuiltinTypeName.Int] = \"Int\";\nBuiltinTypeName[BuiltinTypeName.Number] = \"Number\";\nBuiltinTypeName[BuiltinTypeName.Function] = \"Function\";\nBuiltinTypeName[BuiltinTypeName.Inferred] = \"Inferred\";\nvar BuiltinType = (function (_super) {\n    __extends(BuiltinType, _super);\n    /**\n     * @param {?} name\n     * @param {?=} modifiers\n     */\n    function BuiltinType(name, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BuiltinType.prototype.visitType = function (visitor, context) {\n        return visitor.visitBuiltintType(this, context);\n    };\n    return BuiltinType;\n}(Type$1));\nvar ExpressionType = (function (_super) {\n    __extends(ExpressionType, _super);\n    /**\n     * @param {?} value\n     * @param {?=} modifiers\n     */\n    function ExpressionType(value, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExpressionType.prototype.visitType = function (visitor, context) {\n        return visitor.visitExpressionType(this, context);\n    };\n    return ExpressionType;\n}(Type$1));\nvar ArrayType = (function (_super) {\n    __extends(ArrayType, _super);\n    /**\n     * @param {?} of\n     * @param {?=} modifiers\n     */\n    function ArrayType(of, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.of = of;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ArrayType.prototype.visitType = function (visitor, context) {\n        return visitor.visitArrayType(this, context);\n    };\n    return ArrayType;\n}(Type$1));\nvar MapType = (function (_super) {\n    __extends(MapType, _super);\n    /**\n     * @param {?} valueType\n     * @param {?=} modifiers\n     */\n    function MapType(valueType, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers) || this;\n        _this.valueType = valueType;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    MapType.prototype.visitType = function (visitor, context) { return visitor.visitMapType(this, context); };\n    return MapType;\n}(Type$1));\nvar DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nvar INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nvar BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nvar INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nvar NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nvar STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nvar FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nvar BinaryOperator = {};\nBinaryOperator.Equals = 0;\nBinaryOperator.NotEquals = 1;\nBinaryOperator.Identical = 2;\nBinaryOperator.NotIdentical = 3;\nBinaryOperator.Minus = 4;\nBinaryOperator.Plus = 5;\nBinaryOperator.Divide = 6;\nBinaryOperator.Multiply = 7;\nBinaryOperator.Modulo = 8;\nBinaryOperator.And = 9;\nBinaryOperator.Or = 10;\nBinaryOperator.Lower = 11;\nBinaryOperator.LowerEquals = 12;\nBinaryOperator.Bigger = 13;\nBinaryOperator.BiggerEquals = 14;\nBinaryOperator[BinaryOperator.Equals] = \"Equals\";\nBinaryOperator[BinaryOperator.NotEquals] = \"NotEquals\";\nBinaryOperator[BinaryOperator.Identical] = \"Identical\";\nBinaryOperator[BinaryOperator.NotIdentical] = \"NotIdentical\";\nBinaryOperator[BinaryOperator.Minus] = \"Minus\";\nBinaryOperator[BinaryOperator.Plus] = \"Plus\";\nBinaryOperator[BinaryOperator.Divide] = \"Divide\";\nBinaryOperator[BinaryOperator.Multiply] = \"Multiply\";\nBinaryOperator[BinaryOperator.Modulo] = \"Modulo\";\nBinaryOperator[BinaryOperator.And] = \"And\";\nBinaryOperator[BinaryOperator.Or] = \"Or\";\nBinaryOperator[BinaryOperator.Lower] = \"Lower\";\nBinaryOperator[BinaryOperator.LowerEquals] = \"LowerEquals\";\nBinaryOperator[BinaryOperator.Bigger] = \"Bigger\";\nBinaryOperator[BinaryOperator.BiggerEquals] = \"BiggerEquals\";\n/**\n * @abstract\n */\nvar Expression = (function () {\n    /**\n     * @param {?} type\n     * @param {?=} sourceSpan\n     */\n    function Expression(type, sourceSpan) {\n        this.type = type;\n        this.sourceSpan = sourceSpan;\n    }\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Expression.prototype.visitExpression = function (visitor, context) { };\n    /**\n     * @param {?} name\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.prop = function (name, sourceSpan) {\n        return new ReadPropExpr(this, name, null, sourceSpan);\n    };\n    /**\n     * @param {?} index\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.key = function (index, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        return new ReadKeyExpr(this, index, type, sourceSpan);\n    };\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.callMethod = function (name, params, sourceSpan) {\n        return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n    };\n    /**\n     * @param {?} params\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.callFn = function (params, sourceSpan) {\n        return new InvokeFunctionExpr(this, params, null, sourceSpan);\n    };\n    /**\n     * @param {?} params\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.instantiate = function (params, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        return new InstantiateExpr(this, params, type, sourceSpan);\n    };\n    /**\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.conditional = function (trueCase, falseCase, sourceSpan) {\n        if (falseCase === void 0) { falseCase = null; }\n        return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.equals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.notEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.identical = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.notIdentical = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.minus = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.plus = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.divide = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.multiply = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.modulo = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.and = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.or = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.lower = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.lowerEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.bigger = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?} rhs\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.biggerEquals = function (rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    };\n    /**\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.isBlank = function (sourceSpan) {\n        // Note: We use equals by purpose here to compare to null and undefined in JS.\n        // We use the typed null to allow strictNullChecks to narrow types.\n        return this.equals(TYPED_NULL_EXPR, sourceSpan);\n    };\n    /**\n     * @param {?} type\n     * @param {?=} sourceSpan\n     * @return {?}\n     */\n    Expression.prototype.cast = function (type, sourceSpan) {\n        return new CastExpr(this, type, sourceSpan);\n    };\n    /**\n     * @return {?}\n     */\n    Expression.prototype.toStmt = function () { return new ExpressionStatement(this); };\n    return Expression;\n}());\nvar BuiltinVar = {};\nBuiltinVar.This = 0;\nBuiltinVar.Super = 1;\nBuiltinVar.CatchError = 2;\nBuiltinVar.CatchStack = 3;\nBuiltinVar[BuiltinVar.This] = \"This\";\nBuiltinVar[BuiltinVar.Super] = \"Super\";\nBuiltinVar[BuiltinVar.CatchError] = \"CatchError\";\nBuiltinVar[BuiltinVar.CatchStack] = \"CatchStack\";\nvar ReadVarExpr = (function (_super) {\n    __extends(ReadVarExpr, _super);\n    /**\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ReadVarExpr(name, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        if (typeof name === 'string') {\n            _this.name = name;\n            _this.builtin = null;\n        }\n        else {\n            _this.name = null;\n            _this.builtin = name;\n        }\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReadVarExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadVarExpr(this, context);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ReadVarExpr.prototype.set = function (value) {\n        return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    };\n    return ReadVarExpr;\n}(Expression));\nvar WriteVarExpr = (function (_super) {\n    __extends(WriteVarExpr, _super);\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function WriteVarExpr(name, value, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    WriteVarExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWriteVarExpr(this, context);\n    };\n    /**\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @return {?}\n     */\n    WriteVarExpr.prototype.toDeclStmt = function (type, modifiers) {\n        if (type === void 0) { type = null; }\n        if (modifiers === void 0) { modifiers = null; }\n        return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    };\n    return WriteVarExpr;\n}(Expression));\nvar WriteKeyExpr = (function (_super) {\n    __extends(WriteKeyExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} index\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function WriteKeyExpr(receiver, index, value, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.index = index;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    WriteKeyExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWriteKeyExpr(this, context);\n    };\n    return WriteKeyExpr;\n}(Expression));\nvar WritePropExpr = (function (_super) {\n    __extends(WritePropExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function WritePropExpr(receiver, name, value, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type || value.type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    WritePropExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitWritePropExpr(this, context);\n    };\n    return WritePropExpr;\n}(Expression));\nvar BuiltinMethod = {};\nBuiltinMethod.ConcatArray = 0;\nBuiltinMethod.SubscribeObservable = 1;\nBuiltinMethod.Bind = 2;\nBuiltinMethod[BuiltinMethod.ConcatArray] = \"ConcatArray\";\nBuiltinMethod[BuiltinMethod.SubscribeObservable] = \"SubscribeObservable\";\nBuiltinMethod[BuiltinMethod.Bind] = \"Bind\";\nvar InvokeMethodExpr = (function (_super) {\n    __extends(InvokeMethodExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} method\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function InvokeMethodExpr(receiver, method, args, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.args = args;\n        if (typeof method === 'string') {\n            _this.name = method;\n            _this.builtin = null;\n        }\n        else {\n            _this.name = null;\n            _this.builtin = method;\n        }\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    InvokeMethodExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInvokeMethodExpr(this, context);\n    };\n    return InvokeMethodExpr;\n}(Expression));\nvar InvokeFunctionExpr = (function (_super) {\n    __extends(InvokeFunctionExpr, _super);\n    /**\n     * @param {?} fn\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function InvokeFunctionExpr(fn, args, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.fn = fn;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    InvokeFunctionExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInvokeFunctionExpr(this, context);\n    };\n    return InvokeFunctionExpr;\n}(Expression));\nvar InstantiateExpr = (function (_super) {\n    __extends(InstantiateExpr, _super);\n    /**\n     * @param {?} classExpr\n     * @param {?} args\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function InstantiateExpr(classExpr, args, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.classExpr = classExpr;\n        _this.args = args;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    InstantiateExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitInstantiateExpr(this, context);\n    };\n    return InstantiateExpr;\n}(Expression));\nvar LiteralExpr = (function (_super) {\n    __extends(LiteralExpr, _super);\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function LiteralExpr(value, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    LiteralExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralExpr(this, context);\n    };\n    return LiteralExpr;\n}(Expression));\nvar ExternalExpr = (function (_super) {\n    __extends(ExternalExpr, _super);\n    /**\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} typeParams\n     * @param {?=} sourceSpan\n     */\n    function ExternalExpr(value, type, typeParams, sourceSpan) {\n        if (type === void 0) { type = null; }\n        if (typeParams === void 0) { typeParams = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        _this.typeParams = typeParams;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExternalExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitExternalExpr(this, context);\n    };\n    return ExternalExpr;\n}(Expression));\nvar ConditionalExpr = (function (_super) {\n    __extends(ConditionalExpr, _super);\n    /**\n     * @param {?} condition\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ConditionalExpr(condition, trueCase, falseCase, type, sourceSpan) {\n        if (falseCase === void 0) { falseCase = null; }\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type || trueCase.type, sourceSpan) || this;\n        _this.condition = condition;\n        _this.falseCase = falseCase;\n        _this.trueCase = trueCase;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ConditionalExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitConditionalExpr(this, context);\n    };\n    return ConditionalExpr;\n}(Expression));\nvar NotExpr = (function (_super) {\n    __extends(NotExpr, _super);\n    /**\n     * @param {?} condition\n     * @param {?=} sourceSpan\n     */\n    function NotExpr(condition, sourceSpan) {\n        var _this = _super.call(this, BOOL_TYPE, sourceSpan) || this;\n        _this.condition = condition;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    NotExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitNotExpr(this, context);\n    };\n    return NotExpr;\n}(Expression));\nvar CastExpr = (function (_super) {\n    __extends(CastExpr, _super);\n    /**\n     * @param {?} value\n     * @param {?} type\n     * @param {?=} sourceSpan\n     */\n    function CastExpr(value, type, sourceSpan) {\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    CastExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitCastExpr(this, context);\n    };\n    return CastExpr;\n}(Expression));\nvar FnParam = (function () {\n    /**\n     * @param {?} name\n     * @param {?=} type\n     */\n    function FnParam(name, type) {\n        if (type === void 0) { type = null; }\n        this.name = name;\n        this.type = type;\n    }\n    return FnParam;\n}());\nvar FunctionExpr = (function (_super) {\n    __extends(FunctionExpr, _super);\n    /**\n     * @param {?} params\n     * @param {?} statements\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function FunctionExpr(params, statements, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.params = params;\n        _this.statements = statements;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    FunctionExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitFunctionExpr(this, context);\n    };\n    /**\n     * @param {?} name\n     * @param {?=} modifiers\n     * @return {?}\n     */\n    FunctionExpr.prototype.toDeclStmt = function (name, modifiers) {\n        if (modifiers === void 0) { modifiers = null; }\n        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    };\n    return FunctionExpr;\n}(Expression));\nvar BinaryOperatorExpr = (function (_super) {\n    __extends(BinaryOperatorExpr, _super);\n    /**\n     * @param {?} operator\n     * @param {?} lhs\n     * @param {?} rhs\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function BinaryOperatorExpr(operator, lhs, rhs, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type || lhs.type, sourceSpan) || this;\n        _this.operator = operator;\n        _this.rhs = rhs;\n        _this.lhs = lhs;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    BinaryOperatorExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitBinaryOperatorExpr(this, context);\n    };\n    return BinaryOperatorExpr;\n}(Expression));\nvar ReadPropExpr = (function (_super) {\n    __extends(ReadPropExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ReadPropExpr(receiver, name, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.name = name;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReadPropExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadPropExpr(this, context);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ReadPropExpr.prototype.set = function (value) {\n        return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    };\n    return ReadPropExpr;\n}(Expression));\nvar ReadKeyExpr = (function (_super) {\n    __extends(ReadKeyExpr, _super);\n    /**\n     * @param {?} receiver\n     * @param {?} index\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function ReadKeyExpr(receiver, index, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.receiver = receiver;\n        _this.index = index;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReadKeyExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitReadKeyExpr(this, context);\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ReadKeyExpr.prototype.set = function (value) {\n        return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    };\n    return ReadKeyExpr;\n}(Expression));\nvar LiteralArrayExpr = (function (_super) {\n    __extends(LiteralArrayExpr, _super);\n    /**\n     * @param {?} entries\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function LiteralArrayExpr(entries, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.entries = entries;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    LiteralArrayExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralArrayExpr(this, context);\n    };\n    return LiteralArrayExpr;\n}(Expression));\nvar LiteralMapEntry = (function () {\n    /**\n     * @param {?} key\n     * @param {?} value\n     * @param {?=} quoted\n     */\n    function LiteralMapEntry(key, value, quoted) {\n        if (quoted === void 0) { quoted = false; }\n        this.key = key;\n        this.value = value;\n        this.quoted = quoted;\n    }\n    return LiteralMapEntry;\n}());\nvar LiteralMapExpr = (function (_super) {\n    __extends(LiteralMapExpr, _super);\n    /**\n     * @param {?} entries\n     * @param {?=} type\n     * @param {?=} sourceSpan\n     */\n    function LiteralMapExpr(entries, type, sourceSpan) {\n        if (type === void 0) { type = null; }\n        var _this = _super.call(this, type, sourceSpan) || this;\n        _this.entries = entries;\n        _this.valueType = null;\n        if (type) {\n            _this.valueType = type.valueType;\n        }\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    LiteralMapExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitLiteralMapExpr(this, context);\n    };\n    return LiteralMapExpr;\n}(Expression));\nvar CommaExpr = (function (_super) {\n    __extends(CommaExpr, _super);\n    /**\n     * @param {?} parts\n     * @param {?=} sourceSpan\n     */\n    function CommaExpr(parts, sourceSpan) {\n        var _this = _super.call(this, parts[parts.length - 1].type, sourceSpan) || this;\n        _this.parts = parts;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    CommaExpr.prototype.visitExpression = function (visitor, context) {\n        return visitor.visitCommaExpr(this, context);\n    };\n    return CommaExpr;\n}(Expression));\nvar THIS_EXPR = new ReadVarExpr(BuiltinVar.This);\nvar SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super);\nvar CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError);\nvar CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack);\nvar NULL_EXPR = new LiteralExpr(null, null);\nvar TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE);\nvar StmtModifier = {};\nStmtModifier.Final = 0;\nStmtModifier.Private = 1;\nStmtModifier[StmtModifier.Final] = \"Final\";\nStmtModifier[StmtModifier.Private] = \"Private\";\n/**\n * @abstract\n */\nvar Statement = (function () {\n    /**\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function Statement(modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        this.modifiers = modifiers;\n        this.sourceSpan = sourceSpan;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n    }\n    /**\n     * @abstract\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    Statement.prototype.visitStatement = function (visitor, context) { };\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    Statement.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };\n    return Statement;\n}());\nvar DeclareVarStmt = (function (_super) {\n    __extends(DeclareVarStmt, _super);\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function DeclareVarStmt(name, value, type, modifiers, sourceSpan) {\n        if (type === void 0) { type = null; }\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.value = value;\n        _this.type = type || value.type;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    DeclareVarStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareVarStmt(this, context);\n    };\n    return DeclareVarStmt;\n}(Statement));\nvar DeclareFunctionStmt = (function (_super) {\n    __extends(DeclareFunctionStmt, _super);\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?} statements\n     * @param {?=} type\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function DeclareFunctionStmt(name, params, statements, type, modifiers, sourceSpan) {\n        if (type === void 0) { type = null; }\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.params = params;\n        _this.statements = statements;\n        _this.type = type;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    DeclareFunctionStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareFunctionStmt(this, context);\n    };\n    return DeclareFunctionStmt;\n}(Statement));\nvar ExpressionStatement = (function (_super) {\n    __extends(ExpressionStatement, _super);\n    /**\n     * @param {?} expr\n     * @param {?=} sourceSpan\n     */\n    function ExpressionStatement(expr, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.expr = expr;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ExpressionStatement.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitExpressionStmt(this, context);\n    };\n    return ExpressionStatement;\n}(Statement));\nvar ReturnStatement = (function (_super) {\n    __extends(ReturnStatement, _super);\n    /**\n     * @param {?} value\n     * @param {?=} sourceSpan\n     */\n    function ReturnStatement(value, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.value = value;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ReturnStatement.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitReturnStmt(this, context);\n    };\n    return ReturnStatement;\n}(Statement));\nvar AbstractClassPart = (function () {\n    /**\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function AbstractClassPart(type, modifiers) {\n        if (type === void 0) { type = null; }\n        this.type = type;\n        this.modifiers = modifiers;\n        if (!modifiers) {\n            this.modifiers = [];\n        }\n    }\n    /**\n     * @param {?} modifier\n     * @return {?}\n     */\n    AbstractClassPart.prototype.hasModifier = function (modifier) { return this.modifiers.indexOf(modifier) !== -1; };\n    return AbstractClassPart;\n}());\nvar ClassField = (function (_super) {\n    __extends(ClassField, _super);\n    /**\n     * @param {?} name\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function ClassField(name, type, modifiers) {\n        if (type === void 0) { type = null; }\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        return _this;\n    }\n    return ClassField;\n}(AbstractClassPart));\nvar ClassMethod = (function (_super) {\n    __extends(ClassMethod, _super);\n    /**\n     * @param {?} name\n     * @param {?} params\n     * @param {?} body\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function ClassMethod(name, params, body, type, modifiers) {\n        if (type === void 0) { type = null; }\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.params = params;\n        _this.body = body;\n        return _this;\n    }\n    return ClassMethod;\n}(AbstractClassPart));\nvar ClassGetter = (function (_super) {\n    __extends(ClassGetter, _super);\n    /**\n     * @param {?} name\n     * @param {?} body\n     * @param {?=} type\n     * @param {?=} modifiers\n     */\n    function ClassGetter(name, body, type, modifiers) {\n        if (type === void 0) { type = null; }\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, type, modifiers) || this;\n        _this.name = name;\n        _this.body = body;\n        return _this;\n    }\n    return ClassGetter;\n}(AbstractClassPart));\nvar ClassStmt = (function (_super) {\n    __extends(ClassStmt, _super);\n    /**\n     * @param {?} name\n     * @param {?} parent\n     * @param {?} fields\n     * @param {?} getters\n     * @param {?} constructorMethod\n     * @param {?} methods\n     * @param {?=} modifiers\n     * @param {?=} sourceSpan\n     */\n    function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers, sourceSpan) {\n        if (modifiers === void 0) { modifiers = null; }\n        var _this = _super.call(this, modifiers, sourceSpan) || this;\n        _this.name = name;\n        _this.parent = parent;\n        _this.fields = fields;\n        _this.getters = getters;\n        _this.constructorMethod = constructorMethod;\n        _this.methods = methods;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ClassStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitDeclareClassStmt(this, context);\n    };\n    return ClassStmt;\n}(Statement));\nvar IfStmt = (function (_super) {\n    __extends(IfStmt, _super);\n    /**\n     * @param {?} condition\n     * @param {?} trueCase\n     * @param {?=} falseCase\n     * @param {?=} sourceSpan\n     */\n    function IfStmt(condition, trueCase, falseCase, sourceSpan) {\n        if (falseCase === void 0) { falseCase = []; }\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.condition = condition;\n        _this.trueCase = trueCase;\n        _this.falseCase = falseCase;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    IfStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitIfStmt(this, context);\n    };\n    return IfStmt;\n}(Statement));\nvar TryCatchStmt = (function (_super) {\n    __extends(TryCatchStmt, _super);\n    /**\n     * @param {?} bodyStmts\n     * @param {?} catchStmts\n     * @param {?=} sourceSpan\n     */\n    function TryCatchStmt(bodyStmts, catchStmts, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.bodyStmts = bodyStmts;\n        _this.catchStmts = catchStmts;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    TryCatchStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitTryCatchStmt(this, context);\n    };\n    return TryCatchStmt;\n}(Statement));\nvar ThrowStmt = (function (_super) {\n    __extends(ThrowStmt, _super);\n    /**\n     * @param {?} error\n     * @param {?=} sourceSpan\n     */\n    function ThrowStmt(error, sourceSpan) {\n        var _this = _super.call(this, null, sourceSpan) || this;\n        _this.error = error;\n        return _this;\n    }\n    /**\n     * @param {?} visitor\n     * @param {?} context\n     * @return {?}\n     */\n    ThrowStmt.prototype.visitStatement = function (visitor, context) {\n        return visitor.visitThrowStmt(this, context);\n    };\n    return ThrowStmt;\n}(Statement));\nvar AstTransformer$1 = (function () {\n    function AstTransformer$1() {\n    }\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.transformExpr = function (expr, context) { return expr; };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.transformStmt = function (stmt, context) { return stmt; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReadVarExpr = function (ast, context) { return this.transformExpr(ast, context); };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitWriteVarExpr = function (expr, context) {\n        return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitWriteKeyExpr = function (expr, context) {\n        return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitWritePropExpr = function (expr, context) {\n        return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitInvokeMethodExpr = function (ast, context) {\n        var /** @type {?} */ method = ast.builtin || ast.name;\n        return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitInvokeFunctionExpr = function (ast, context) {\n        return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitInstantiateExpr = function (ast, context) {\n        return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitLiteralExpr = function (ast, context) { return this.transformExpr(ast, context); };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitExternalExpr = function (ast, context) {\n        return this.transformExpr(ast, context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitConditionalExpr = function (ast, context) {\n        return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitNotExpr = function (ast, context) {\n        return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitCastExpr = function (ast, context) {\n        return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitFunctionExpr = function (ast, context) {\n        return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitBinaryOperatorExpr = function (ast, context) {\n        return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReadPropExpr = function (ast, context) {\n        return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReadKeyExpr = function (ast, context) {\n        return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitLiteralArrayExpr = function (ast, context) {\n        return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ entries = ast.entries.map(function (entry) { return new LiteralMapEntry(entry.key, entry.value.visitExpression(_this, context), entry.quoted); });\n        var /** @type {?} */ mapType = new MapType(ast.valueType);\n        return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitCommaExpr = function (ast, context) {\n        return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n    };\n    /**\n     * @param {?} exprs\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitAllExpressions = function (exprs, context) {\n        var _this = this;\n        return exprs.map(function (expr) { return expr.visitExpression(_this, context); });\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitDeclareVarStmt = function (stmt, context) {\n        return this.transformStmt(new DeclareVarStmt(stmt.name, stmt.value.visitExpression(this, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitExpressionStmt = function (stmt, context) {\n        return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitReturnStmt = function (stmt, context) {\n        return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitDeclareClassStmt = function (stmt, context) {\n        var _this = this;\n        var /** @type {?} */ parent = stmt.parent.visitExpression(this, context);\n        var /** @type {?} */ getters = stmt.getters.map(function (getter) { return new ClassGetter(getter.name, _this.visitAllStatements(getter.body, context), getter.type, getter.modifiers); });\n        var /** @type {?} */ ctorMethod = stmt.constructorMethod &&\n            new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\n        var /** @type {?} */ methods = stmt.methods.map(function (method) { return new ClassMethod(method.name, method.params, _this.visitAllStatements(method.body, context), method.type, method.modifiers); });\n        return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitIfStmt = function (stmt, context) {\n        return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitTryCatchStmt = function (stmt, context) {\n        return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitThrowStmt = function (stmt, context) {\n        return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitCommentStmt = function (stmt, context) {\n        return this.transformStmt(stmt, context);\n    };\n    /**\n     * @param {?} stmts\n     * @param {?} context\n     * @return {?}\n     */\n    AstTransformer$1.prototype.visitAllStatements = function (stmts, context) {\n        var _this = this;\n        return stmts.map(function (stmt) { return stmt.visitStatement(_this, context); });\n    };\n    return AstTransformer$1;\n}());\nvar RecursiveAstVisitor$1 = (function () {\n    function RecursiveAstVisitor$1() {\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReadVarExpr = function (ast, context) { return ast; };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitWriteVarExpr = function (expr, context) {\n        expr.value.visitExpression(this, context);\n        return expr;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitWriteKeyExpr = function (expr, context) {\n        expr.receiver.visitExpression(this, context);\n        expr.index.visitExpression(this, context);\n        expr.value.visitExpression(this, context);\n        return expr;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitWritePropExpr = function (expr, context) {\n        expr.receiver.visitExpression(this, context);\n        expr.value.visitExpression(this, context);\n        return expr;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitInvokeMethodExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitInvokeFunctionExpr = function (ast, context) {\n        ast.fn.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitInstantiateExpr = function (ast, context) {\n        ast.classExpr.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitLiteralExpr = function (ast, context) { return ast; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitExternalExpr = function (ast, context) { return ast; };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitConditionalExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        ast.trueCase.visitExpression(this, context);\n        ast.falseCase.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitNotExpr = function (ast, context) {\n        ast.condition.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitCastExpr = function (ast, context) {\n        ast.value.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitFunctionExpr = function (ast, context) {\n        this.visitAllStatements(ast.statements, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitBinaryOperatorExpr = function (ast, context) {\n        ast.lhs.visitExpression(this, context);\n        ast.rhs.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReadPropExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReadKeyExpr = function (ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitLiteralArrayExpr = function (ast, context) {\n        this.visitAllExpressions(ast.entries, context);\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitLiteralMapExpr = function (ast, context) {\n        var _this = this;\n        ast.entries.forEach(function (entry) { return entry.value.visitExpression(_this, context); });\n        return ast;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitCommaExpr = function (ast, context) {\n        this.visitAllExpressions(ast.parts, context);\n    };\n    /**\n     * @param {?} exprs\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitAllExpressions = function (exprs, context) {\n        var _this = this;\n        exprs.forEach(function (expr) { return expr.visitExpression(_this, context); });\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitDeclareVarStmt = function (stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        this.visitAllStatements(stmt.statements, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitExpressionStmt = function (stmt, context) {\n        stmt.expr.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitReturnStmt = function (stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitDeclareClassStmt = function (stmt, context) {\n        var _this = this;\n        stmt.parent.visitExpression(this, context);\n        stmt.getters.forEach(function (getter) { return _this.visitAllStatements(getter.body, context); });\n        if (stmt.constructorMethod) {\n            this.visitAllStatements(stmt.constructorMethod.body, context);\n        }\n        stmt.methods.forEach(function (method) { return _this.visitAllStatements(method.body, context); });\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitIfStmt = function (stmt, context) {\n        stmt.condition.visitExpression(this, context);\n        this.visitAllStatements(stmt.trueCase, context);\n        this.visitAllStatements(stmt.falseCase, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitTryCatchStmt = function (stmt, context) {\n        this.visitAllStatements(stmt.bodyStmts, context);\n        this.visitAllStatements(stmt.catchStmts, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitThrowStmt = function (stmt, context) {\n        stmt.error.visitExpression(this, context);\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitCommentStmt = function (stmt, context) { return stmt; };\n    /**\n     * @param {?} stmts\n     * @param {?} context\n     * @return {?}\n     */\n    RecursiveAstVisitor$1.prototype.visitAllStatements = function (stmts, context) {\n        var _this = this;\n        stmts.forEach(function (stmt) { return stmt.visitStatement(_this, context); });\n    };\n    return RecursiveAstVisitor$1;\n}());\n/**\n * @param {?} stmts\n * @return {?}\n */\nfunction findReadVarNames(stmts) {\n    var /** @type {?} */ visitor = new _ReadVarVisitor();\n    visitor.visitAllStatements(stmts, null);\n    return visitor.varNames;\n}\nvar _ReadVarVisitor = (function (_super) {\n    __extends(_ReadVarVisitor, _super);\n    function _ReadVarVisitor() {\n        var _this = _super.apply(this, arguments) || this;\n        _this.varNames = new Set();\n        return _this;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    _ReadVarVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n        // Don't descend into nested functions\n        return stmt;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    _ReadVarVisitor.prototype.visitDeclareClassStmt = function (stmt, context) {\n        // Don't descend into nested classes\n        return stmt;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _ReadVarVisitor.prototype.visitReadVarExpr = function (ast, context) {\n        this.varNames.add(ast.name);\n        return null;\n    };\n    return _ReadVarVisitor;\n}(RecursiveAstVisitor$1));\n/**\n * @param {?} stmt\n * @param {?} sourceSpan\n * @return {?}\n */\nfunction applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {\n    if (!sourceSpan) {\n        return stmt;\n    }\n    var /** @type {?} */ transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return stmt.visitStatement(transformer, null);\n}\n/**\n * @param {?} expr\n * @param {?} sourceSpan\n * @return {?}\n */\nfunction applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {\n    if (!sourceSpan) {\n        return expr;\n    }\n    var /** @type {?} */ transformer = new _ApplySourceSpanTransformer(sourceSpan);\n    return expr.visitExpression(transformer, null);\n}\nvar _ApplySourceSpanTransformer = (function (_super) {\n    __extends(_ApplySourceSpanTransformer, _super);\n    /**\n     * @param {?} sourceSpan\n     */\n    function _ApplySourceSpanTransformer(sourceSpan) {\n        var _this = _super.call(this) || this;\n        _this.sourceSpan = sourceSpan;\n        return _this;\n    }\n    /**\n     * @param {?} obj\n     * @return {?}\n     */\n    _ApplySourceSpanTransformer.prototype._clone = function (obj) {\n        var /** @type {?} */ clone = Object.create(obj.constructor.prototype);\n        for (var /** @type {?} */ prop in obj) {\n            clone[prop] = obj[prop];\n        }\n        return clone;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} context\n     * @return {?}\n     */\n    _ApplySourceSpanTransformer.prototype.transformExpr = function (expr, context) {\n        if (!expr.sourceSpan) {\n            expr = this._clone(expr);\n            expr.sourceSpan = this.sourceSpan;\n        }\n        return expr;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    _ApplySourceSpanTransformer.prototype.transformStmt = function (stmt, context) {\n        if (!stmt.sourceSpan) {\n            stmt = this._clone(stmt);\n            stmt.sourceSpan = this.sourceSpan;\n        }\n        return stmt;\n    };\n    return _ApplySourceSpanTransformer;\n}(AstTransformer$1));\n/**\n * @param {?} name\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction variable(name, type, sourceSpan) {\n    if (type === void 0) { type = null; }\n    return new ReadVarExpr(name, type, sourceSpan);\n}\n/**\n * @param {?} id\n * @param {?=} typeParams\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction importExpr(id, typeParams, sourceSpan) {\n    if (typeParams === void 0) { typeParams = null; }\n    return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n/**\n * @param {?} id\n * @param {?=} typeParams\n * @param {?=} typeModifiers\n * @return {?}\n */\nfunction importType(id, typeParams, typeModifiers) {\n    if (typeParams === void 0) { typeParams = null; }\n    if (typeModifiers === void 0) { typeModifiers = null; }\n    return id != null ? expressionType(importExpr(id, typeParams), typeModifiers) : null;\n}\n/**\n * @param {?} expr\n * @param {?=} typeModifiers\n * @return {?}\n */\nfunction expressionType(expr, typeModifiers) {\n    if (typeModifiers === void 0) { typeModifiers = null; }\n    return expr != null ? new ExpressionType(expr, typeModifiers) : null;\n}\n/**\n * @param {?} values\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction literalArr(values, type, sourceSpan) {\n    if (type === void 0) { type = null; }\n    return new LiteralArrayExpr(values, type, sourceSpan);\n}\n/**\n * @param {?} values\n * @param {?=} type\n * @param {?=} quoted\n * @return {?}\n */\nfunction literalMap(values, type, quoted) {\n    if (type === void 0) { type = null; }\n    if (quoted === void 0) { quoted = false; }\n    return new LiteralMapExpr(values.map(function (entry) { return new LiteralMapEntry(entry[0], entry[1], quoted); }), type);\n}\n/**\n * @param {?} expr\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction not(expr, sourceSpan) {\n    return new NotExpr(expr, sourceSpan);\n}\n/**\n * @param {?} params\n * @param {?} body\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction fn(params, body, type, sourceSpan) {\n    if (type === void 0) { type = null; }\n    return new FunctionExpr(params, body, type, sourceSpan);\n}\n/**\n * @param {?} value\n * @param {?=} type\n * @param {?=} sourceSpan\n * @return {?}\n */\nfunction literal(value, type, sourceSpan) {\n    if (type === void 0) { type = null; }\n    return new LiteralExpr(value, type, sourceSpan);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Create a new class stmts based on the given data.\n * @param {?} config\n * @return {?}\n */\nfunction createClassStmt(config) {\n    var /** @type {?} */ parentArgs = config.parentArgs || [];\n    var /** @type {?} */ superCtorStmts = config.parent ? [SUPER_EXPR.callFn(parentArgs).toStmt()] : [];\n    var /** @type {?} */ builder = concatClassBuilderParts(Array.isArray(config.builders) ? config.builders : [config.builders]);\n    var /** @type {?} */ ctor = new ClassMethod(null, config.ctorParams || [], superCtorStmts.concat(builder.ctorStmts));\n    return new ClassStmt(config.name, config.parent, builder.fields, builder.getters, ctor, builder.methods, config.modifiers || [], config.sourceSpan);\n}\n/**\n * @param {?} builders\n * @return {?}\n */\nfunction concatClassBuilderParts(builders) {\n    return {\n        fields: [].concat.apply([], builders.map(function (builder) { return builder.fields || []; })),\n        methods: [].concat.apply([], builders.map(function (builder) { return builder.methods || []; })),\n        getters: [].concat.apply([], builders.map(function (builder) { return builder.getters || []; })),\n        ctorStmts: [].concat.apply([], builders.map(function (builder) { return builder.ctorStmts || []; })),\n    };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar QUOTED_KEYS = '$quoted$';\n/**\n * @param {?} value\n * @param {?=} type\n * @return {?}\n */\nfunction convertValueToOutputAst(value, type) {\n    if (type === void 0) { type = null; }\n    return visitValue(value, new _ValueOutputAstTransformer(), type);\n}\nvar _ValueOutputAstTransformer = (function () {\n    function _ValueOutputAstTransformer() {\n    }\n    /**\n     * @param {?} arr\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitArray = function (arr, type) {\n        var _this = this;\n        return literalArr(arr.map(function (value) { return visitValue(value, _this, null); }), type);\n    };\n    /**\n     * @param {?} map\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitStringMap = function (map, type) {\n        var _this = this;\n        var /** @type {?} */ entries = [];\n        var /** @type {?} */ quotedSet = new Set(map && map[QUOTED_KEYS]);\n        Object.keys(map).forEach(function (key) {\n            entries.push(new LiteralMapEntry(key, visitValue(map[key], _this, null), quotedSet.has(key)));\n        });\n        return new LiteralMapExpr(entries, type);\n    };\n    /**\n     * @param {?} value\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, type) { return literal(value, type); };\n    /**\n     * @param {?} value\n     * @param {?} type\n     * @return {?}\n     */\n    _ValueOutputAstTransformer.prototype.visitOther = function (value, type) {\n        if (value instanceof Expression) {\n            return value;\n        }\n        else {\n            return importExpr({ reference: value });\n        }\n    };\n    return _ValueOutputAstTransformer;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This is currently not read, but will probably be used in the future.\n * We keep it as we already pass it through all the rigth places...\n */\nvar ComponentFactoryDependency = (function () {\n    /**\n     * @param {?} compType\n     */\n    function ComponentFactoryDependency(compType) {\n        this.compType = compType;\n    }\n    return ComponentFactoryDependency;\n}());\nvar NgModuleCompileResult = (function () {\n    /**\n     * @param {?} statements\n     * @param {?} ngModuleFactoryVar\n     * @param {?} dependencies\n     */\n    function NgModuleCompileResult(statements, ngModuleFactoryVar, dependencies) {\n        this.statements = statements;\n        this.ngModuleFactoryVar = ngModuleFactoryVar;\n        this.dependencies = dependencies;\n    }\n    return NgModuleCompileResult;\n}());\nvar NgModuleCompiler = (function () {\n    function NgModuleCompiler() {\n    }\n    /**\n     * @param {?} ngModuleMeta\n     * @param {?} extraProviders\n     * @return {?}\n     */\n    NgModuleCompiler.prototype.compile = function (ngModuleMeta, extraProviders) {\n        var /** @type {?} */ sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);\n        var /** @type {?} */ deps = [];\n        var /** @type {?} */ bootstrapComponentFactories = [];\n        var /** @type {?} */ entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents.map(function (entryComponent) {\n            if (ngModuleMeta.bootstrapComponents.some(function (id) { return id.reference === entryComponent.componentType; })) {\n                bootstrapComponentFactories.push({ reference: entryComponent.componentFactory });\n            }\n            deps.push(new ComponentFactoryDependency(entryComponent.componentType));\n            return { reference: entryComponent.componentFactory };\n        });\n        var /** @type {?} */ builder = new _InjectorBuilder(ngModuleMeta, entryComponentFactories, bootstrapComponentFactories, sourceSpan);\n        var /** @type {?} */ providerParser = new NgModuleProviderAnalyzer(ngModuleMeta, extraProviders, sourceSpan);\n        providerParser.parse().forEach(function (provider) { return builder.addProvider(provider); });\n        var /** @type {?} */ injectorClass = builder.build();\n        var /** @type {?} */ ngModuleFactoryVar = identifierName(ngModuleMeta.type) + \"NgFactory\";\n        var /** @type {?} */ ngModuleFactoryStmt = variable(ngModuleFactoryVar)\n            .set(importExpr(createIdentifier(Identifiers.NgModuleFactory))\n            .instantiate([variable(injectorClass.name), importExpr(ngModuleMeta.type)], importType(createIdentifier(Identifiers.NgModuleFactory), [importType(ngModuleMeta.type)], [TypeModifier.Const])))\n            .toDeclStmt(null, [StmtModifier.Final]);\n        var /** @type {?} */ stmts = [injectorClass, ngModuleFactoryStmt];\n        if (ngModuleMeta.id) {\n            var /** @type {?} */ registerFactoryStmt = importExpr(createIdentifier(Identifiers.RegisterModuleFactoryFn))\n                .callFn([literal(ngModuleMeta.id), variable(ngModuleFactoryVar)])\n                .toStmt();\n            stmts.push(registerFactoryStmt);\n        }\n        return new NgModuleCompileResult(stmts, ngModuleFactoryVar, deps);\n    };\n    return NgModuleCompiler;\n}());\nNgModuleCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nNgModuleCompiler.ctorParameters = function () { return []; };\nvar _InjectorBuilder = (function () {\n    /**\n     * @param {?} _ngModuleMeta\n     * @param {?} _entryComponentFactories\n     * @param {?} _bootstrapComponentFactories\n     * @param {?} _sourceSpan\n     */\n    function _InjectorBuilder(_ngModuleMeta, _entryComponentFactories, _bootstrapComponentFactories, _sourceSpan) {\n        this._ngModuleMeta = _ngModuleMeta;\n        this._entryComponentFactories = _entryComponentFactories;\n        this._bootstrapComponentFactories = _bootstrapComponentFactories;\n        this._sourceSpan = _sourceSpan;\n        this.fields = [];\n        this.getters = [];\n        this.methods = [];\n        this.ctorStmts = [];\n        this._lazyProps = new Map();\n        this._tokens = [];\n        this._instances = new Map();\n        this._createStmts = [];\n        this._destroyStmts = [];\n    }\n    /**\n     * @param {?} resolvedProvider\n     * @return {?}\n     */\n    _InjectorBuilder.prototype.addProvider = function (resolvedProvider) {\n        var _this = this;\n        var /** @type {?} */ providerValueExpressions = resolvedProvider.providers.map(function (provider) { return _this._getProviderValue(provider); });\n        var /** @type {?} */ propName = \"_\" + tokenName(resolvedProvider.token) + \"_\" + this._instances.size;\n        var /** @type {?} */ instance = this._createProviderProperty(propName, resolvedProvider, providerValueExpressions, resolvedProvider.multiProvider, resolvedProvider.eager);\n        if (resolvedProvider.lifecycleHooks.indexOf(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnDestroy) !== -1) {\n            var /** @type {?} */ callNgOnDestroy = instance.callMethod('ngOnDestroy', []);\n            if (!resolvedProvider.eager) {\n                callNgOnDestroy = this._lazyProps.get(instance.name).and(callNgOnDestroy);\n            }\n            this._destroyStmts.push(callNgOnDestroy.toStmt());\n        }\n        this._tokens.push(resolvedProvider.token);\n        this._instances.set(tokenReference(resolvedProvider.token), instance);\n    };\n    /**\n     * @return {?}\n     */\n    _InjectorBuilder.prototype.build = function () {\n        var _this = this;\n        var /** @type {?} */ getMethodStmts = this._tokens.map(function (token) {\n            var /** @type {?} */ providerExpr = _this._instances.get(tokenReference(token));\n            return new IfStmt(InjectMethodVars.token.identical(createDiTokenExpression(token)), [new ReturnStatement(providerExpr)]);\n        });\n        var /** @type {?} */ methods = [\n            new ClassMethod('createInternal', [], this._createStmts.concat(new ReturnStatement(this._instances.get(this._ngModuleMeta.type.reference))), importType(this._ngModuleMeta.type)),\n            new ClassMethod('getInternal', [\n                new FnParam(InjectMethodVars.token.name, DYNAMIC_TYPE),\n                new FnParam(InjectMethodVars.notFoundResult.name, DYNAMIC_TYPE)\n            ], getMethodStmts.concat([new ReturnStatement(InjectMethodVars.notFoundResult)]), DYNAMIC_TYPE),\n            new ClassMethod('destroyInternal', [], this._destroyStmts),\n        ];\n        var /** @type {?} */ parentArgs = [\n            variable(InjectorProps.parent.name),\n            literalArr(this._entryComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); })),\n            literalArr(this._bootstrapComponentFactories.map(function (componentFactory) { return importExpr(componentFactory); }))\n        ];\n        var /** @type {?} */ injClassName = identifierName(this._ngModuleMeta.type) + \"Injector\";\n        return createClassStmt({\n            name: injClassName,\n            ctorParams: [new FnParam(InjectorProps.parent.name, importType(createIdentifier(Identifiers.Injector)))],\n            parent: importExpr(createIdentifier(Identifiers.NgModuleInjector), [importType(this._ngModuleMeta.type)]),\n            parentArgs: parentArgs,\n            builders: [{ methods: methods }, this]\n        });\n    };\n    /**\n     * @param {?} provider\n     * @return {?}\n     */\n    _InjectorBuilder.prototype._getProviderValue = function (provider) {\n        var _this = this;\n        var /** @type {?} */ result;\n        if (provider.useExisting != null) {\n            result = this._getDependency({ token: provider.useExisting });\n        }\n        else if (provider.useFactory != null) {\n            var /** @type {?} */ deps = provider.deps || provider.useFactory.diDeps;\n            var /** @type {?} */ depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });\n            result = importExpr(provider.useFactory).callFn(depsExpr);\n        }\n        else if (provider.useClass != null) {\n            var /** @type {?} */ deps = provider.deps || provider.useClass.diDeps;\n            var /** @type {?} */ depsExpr = deps.map(function (dep) { return _this._getDependency(dep); });\n            result =\n                importExpr(provider.useClass).instantiate(depsExpr, importType(provider.useClass));\n        }\n        else {\n            result = convertValueToOutputAst(provider.useValue);\n        }\n        return result;\n    };\n    /**\n     * @param {?} propName\n     * @param {?} provider\n     * @param {?} providerValueExpressions\n     * @param {?} isMulti\n     * @param {?} isEager\n     * @return {?}\n     */\n    _InjectorBuilder.prototype._createProviderProperty = function (propName, provider, providerValueExpressions, isMulti, isEager) {\n        var /** @type {?} */ resolvedProviderValueExpr;\n        var /** @type {?} */ type;\n        if (isMulti) {\n            resolvedProviderValueExpr = literalArr(providerValueExpressions);\n            type = new ArrayType(DYNAMIC_TYPE);\n        }\n        else {\n            resolvedProviderValueExpr = providerValueExpressions[0];\n            type = providerValueExpressions[0].type;\n        }\n        if (!type) {\n            type = DYNAMIC_TYPE;\n        }\n        if (isEager) {\n            this.fields.push(new ClassField(propName, type));\n            this._createStmts.push(THIS_EXPR.prop(propName).set(resolvedProviderValueExpr).toStmt());\n        }\n        else {\n            var /** @type {?} */ internalFieldProp = THIS_EXPR.prop(\"_\" + propName);\n            this.fields.push(new ClassField(internalFieldProp.name, type));\n            // Note: Equals is important for JS so that it also checks the undefined case!\n            var /** @type {?} */ getterStmts = [\n                new IfStmt(internalFieldProp.isBlank(), [internalFieldProp.set(resolvedProviderValueExpr).toStmt()]),\n                new ReturnStatement(internalFieldProp)\n            ];\n            this.getters.push(new ClassGetter(propName, getterStmts, type));\n            this._lazyProps.set(propName, internalFieldProp);\n        }\n        return THIS_EXPR.prop(propName);\n    };\n    /**\n     * @param {?} dep\n     * @return {?}\n     */\n    _InjectorBuilder.prototype._getDependency = function (dep) {\n        var /** @type {?} */ result = null;\n        if (dep.isValue) {\n            result = literal(dep.value);\n        }\n        if (!dep.isSkipSelf) {\n            if (dep.token) {\n                if (tokenReference(dep.token) === resolveIdentifier(Identifiers.Injector)) {\n                    result = THIS_EXPR;\n                }\n                else if (tokenReference(dep.token) === resolveIdentifier(Identifiers.ComponentFactoryResolver)) {\n                    result = THIS_EXPR.prop('componentFactoryResolver');\n                }\n            }\n            if (!result) {\n                result = this._instances.get(tokenReference(dep.token));\n            }\n        }\n        if (!result) {\n            var /** @type {?} */ args = [createDiTokenExpression(dep.token)];\n            if (dep.isOptional) {\n                args.push(NULL_EXPR);\n            }\n            result = InjectorProps.parent.callMethod('get', args);\n        }\n        return result;\n    };\n    return _InjectorBuilder;\n}());\n/**\n * @param {?} token\n * @return {?}\n */\nfunction createDiTokenExpression(token) {\n    if (token.value != null) {\n        return literal(token.value);\n    }\n    else {\n        return importExpr(token.identifier);\n    }\n}\nvar InjectorProps = (function () {\n    function InjectorProps() {\n    }\n    return InjectorProps;\n}());\nInjectorProps.parent = THIS_EXPR.prop('parent');\nvar InjectMethodVars = (function () {\n    function InjectMethodVars() {\n    }\n    return InjectMethodVars;\n}());\nInjectMethodVars.token = variable('token');\nInjectMethodVars.notFoundResult = variable('notFoundResult');\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nvar VERSION$1 = 3;\nvar JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nvar SourceMapGenerator = (function () {\n    /**\n     * @param {?=} file\n     */\n    function SourceMapGenerator(file) {\n        if (file === void 0) { file = null; }\n        this.file = file;\n        this.sourcesContent = new Map();\n        this.lines = [];\n        this.lastCol0 = 0;\n        this.hasMappings = false;\n    }\n    /**\n     * @param {?} url\n     * @param {?=} content\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.addSource = function (url, content) {\n        if (content === void 0) { content = null; }\n        if (!this.sourcesContent.has(url)) {\n            this.sourcesContent.set(url, content);\n        }\n        return this;\n    };\n    /**\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.addLine = function () {\n        this.lines.push([]);\n        this.lastCol0 = 0;\n        return this;\n    };\n    /**\n     * @param {?} col0\n     * @param {?=} sourceUrl\n     * @param {?=} sourceLine0\n     * @param {?=} sourceCol0\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.addMapping = function (col0, sourceUrl, sourceLine0, sourceCol0) {\n        if (!this.currentLine) {\n            throw new Error(\"A line must be added before mappings can be added\");\n        }\n        if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n            throw new Error(\"Unknown source file \\\"\" + sourceUrl + \"\\\"\");\n        }\n        if (col0 == null) {\n            throw new Error(\"The column in the generated code must be provided\");\n        }\n        if (col0 < this.lastCol0) {\n            throw new Error(\"Mapping should be added in output order\");\n        }\n        if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n            throw new Error(\"The source location must be provided when a source url is provided\");\n        }\n        this.hasMappings = true;\n        this.lastCol0 = col0;\n        this.currentLine.push({ col0: col0, sourceUrl: sourceUrl, sourceLine0: sourceLine0, sourceCol0: sourceCol0 });\n        return this;\n    };\n    Object.defineProperty(SourceMapGenerator.prototype, \"currentLine\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this.lines.slice(-1)[0]; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.toJSON = function () {\n        var _this = this;\n        if (!this.hasMappings) {\n            return null;\n        }\n        var /** @type {?} */ sourcesIndex = new Map();\n        var /** @type {?} */ sources = [];\n        var /** @type {?} */ sourcesContent = [];\n        Array.from(this.sourcesContent.keys()).forEach(function (url, i) {\n            sourcesIndex.set(url, i);\n            sources.push(url);\n            sourcesContent.push(_this.sourcesContent.get(url) || null);\n        });\n        var /** @type {?} */ mappings = '';\n        var /** @type {?} */ lastCol0 = 0;\n        var /** @type {?} */ lastSourceIndex = 0;\n        var /** @type {?} */ lastSourceLine0 = 0;\n        var /** @type {?} */ lastSourceCol0 = 0;\n        this.lines.forEach(function (segments) {\n            lastCol0 = 0;\n            mappings += segments\n                .map(function (segment) {\n                // zero-based starting column of the line in the generated code\n                var /** @type {?} */ segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                lastCol0 = segment.col0;\n                if (segment.sourceUrl != null) {\n                    // zero-based index into the “sources” list\n                    segAsStr +=\n                        toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n                    lastSourceIndex = sourcesIndex.get(segment.sourceUrl);\n                    // the zero-based starting line in the original source\n                    segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n                    lastSourceLine0 = segment.sourceLine0;\n                    // the zero-based starting column in the original source\n                    segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n                    lastSourceCol0 = segment.sourceCol0;\n                }\n                return segAsStr;\n            })\n                .join(',');\n            mappings += ';';\n        });\n        mappings = mappings.slice(0, -1);\n        return {\n            'file': this.file || '',\n            'version': VERSION$1,\n            'sourceRoot': '',\n            'sources': sources,\n            'sourcesContent': sourcesContent,\n            'mappings': mappings,\n        };\n    };\n    /**\n     * @return {?}\n     */\n    SourceMapGenerator.prototype.toJsComment = function () {\n        return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n            '';\n    };\n    return SourceMapGenerator;\n}());\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64String(value) {\n    var /** @type {?} */ b64 = '';\n    value = utf8Encode(value);\n    for (var /** @type {?} */ i = 0; i < value.length;) {\n        var /** @type {?} */ i1 = value.charCodeAt(i++);\n        var /** @type {?} */ i2 = value.charCodeAt(i++);\n        var /** @type {?} */ i3 = value.charCodeAt(i++);\n        b64 += toBase64Digit(i1 >> 2);\n        b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));\n        b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));\n        b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);\n    }\n    return b64;\n}\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64VLQ(value) {\n    value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n    var /** @type {?} */ out = '';\n    do {\n        var /** @type {?} */ digit = value & 31;\n        value = value >> 5;\n        if (value > 0) {\n            digit = digit | 32;\n        }\n        out += toBase64Digit(digit);\n    } while (value > 0);\n    return out;\n}\nvar B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n/**\n * @param {?} value\n * @return {?}\n */\nfunction toBase64Digit(value) {\n    if (value < 0 || value >= 64) {\n        throw new Error(\"Can only encode value in the range [0, 63]\");\n    }\n    return B64_DIGITS[value];\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nvar _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nvar _INDENT_WITH = '  ';\nvar CATCH_ERROR_VAR$1 = variable('error');\nvar CATCH_STACK_VAR$1 = variable('stack');\n/**\n * @abstract\n */\nvar _EmittedLine = (function () {\n    /**\n     * @param {?} indent\n     */\n    function _EmittedLine(indent) {\n        this.indent = indent;\n        this.parts = [];\n        this.srcSpans = [];\n    }\n    return _EmittedLine;\n}());\nvar EmitterVisitorContext = (function () {\n    /**\n     * @param {?} _exportedVars\n     * @param {?} _indent\n     */\n    function EmitterVisitorContext(_exportedVars, _indent) {\n        this._exportedVars = _exportedVars;\n        this._indent = _indent;\n        this._classes = [];\n        this._lines = [new _EmittedLine(_indent)];\n    }\n    /**\n     * @param {?} exportedVars\n     * @return {?}\n     */\n    EmitterVisitorContext.createRoot = function (exportedVars) {\n        return new EmitterVisitorContext(exportedVars, 0);\n    };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"_currentLine\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._lines[this._lines.length - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} varName\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.isExportedVar = function (varName) { return this._exportedVars.indexOf(varName) !== -1; };\n    /**\n     * @param {?=} from\n     * @param {?=} lastPart\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.println = function (from, lastPart) {\n        if (lastPart === void 0) { lastPart = ''; }\n        this.print(from, lastPart, true);\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.lineIsEmpty = function () { return this._currentLine.parts.length === 0; };\n    /**\n     * @param {?} from\n     * @param {?} part\n     * @param {?=} newLine\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.print = function (from, part, newLine) {\n        if (newLine === void 0) { newLine = false; }\n        if (part.length > 0) {\n            this._currentLine.parts.push(part);\n            this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n        }\n        if (newLine) {\n            this._lines.push(new _EmittedLine(this._indent));\n        }\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.removeEmptyLastLine = function () {\n        if (this.lineIsEmpty()) {\n            this._lines.pop();\n        }\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.incIndent = function () {\n        this._indent++;\n        this._currentLine.indent = this._indent;\n    };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.decIndent = function () {\n        this._indent--;\n        this._currentLine.indent = this._indent;\n    };\n    /**\n     * @param {?} clazz\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.pushClass = function (clazz) { this._classes.push(clazz); };\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.popClass = function () { return this._classes.pop(); };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"currentClass\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.toSource = function () {\n        return this.sourceLines\n            .map(function (l) { return l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : ''; })\n            .join('\\n');\n    };\n    /**\n     * @param {?} sourceFilePath\n     * @param {?} genFilePath\n     * @param {?=} startsAtLine\n     * @return {?}\n     */\n    EmitterVisitorContext.prototype.toSourceMapGenerator = function (sourceFilePath, genFilePath, startsAtLine) {\n        if (startsAtLine === void 0) { startsAtLine = 0; }\n        var /** @type {?} */ map = new SourceMapGenerator(genFilePath);\n        var /** @type {?} */ firstOffsetMapped = false;\n        var /** @type {?} */ mapFirstOffsetIfNeeded = function () {\n            if (!firstOffsetMapped) {\n                // Add a single space so that tools won't try to load the file from disk.\n                // Note: We are using virtual urls like `ng:///`, so we have to\n                // provide a content here.\n                map.addSource(sourceFilePath, ' ').addMapping(0, sourceFilePath, 0, 0);\n                firstOffsetMapped = true;\n            }\n        };\n        for (var /** @type {?} */ i = 0; i < startsAtLine; i++) {\n            map.addLine();\n            mapFirstOffsetIfNeeded();\n        }\n        this.sourceLines.forEach(function (line, lineIdx) {\n            map.addLine();\n            var /** @type {?} */ spans = line.srcSpans;\n            var /** @type {?} */ parts = line.parts;\n            var /** @type {?} */ col0 = line.indent * _INDENT_WITH.length;\n            var /** @type {?} */ spanIdx = 0;\n            // skip leading parts without source spans\n            while (spanIdx < spans.length && !spans[spanIdx]) {\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n            }\n            if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n                firstOffsetMapped = true;\n            }\n            else {\n                mapFirstOffsetIfNeeded();\n            }\n            while (spanIdx < spans.length) {\n                var /** @type {?} */ span = spans[spanIdx];\n                var /** @type {?} */ source = span.start.file;\n                var /** @type {?} */ sourceLine = span.start.line;\n                var /** @type {?} */ sourceCol = span.start.col;\n                map.addSource(source.url, source.content)\n                    .addMapping(col0, source.url, sourceLine, sourceCol);\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n                // assign parts without span or the same span to the previous segment\n                while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n                    col0 += parts[spanIdx].length;\n                    spanIdx++;\n                }\n            }\n        });\n        return map;\n    };\n    Object.defineProperty(EmitterVisitorContext.prototype, \"sourceLines\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n                return this._lines.slice(0, -1);\n            }\n            return this._lines;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return EmitterVisitorContext;\n}());\n/**\n * @abstract\n */\nvar AbstractEmitterVisitor = (function () {\n    /**\n     * @param {?} _escapeDollarInStrings\n     */\n    function AbstractEmitterVisitor(_escapeDollarInStrings) {\n        this._escapeDollarInStrings = _escapeDollarInStrings;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {\n        stmt.expr.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"return \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCastExpr = function (ast, context) { };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) { };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"if (\");\n        stmt.condition.visitExpression(this, ctx);\n        ctx.print(stmt, \") {\");\n        var /** @type {?} */ hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n        if (stmt.trueCase.length <= 1 && !hasElseCase) {\n            ctx.print(stmt, \" \");\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.removeEmptyLastLine();\n            ctx.print(stmt, \" \");\n        }\n        else {\n            ctx.println();\n            ctx.incIndent();\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.decIndent();\n            if (hasElseCase) {\n                ctx.println(stmt, \"} else {\");\n                ctx.incIndent();\n                this.visitAllStatements(stmt.falseCase, ctx);\n                ctx.decIndent();\n            }\n        }\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) { };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"throw \");\n        stmt.error.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCommentStmt = function (stmt, ctx) {\n        var /** @type {?} */ lines = stmt.comment.split('\\n');\n        lines.forEach(function (line) { ctx.println(stmt, \"// \" + line); });\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) { };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {\n        var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        ctx.print(expr, expr.name + \" = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {\n        var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, \"[\");\n        expr.index.visitExpression(this, ctx);\n        ctx.print(expr, \"] = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {\n        var /** @type {?} */ lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, \".\" + expr.name + \" = \");\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n        expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ name = expr.name;\n        if (expr.builtin != null) {\n            name = this.getBuiltinMethodName(expr.builtin);\n            if (name == null) {\n                // some builtins just mean to skip the call.\n                return null;\n            }\n        }\n        ctx.print(expr, \".\" + name + \"(\");\n        this.visitAllExpressions(expr.args, ctx, \",\");\n        ctx.print(expr, \")\");\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} method\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.getBuiltinMethodName = function (method) { };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n        expr.fn.visitExpression(this, ctx);\n        ctx.print(expr, \"(\");\n        this.visitAllExpressions(expr.args, ctx, ',');\n        ctx.print(expr, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n        var /** @type {?} */ varName = ast.name;\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case BuiltinVar.Super:\n                    varName = 'super';\n                    break;\n                case BuiltinVar.This:\n                    varName = 'this';\n                    break;\n                case BuiltinVar.CatchError:\n                    varName = CATCH_ERROR_VAR$1.name;\n                    break;\n                case BuiltinVar.CatchStack:\n                    varName = CATCH_STACK_VAR$1.name;\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin variable \" + ast.builtin);\n            }\n        }\n        ctx.print(ast, varName);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n        ctx.print(ast, \"new \");\n        ast.classExpr.visitExpression(this, ctx);\n        ctx.print(ast, \"(\");\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n        var /** @type {?} */ value = ast.value;\n        if (typeof value === 'string') {\n            ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n        }\n        else {\n            ctx.print(ast, \"\" + value);\n        }\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) { };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {\n        ctx.print(ast, \"(\");\n        ast.condition.visitExpression(this, ctx);\n        ctx.print(ast, '? ');\n        ast.trueCase.visitExpression(this, ctx);\n        ctx.print(ast, ': ');\n        ast.falseCase.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {\n        ctx.print(ast, '!');\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @abstract\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) { };\n    /**\n     * @abstract\n     * @param {?} stmt\n     * @param {?} context\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n        var /** @type {?} */ opStr;\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                opStr = '==';\n                break;\n            case BinaryOperator.Identical:\n                opStr = '===';\n                break;\n            case BinaryOperator.NotEquals:\n                opStr = '!=';\n                break;\n            case BinaryOperator.NotIdentical:\n                opStr = '!==';\n                break;\n            case BinaryOperator.And:\n                opStr = '&&';\n                break;\n            case BinaryOperator.Or:\n                opStr = '||';\n                break;\n            case BinaryOperator.Plus:\n                opStr = '+';\n                break;\n            case BinaryOperator.Minus:\n                opStr = '-';\n                break;\n            case BinaryOperator.Divide:\n                opStr = '/';\n                break;\n            case BinaryOperator.Multiply:\n                opStr = '*';\n                break;\n            case BinaryOperator.Modulo:\n                opStr = '%';\n                break;\n            case BinaryOperator.Lower:\n                opStr = '<';\n                break;\n            case BinaryOperator.LowerEquals:\n                opStr = '<=';\n                break;\n            case BinaryOperator.Bigger:\n                opStr = '>';\n                break;\n            case BinaryOperator.BiggerEquals:\n                opStr = '>=';\n                break;\n            default:\n                throw new Error(\"Unknown operator \" + ast.operator);\n        }\n        ctx.print(ast, \"(\");\n        ast.lhs.visitExpression(this, ctx);\n        ctx.print(ast, \" \" + opStr + \" \");\n        ast.rhs.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, \".\");\n        ctx.print(ast, ast.name);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, \"[\");\n        ast.index.visitExpression(this, ctx);\n        ctx.print(ast, \"]\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        var /** @type {?} */ useNewLine = ast.entries.length > 1;\n        ctx.print(ast, \"[\", useNewLine);\n        ctx.incIndent();\n        this.visitAllExpressions(ast.entries, ctx, ',', useNewLine);\n        ctx.decIndent();\n        ctx.print(ast, \"]\", useNewLine);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {\n        var _this = this;\n        var /** @type {?} */ useNewLine = ast.entries.length > 1;\n        ctx.print(ast, \"{\", useNewLine);\n        ctx.incIndent();\n        this.visitAllObjects(function (entry) {\n            ctx.print(ast, escapeIdentifier(entry.key, _this._escapeDollarInStrings, entry.quoted) + \": \");\n            entry.value.visitExpression(_this, ctx);\n        }, ast.entries, ctx, ',', useNewLine);\n        ctx.decIndent();\n        ctx.print(ast, \"}\", useNewLine);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitCommaExpr = function (ast, ctx) {\n        ctx.print(ast, '(');\n        this.visitAllExpressions(ast.parts, ctx, ',');\n        ctx.print(ast, ')');\n        return null;\n    };\n    /**\n     * @param {?} expressions\n     * @param {?} ctx\n     * @param {?} separator\n     * @param {?=} newLine\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator, newLine) {\n        var _this = this;\n        if (newLine === void 0) { newLine = false; }\n        this.visitAllObjects(function (expr) { return expr.visitExpression(_this, ctx); }, expressions, ctx, separator, newLine);\n    };\n    /**\n     * @template T\n     * @param {?} handler\n     * @param {?} expressions\n     * @param {?} ctx\n     * @param {?} separator\n     * @param {?=} newLine\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator, newLine) {\n        if (newLine === void 0) { newLine = false; }\n        for (var /** @type {?} */ i = 0; i < expressions.length; i++) {\n            if (i > 0) {\n                ctx.print(null, separator, newLine);\n            }\n            handler(expressions[i]);\n        }\n        if (newLine) {\n            ctx.println();\n        }\n    };\n    /**\n     * @param {?} statements\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {\n        var _this = this;\n        statements.forEach(function (stmt) { return stmt.visitStatement(_this, ctx); });\n    };\n    return AbstractEmitterVisitor;\n}());\n/**\n * @param {?} input\n * @param {?} escapeDollar\n * @param {?=} alwaysQuote\n * @return {?}\n */\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote) {\n    if (alwaysQuote === void 0) { alwaysQuote = true; }\n    if (input == null) {\n        return null;\n    }\n    var /** @type {?} */ body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {\n        var match = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            match[_i] = arguments[_i];\n        }\n        if (match[0] == '$') {\n            return escapeDollar ? '\\\\$' : '$';\n        }\n        else if (match[0] == '\\n') {\n            return '\\\\n';\n        }\n        else if (match[0] == '\\r') {\n            return '\\\\r';\n        }\n        else {\n            return \"\\\\\" + match[0];\n        }\n    });\n    var /** @type {?} */ requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n    return requiresQuotes ? \"'\" + body + \"'\" : body;\n}\n/**\n * @param {?} count\n * @return {?}\n */\nfunction _createIndent(count) {\n    var /** @type {?} */ res = '';\n    for (var /** @type {?} */ i = 0; i < count; i++) {\n        res += _INDENT_WITH;\n    }\n    return res;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _debugFilePath = '/debug/lib';\n/**\n * @param {?} ast\n * @return {?}\n */\nfunction debugOutputAstAsTypeScript(ast) {\n    var /** @type {?} */ converter = new _TsEmitterVisitor(_debugFilePath, {\n        /**\n         * @param {?} filePath\n         * @param {?} containingFilePath\n         * @return {?}\n         */\n        fileNameToModuleName: function (filePath, containingFilePath) { return filePath; },\n        /**\n         * @param {?} symbol\n         * @return {?}\n         */\n        getImportAs: function (symbol) { return null; },\n        getTypeArity: function (symbol) { return null; }\n    });\n    var /** @type {?} */ ctx = EmitterVisitorContext.createRoot([]);\n    var /** @type {?} */ asts = Array.isArray(ast) ? ast : [ast];\n    asts.forEach(function (ast) {\n        if (ast instanceof Statement) {\n            ast.visitStatement(converter, ctx);\n        }\n        else if (ast instanceof Expression) {\n            ast.visitExpression(converter, ctx);\n        }\n        else if (ast instanceof Type$1) {\n            ast.visitType(converter, ctx);\n        }\n        else {\n            throw new Error(\"Don't know how to print debug info for \" + ast);\n        }\n    });\n    return ctx.toSource();\n}\nvar TypeScriptEmitter = (function () {\n    /**\n     * @param {?} _importResolver\n     */\n    function TypeScriptEmitter(_importResolver) {\n        this._importResolver = _importResolver;\n    }\n    /**\n     * @param {?} srcFilePath\n     * @param {?} genFilePath\n     * @param {?} stmts\n     * @param {?} exportedVars\n     * @param {?=} preamble\n     * @return {?}\n     */\n    TypeScriptEmitter.prototype.emitStatements = function (srcFilePath, genFilePath, stmts, exportedVars, preamble) {\n        var _this = this;\n        if (preamble === void 0) { preamble = ''; }\n        var /** @type {?} */ converter = new _TsEmitterVisitor(genFilePath, this._importResolver);\n        var /** @type {?} */ ctx = EmitterVisitorContext.createRoot(exportedVars);\n        converter.visitAllStatements(stmts, ctx);\n        var /** @type {?} */ preambleLines = preamble ? preamble.split('\\n') : [];\n        converter.reexports.forEach(function (reexports, exportedFilePath) {\n            var /** @type {?} */ reexportsCode = reexports.map(function (reexport) { return reexport.name + \" as \" + reexport.as; }).join(',');\n            preambleLines.push(\"export {\" + reexportsCode + \"} from '\" + _this._importResolver.fileNameToModuleName(exportedFilePath, genFilePath) + \"';\");\n        });\n        converter.importsWithPrefixes.forEach(function (prefix, importedFilePath) {\n            // Note: can't write the real word for import as it screws up system.js auto detection...\n            preambleLines.push(\"imp\" +\n                (\"ort * as \" + prefix + \" from '\" + _this._importResolver.fileNameToModuleName(importedFilePath, genFilePath) + \"';\"));\n        });\n        var /** @type {?} */ sm = ctx.toSourceMapGenerator(srcFilePath, genFilePath, preambleLines.length).toJsComment();\n        var /** @type {?} */ lines = preambleLines.concat([ctx.toSource(), sm]);\n        if (sm) {\n            // always add a newline at the end, as some tools have bugs without it.\n            lines.push('');\n        }\n        return lines.join('\\n');\n    };\n    return TypeScriptEmitter;\n}());\nvar _TsEmitterVisitor = (function (_super) {\n    __extends(_TsEmitterVisitor, _super);\n    /**\n     * @param {?} _genFilePath\n     * @param {?} _importResolver\n     */\n    function _TsEmitterVisitor(_genFilePath, _importResolver) {\n        var _this = _super.call(this, false) || this;\n        _this._genFilePath = _genFilePath;\n        _this._importResolver = _importResolver;\n        _this.typeExpression = 0;\n        _this.importsWithPrefixes = new Map();\n        _this.reexports = new Map();\n        return _this;\n    }\n    /**\n     * @param {?} t\n     * @param {?} ctx\n     * @param {?=} defaultType\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitType = function (t, ctx, defaultType) {\n        if (defaultType === void 0) { defaultType = 'any'; }\n        if (t != null) {\n            this.typeExpression++;\n            t.visitType(this, ctx);\n            this.typeExpression--;\n        }\n        else {\n            ctx.print(null, defaultType);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n        var /** @type {?} */ value = ast.value;\n        if (value == null && ast.type != INFERRED_TYPE) {\n            ctx.print(ast, \"(\" + value + \" as any)\");\n            return null;\n        }\n        return _super.prototype.visitLiteralExpr.call(this, ast, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        if (ast.entries.length === 0) {\n            ctx.print(ast, '(');\n        }\n        var /** @type {?} */ result = _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);\n        if (ast.entries.length === 0) {\n            ctx.print(ast, ' as any[])');\n        }\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n        this._visitIdentifier(ast.value, ast.typeParams, ctx);\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        if (ctx.isExportedVar(stmt.name) && stmt.value instanceof ExternalExpr && !stmt.type) {\n            // check for a reexport\n            var _a = this._resolveStaticSymbol(stmt.value.value), name = _a.name, filePath = _a.filePath, members = _a.members;\n            if (members.length === 0 && filePath !== this._genFilePath) {\n                var /** @type {?} */ reexports = this.reexports.get(filePath);\n                if (!reexports) {\n                    reexports = [];\n                    this.reexports.set(filePath, reexports);\n                }\n                reexports.push({ name: name, as: stmt.name });\n                return null;\n            }\n        }\n        if (ctx.isExportedVar(stmt.name)) {\n            ctx.print(stmt, \"export \");\n        }\n        if (stmt.hasModifier(StmtModifier.Final)) {\n            ctx.print(stmt, \"const\");\n        }\n        else {\n            ctx.print(stmt, \"var\");\n        }\n        ctx.print(stmt, \" \" + stmt.name);\n        this._printColonType(stmt.type, ctx);\n        ctx.print(stmt, \" = \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n        ctx.print(ast, \"(<\");\n        ast.type.visitType(this, ctx);\n        ctx.print(ast, \">\");\n        ast.value.visitExpression(this, ctx);\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n        ctx.print(ast, \"new \");\n        this.typeExpression++;\n        ast.classExpr.visitExpression(this, ctx);\n        this.typeExpression--;\n        ctx.print(ast, \"(\");\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, \")\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var _this = this;\n        ctx.pushClass(stmt);\n        if (ctx.isExportedVar(stmt.name)) {\n            ctx.print(stmt, \"export \");\n        }\n        ctx.print(stmt, \"class \" + stmt.name);\n        if (stmt.parent != null) {\n            ctx.print(stmt, \" extends \");\n            this.typeExpression++;\n            stmt.parent.visitExpression(this, ctx);\n            this.typeExpression--;\n        }\n        ctx.println(stmt, \" {\");\n        ctx.incIndent();\n        stmt.fields.forEach(function (field) { return _this._visitClassField(field, ctx); });\n        if (stmt.constructorMethod != null) {\n            this._visitClassConstructor(stmt, ctx);\n        }\n        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(getter, ctx); });\n        stmt.methods.forEach(function (method) { return _this._visitClassMethod(method, ctx); });\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        ctx.popClass();\n        return null;\n    };\n    /**\n     * @param {?} field\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {\n        if (field.hasModifier(StmtModifier.Private)) {\n            // comment out as a workaround for #10967\n            ctx.print(null, \"/*private*/ \");\n        }\n        ctx.print(null, field.name);\n        this._printColonType(field.type, ctx);\n        ctx.println(null, \";\");\n    };\n    /**\n     * @param {?} getter\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {\n        if (getter.hasModifier(StmtModifier.Private)) {\n            ctx.print(null, \"private \");\n        }\n        ctx.print(null, \"get \" + getter.name + \"()\");\n        this._printColonType(getter.type, ctx);\n        ctx.println(null, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(getter.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, \"}\");\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n        ctx.print(stmt, \"constructor(\");\n        this._visitParams(stmt.constructorMethod.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.constructorMethod.body, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n    };\n    /**\n     * @param {?} method\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {\n        if (method.hasModifier(StmtModifier.Private)) {\n            ctx.print(null, \"private \");\n        }\n        ctx.print(null, method.name + \"(\");\n        this._visitParams(method.params, ctx);\n        ctx.print(null, \")\");\n        this._printColonType(method.type, ctx, 'void');\n        ctx.println(null, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(method.body, ctx);\n        ctx.decIndent();\n        ctx.println(null, \"}\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n        ctx.print(ast, \"(\");\n        this._visitParams(ast.params, ctx);\n        ctx.print(ast, \")\");\n        this._printColonType(ast.type, ctx, 'void');\n        ctx.println(ast, \" => {\");\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        if (ctx.isExportedVar(stmt.name)) {\n            ctx.print(stmt, \"export \");\n        }\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        this._visitParams(stmt.params, ctx);\n        ctx.print(stmt, \")\");\n        this._printColonType(stmt.type, ctx, 'void');\n        ctx.println(stmt, \" {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"try {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"} catch (\" + CATCH_ERROR_VAR$1.name + \") {\");\n        ctx.incIndent();\n        var /** @type {?} */ catchStmts = [/** @type {?} */ (CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [\n                StmtModifier.Final\n            ]))].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitBuiltintType = function (type, ctx) {\n        var /** @type {?} */ typeStr;\n        switch (type.name) {\n            case BuiltinTypeName.Bool:\n                typeStr = 'boolean';\n                break;\n            case BuiltinTypeName.Dynamic:\n                typeStr = 'any';\n                break;\n            case BuiltinTypeName.Function:\n                typeStr = 'Function';\n                break;\n            case BuiltinTypeName.Number:\n                typeStr = 'number';\n                break;\n            case BuiltinTypeName.Int:\n                typeStr = 'number';\n                break;\n            case BuiltinTypeName.String:\n                typeStr = 'string';\n                break;\n            default:\n                throw new Error(\"Unsupported builtin type \" + type.name);\n        }\n        ctx.print(null, typeStr);\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitExpressionType = function (ast, ctx) {\n        ast.value.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {\n        this.visitType(type.of, ctx);\n        ctx.print(null, \"[]\");\n        return null;\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {\n        ctx.print(null, \"{[key: string]:\");\n        this.visitType(type.valueType, ctx);\n        ctx.print(null, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} method\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n        var /** @type {?} */ name;\n        switch (method) {\n            case BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(\"Unknown builtin method: \" + method);\n        }\n        return name;\n    };\n    /**\n     * @param {?} params\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n        var _this = this;\n        this.visitAllObjects(function (param) {\n            ctx.print(null, param.name);\n            _this._printColonType(param.type, ctx);\n        }, params, ctx, ',');\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._resolveStaticSymbol = function (value) {\n        var /** @type {?} */ reference = value.reference;\n        if (!(reference instanceof StaticSymbol)) {\n            throw new Error(\"Internal error: unknown identifier \" + JSON.stringify(value));\n        }\n        var /** @type {?} */ arity = this._importResolver.getTypeArity(reference) || undefined;\n        var /** @type {?} */ importReference = this._importResolver.getImportAs(reference) || reference;\n        return {\n            name: importReference.name,\n            filePath: importReference.filePath,\n            members: importReference.members, arity: arity\n        };\n    };\n    /**\n     * @param {?} value\n     * @param {?} typeParams\n     * @param {?} ctx\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {\n        var _this = this;\n        var _a = this._resolveStaticSymbol(value), name = _a.name, filePath = _a.filePath, members = _a.members, arity = _a.arity;\n        if (filePath != this._genFilePath) {\n            var /** @type {?} */ prefix = this.importsWithPrefixes.get(filePath);\n            if (prefix == null) {\n                prefix = \"import\" + this.importsWithPrefixes.size;\n                this.importsWithPrefixes.set(filePath, prefix);\n            }\n            ctx.print(null, prefix + \".\");\n        }\n        if (members.length) {\n            ctx.print(null, name);\n            ctx.print(null, '.');\n            ctx.print(null, members.join('.'));\n        }\n        else {\n            ctx.print(null, name);\n        }\n        if (this.typeExpression > 0) {\n            // If we are in a type expression that refers to a generic type then supply\n            // the required type parameters. If there were not enough type parameters\n            // supplied, supply any as the type. Outside a type expression the reference\n            // should not supply type parameters and be treated as a simple value reference\n            // to the constructor function itself.\n            var /** @type {?} */ suppliedParameters = (typeParams && typeParams.length) || 0;\n            var /** @type {?} */ additionalParameters = (arity || 0) - suppliedParameters;\n            if (suppliedParameters > 0 || additionalParameters > 0) {\n                ctx.print(null, \"<\");\n                if (suppliedParameters > 0) {\n                    this.visitAllObjects(function (type) { return type.visitType(_this, ctx); }, typeParams, ctx, ',');\n                }\n                if (additionalParameters > 0) {\n                    for (var /** @type {?} */ i = 0; i < additionalParameters; i++) {\n                        if (i > 0 || suppliedParameters > 0)\n                            ctx.print(null, ',');\n                        ctx.print(null, 'any');\n                    }\n                }\n                ctx.print(null, \">\");\n            }\n        }\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctx\n     * @param {?=} defaultType\n     * @return {?}\n     */\n    _TsEmitterVisitor.prototype._printColonType = function (type, ctx, defaultType) {\n        if (type !== INFERRED_TYPE) {\n            ctx.print(null, ':');\n            this.visitType(type, ctx, defaultType);\n        }\n    };\n    return _TsEmitterVisitor;\n}(AbstractEmitterVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n/** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */\nvar SECURITY_SCHEMA = {};\n/**\n * @param {?} ctx\n * @param {?} specs\n * @return {?}\n */\nfunction registerContext(ctx, specs) {\n    for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {\n        var spec = specs_1[_i];\n        SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n    }\n}\n// Case is insignificant below, all element and attribute names are lower-cased for lookup.\nregisterContext(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].HTML, [\n    'iframe|srcdoc',\n    '*|innerHTML',\n    '*|outerHTML',\n]);\nregisterContext(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].STYLE, ['*|style']);\n// NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\nregisterContext(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].URL, [\n    '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',\n    'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',\n    'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',\n    'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',\n]);\nregisterContext(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].RESOURCE_URL, [\n    'applet|code',\n    'applet|codebase',\n    'base|href',\n    'embed|src',\n    'frame|src',\n    'head|profile',\n    'html|manifest',\n    'iframe|src',\n    'link|href',\n    'media|src',\n    'object|codebase',\n    'object|data',\n    'script|src',\n]);\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar BOOLEAN = 'boolean';\nvar NUMBER = 'number';\nvar STRING = 'string';\nvar OBJECT = 'object';\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\nvar SCHEMA = [\n    '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop',\n    '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*beforecopy,*beforecut,*beforepaste,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*message,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*paste,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*search,*seeked,*seeking,*select,*selectstart,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'media^[HTMLElement]|!autoplay,!controls,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,#playbackRate,preload,src,%srcObject,#volume',\n    ':svg:^[HTMLElement]|*abort,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',\n    ':svg:graphics^:svg:|',\n    ':svg:animation^:svg:|*begin,*end,*repeat',\n    ':svg:geometry^:svg:|',\n    ':svg:componentTransferFunction^:svg:|',\n    ':svg:gradient^:svg:|',\n    ':svg:textContent^:svg:graphics|',\n    ':svg:textPositioning^:svg:textContent|',\n    'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',\n    'area^[HTMLElement]|alt,coords,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,search,shape,target,username',\n    'audio^media|',\n    'br^[HTMLElement]|clear',\n    'base^[HTMLElement]|href,target',\n    'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n    'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n    'canvas^[HTMLElement]|#height,#width',\n    'content^[HTMLElement]|select',\n    'dl^[HTMLElement]|!compact',\n    'datalist^[HTMLElement]|',\n    'details^[HTMLElement]|!open',\n    'dialog^[HTMLElement]|!open,returnValue',\n    'dir^[HTMLElement]|!compact',\n    'div^[HTMLElement]|align',\n    'embed^[HTMLElement]|align,height,name,src,type,width',\n    'fieldset^[HTMLElement]|!disabled,name',\n    'font^[HTMLElement]|color,face,size',\n    'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n    'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n    'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n    'hr^[HTMLElement]|align,color,!noShade,size,width',\n    'head^[HTMLElement]|',\n    'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n    'html^[HTMLElement]|version',\n    'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n    'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n    'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n    'keygen^[HTMLElement]|!autofocus,challenge,!disabled,keytype,name',\n    'li^[HTMLElement]|type,#value',\n    'label^[HTMLElement]|htmlFor',\n    'legend^[HTMLElement]|align',\n    'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,rel,%relList,rev,%sizes,target,type',\n    'map^[HTMLElement]|name',\n    'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n    'menu^[HTMLElement]|!compact',\n    'meta^[HTMLElement]|content,httpEquiv,name,scheme',\n    'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n    'ins,del^[HTMLElement]|cite,dateTime',\n    'ol^[HTMLElement]|!compact,!reversed,#start,type',\n    'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n    'optgroup^[HTMLElement]|!disabled,label',\n    'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n    'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n    'p^[HTMLElement]|align',\n    'param^[HTMLElement]|name,type,value,valueType',\n    'picture^[HTMLElement]|',\n    'pre^[HTMLElement]|#width',\n    'progress^[HTMLElement]|#max,#value',\n    'q,blockquote,cite^[HTMLElement]|',\n    'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',\n    'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n    'shadow^[HTMLElement]|',\n    'source^[HTMLElement]|media,sizes,src,srcset,type',\n    'span^[HTMLElement]|',\n    'style^[HTMLElement]|!disabled,media,type',\n    'caption^[HTMLElement]|align',\n    'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n    'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n    'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n    'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n    'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n    'template^[HTMLElement]|',\n    'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n    'title^[HTMLElement]|text',\n    'track^[HTMLElement]|!default,kind,label,src,srclang',\n    'ul^[HTMLElement]|!compact,type',\n    'unknown^[HTMLElement]|',\n    'video^media|#height,poster,#width',\n    ':svg:a^:svg:graphics|',\n    ':svg:animate^:svg:animation|',\n    ':svg:animateMotion^:svg:animation|',\n    ':svg:animateTransform^:svg:animation|',\n    ':svg:circle^:svg:geometry|',\n    ':svg:clipPath^:svg:graphics|',\n    ':svg:cursor^:svg:|',\n    ':svg:defs^:svg:graphics|',\n    ':svg:desc^:svg:|',\n    ':svg:discard^:svg:|',\n    ':svg:ellipse^:svg:geometry|',\n    ':svg:feBlend^:svg:|',\n    ':svg:feColorMatrix^:svg:|',\n    ':svg:feComponentTransfer^:svg:|',\n    ':svg:feComposite^:svg:|',\n    ':svg:feConvolveMatrix^:svg:|',\n    ':svg:feDiffuseLighting^:svg:|',\n    ':svg:feDisplacementMap^:svg:|',\n    ':svg:feDistantLight^:svg:|',\n    ':svg:feDropShadow^:svg:|',\n    ':svg:feFlood^:svg:|',\n    ':svg:feFuncA^:svg:componentTransferFunction|',\n    ':svg:feFuncB^:svg:componentTransferFunction|',\n    ':svg:feFuncG^:svg:componentTransferFunction|',\n    ':svg:feFuncR^:svg:componentTransferFunction|',\n    ':svg:feGaussianBlur^:svg:|',\n    ':svg:feImage^:svg:|',\n    ':svg:feMerge^:svg:|',\n    ':svg:feMergeNode^:svg:|',\n    ':svg:feMorphology^:svg:|',\n    ':svg:feOffset^:svg:|',\n    ':svg:fePointLight^:svg:|',\n    ':svg:feSpecularLighting^:svg:|',\n    ':svg:feSpotLight^:svg:|',\n    ':svg:feTile^:svg:|',\n    ':svg:feTurbulence^:svg:|',\n    ':svg:filter^:svg:|',\n    ':svg:foreignObject^:svg:graphics|',\n    ':svg:g^:svg:graphics|',\n    ':svg:image^:svg:graphics|',\n    ':svg:line^:svg:geometry|',\n    ':svg:linearGradient^:svg:gradient|',\n    ':svg:mpath^:svg:|',\n    ':svg:marker^:svg:|',\n    ':svg:mask^:svg:|',\n    ':svg:metadata^:svg:|',\n    ':svg:path^:svg:geometry|',\n    ':svg:pattern^:svg:|',\n    ':svg:polygon^:svg:geometry|',\n    ':svg:polyline^:svg:geometry|',\n    ':svg:radialGradient^:svg:gradient|',\n    ':svg:rect^:svg:geometry|',\n    ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n    ':svg:script^:svg:|type',\n    ':svg:set^:svg:animation|',\n    ':svg:stop^:svg:|',\n    ':svg:style^:svg:|!disabled,media,title,type',\n    ':svg:switch^:svg:graphics|',\n    ':svg:symbol^:svg:|',\n    ':svg:tspan^:svg:textPositioning|',\n    ':svg:text^:svg:textPositioning|',\n    ':svg:textPath^:svg:textContent|',\n    ':svg:title^:svg:|',\n    ':svg:use^:svg:graphics|',\n    ':svg:view^:svg:|#zoomAndPan',\n    'data^[HTMLElement]|value',\n    'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n    'summary^[HTMLElement]|',\n    'time^[HTMLElement]|dateTime',\n];\nvar _ATTR_TO_PROP = {\n    'class': 'className',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'innerHtml': 'innerHTML',\n    'readonly': 'readOnly',\n    'tabindex': 'tabIndex',\n};\nvar DomElementSchemaRegistry = (function (_super) {\n    __extends(DomElementSchemaRegistry, _super);\n    function DomElementSchemaRegistry() {\n        var _this = _super.call(this) || this;\n        _this._schema = {};\n        SCHEMA.forEach(function (encodedType) {\n            var type = {};\n            var _a = encodedType.split('|'), strType = _a[0], strProperties = _a[1];\n            var properties = strProperties.split(',');\n            var _b = strType.split('^'), typeNames = _b[0], superName = _b[1];\n            typeNames.split(',').forEach(function (tag) { return _this._schema[tag.toLowerCase()] = type; });\n            var superType = superName && _this._schema[superName.toLowerCase()];\n            if (superType) {\n                Object.keys(superType).forEach(function (prop) { type[prop] = superType[prop]; });\n            }\n            properties.forEach(function (property) {\n                if (property.length > 0) {\n                    switch (property[0]) {\n                        case '*':\n                            // We don't yet support events.\n                            // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events\n                            // will\n                            // almost certainly introduce bad XSS vulnerabilities.\n                            // type[property.substring(1)] = EVENT;\n                            break;\n                        case '!':\n                            type[property.substring(1)] = BOOLEAN;\n                            break;\n                        case '#':\n                            type[property.substring(1)] = NUMBER;\n                            break;\n                        case '%':\n                            type[property.substring(1)] = OBJECT;\n                            break;\n                        default:\n                            type[property] = STRING;\n                    }\n                }\n            });\n        });\n        return _this;\n    }\n    /**\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName, schemaMetas) {\n        if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_45\" /* NO_ERRORS_SCHEMA */].name; })) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (tagName === 'ng-container' || tagName === 'ng-content') {\n                return false;\n            }\n            if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_46\" /* CUSTOM_ELEMENTS_SCHEMA */].name; })) {\n                // Can't tell now as we don't know which properties a custom element will get\n                // once it is instantiated\n                return true;\n            }\n        }\n        var /** @type {?} */ elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n        return !!elementProperties[propName];\n    };\n    /**\n     * @param {?} tagName\n     * @param {?} schemaMetas\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.hasElement = function (tagName, schemaMetas) {\n        if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_45\" /* NO_ERRORS_SCHEMA */].name; })) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (tagName === 'ng-container' || tagName === 'ng-content') {\n                return true;\n            }\n            if (schemaMetas.some(function (schema) { return schema.name === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_46\" /* CUSTOM_ELEMENTS_SCHEMA */].name; })) {\n                // Allow any custom elements\n                return true;\n            }\n        }\n        return !!this._schema[tagName.toLowerCase()];\n    };\n    /**\n     * securityContext returns the security context for the given property on the given DOM tag.\n     *\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n     * possible to bind a value into a changing attribute or tag name.\n     *\n     * The filtering is white list based. All attributes in the schema above are assumed to have the\n     * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known\n     * attack vectors are assigned their appropriate context.\n     * @param {?} tagName\n     * @param {?} propName\n     * @param {?} isAttribute\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.securityContext = function (tagName, propName, isAttribute) {\n        if (isAttribute) {\n            // NB: For security purposes, use the mapped property name, not the attribute name.\n            propName = this.getMappedPropName(propName);\n        }\n        // Make sure comparisons are case insensitive, so that case differences between attribute and\n        // property names do not have a security impact.\n        tagName = tagName.toLowerCase();\n        propName = propName.toLowerCase();\n        var /** @type {?} */ ctx = SECURITY_SCHEMA[tagName + '|' + propName];\n        if (ctx) {\n            return ctx;\n        }\n        ctx = SECURITY_SCHEMA['*|' + propName];\n        return ctx ? ctx : __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"q\" /* SecurityContext */].NONE;\n    };\n    /**\n     * @param {?} propName\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return _ATTR_TO_PROP[propName] || propName; };\n    /**\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.getDefaultComponentElementName = function () { return 'ng-component'; };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.validateProperty = function (name) {\n        if (name.toLowerCase().startsWith('on')) {\n            var /** @type {?} */ msg = \"Binding to event property '\" + name + \"' is disallowed for security reasons, \" +\n                (\"please use (\" + name.slice(2) + \")=...\") +\n                (\"\\nIf '\" + name + \"' is a directive input, make sure the directive is imported by the\") +\n                \" current module.\";\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.validateAttribute = function (name) {\n        if (name.toLowerCase().startsWith('on')) {\n            var /** @type {?} */ msg = \"Binding to event attribute '\" + name + \"' is disallowed for security reasons, \" +\n                (\"please use (\" + name.slice(2) + \")=...\");\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    };\n    /**\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.allKnownElementNames = function () { return Object.keys(this._schema); };\n    /**\n     * @param {?} propName\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.normalizeAnimationStyleProperty = function (propName) {\n        return dashCaseToCamelCase(propName);\n    };\n    /**\n     * @param {?} camelCaseProp\n     * @param {?} userProvidedProp\n     * @param {?} val\n     * @return {?}\n     */\n    DomElementSchemaRegistry.prototype.normalizeAnimationStyleValue = function (camelCaseProp, userProvidedProp, val) {\n        var /** @type {?} */ unit = '';\n        var /** @type {?} */ strVal = val.toString().trim();\n        var /** @type {?} */ errorMsg = null;\n        if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n            if (typeof val === 'number') {\n                unit = 'px';\n            }\n            else {\n                var /** @type {?} */ valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                    errorMsg = \"Please provide a CSS unit value for \" + userProvidedProp + \":\" + val;\n                }\n            }\n        }\n        return { error: errorMsg, value: strVal + unit };\n    };\n    return DomElementSchemaRegistry;\n}(ElementSchemaRegistry));\nDomElementSchemaRegistry.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nDomElementSchemaRegistry.ctorParameters = function () { return []; };\n/**\n * @param {?} prop\n * @return {?}\n */\nfunction _isPixelDimensionStyle(prop) {\n    switch (prop) {\n        case 'width':\n        case 'height':\n        case 'minWidth':\n        case 'minHeight':\n        case 'maxWidth':\n        case 'maxHeight':\n        case 'left':\n        case 'top':\n        case 'bottom':\n        case 'right':\n        case 'fontSize':\n        case 'outlineWidth':\n        case 'outlineOffset':\n        case 'paddingTop':\n        case 'paddingLeft':\n        case 'paddingBottom':\n        case 'paddingRight':\n        case 'marginTop':\n        case 'marginLeft':\n        case 'marginBottom':\n        case 'marginRight':\n        case 'borderRadius':\n        case 'borderWidth':\n        case 'borderTopWidth':\n        case 'borderLeftWidth':\n        case 'borderRightWidth':\n        case 'borderBottomWidth':\n        case 'textIndent':\n            return true;\n        default:\n            return false;\n    }\n}\nvar ShadowCss = (function () {\n    function ShadowCss() {\n        this.strictStyling = true;\n    }\n    /**\n     * @param {?} cssText\n     * @param {?} selector\n     * @param {?=} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {\n        if (hostSelector === void 0) { hostSelector = ''; }\n        var /** @type {?} */ sourceMappingUrl = extractSourceMappingUrl(cssText);\n        cssText = stripComments(cssText);\n        cssText = this._insertDirectives(cssText);\n        return this._scopeCssText(cssText, selector, hostSelector) + sourceMappingUrl;\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._insertDirectives = function (cssText) {\n        cssText = this._insertPolyfillDirectivesInCssText(cssText);\n        return this._insertPolyfillRulesInCssText(cssText);\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentNextSelectorRe, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            return m[2] + '{';\n        });\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentRuleRe, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            var /** @type {?} */ rule = m[0].replace(m[1], '').replace(m[2], '');\n            return m[4] + rule;\n        });\n    };\n    /**\n     * @param {?} cssText\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {\n        var /** @type {?} */ unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n        cssText = this._insertPolyfillHostInCssText(cssText);\n        cssText = this._convertColonHost(cssText);\n        cssText = this._convertColonHostContext(cssText);\n        cssText = this._convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n        }\n        cssText = cssText + '\\n' + unscopedRules;\n        return cssText.trim();\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        var /** @type {?} */ r = '';\n        var /** @type {?} */ m;\n        _cssContentUnscopedRuleRe.lastIndex = 0;\n        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n            var /** @type {?} */ rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n            r += rule + '\\n\\n';\n        }\n        return r;\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._convertColonHost = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._convertColonHostContext = function (cssText) {\n        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n    };\n    /**\n     * @param {?} cssText\n     * @param {?} regExp\n     * @param {?} partReplacer\n     * @return {?}\n     */\n    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {\n        // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n        return cssText.replace(regExp, function () {\n            var m = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                m[_i] = arguments[_i];\n            }\n            if (m[2]) {\n                var /** @type {?} */ parts = m[2].split(',');\n                var /** @type {?} */ r = [];\n                for (var /** @type {?} */ i = 0; i < parts.length; i++) {\n                    var /** @type {?} */ p = parts[i].trim();\n                    if (!p)\n                        break;\n                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n                }\n                return r.join(',');\n            }\n            else {\n                return _polyfillHostNoCombinator + m[3];\n            }\n        });\n    };\n    /**\n     * @param {?} host\n     * @param {?} part\n     * @param {?} suffix\n     * @return {?}\n     */\n    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {\n        if (part.indexOf(_polyfillHost) > -1) {\n            return this._colonHostPartReplacer(host, part, suffix);\n        }\n        else {\n            return host + part + suffix + ', ' + part + ' ' + host + suffix;\n        }\n    };\n    /**\n     * @param {?} host\n     * @param {?} part\n     * @param {?} suffix\n     * @return {?}\n     */\n    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {\n        return host + part.replace(_polyfillHost, '') + suffix;\n    };\n    /**\n     * @param {?} cssText\n     * @return {?}\n     */\n    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {\n        return _shadowDOMSelectorsRe.reduce(function (result, pattern) { return result.replace(pattern, ' '); }, cssText);\n    };\n    /**\n     * @param {?} cssText\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._scopeSelectors = function (cssText, scopeSelector, hostSelector) {\n        var _this = this;\n        return processRules(cssText, function (rule) {\n            var /** @type {?} */ selector = rule.selector;\n            var /** @type {?} */ content = rule.content;\n            if (rule.selector[0] != '@') {\n                selector =\n                    _this._scopeSelector(rule.selector, scopeSelector, hostSelector, _this.strictStyling);\n            }\n            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n                content = _this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n            }\n            return new CssRule(selector, content);\n        });\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @param {?} strict\n     * @return {?}\n     */\n    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {\n        var _this = this;\n        return selector.split(',')\n            .map(function (part) { return part.trim().split(_shadowDeepSelectors); })\n            .map(function (deepParts) {\n            var shallowPart = deepParts[0], otherParts = deepParts.slice(1);\n            var /** @type {?} */ applyScope = function (shallowPart) {\n                if (_this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                    return strict ?\n                        _this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                        _this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n                }\n                else {\n                    return shallowPart;\n                }\n            };\n            return [applyScope(shallowPart)].concat(otherParts).join(' ');\n        })\n            .join(', ');\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {\n        var /** @type {?} */ re = this._makeScopeMatcher(scopeSelector);\n        return !re.test(selector);\n    };\n    /**\n     * @param {?} scopeSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {\n        var /** @type {?} */ lre = /\\[/g;\n        var /** @type {?} */ rre = /\\]/g;\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {\n        // Difference from webcomponents.js: scopeSelector could not be an array\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n        _polyfillHostRe.lastIndex = 0;\n        if (_polyfillHostRe.test(selector)) {\n            var /** @type {?} */ replaceBy_1 = this.strictStyling ? \"[\" + hostSelector + \"]\" : scopeSelector;\n            return selector\n                .replace(_polyfillHostNoCombinatorRe, function (hnc, selector) {\n                return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {\n                    return before + replaceBy_1 + colon + after;\n                });\n            })\n                .replace(_polyfillHostRe, replaceBy_1 + ' ');\n        }\n        return scopeSelector + ' ' + selector;\n    };\n    /**\n     * @param {?} selector\n     * @param {?} scopeSelector\n     * @param {?} hostSelector\n     * @return {?}\n     */\n    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector, hostSelector) {\n        var _this = this;\n        var /** @type {?} */ isRe = /\\[is=([^\\]]*)\\]/g;\n        scopeSelector = scopeSelector.replace(isRe, function (_) {\n            var parts = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                parts[_i - 1] = arguments[_i];\n            }\n            return parts[0];\n        });\n        var /** @type {?} */ attrName = '[' + scopeSelector + ']';\n        var /** @type {?} */ _scopeSelectorPart = function (p) {\n            var /** @type {?} */ scopedP = p.trim();\n            if (!scopedP) {\n                return '';\n            }\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                scopedP = _this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n            }\n            else {\n                // remove :host since it should be unnecessary\n                var /** @type {?} */ t = p.replace(_polyfillHostRe, '');\n                if (t.length > 0) {\n                    var /** @type {?} */ matches = t.match(/([^:]*)(:*)(.*)/);\n                    if (matches) {\n                        scopedP = matches[1] + attrName + matches[2] + matches[3];\n                    }\n                }\n            }\n            return scopedP;\n        };\n        var /** @type {?} */ safeContent = new SafeSelector(selector);\n        selector = safeContent.content();\n        var /** @type {?} */ scopedSelector = '';\n        var /** @type {?} */ startIndex = 0;\n        var /** @type {?} */ res;\n        var /** @type {?} */ sep = /( |>|\\+|~(?!=))\\s*/g;\n        var /** @type {?} */ scopeAfter = selector.indexOf(_polyfillHostNoCombinator);\n        while ((res = sep.exec(selector)) !== null) {\n            var /** @type {?} */ separator = res[1];\n            var /** @type {?} */ part = selector.slice(startIndex, res.index).trim();\n            // if a selector appears before :host-context it should not be shimmed as it\n            // matches on ancestor elements and not on elements in the host's shadow\n            var /** @type {?} */ scopedPart = startIndex >= scopeAfter ? _scopeSelectorPart(part) : part;\n            scopedSelector += scopedPart + \" \" + separator + \" \";\n            startIndex = sep.lastIndex;\n        }\n        scopedSelector += _scopeSelectorPart(selector.substring(startIndex));\n        // replace the placeholders with their original values\n        return safeContent.restore(scopedSelector);\n    };\n    /**\n     * @param {?} selector\n     * @return {?}\n     */\n    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {\n        return selector.replace(_colonHostContextRe, _polyfillHostContext)\n            .replace(_colonHostRe, _polyfillHost);\n    };\n    return ShadowCss;\n}());\nvar SafeSelector = (function () {\n    /**\n     * @param {?} selector\n     */\n    function SafeSelector(selector) {\n        var _this = this;\n        this.placeholders = [];\n        this.index = 0;\n        // Replaces attribute selectors with placeholders.\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n        selector = selector.replace(/(\\[[^\\]]*\\])/g, function (_, keep) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(keep);\n            _this.index++;\n            return replaceBy;\n        });\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n        // WS and \"+\" would otherwise be interpreted as selector separators.\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, function (_, pseudo, exp) {\n            var replaceBy = \"__ph-\" + _this.index + \"__\";\n            _this.placeholders.push(exp);\n            _this.index++;\n            return pseudo + replaceBy;\n        });\n    }\n    ;\n    /**\n     * @param {?} content\n     * @return {?}\n     */\n    SafeSelector.prototype.restore = function (content) {\n        var _this = this;\n        return content.replace(/__ph-(\\d+)__/g, function (ph, index) { return _this.placeholders[+index]; });\n    };\n    /**\n     * @return {?}\n     */\n    SafeSelector.prototype.content = function () { return this._content; };\n    return SafeSelector;\n}());\nvar _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nvar _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nvar _polyfillHostContext = '-shadowcsscontext';\nvar _parenSuffix = ')(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nvar _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\nvar _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\nvar _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nvar _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nvar _shadowDOMSelectorsRe = [\n    /::shadow/g,\n    /::content/g,\n    // Deprecated selectors\n    /\\/shadow-deep\\//g,\n    /\\/shadow\\//g,\n];\nvar _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)/g;\nvar _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\nvar _polyfillHostRe = /-shadowcsshost/gim;\nvar _colonHostRe = /:host/gim;\nvar _colonHostContextRe = /:host-context/gim;\nvar _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction stripComments(input) {\n    return input.replace(_commentRe, '');\n}\n// all comments except inline source mapping\nvar _sourceMappingUrlRe = /\\/\\*\\s*#\\s*sourceMappingURL=[\\s\\S]+?\\*\\//;\n/**\n * @param {?} input\n * @return {?}\n */\nfunction extractSourceMappingUrl(input) {\n    var /** @type {?} */ matcher = input.match(_sourceMappingUrlRe);\n    return matcher ? matcher[0] : '';\n}\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nvar _curlyRe = /([{}])/g;\nvar OPEN_CURLY = '{';\nvar CLOSE_CURLY = '}';\nvar BLOCK_PLACEHOLDER = '%BLOCK%';\nvar CssRule = (function () {\n    /**\n     * @param {?} selector\n     * @param {?} content\n     */\n    function CssRule(selector, content) {\n        this.selector = selector;\n        this.content = content;\n    }\n    return CssRule;\n}());\n/**\n * @param {?} input\n * @param {?} ruleCallback\n * @return {?}\n */\nfunction processRules(input, ruleCallback) {\n    var /** @type {?} */ inputWithEscapedBlocks = escapeBlocks(input);\n    var /** @type {?} */ nextBlockIndex = 0;\n    return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {\n        var m = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            m[_i] = arguments[_i];\n        }\n        var /** @type {?} */ selector = m[2];\n        var /** @type {?} */ content = '';\n        var /** @type {?} */ suffix = m[4];\n        var /** @type {?} */ contentPrefix = '';\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = '{';\n        }\n        var /** @type {?} */ rule = ruleCallback(new CssRule(selector, content));\n        return \"\" + m[1] + rule.selector + m[3] + contentPrefix + rule.content + suffix;\n    });\n}\nvar StringWithEscapedBlocks = (function () {\n    /**\n     * @param {?} escapedString\n     * @param {?} blocks\n     */\n    function StringWithEscapedBlocks(escapedString, blocks) {\n        this.escapedString = escapedString;\n        this.blocks = blocks;\n    }\n    return StringWithEscapedBlocks;\n}());\n/**\n * @param {?} input\n * @return {?}\n */\nfunction escapeBlocks(input) {\n    var /** @type {?} */ inputParts = input.split(_curlyRe);\n    var /** @type {?} */ resultParts = [];\n    var /** @type {?} */ escapedBlocks = [];\n    var /** @type {?} */ bracketCount = 0;\n    var /** @type {?} */ currentBlockParts = [];\n    for (var /** @type {?} */ partIndex = 0; partIndex < inputParts.length; partIndex++) {\n        var /** @type {?} */ part = inputParts[partIndex];\n        if (part == CLOSE_CURLY) {\n            bracketCount--;\n        }\n        if (bracketCount > 0) {\n            currentBlockParts.push(part);\n        }\n        else {\n            if (currentBlockParts.length > 0) {\n                escapedBlocks.push(currentBlockParts.join(''));\n                resultParts.push(BLOCK_PLACEHOLDER);\n                currentBlockParts = [];\n            }\n            resultParts.push(part);\n        }\n        if (part == OPEN_CURLY) {\n            bracketCount++;\n        }\n    }\n    if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(''));\n        resultParts.push(BLOCK_PLACEHOLDER);\n    }\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar COMPONENT_VARIABLE = '%COMP%';\nvar HOST_ATTR = \"_nghost-\" + COMPONENT_VARIABLE;\nvar CONTENT_ATTR = \"_ngcontent-\" + COMPONENT_VARIABLE;\nvar StylesCompileDependency = (function () {\n    /**\n     * @param {?} name\n     * @param {?} moduleUrl\n     * @param {?} isShimmed\n     * @param {?} valuePlaceholder\n     */\n    function StylesCompileDependency(name, moduleUrl, isShimmed, valuePlaceholder) {\n        this.name = name;\n        this.moduleUrl = moduleUrl;\n        this.isShimmed = isShimmed;\n        this.valuePlaceholder = valuePlaceholder;\n    }\n    return StylesCompileDependency;\n}());\nvar StylesCompileResult = (function () {\n    /**\n     * @param {?} componentStylesheet\n     * @param {?} externalStylesheets\n     */\n    function StylesCompileResult(componentStylesheet, externalStylesheets) {\n        this.componentStylesheet = componentStylesheet;\n        this.externalStylesheets = externalStylesheets;\n    }\n    return StylesCompileResult;\n}());\nvar CompiledStylesheet = (function () {\n    /**\n     * @param {?} statements\n     * @param {?} stylesVar\n     * @param {?} dependencies\n     * @param {?} isShimmed\n     * @param {?} meta\n     */\n    function CompiledStylesheet(statements, stylesVar, dependencies, isShimmed, meta) {\n        this.statements = statements;\n        this.stylesVar = stylesVar;\n        this.dependencies = dependencies;\n        this.isShimmed = isShimmed;\n        this.meta = meta;\n    }\n    return CompiledStylesheet;\n}());\nvar StyleCompiler = (function () {\n    /**\n     * @param {?} _urlResolver\n     */\n    function StyleCompiler(_urlResolver) {\n        this._urlResolver = _urlResolver;\n        this._shadowCss = new ShadowCss();\n    }\n    /**\n     * @param {?} comp\n     * @return {?}\n     */\n    StyleCompiler.prototype.compileComponent = function (comp) {\n        var _this = this;\n        var /** @type {?} */ externalStylesheets = [];\n        var /** @type {?} */ componentStylesheet = this._compileStyles(comp, new CompileStylesheetMetadata({\n            styles: comp.template.styles,\n            styleUrls: comp.template.styleUrls,\n            moduleUrl: identifierModuleUrl(comp.type)\n        }), true);\n        comp.template.externalStylesheets.forEach(function (stylesheetMeta) {\n            var /** @type {?} */ compiledStylesheet = _this._compileStyles(comp, stylesheetMeta, false);\n            externalStylesheets.push(compiledStylesheet);\n        });\n        return new StylesCompileResult(componentStylesheet, externalStylesheets);\n    };\n    /**\n     * @param {?} comp\n     * @param {?} stylesheet\n     * @param {?} isComponentStylesheet\n     * @return {?}\n     */\n    StyleCompiler.prototype._compileStyles = function (comp, stylesheet, isComponentStylesheet) {\n        var _this = this;\n        var /** @type {?} */ shim = comp.template.encapsulation === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].Emulated;\n        var /** @type {?} */ styleExpressions = stylesheet.styles.map(function (plainStyle) { return literal(_this._shimIfNeeded(plainStyle, shim)); });\n        var /** @type {?} */ dependencies = [];\n        for (var /** @type {?} */ i = 0; i < stylesheet.styleUrls.length; i++) {\n            var /** @type {?} */ identifier = { reference: null };\n            dependencies.push(new StylesCompileDependency(getStylesVarName(null), stylesheet.styleUrls[i], shim, identifier));\n            styleExpressions.push(new ExternalExpr(identifier));\n        }\n        // styles variable contains plain strings and arrays of other styles arrays (recursive),\n        // so we set its type to dynamic.\n        var /** @type {?} */ stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\n        var /** @type {?} */ stmt = variable(stylesVar)\n            .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))\n            .toDeclStmt(null, [StmtModifier.Final]);\n        return new CompiledStylesheet([stmt], stylesVar, dependencies, shim, stylesheet);\n    };\n    /**\n     * @param {?} style\n     * @param {?} shim\n     * @return {?}\n     */\n    StyleCompiler.prototype._shimIfNeeded = function (style$$1, shim) {\n        return shim ? this._shadowCss.shimCssText(style$$1, CONTENT_ATTR, HOST_ATTR) : style$$1;\n    };\n    return StyleCompiler;\n}());\nStyleCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nStyleCompiler.ctorParameters = function () { return [\n    { type: UrlResolver, },\n]; };\n/**\n * @param {?} component\n * @return {?}\n */\nfunction getStylesVarName(component) {\n    var /** @type {?} */ result = \"styles\";\n    if (component) {\n        result += \"_\" + identifierName(component.type);\n    }\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar EventHandlerVars = (function () {\n    function EventHandlerVars() {\n    }\n    return EventHandlerVars;\n}());\nEventHandlerVars.event = variable('$event');\nvar ConvertActionBindingResult = (function () {\n    /**\n     * @param {?} stmts\n     * @param {?} allowDefault\n     */\n    function ConvertActionBindingResult(stmts, allowDefault) {\n        this.stmts = stmts;\n        this.allowDefault = allowDefault;\n    }\n    return ConvertActionBindingResult;\n}());\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} action\n * @param {?} bindingId\n * @return {?}\n */\nfunction convertActionBinding(localResolver, implicitReceiver, action, bindingId) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    var /** @type {?} */ actionWithoutBuiltins = convertPropertyBindingBuiltins({\n        createLiteralArrayConverter: function (argCount) {\n            // Note: no caching for literal arrays in actions.\n            return function (args) { return literalArr(args); };\n        },\n        createLiteralMapConverter: function (keys) {\n            // Note: no caching for literal maps in actions.\n            return function (args) { return literalMap(/** @type {?} */ (keys.map(function (key, i) { return [key, args[i]]; }))); };\n        },\n        createPipeConverter: function (name) {\n            throw new Error(\"Illegal State: Actions are not allowed to contain pipes. Pipe: \" + name);\n        }\n    }, action);\n    var /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n    var /** @type {?} */ actionStmts = [];\n    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n    var /** @type {?} */ lastIndex = actionStmts.length - 1;\n    var /** @type {?} */ preventDefaultVar = null;\n    if (lastIndex >= 0) {\n        var /** @type {?} */ lastStatement = actionStmts[lastIndex];\n        var /** @type {?} */ returnExpr = convertStmtIntoExpression(lastStatement);\n        if (returnExpr) {\n            // Note: We need to cast the result of the method call to dynamic,\n            // as it might be a void method!\n            preventDefaultVar = createPreventDefaultVar(bindingId);\n            actionStmts[lastIndex] =\n                preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))\n                    .toDeclStmt(null, [StmtModifier.Final]);\n        }\n    }\n    return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nfunction convertPropertyBindingBuiltins(converterFactory, ast) {\n    return convertBuiltins(converterFactory, ast);\n}\nvar ConvertPropertyBindingResult = (function () {\n    /**\n     * @param {?} stmts\n     * @param {?} currValExpr\n     */\n    function ConvertPropertyBindingResult(stmts, currValExpr) {\n        this.stmts = stmts;\n        this.currValExpr = currValExpr;\n    }\n    return ConvertPropertyBindingResult;\n}());\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} expressionWithoutBuiltins\n * @param {?} bindingId\n * @return {?}\n */\nfunction convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    var /** @type {?} */ currValExpr = createCurrValueExpr(bindingId);\n    var /** @type {?} */ stmts = [];\n    var /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n    var /** @type {?} */ outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n    if (visitor.temporaryCount) {\n        for (var /** @type {?} */ i = 0; i < visitor.temporaryCount; i++) {\n            stmts.push(temporaryDeclaration(bindingId, i));\n        }\n    }\n    stmts.push(currValExpr.set(outputExpr).toDeclStmt(null, [StmtModifier.Final]));\n    return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nfunction convertBuiltins(converterFactory, ast) {\n    var /** @type {?} */ visitor = new _BuiltinAstConverter(converterFactory);\n    return ast.visit(visitor);\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nfunction temporaryName(bindingId, temporaryNumber) {\n    return \"tmp_\" + bindingId + \"_\" + temporaryNumber;\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nfunction temporaryDeclaration(bindingId, temporaryNumber) {\n    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);\n}\n/**\n * @param {?} temporaryCount\n * @param {?} bindingId\n * @param {?} statements\n * @return {?}\n */\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\n    for (var /** @type {?} */ i = temporaryCount - 1; i >= 0; i--) {\n        statements.unshift(temporaryDeclaration(bindingId, i));\n    }\n}\nvar _Mode = {};\n_Mode.Statement = 0;\n_Mode.Expression = 1;\n_Mode[_Mode.Statement] = \"Statement\";\n_Mode[_Mode.Expression] = \"Expression\";\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureStatementMode(mode, ast) {\n    if (mode !== _Mode.Statement) {\n        throw new Error(\"Expected a statement, but saw \" + ast);\n    }\n}\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureExpressionMode(mode, ast) {\n    if (mode !== _Mode.Expression) {\n        throw new Error(\"Expected an expression, but saw \" + ast);\n    }\n}\n/**\n * @param {?} mode\n * @param {?} expr\n * @return {?}\n */\nfunction convertToStatementIfNeeded(mode, expr) {\n    if (mode === _Mode.Statement) {\n        return expr.toStmt();\n    }\n    else {\n        return expr;\n    }\n}\nvar _BuiltinAstConverter = (function (_super) {\n    __extends(_BuiltinAstConverter, _super);\n    /**\n     * @param {?} _converterFactory\n     */\n    function _BuiltinAstConverter(_converterFactory) {\n        var _this = _super.call(this) || this;\n        _this._converterFactory = _converterFactory;\n        return _this;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _BuiltinAstConverter.prototype.visitPipe = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ args = [ast.exp].concat(ast.args).map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _BuiltinAstConverter.prototype.visitLiteralArray = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ args = ast.expressions.map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    _BuiltinAstConverter.prototype.visitLiteralMap = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ args = ast.values.map(function (ast) { return ast.visit(_this, context); });\n        return new BuiltinFunctionCall(ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    };\n    return _BuiltinAstConverter;\n}(AstTransformer));\nvar _AstToIrVisitor = (function () {\n    /**\n     * @param {?} _localResolver\n     * @param {?} _implicitReceiver\n     * @param {?} bindingId\n     */\n    function _AstToIrVisitor(_localResolver, _implicitReceiver, bindingId) {\n        this._localResolver = _localResolver;\n        this._implicitReceiver = _implicitReceiver;\n        this.bindingId = bindingId;\n        this._nodeMap = new Map();\n        this._resultMap = new Map();\n        this._currentTemporary = 0;\n        this.temporaryCount = 0;\n    }\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {\n        var /** @type {?} */ op;\n        switch (ast.operation) {\n            case '+':\n                op = BinaryOperator.Plus;\n                break;\n            case '-':\n                op = BinaryOperator.Minus;\n                break;\n            case '*':\n                op = BinaryOperator.Multiply;\n                break;\n            case '/':\n                op = BinaryOperator.Divide;\n                break;\n            case '%':\n                op = BinaryOperator.Modulo;\n                break;\n            case '&&':\n                op = BinaryOperator.And;\n                break;\n            case '||':\n                op = BinaryOperator.Or;\n                break;\n            case '==':\n                op = BinaryOperator.Equals;\n                break;\n            case '!=':\n                op = BinaryOperator.NotEquals;\n                break;\n            case '===':\n                op = BinaryOperator.Identical;\n                break;\n            case '!==':\n                op = BinaryOperator.NotIdentical;\n                break;\n            case '<':\n                op = BinaryOperator.Lower;\n                break;\n            case '>':\n                op = BinaryOperator.Bigger;\n                break;\n            case '<=':\n                op = BinaryOperator.LowerEquals;\n                break;\n            case '>=':\n                op = BinaryOperator.BiggerEquals;\n                break;\n            default:\n                throw new Error(\"Unsupported operation \" + ast.operation);\n        }\n        return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this.visit(ast.left, _Mode.Expression), this.visit(ast.right, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitChain = function (ast, mode) {\n        ensureStatementMode(mode, ast);\n        return this.visitAll(ast.expressions, mode);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {\n        var /** @type {?} */ value = this.visit(ast.condition, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, value.conditional(this.visit(ast.trueExp, _Mode.Expression), this.visit(ast.falseExp, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {\n        throw new Error(\"Illegal state: Pipes should have been converted into functions. Pipe: \" + ast.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {\n        var /** @type {?} */ convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n        var /** @type {?} */ fnResult;\n        if (ast instanceof BuiltinFunctionCall) {\n            fnResult = ast.converter(convertedArgs);\n        }\n        else {\n            fnResult = this.visit(ast.target, _Mode.Expression).callFn(convertedArgs);\n        }\n        return convertToStatementIfNeeded(mode, fnResult);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {\n        ensureExpressionMode(mode, ast);\n        return this._implicitReceiver;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {\n        ensureExpressionMode(mode, ast);\n        var /** @type {?} */ args = [literal(ast.expressions.length)];\n        for (var /** @type {?} */ i = 0; i < ast.strings.length - 1; i++) {\n            args.push(literal(ast.strings[i]));\n            args.push(this.visit(ast.expressions[i], _Mode.Expression));\n        }\n        args.push(literal(ast.strings[ast.strings.length - 1]));\n        return ast.expressions.length <= 9 ?\n            importExpr(createIdentifier(Identifiers.inlineInterpolate)).callFn(args) :\n            importExpr(createIdentifier(Identifiers.interpolate)).callFn([\n                args[0], literalArr(args.slice(1))\n            ]);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {\n        var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            return convertToStatementIfNeeded(mode, this.visit(ast.obj, _Mode.Expression).key(this.visit(ast.key, _Mode.Expression)));\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {\n        var /** @type {?} */ obj = this.visit(ast.obj, _Mode.Expression);\n        var /** @type {?} */ key = this.visit(ast.key, _Mode.Expression);\n        var /** @type {?} */ value = this.visit(ast.value, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {\n        throw new Error(\"Illegal State: literal arrays should have been converted into functions\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {\n        throw new Error(\"Illegal State: literal maps should have been converted into functions\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, literal(ast.value));\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype._getLocal = function (name) { return this._localResolver.getLocal(name); };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {\n        var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            var /** @type {?} */ args = this.visitAll(ast.args, _Mode.Expression);\n            var /** @type {?} */ result = null;\n            var /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                var /** @type {?} */ varExpr = this._getLocal(ast.name);\n                if (varExpr) {\n                    result = varExpr.callFn(args);\n                }\n            }\n            if (result == null) {\n                result = receiver.callMethod(ast.name, args);\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {\n        return convertToStatementIfNeeded(mode, not(this.visit(ast.expression, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {\n        var /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            var /** @type {?} */ result = null;\n            var /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                result = this._getLocal(ast.name);\n            }\n            if (result == null) {\n                result = receiver.prop(ast.name);\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {\n        var /** @type {?} */ receiver = this.visit(ast.receiver, _Mode.Expression);\n        if (receiver === this._implicitReceiver) {\n            var /** @type {?} */ varExpr = this._getLocal(ast.name);\n            if (varExpr) {\n                throw new Error('Cannot assign to a reference or variable!');\n            }\n        }\n        return convertToStatementIfNeeded(mode, receiver.prop(ast.name).set(this.visit(ast.value, _Mode.Expression)));\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n    /**\n     * @param {?} asts\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitAll = function (asts, mode) {\n        var _this = this;\n        return asts.map(function (ast) { return _this.visit(ast, mode); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {\n        throw new Error('Quotes are not supported for evaluation!');\n    };\n    /**\n     * @param {?} ast\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.visit = function (ast, mode) {\n        var /** @type {?} */ result = this._resultMap.get(ast);\n        if (result)\n            return result;\n        return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} leftMostSafe\n     * @param {?} mode\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.convertSafeAccess = function (ast, leftMostSafe, mode) {\n        // If the expression contains a safe access node on the left it needs to be converted to\n        // an expression that guards the access to the member by checking the receiver for blank. As\n        // execution proceeds from left to right, the left most part of the expression must be guarded\n        // first but, because member access is left associative, the right side of the expression is at\n        // the top of the AST. The desired result requires lifting a copy of the the left part of the\n        // expression up to test it for blank before generating the unguarded version.\n        // Consider, for example the following expression: a?.b.c?.d.e\n        // This results in the ast:\n        //         .\n        //        / \\\n        //       ?.   e\n        //      /  \\\n        //     .    d\n        //    / \\\n        //   ?.  c\n        //  /  \\\n        // a    b\n        // The following tree should be generated:\n        //\n        //        /---- ? ----\\\n        //       /      |      \\\n        //     a   /--- ? ---\\  null\n        //        /     |     \\\n        //       .      .     null\n        //      / \\    / \\\n        //     .  c   .   e\n        //    / \\    / \\\n        //   a   b  ,   d\n        //         / \\\n        //        .   c\n        //       / \\\n        //      a   b\n        //\n        // Notice that the first guard condition is the left hand of the left most safe access node\n        // which comes in as leftMostSafe to this routine.\n        var /** @type {?} */ guardedExpression = this.visit(leftMostSafe.receiver, _Mode.Expression);\n        var /** @type {?} */ temporary;\n        if (this.needsTemporary(leftMostSafe.receiver)) {\n            // If the expression has method calls or pipes then we need to save the result into a\n            // temporary variable to avoid calling stateful or impure code more than once.\n            temporary = this.allocateTemporary();\n            // Preserve the result in the temporary variable\n            guardedExpression = temporary.set(guardedExpression);\n            // Ensure all further references to the guarded expression refer to the temporary instead.\n            this._resultMap.set(leftMostSafe.receiver, temporary);\n        }\n        var /** @type {?} */ condition = guardedExpression.isBlank();\n        // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n        // leftMostNode with its unguarded version in the call to `this.visit()`.\n        if (leftMostSafe instanceof SafeMethodCall) {\n            this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n        }\n        else {\n            this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n        }\n        // Recursively convert the node now without the guarded member access.\n        var /** @type {?} */ access = this.visit(ast, _Mode.Expression);\n        // Remove the mapping. This is not strictly required as the converter only traverses each node\n        // once but is safer if the conversion is changed to traverse the nodes more than once.\n        this._nodeMap.delete(leftMostSafe);\n        // If we allocated a temporary, release it.\n        if (temporary) {\n            this.releaseTemporary(temporary);\n        }\n        // Produce the conditional\n        return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));\n    };\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.leftMostSafeNode = function (ast) {\n        var _this = this;\n        var /** @type {?} */ visit = function (visitor, ast) {\n            return (_this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        return ast.visit({\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitBinary: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitChain: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitConditional: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitFunctionCall: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitImplicitReceiver: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitInterpolation: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedRead: function (ast) { return visit(this, ast.obj); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedWrite: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralArray: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralMap: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralPrimitive: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitMethodCall: function (ast) { return visit(this, ast.receiver); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPipe: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPrefixNot: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyRead: function (ast) { return visit(this, ast.receiver); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyWrite: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitQuote: function (ast) { return null; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafeMethodCall: function (ast) { return visit(this, ast.receiver) || ast; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafePropertyRead: function (ast) {\n                return visit(this, ast.receiver) || ast;\n            }\n        });\n    };\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.needsTemporary = function (ast) {\n        var _this = this;\n        var /** @type {?} */ visit = function (visitor, ast) {\n            return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        var /** @type {?} */ visitSome = function (visitor, ast) {\n            return ast.some(function (ast) { return visit(visitor, ast); });\n        };\n        return ast.visit({\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitBinary: function (ast) { return visit(this, ast.left) || visit(this, ast.right); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitChain: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitConditional: function (ast) {\n                return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                    visit(this, ast.falseExp);\n            },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitFunctionCall: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitImplicitReceiver: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitInterpolation: function (ast) { return visitSome(this, ast.expressions); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedRead: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitKeyedWrite: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralArray: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralMap: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitLiteralPrimitive: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitMethodCall: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPipe: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPrefixNot: function (ast) { return visit(this, ast.expression); },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyRead: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitPropertyWrite: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitQuote: function (ast) { return false; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafeMethodCall: function (ast) { return true; },\n            /**\n             * @param {?} ast\n             * @return {?}\n             */\n            visitSafePropertyRead: function (ast) { return false; }\n        });\n    };\n    /**\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.allocateTemporary = function () {\n        var /** @type {?} */ tempNumber = this._currentTemporary++;\n        this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n        return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    };\n    /**\n     * @param {?} temporary\n     * @return {?}\n     */\n    _AstToIrVisitor.prototype.releaseTemporary = function (temporary) {\n        this._currentTemporary--;\n        if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n            throw new Error(\"Temporary \" + temporary.name + \" released out of order\");\n        }\n    };\n    return _AstToIrVisitor;\n}());\n/**\n * @param {?} arg\n * @param {?} output\n * @return {?}\n */\nfunction flattenStatements(arg, output) {\n    if (Array.isArray(arg)) {\n        ((arg)).forEach(function (entry) { return flattenStatements(entry, output); });\n    }\n    else {\n        output.push(arg);\n    }\n}\nvar DefaultLocalResolver = (function () {\n    function DefaultLocalResolver() {\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    DefaultLocalResolver.prototype.getLocal = function (name) {\n        if (name === EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        return null;\n    };\n    return DefaultLocalResolver;\n}());\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createCurrValueExpr(bindingId) {\n    return variable(\"currVal_\" + bindingId); // fix syntax highlighting: `\n}\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createPreventDefaultVar(bindingId) {\n    return variable(\"pd_\" + bindingId);\n}\n/**\n * @param {?} stmt\n * @return {?}\n */\nfunction convertStmtIntoExpression(stmt) {\n    if (stmt instanceof ExpressionStatement) {\n        return stmt.expr;\n    }\n    else if (stmt instanceof ReturnStatement) {\n        return stmt.value;\n    }\n    return null;\n}\nvar BuiltinFunctionCall = (function (_super) {\n    __extends(BuiltinFunctionCall, _super);\n    /**\n     * @param {?} span\n     * @param {?} args\n     * @param {?} converter\n     */\n    function BuiltinFunctionCall(span, args, converter) {\n        var _this = _super.call(this, span, null, args) || this;\n        _this.args = args;\n        _this.converter = converter;\n        return _this;\n    }\n    return BuiltinFunctionCall;\n}(FunctionCall));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar CLASS_ATTR$1 = 'class';\nvar STYLE_ATTR = 'style';\nvar IMPLICIT_TEMPLATE_VAR = '\\$implicit';\nvar NG_CONTAINER_TAG = 'ng-container';\nvar ViewCompileResult = (function () {\n    /**\n     * @param {?} statements\n     * @param {?} viewClassVar\n     * @param {?} rendererTypeVar\n     */\n    function ViewCompileResult(statements, viewClassVar, rendererTypeVar) {\n        this.statements = statements;\n        this.viewClassVar = viewClassVar;\n        this.rendererTypeVar = rendererTypeVar;\n    }\n    return ViewCompileResult;\n}());\nvar ViewCompiler = (function () {\n    /**\n     * @param {?} _genConfigNext\n     * @param {?} _schemaRegistry\n     */\n    function ViewCompiler(_genConfigNext, _schemaRegistry) {\n        this._genConfigNext = _genConfigNext;\n        this._schemaRegistry = _schemaRegistry;\n    }\n    /**\n     * @param {?} component\n     * @param {?} template\n     * @param {?} styles\n     * @param {?} usedPipes\n     * @return {?}\n     */\n    ViewCompiler.prototype.compileComponent = function (component, template, styles, usedPipes) {\n        var /** @type {?} */ embeddedViewCount = 0;\n        var /** @type {?} */ staticQueryIds = findStaticQueryIds(template);\n        var /** @type {?} */ statements = [];\n        var /** @type {?} */ renderComponentVarName;\n        if (!component.isHost) {\n            var /** @type {?} */ customRenderData = [];\n            if (component.template.animations && component.template.animations.length) {\n                customRenderData.push(new LiteralMapEntry('animation', convertValueToOutputAst(component.template.animations), true));\n            }\n            var /** @type {?} */ renderComponentVar = variable(rendererTypeName(component.type.reference));\n            renderComponentVarName = renderComponentVar.name;\n            statements.push(renderComponentVar\n                .set(importExpr(createIdentifier(Identifiers.createRendererType2))\n                .callFn([new LiteralMapExpr([\n                    new LiteralMapEntry('encapsulation', literal(component.template.encapsulation)),\n                    new LiteralMapEntry('styles', styles),\n                    new LiteralMapEntry('data', new LiteralMapExpr(customRenderData))\n                ])]))\n                .toDeclStmt(importType(createIdentifier(Identifiers.RendererType2)), [StmtModifier.Final]));\n        }\n        var /** @type {?} */ viewBuilderFactory = function (parent) {\n            var /** @type {?} */ embeddedViewIndex = embeddedViewCount++;\n            return new ViewBuilder(parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory);\n        };\n        var /** @type {?} */ visitor = viewBuilderFactory(null);\n        visitor.visitAll([], template);\n        statements.push.apply(statements, visitor.build());\n        return new ViewCompileResult(statements, visitor.viewName, renderComponentVarName);\n    };\n    return ViewCompiler;\n}());\nViewCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nViewCompiler.ctorParameters = function () { return [\n    { type: CompilerConfig, },\n    { type: ElementSchemaRegistry, },\n]; };\nvar LOG_VAR = variable('l');\nvar VIEW_VAR = variable('v');\nvar CHECK_VAR = variable('ck');\nvar COMP_VAR = variable('co');\nvar EVENT_NAME_VAR = variable('en');\nvar ALLOW_DEFAULT_VAR = variable(\"ad\");\nvar ViewBuilder = (function () {\n    /**\n     * @param {?} parent\n     * @param {?} component\n     * @param {?} embeddedViewIndex\n     * @param {?} usedPipes\n     * @param {?} staticQueryIds\n     * @param {?} viewBuilderFactory\n     */\n    function ViewBuilder(parent, component, embeddedViewIndex, usedPipes, staticQueryIds, viewBuilderFactory) {\n        this.parent = parent;\n        this.component = component;\n        this.embeddedViewIndex = embeddedViewIndex;\n        this.usedPipes = usedPipes;\n        this.staticQueryIds = staticQueryIds;\n        this.viewBuilderFactory = viewBuilderFactory;\n        this.nodes = [];\n        this.purePipeNodeIndices = Object.create(null);\n        this.refNodeIndices = Object.create(null);\n        this.variables = [];\n        this.children = [];\n        // TODO(tbosch): The old view compiler used to use an `any` type\n        // for the context in any embedded view. We keep this behaivor for now\n        // to be able to introduce the new view compiler without too many errors.\n        this.compType = this.embeddedViewIndex > 0 ? DYNAMIC_TYPE : importType(this.component.type);\n    }\n    Object.defineProperty(ViewBuilder.prototype, \"viewName\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return viewClassName(this.component.type.reference, this.embeddedViewIndex);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @param {?} variables\n     * @param {?} astNodes\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitAll = function (variables, astNodes) {\n        var _this = this;\n        this.variables = variables;\n        // create the pipes for the pure pipes immediately, so that we know their indices.\n        if (!this.parent) {\n            this.usedPipes.forEach(function (pipe) {\n                if (pipe.pure) {\n                    _this.purePipeNodeIndices[pipe.name] = _this._createPipe(null, pipe);\n                }\n            });\n        }\n        if (!this.parent) {\n            var /** @type {?} */ queryIds_1 = staticViewQueryIds(this.staticQueryIds);\n            this.component.viewQueries.forEach(function (query, queryIndex) {\n                // Note: queries start with id 1 so we can use the number in a Bloom filter!\n                var /** @type {?} */ queryId = queryIndex + 1;\n                var /** @type {?} */ bindingType = query.first ? 0 /* First */ : 1;\n                var /** @type {?} */ flags = 67108864 /* TypeViewQuery */ | calcStaticDynamicQueryFlags(queryIds_1, queryId, query.first);\n                _this.nodes.push(function () { return ({\n                    sourceSpan: null,\n                    nodeFlags: flags,\n                    nodeDef: importExpr(createIdentifier(Identifiers.queryDef)).callFn([\n                        literal(flags), literal(queryId),\n                        new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType))])\n                    ])\n                }); });\n            });\n        }\n        templateVisitAll(this, astNodes);\n        if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {\n            // if the view is an embedded view, then we need to add an additional root node in some cases\n            this.nodes.push(function () { return ({\n                sourceSpan: null,\n                nodeFlags: 1 /* TypeElement */,\n                nodeDef: importExpr(createIdentifier(Identifiers.anchorDef)).callFn([\n                    literal(0 /* None */), NULL_EXPR, NULL_EXPR, literal(0)\n                ])\n            }); });\n        }\n    };\n    /**\n     * @param {?=} targetStatements\n     * @return {?}\n     */\n    ViewBuilder.prototype.build = function (targetStatements) {\n        if (targetStatements === void 0) { targetStatements = []; }\n        this.children.forEach(function (child) { return child.build(targetStatements); });\n        var _a = this._createNodeExpressions(), updateRendererStmts = _a.updateRendererStmts, updateDirectivesStmts = _a.updateDirectivesStmts, nodeDefExprs = _a.nodeDefExprs;\n        var /** @type {?} */ updateRendererFn = this._createUpdateFn(updateRendererStmts);\n        var /** @type {?} */ updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);\n        var /** @type {?} */ viewFlags = 0;\n        if (!this.parent && this.component.changeDetection === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_0\" /* ChangeDetectionStrategy */].OnPush) {\n            viewFlags |= 2 /* OnPush */;\n        }\n        var /** @type {?} */ viewFactory = new DeclareFunctionStmt(this.viewName, [new FnParam(LOG_VAR.name)], [new ReturnStatement(importExpr(createIdentifier(Identifiers.viewDef)).callFn([\n                literal(viewFlags),\n                literalArr(nodeDefExprs),\n                updateDirectivesFn,\n                updateRendererFn,\n            ]))], importType(createIdentifier(Identifiers.ViewDefinition)));\n        targetStatements.push(viewFactory);\n        return targetStatements;\n    };\n    /**\n     * @param {?} updateStmts\n     * @return {?}\n     */\n    ViewBuilder.prototype._createUpdateFn = function (updateStmts) {\n        var /** @type {?} */ updateFn;\n        if (updateStmts.length > 0) {\n            var /** @type {?} */ preStmts = [];\n            if (!this.component.isHost && findReadVarNames(updateStmts).has(COMP_VAR.name)) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            updateFn = fn([\n                new FnParam(CHECK_VAR.name, INFERRED_TYPE),\n                new FnParam(VIEW_VAR.name, INFERRED_TYPE)\n            ], preStmts.concat(updateStmts), INFERRED_TYPE);\n        }\n        else {\n            updateFn = NULL_EXPR;\n        }\n        return updateFn;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitNgContent = function (ast, context) {\n        // ngContentDef(ngContentIndex: number, index: number): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 4 /* TypeNgContent */,\n            nodeDef: importExpr(createIdentifier(Identifiers.ngContentDef)).callFn([\n                literal(ast.ngContentIndex), literal(ast.index)\n            ])\n        }); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitText = function (ast, context) {\n        // textDef(ngContentIndex: number, constants: string[]): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: importExpr(createIdentifier(Identifiers.textDef)).callFn([\n                literal(ast.ngContentIndex), literalArr([literal(ast.value)])\n            ])\n        }); });\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitBoundText = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(null);\n        var /** @type {?} */ astWithSource = (ast.value);\n        var /** @type {?} */ inter = (astWithSource.ast);\n        var /** @type {?} */ updateRendererExpressions = inter.expressions.map(function (expr, bindingIndex) { return _this._preprocessUpdateExpression({ nodeIndex: nodeIndex, bindingIndex: bindingIndex, sourceSpan: ast.sourceSpan, context: COMP_VAR, value: expr }); });\n        // textDef(ngContentIndex: number, constants: string[]): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 2 /* TypeText */,\n            nodeDef: importExpr(createIdentifier(Identifiers.textDef)).callFn([\n                literal(ast.ngContentIndex), literalArr(inter.strings.map(function (s) { return literal(s); }))\n            ]),\n            updateRenderer: updateRendererExpressions\n        }); };\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitEmbeddedTemplate = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array\n        this.nodes.push(null);\n        var _a = this._visitElementOrTemplate(nodeIndex, ast), flags = _a.flags, queryMatchesExpr = _a.queryMatchesExpr, hostEvents = _a.hostEvents;\n        var /** @type {?} */ childVisitor = this.viewBuilderFactory(this);\n        this.children.push(childVisitor);\n        childVisitor.visitAll(ast.variables, ast.children);\n        var /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        // anchorDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,\n        //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:\n        //   ViewDefinitionFactory): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: importExpr(createIdentifier(Identifiers.anchorDef)).callFn([\n                literal(flags),\n                queryMatchesExpr,\n                literal(ast.ngContentIndex),\n                literal(childCount),\n                _this._createElementHandleEventFn(nodeIndex, hostEvents),\n                variable(childVisitor.viewName),\n            ])\n        }); };\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitElement = function (ast, context) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(null);\n        var /** @type {?} */ elName = ast.name;\n        if (ast.name === NG_CONTAINER_TAG) {\n            // Using a null element name creates an anchor.\n            elName = null;\n        }\n        var _a = this._visitElementOrTemplate(nodeIndex, ast), flags = _a.flags, usedEvents = _a.usedEvents, queryMatchesExpr = _a.queryMatchesExpr, dirHostBindings = _a.hostBindings, hostEvents = _a.hostEvents;\n        var /** @type {?} */ inputDefs = [];\n        var /** @type {?} */ updateRendererExpressions = [];\n        var /** @type {?} */ outputDefs = [];\n        if (elName) {\n            var /** @type {?} */ hostBindings = ast.inputs\n                .map(function (inputAst) { return ({\n                context: /** @type {?} */ (COMP_VAR),\n                inputAst: inputAst,\n                dirAst: null,\n            }); })\n                .concat(dirHostBindings);\n            if (hostBindings.length) {\n                updateRendererExpressions =\n                    hostBindings.map(function (hostBinding, bindingIndex) { return _this._preprocessUpdateExpression({\n                        context: hostBinding.context,\n                        nodeIndex: nodeIndex,\n                        bindingIndex: bindingIndex,\n                        sourceSpan: hostBinding.inputAst.sourceSpan,\n                        value: hostBinding.inputAst.value\n                    }); });\n                inputDefs = hostBindings.map(function (hostBinding) { return elementBindingDef(hostBinding.inputAst, hostBinding.dirAst); });\n            }\n            outputDefs = usedEvents.map(function (_a) {\n                var target = _a[0], eventName = _a[1];\n                return literalArr([literal(target), literal(eventName)]);\n            });\n        }\n        templateVisitAll(this, ast.children);\n        var /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        var /** @type {?} */ compAst = ast.directives.find(function (dirAst) { return dirAst.directive.isComponent; });\n        var /** @type {?} */ compRendererType = NULL_EXPR;\n        var /** @type {?} */ compView = NULL_EXPR;\n        if (compAst) {\n            compView = importExpr({ reference: compAst.directive.componentViewType });\n            compRendererType = importExpr({ reference: compAst.directive.rendererType });\n        }\n        // elementDef(\n        //   flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][],\n        //   ngContentIndex: number, childCount: number, namespaceAndName: string,\n        //   fixedAttrs: [string, string][] = [],\n        //   bindings?: [BindingFlags, string, string | SecurityContext][],\n        //   outputs?: ([OutputType.ElementOutput | OutputType.DirectiveHostOutput, string, string])[],\n        //   handleEvent?: ElementHandleEventFn,\n        //   componentView?: () => ViewDefinition, componentRendererType?: RendererType2): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: ast.sourceSpan,\n            nodeFlags: 1 /* TypeElement */ | flags,\n            nodeDef: importExpr(createIdentifier(Identifiers.elementDef)).callFn([\n                literal(flags),\n                queryMatchesExpr,\n                literal(ast.ngContentIndex),\n                literal(childCount),\n                literal(elName),\n                elName ? fixedAttrsDef(ast) : NULL_EXPR,\n                inputDefs.length ? literalArr(inputDefs) : NULL_EXPR,\n                outputDefs.length ? literalArr(outputDefs) : NULL_EXPR,\n                _this._createElementHandleEventFn(nodeIndex, hostEvents),\n                compView,\n                compRendererType,\n            ]),\n            updateRenderer: updateRendererExpressions\n        }); };\n    };\n    /**\n     * @param {?} nodeIndex\n     * @param {?} ast\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitElementOrTemplate = function (nodeIndex, ast) {\n        var _this = this;\n        var /** @type {?} */ flags = 0;\n        if (ast.hasViewContainer) {\n            flags |= 8388608 /* EmbeddedViews */;\n        }\n        var /** @type {?} */ usedEvents = new Map();\n        ast.outputs.forEach(function (event) {\n            var _a = elementEventNameAndTarget(event, null), name = _a.name, target = _a.target;\n            usedEvents.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_47\" /* ɵelementEventFullName */])(target, name), [target, name]);\n        });\n        ast.directives.forEach(function (dirAst) {\n            dirAst.hostEvents.forEach(function (event) {\n                var _a = elementEventNameAndTarget(event, dirAst), name = _a.name, target = _a.target;\n                usedEvents.set(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_47\" /* ɵelementEventFullName */])(target, name), [target, name]);\n            });\n        });\n        var /** @type {?} */ hostBindings = [];\n        var /** @type {?} */ hostEvents = [];\n        var /** @type {?} */ componentFactoryResolverProvider = createComponentFactoryResolver(ast.directives);\n        if (componentFactoryResolverProvider) {\n            this._visitProvider(componentFactoryResolverProvider, ast.queryMatches);\n        }\n        ast.providers.forEach(function (providerAst, providerIndex) {\n            var /** @type {?} */ dirAst;\n            var /** @type {?} */ dirIndex;\n            ast.directives.forEach(function (localDirAst, i) {\n                if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {\n                    dirAst = localDirAst;\n                    dirIndex = i;\n                }\n            });\n            if (dirAst) {\n                var _a = _this._visitDirective(providerAst, dirAst, dirIndex, nodeIndex, ast.references, ast.queryMatches, usedEvents, _this.staticQueryIds.get(/** @type {?} */ (ast))), dirHostBindings = _a.hostBindings, dirHostEvents = _a.hostEvents;\n                hostBindings.push.apply(hostBindings, dirHostBindings);\n                hostEvents.push.apply(hostEvents, dirHostEvents);\n            }\n            else {\n                _this._visitProvider(providerAst, ast.queryMatches);\n            }\n        });\n        var /** @type {?} */ queryMatchExprs = [];\n        ast.queryMatches.forEach(function (match) {\n            var /** @type {?} */ valueType;\n            if (tokenReference(match.value) === resolveIdentifier(Identifiers.ElementRef)) {\n                valueType = 0 /* ElementRef */;\n            }\n            else if (tokenReference(match.value) === resolveIdentifier(Identifiers.ViewContainerRef)) {\n                valueType = 3 /* ViewContainerRef */;\n            }\n            else if (tokenReference(match.value) === resolveIdentifier(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(valueType)]));\n            }\n        });\n        ast.references.forEach(function (ref) {\n            var /** @type {?} */ valueType;\n            if (!ref.value) {\n                valueType = 1 /* RenderElement */;\n            }\n            else if (tokenReference(ref.value) === resolveIdentifier(Identifiers.TemplateRef)) {\n                valueType = 2 /* TemplateRef */;\n            }\n            if (valueType != null) {\n                _this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(valueType)]));\n            }\n        });\n        ast.outputs.forEach(function (outputAst) {\n            hostEvents.push({ context: COMP_VAR, eventAst: outputAst, dirAst: null });\n        });\n        return {\n            flags: flags,\n            usedEvents: Array.from(usedEvents.values()),\n            queryMatchesExpr: queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n            hostBindings: hostBindings,\n            hostEvents: hostEvents\n        };\n    };\n    /**\n     * @param {?} providerAst\n     * @param {?} dirAst\n     * @param {?} directiveIndex\n     * @param {?} elementNodeIndex\n     * @param {?} refs\n     * @param {?} queryMatches\n     * @param {?} usedEvents\n     * @param {?} queryIds\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitDirective = function (providerAst, dirAst, directiveIndex, elementNodeIndex, refs, queryMatches, usedEvents, queryIds) {\n        var _this = this;\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(null);\n        dirAst.directive.queries.forEach(function (query, queryIndex) {\n            var /** @type {?} */ queryId = dirAst.contentQueryStartId + queryIndex;\n            var /** @type {?} */ flags = 33554432 /* TypeContentQuery */ | calcStaticDynamicQueryFlags(queryIds, queryId, query.first);\n            var /** @type {?} */ bindingType = query.first ? 0 /* First */ : 1;\n            _this.nodes.push(function () { return ({\n                sourceSpan: dirAst.sourceSpan,\n                nodeFlags: flags,\n                nodeDef: importExpr(createIdentifier(Identifiers.queryDef)).callFn([\n                    literal(flags), literal(queryId),\n                    new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType))])\n                ]),\n            }); });\n        });\n        // Note: the operation below might also create new nodeDefs,\n        // but we don't want them to be a child of a directive,\n        // as they might be a provider/pipe on their own.\n        // I.e. we only allow queries as children of directives nodes.\n        var /** @type {?} */ childCount = this.nodes.length - nodeIndex - 1;\n        var _a = this._visitProviderOrDirective(providerAst, queryMatches), flags = _a.flags, queryMatchExprs = _a.queryMatchExprs, providerExpr = _a.providerExpr, depsExpr = _a.depsExpr;\n        refs.forEach(function (ref) {\n            if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {\n                _this.refNodeIndices[ref.name] = nodeIndex;\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(4 /* Provider */)]));\n            }\n        });\n        if (dirAst.directive.isComponent) {\n            flags |= 16384 /* Component */;\n        }\n        var /** @type {?} */ inputDefs = dirAst.inputs.map(function (inputAst, inputIndex) {\n            var /** @type {?} */ mapValue = literalArr([literal(inputIndex), literal(inputAst.directiveName)]);\n            // Note: it's important to not quote the key so that we can capture renames by minifiers!\n            return new LiteralMapEntry(inputAst.directiveName, mapValue, false);\n        });\n        var /** @type {?} */ outputDefs = [];\n        var /** @type {?} */ dirMeta = dirAst.directive;\n        Object.keys(dirMeta.outputs).forEach(function (propName) {\n            var /** @type {?} */ eventName = dirMeta.outputs[propName];\n            if (usedEvents.has(eventName)) {\n                // Note: it's important to not quote the key so that we can capture renames by minifiers!\n                outputDefs.push(new LiteralMapEntry(propName, literal(eventName), false));\n            }\n        });\n        var /** @type {?} */ updateDirectiveExpressions = [];\n        if (dirAst.inputs.length || (flags & (131072 /* DoCheck */ | 32768 /* OnInit */)) > 0) {\n            updateDirectiveExpressions =\n                dirAst.inputs.map(function (input, bindingIndex) { return _this._preprocessUpdateExpression({\n                    nodeIndex: nodeIndex,\n                    bindingIndex: bindingIndex,\n                    sourceSpan: input.sourceSpan,\n                    context: COMP_VAR,\n                    value: input.value\n                }); });\n        }\n        var /** @type {?} */ dirContextExpr = importExpr(createIdentifier(Identifiers.nodeValue)).callFn([\n            VIEW_VAR, literal(nodeIndex)\n        ]);\n        var /** @type {?} */ hostBindings = dirAst.hostProperties.map(function (inputAst) { return ({\n            context: dirContextExpr,\n            dirAst: dirAst,\n            inputAst: inputAst,\n        }); });\n        var /** @type {?} */ hostEvents = dirAst.hostEvents.map(function (hostEventAst) { return ({\n            context: dirContextExpr,\n            eventAst: hostEventAst, dirAst: dirAst,\n        }); });\n        // directiveDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], childCount: number, ctor:\n        //   any,\n        //   deps: ([DepFlags, any] | any)[], props?: {[name: string]: [number, string]},\n        //   outputs?: {[name: string]: string}, component?: () => ViewDefinition): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: dirAst.sourceSpan,\n            nodeFlags: 8192 /* TypeDirective */ | flags,\n            nodeDef: importExpr(createIdentifier(Identifiers.directiveDef)).callFn([\n                literal(flags), queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n                literal(childCount), providerExpr, depsExpr,\n                inputDefs.length ? new LiteralMapExpr(inputDefs) : NULL_EXPR,\n                outputDefs.length ? new LiteralMapExpr(outputDefs) : NULL_EXPR\n            ]),\n            updateDirectives: updateDirectiveExpressions,\n            directive: dirAst.directive.type,\n        }); };\n        return { hostBindings: hostBindings, hostEvents: hostEvents };\n    };\n    /**\n     * @param {?} providerAst\n     * @param {?} queryMatches\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitProvider = function (providerAst, queryMatches) {\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // reserve the space in the nodeDefs array so we can add children\n        this.nodes.push(null);\n        var _a = this._visitProviderOrDirective(providerAst, queryMatches), flags = _a.flags, queryMatchExprs = _a.queryMatchExprs, providerExpr = _a.providerExpr, depsExpr = _a.depsExpr;\n        // providerDef(\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,\n        //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\n        this.nodes[nodeIndex] = function () { return ({\n            sourceSpan: providerAst.sourceSpan,\n            nodeFlags: flags,\n            nodeDef: importExpr(createIdentifier(Identifiers.providerDef)).callFn([\n                literal(flags), queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n                tokenExpr(providerAst.token), providerExpr, depsExpr\n            ])\n        }); };\n    };\n    /**\n     * @param {?} providerAst\n     * @param {?} queryMatches\n     * @return {?}\n     */\n    ViewBuilder.prototype._visitProviderOrDirective = function (providerAst, queryMatches) {\n        var /** @type {?} */ flags = 0;\n        if (!providerAst.eager) {\n            flags |= 2048 /* LazyProvider */;\n        }\n        if (providerAst.providerType === ProviderAstType.PrivateService) {\n            flags |= 4096 /* PrivateProvider */;\n        }\n        providerAst.lifecycleHooks.forEach(function (lifecycleHook) {\n            // for regular providers, we only support ngOnDestroy\n            if (lifecycleHook === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnDestroy ||\n                providerAst.providerType === ProviderAstType.Directive ||\n                providerAst.providerType === ProviderAstType.Component) {\n                flags |= lifecycleHookToNodeFlag(lifecycleHook);\n            }\n        });\n        var /** @type {?} */ queryMatchExprs = [];\n        queryMatches.forEach(function (match) {\n            if (tokenReference(match.value) === tokenReference(providerAst.token)) {\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(4 /* Provider */)]));\n            }\n        });\n        var _a = providerDef(providerAst), providerExpr = _a.providerExpr, depsExpr = _a.depsExpr, providerType = _a.flags;\n        return { flags: flags | providerType, queryMatchExprs: queryMatchExprs, providerExpr: providerExpr, depsExpr: depsExpr };\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    ViewBuilder.prototype.getLocal = function (name) {\n        if (name == EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        var /** @type {?} */ currViewExpr = VIEW_VAR;\n        for (var /** @type {?} */ currBuilder = this; currBuilder; currBuilder = currBuilder.parent,\n            currViewExpr = currViewExpr.prop('parent').cast(DYNAMIC_TYPE)) {\n            // check references\n            var /** @type {?} */ refNodeIndex = currBuilder.refNodeIndices[name];\n            if (refNodeIndex != null) {\n                return importExpr(createIdentifier(Identifiers.nodeValue)).callFn([\n                    currViewExpr, literal(refNodeIndex)\n                ]);\n            }\n            // check variables\n            var /** @type {?} */ varAst = currBuilder.variables.find(function (varAst) { return varAst.name === name; });\n            if (varAst) {\n                var /** @type {?} */ varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;\n                return currViewExpr.prop('context').prop(varValue);\n            }\n        }\n        return null;\n    };\n    /**\n     * @param {?} sourceSpan\n     * @param {?} argCount\n     * @return {?}\n     */\n    ViewBuilder.prototype.createLiteralArrayConverter = function (sourceSpan, argCount) {\n        if (argCount === 0) {\n            var /** @type {?} */ valueExpr_1 = importExpr(createIdentifier(Identifiers.EMPTY_ARRAY));\n            return function () { return valueExpr_1; };\n        }\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // pureArrayDef(argCount: number): NodeDef;\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 16 /* TypePureArray */,\n            nodeDef: importExpr(createIdentifier(Identifiers.pureArrayDef)).callFn([literal(argCount)])\n        }); });\n        return function (args) { return callCheckStmt(nodeIndex, args); };\n    };\n    /**\n     * @param {?} sourceSpan\n     * @param {?} keys\n     * @return {?}\n     */\n    ViewBuilder.prototype.createLiteralMapConverter = function (sourceSpan, keys) {\n        if (keys.length === 0) {\n            var /** @type {?} */ valueExpr_2 = importExpr(createIdentifier(Identifiers.EMPTY_MAP));\n            return function () { return valueExpr_2; };\n        }\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        // function pureObjectDef(propertyNames: string[]): NodeDef\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 32 /* TypePureObject */,\n            nodeDef: importExpr(createIdentifier(Identifiers.pureObjectDef))\n                .callFn([literalArr(keys.map(function (key) { return literal(key); }))])\n        }); });\n        return function (args) { return callCheckStmt(nodeIndex, args); };\n    };\n    /**\n     * @param {?} expression\n     * @param {?} name\n     * @param {?} argCount\n     * @return {?}\n     */\n    ViewBuilder.prototype.createPipeConverter = function (expression, name, argCount) {\n        var /** @type {?} */ pipe = this.usedPipes.find(function (pipeSummary) { return pipeSummary.name === name; });\n        if (pipe.pure) {\n            var /** @type {?} */ nodeIndex_1 = this.nodes.length;\n            // function purePipeDef(argCount: number): NodeDef;\n            this.nodes.push(function () { return ({\n                sourceSpan: expression.sourceSpan,\n                nodeFlags: 64 /* TypePurePipe */,\n                nodeDef: importExpr(createIdentifier(Identifiers.purePipeDef))\n                    .callFn([literal(argCount)])\n            }); });\n            // find underlying pipe in the component view\n            var /** @type {?} */ compViewExpr = VIEW_VAR;\n            var /** @type {?} */ compBuilder = this;\n            while (compBuilder.parent) {\n                compBuilder = compBuilder.parent;\n                compViewExpr = compViewExpr.prop('parent').cast(DYNAMIC_TYPE);\n            }\n            var /** @type {?} */ pipeNodeIndex = compBuilder.purePipeNodeIndices[name];\n            var /** @type {?} */ pipeValueExpr_1 = importExpr(createIdentifier(Identifiers.nodeValue)).callFn([\n                compViewExpr, literal(pipeNodeIndex)\n            ]);\n            return function (args) { return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(nodeIndex_1, [pipeValueExpr_1].concat(args))); };\n        }\n        else {\n            var /** @type {?} */ nodeIndex = this._createPipe(expression.sourceSpan, pipe);\n            var /** @type {?} */ nodeValueExpr_1 = importExpr(createIdentifier(Identifiers.nodeValue)).callFn([\n                VIEW_VAR, literal(nodeIndex)\n            ]);\n            return function (args) { return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr_1.callMethod('transform', args)); };\n        }\n    };\n    /**\n     * @param {?} sourceSpan\n     * @param {?} pipe\n     * @return {?}\n     */\n    ViewBuilder.prototype._createPipe = function (sourceSpan, pipe) {\n        var /** @type {?} */ nodeIndex = this.nodes.length;\n        var /** @type {?} */ flags = 0;\n        pipe.type.lifecycleHooks.forEach(function (lifecycleHook) {\n            // for pipes, we only support ngOnDestroy\n            if (lifecycleHook === __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnDestroy) {\n                flags |= lifecycleHookToNodeFlag(lifecycleHook);\n            }\n        });\n        var /** @type {?} */ depExprs = pipe.type.diDeps.map(depDef);\n        // function pipeDef(\n        //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef\n        this.nodes.push(function () { return ({\n            sourceSpan: sourceSpan,\n            nodeFlags: 8 /* TypePipe */,\n            nodeDef: importExpr(createIdentifier(Identifiers.pipeDef)).callFn([\n                literal(flags), importExpr(pipe.type), literalArr(depExprs)\n            ])\n        }); });\n        return nodeIndex;\n    };\n    /**\n     * @param {?} expression\n     * @return {?}\n     */\n    ViewBuilder.prototype._preprocessUpdateExpression = function (expression) {\n        var _this = this;\n        return {\n            nodeIndex: expression.nodeIndex,\n            bindingIndex: expression.bindingIndex,\n            sourceSpan: expression.sourceSpan,\n            context: expression.context,\n            value: convertPropertyBindingBuiltins({\n                createLiteralArrayConverter: function (argCount) { return _this.createLiteralArrayConverter(expression.sourceSpan, argCount); },\n                createLiteralMapConverter: function (keys) { return _this.createLiteralMapConverter(expression.sourceSpan, keys); },\n                createPipeConverter: function (name, argCount) { return _this.createPipeConverter(expression, name, argCount); }\n            }, expression.value)\n        };\n    };\n    /**\n     * @return {?}\n     */\n    ViewBuilder.prototype._createNodeExpressions = function () {\n        var /** @type {?} */ self = this;\n        var /** @type {?} */ updateBindingCount = 0;\n        var /** @type {?} */ updateRendererStmts = [];\n        var /** @type {?} */ updateDirectivesStmts = [];\n        var /** @type {?} */ nodeDefExprs = this.nodes.map(function (factory, nodeIndex) {\n            var _a = factory(), nodeDef = _a.nodeDef, nodeFlags = _a.nodeFlags, updateDirectives = _a.updateDirectives, updateRenderer = _a.updateRenderer, sourceSpan = _a.sourceSpan;\n            if (updateRenderer) {\n                updateRendererStmts.push.apply(updateRendererStmts, createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false));\n            }\n            if (updateDirectives) {\n                updateDirectivesStmts.push.apply(updateDirectivesStmts, createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (131072 /* DoCheck */ | 32768 /* OnInit */)) > 0));\n            }\n            // We use a comma expression to call the log function before\n            // the nodeDef function, but still use the result of the nodeDef function\n            // as the value.\n            // Note: We only add the logger to elements / text nodes,\n            // so we don't generate too much code.\n            var /** @type {?} */ logWithNodeDef = nodeFlags & 3 /* CatRenderNode */ ?\n                new CommaExpr([LOG_VAR.callFn([]).callFn([]), nodeDef]) :\n                nodeDef;\n            return applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);\n        });\n        return { updateRendererStmts: updateRendererStmts, updateDirectivesStmts: updateDirectivesStmts, nodeDefExprs: nodeDefExprs };\n        /**\n         * @param {?} nodeIndex\n         * @param {?} sourceSpan\n         * @param {?} expressions\n         * @param {?} allowEmptyExprs\n         * @return {?}\n         */\n        function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {\n            var /** @type {?} */ updateStmts = [];\n            var /** @type {?} */ exprs = expressions.map(function (_a) {\n                var sourceSpan = _a.sourceSpan, context = _a.context, value = _a.value;\n                var /** @type {?} */ bindingId = \"\" + updateBindingCount++;\n                var /** @type {?} */ nameResolver = context === COMP_VAR ? self : null;\n                var _b = convertPropertyBinding(nameResolver, context, value, bindingId), stmts = _b.stmts, currValExpr = _b.currValExpr;\n                updateStmts.push.apply(updateStmts, stmts.map(function (stmt) { return applySourceSpanToStatementIfNeeded(stmt, sourceSpan); }));\n                return applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);\n            });\n            if (expressions.length || allowEmptyExprs) {\n                updateStmts.push(applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));\n            }\n            return updateStmts;\n        }\n    };\n    /**\n     * @param {?} nodeIndex\n     * @param {?} handlers\n     * @return {?}\n     */\n    ViewBuilder.prototype._createElementHandleEventFn = function (nodeIndex, handlers) {\n        var _this = this;\n        var /** @type {?} */ handleEventStmts = [];\n        var /** @type {?} */ handleEventBindingCount = 0;\n        handlers.forEach(function (_a) {\n            var context = _a.context, eventAst = _a.eventAst, dirAst = _a.dirAst;\n            var /** @type {?} */ bindingId = \"\" + handleEventBindingCount++;\n            var /** @type {?} */ nameResolver = context === COMP_VAR ? _this : null;\n            var _b = convertActionBinding(nameResolver, context, eventAst.handler, bindingId), stmts = _b.stmts, allowDefault = _b.allowDefault;\n            var /** @type {?} */ trueStmts = stmts;\n            if (allowDefault) {\n                trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());\n            }\n            var _c = elementEventNameAndTarget(eventAst, dirAst), eventTarget = _c.target, eventName = _c.name;\n            var /** @type {?} */ fullEventName = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_47\" /* ɵelementEventFullName */])(eventTarget, eventName);\n            handleEventStmts.push(applySourceSpanToStatementIfNeeded(new IfStmt(literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));\n        });\n        var /** @type {?} */ handleEventFn;\n        if (handleEventStmts.length > 0) {\n            var /** @type {?} */ preStmts = [ALLOW_DEFAULT_VAR.set(literal(true)).toDeclStmt(BOOL_TYPE)];\n            if (!this.component.isHost && findReadVarNames(handleEventStmts).has(COMP_VAR.name)) {\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n            }\n            handleEventFn = fn([\n                new FnParam(VIEW_VAR.name, INFERRED_TYPE),\n                new FnParam(EVENT_NAME_VAR.name, INFERRED_TYPE),\n                new FnParam(EventHandlerVars.event.name, INFERRED_TYPE)\n            ], preStmts.concat(handleEventStmts, [new ReturnStatement(ALLOW_DEFAULT_VAR)]), INFERRED_TYPE);\n        }\n        else {\n            handleEventFn = NULL_EXPR;\n        }\n        return handleEventFn;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitDirective = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitDirectiveProperty = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitReference = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitVariable = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitEvent = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitElementProperty = function (ast, context) { };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    ViewBuilder.prototype.visitAttr = function (ast, context) { };\n    return ViewBuilder;\n}());\n/**\n * @param {?} providerAst\n * @return {?}\n */\nfunction providerDef(providerAst) {\n    return providerAst.multiProvider ?\n        multiProviderDef(providerAst.providers) :\n        singleProviderDef(providerAst.providerType, providerAst.providers[0]);\n}\n/**\n * @param {?} providers\n * @return {?}\n */\nfunction multiProviderDef(providers) {\n    var /** @type {?} */ allDepDefs = [];\n    var /** @type {?} */ allParams = [];\n    var /** @type {?} */ exprs = providers.map(function (provider, providerIndex) {\n        var /** @type {?} */ expr;\n        if (provider.useClass) {\n            var /** @type {?} */ depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n            expr = importExpr(provider.useClass).instantiate(depExprs);\n        }\n        else if (provider.useFactory) {\n            var /** @type {?} */ depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n            expr = importExpr(provider.useFactory).callFn(depExprs);\n        }\n        else if (provider.useExisting) {\n            var /** @type {?} */ depExprs = convertDeps(providerIndex, [{ token: provider.useExisting }]);\n            expr = depExprs[0];\n        }\n        else {\n            expr = convertValueToOutputAst(provider.useValue);\n        }\n        return expr;\n    });\n    var /** @type {?} */ providerExpr = fn(allParams, [new ReturnStatement(literalArr(exprs))], INFERRED_TYPE);\n    return { providerExpr: providerExpr, flags: 512 /* TypeFactoryProvider */, depsExpr: literalArr(allDepDefs) };\n    /**\n     * @param {?} providerIndex\n     * @param {?} deps\n     * @return {?}\n     */\n    function convertDeps(providerIndex, deps) {\n        return deps.map(function (dep, depIndex) {\n            var /** @type {?} */ paramName = \"p\" + providerIndex + \"_\" + depIndex;\n            allParams.push(new FnParam(paramName, DYNAMIC_TYPE));\n            allDepDefs.push(depDef(dep));\n            return variable(paramName);\n        });\n    }\n}\n/**\n * @param {?} providerType\n * @param {?} providerMeta\n * @return {?}\n */\nfunction singleProviderDef(providerType, providerMeta) {\n    var /** @type {?} */ providerExpr;\n    var /** @type {?} */ flags;\n    var /** @type {?} */ deps;\n    if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n        providerExpr = importExpr(providerMeta.useClass);\n        flags = 8192 /* TypeDirective */;\n        deps = providerMeta.deps || providerMeta.useClass.diDeps;\n    }\n    else {\n        if (providerMeta.useClass) {\n            providerExpr = importExpr(providerMeta.useClass);\n            flags = 256 /* TypeClassProvider */;\n            deps = providerMeta.deps || providerMeta.useClass.diDeps;\n        }\n        else if (providerMeta.useFactory) {\n            providerExpr = importExpr(providerMeta.useFactory);\n            flags = 512 /* TypeFactoryProvider */;\n            deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n        }\n        else if (providerMeta.useExisting) {\n            providerExpr = NULL_EXPR;\n            flags = 1024 /* TypeUseExistingProvider */;\n            deps = [{ token: providerMeta.useExisting }];\n        }\n        else {\n            providerExpr = convertValueToOutputAst(providerMeta.useValue);\n            flags = 128 /* TypeValueProvider */;\n            deps = [];\n        }\n    }\n    var /** @type {?} */ depsExpr = literalArr(deps.map(function (dep) { return depDef(dep); }));\n    return { providerExpr: providerExpr, flags: flags, depsExpr: depsExpr };\n}\n/**\n * @param {?} tokenMeta\n * @return {?}\n */\nfunction tokenExpr(tokenMeta) {\n    return tokenMeta.identifier ? importExpr(tokenMeta.identifier) : literal(tokenMeta.value);\n}\n/**\n * @param {?} dep\n * @return {?}\n */\nfunction depDef(dep) {\n    // Note: the following fields have already been normalized out by provider_analyzer:\n    // - isAttribute, isSelf, isHost\n    var /** @type {?} */ expr = dep.isValue ? convertValueToOutputAst(dep.value) : tokenExpr(dep.token);\n    var /** @type {?} */ flags = 0;\n    if (dep.isSkipSelf) {\n        flags |= 1 /* SkipSelf */;\n    }\n    if (dep.isOptional) {\n        flags |= 2 /* Optional */;\n    }\n    if (dep.isValue) {\n        flags |= 8 /* Value */;\n    }\n    return flags === 0 /* None */ ? expr : literalArr([literal(flags), expr]);\n}\n/**\n * @param {?} astNodes\n * @return {?}\n */\nfunction needsAdditionalRootNode(astNodes) {\n    var /** @type {?} */ lastAstNode = astNodes[astNodes.length - 1];\n    if (lastAstNode instanceof EmbeddedTemplateAst) {\n        return lastAstNode.hasViewContainer;\n    }\n    if (lastAstNode instanceof ElementAst) {\n        if (lastAstNode.name === NG_CONTAINER_TAG && lastAstNode.children.length) {\n            return needsAdditionalRootNode(lastAstNode.children);\n        }\n        return lastAstNode.hasViewContainer;\n    }\n    return lastAstNode instanceof NgContentAst;\n}\n/**\n * @param {?} lifecycleHook\n * @return {?}\n */\nfunction lifecycleHookToNodeFlag(lifecycleHook) {\n    var /** @type {?} */ nodeFlag = 0;\n    switch (lifecycleHook) {\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterContentChecked:\n            nodeFlag = 1048576 /* AfterContentChecked */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterContentInit:\n            nodeFlag = 524288 /* AfterContentInit */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterViewChecked:\n            nodeFlag = 4194304 /* AfterViewChecked */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].AfterViewInit:\n            nodeFlag = 2097152 /* AfterViewInit */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].DoCheck:\n            nodeFlag = 131072 /* DoCheck */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnChanges:\n            nodeFlag = 262144 /* OnChanges */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnDestroy:\n            nodeFlag = 65536 /* OnDestroy */;\n            break;\n        case __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_40\" /* ɵLifecycleHooks */].OnInit:\n            nodeFlag = 32768 /* OnInit */;\n            break;\n    }\n    return nodeFlag;\n}\n/**\n * @param {?} inputAst\n * @param {?} dirAst\n * @return {?}\n */\nfunction elementBindingDef(inputAst, dirAst) {\n    switch (inputAst.type) {\n        case PropertyBindingType.Attribute:\n            return literalArr([\n                literal(1 /* TypeElementAttribute */), literal(inputAst.name),\n                literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Property:\n            return literalArr([\n                literal(8 /* TypeProperty */), literal(inputAst.name),\n                literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Animation:\n            var /** @type {?} */ bindingType = 8 /* TypeProperty */ |\n                (dirAst && dirAst.directive.isComponent ? 32 /* SyntheticHostProperty */ :\n                    16 /* SyntheticProperty */);\n            return literalArr([\n                literal(bindingType), literal('@' + inputAst.name), literal(inputAst.securityContext)\n            ]);\n        case PropertyBindingType.Class:\n            return literalArr([literal(2 /* TypeElementClass */), literal(inputAst.name), NULL_EXPR]);\n        case PropertyBindingType.Style:\n            return literalArr([\n                literal(4 /* TypeElementStyle */), literal(inputAst.name), literal(inputAst.unit)\n            ]);\n    }\n}\n/**\n * @param {?} elementAst\n * @return {?}\n */\nfunction fixedAttrsDef(elementAst) {\n    var /** @type {?} */ mapResult = Object.create(null);\n    elementAst.attrs.forEach(function (attrAst) { mapResult[attrAst.name] = attrAst.value; });\n    elementAst.directives.forEach(function (dirAst) {\n        Object.keys(dirAst.directive.hostAttributes).forEach(function (name) {\n            var /** @type {?} */ value = dirAst.directive.hostAttributes[name];\n            var /** @type {?} */ prevValue = mapResult[name];\n            mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;\n        });\n    });\n    var /** @type {?} */ mapEntries = [];\n    // Note: We need to sort to get a defined output order\n    // for tests and for caching generated artifacts...\n    return literalArr(Object.keys(mapResult).sort().map(function (attrName) { return literalArr([literal(attrName), literal(mapResult[attrName])]); }));\n}\n/**\n * @param {?} attrName\n * @param {?} attrValue1\n * @param {?} attrValue2\n * @return {?}\n */\nfunction mergeAttributeValue(attrName, attrValue1, attrValue2) {\n    if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {\n        return attrValue1 + \" \" + attrValue2;\n    }\n    else {\n        return attrValue2;\n    }\n}\n/**\n * @param {?} nodeIndex\n * @param {?} exprs\n * @return {?}\n */\nfunction callCheckStmt(nodeIndex, exprs) {\n    if (exprs.length > 10) {\n        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(1 /* Dynamic */), literalArr(exprs)]);\n    }\n    else {\n        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(0 /* Inline */)].concat(exprs));\n    }\n}\n/**\n * @param {?} nodeIndex\n * @param {?} bindingIdx\n * @param {?} expr\n * @return {?}\n */\nfunction callUnwrapValue(nodeIndex, bindingIdx, expr) {\n    return importExpr(createIdentifier(Identifiers.unwrapValue)).callFn([\n        VIEW_VAR, literal(nodeIndex), literal(bindingIdx), expr\n    ]);\n}\n/**\n * @param {?} nodes\n * @param {?=} result\n * @return {?}\n */\nfunction findStaticQueryIds(nodes, result) {\n    if (result === void 0) { result = new Map(); }\n    nodes.forEach(function (node) {\n        var /** @type {?} */ staticQueryIds = new Set();\n        var /** @type {?} */ dynamicQueryIds = new Set();\n        var /** @type {?} */ queryMatches;\n        if (node instanceof ElementAst) {\n            findStaticQueryIds(node.children, result);\n            node.children.forEach(function (child) {\n                var /** @type {?} */ childData = result.get(child);\n                childData.staticQueryIds.forEach(function (queryId) { return staticQueryIds.add(queryId); });\n                childData.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n            });\n            queryMatches = node.queryMatches;\n        }\n        else if (node instanceof EmbeddedTemplateAst) {\n            findStaticQueryIds(node.children, result);\n            node.children.forEach(function (child) {\n                var /** @type {?} */ childData = result.get(child);\n                childData.staticQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n                childData.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n            });\n            queryMatches = node.queryMatches;\n        }\n        if (queryMatches) {\n            queryMatches.forEach(function (match) { return staticQueryIds.add(match.queryId); });\n        }\n        dynamicQueryIds.forEach(function (queryId) { return staticQueryIds.delete(queryId); });\n        result.set(node, { staticQueryIds: staticQueryIds, dynamicQueryIds: dynamicQueryIds });\n    });\n    return result;\n}\n/**\n * @param {?} nodeStaticQueryIds\n * @return {?}\n */\nfunction staticViewQueryIds(nodeStaticQueryIds) {\n    var /** @type {?} */ staticQueryIds = new Set();\n    var /** @type {?} */ dynamicQueryIds = new Set();\n    Array.from(nodeStaticQueryIds.values()).forEach(function (entry) {\n        entry.staticQueryIds.forEach(function (queryId) { return staticQueryIds.add(queryId); });\n        entry.dynamicQueryIds.forEach(function (queryId) { return dynamicQueryIds.add(queryId); });\n    });\n    dynamicQueryIds.forEach(function (queryId) { return staticQueryIds.delete(queryId); });\n    return { staticQueryIds: staticQueryIds, dynamicQueryIds: dynamicQueryIds };\n}\n/**\n * @param {?} directives\n * @return {?}\n */\nfunction createComponentFactoryResolver(directives) {\n    var /** @type {?} */ componentDirMeta = directives.find(function (dirAst) { return dirAst.directive.isComponent; });\n    if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {\n        var /** @type {?} */ entryComponentFactories = componentDirMeta.directive.entryComponents.map(function (entryComponent) { return importExpr({ reference: entryComponent.componentFactory }); });\n        var /** @type {?} */ token = createIdentifierToken(Identifiers.ComponentFactoryResolver);\n        var /** @type {?} */ classMeta = {\n            diDeps: [\n                { isValue: true, value: literalArr(entryComponentFactories) },\n                { token: token, isSkipSelf: true, isOptional: true },\n                { token: createIdentifierToken(Identifiers.NgModuleRef) },\n            ],\n            lifecycleHooks: [],\n            reference: resolveIdentifier(Identifiers.CodegenComponentFactoryResolver)\n        };\n        return new ProviderAst(token, false, true, [{ token: token, multi: false, useClass: classMeta }], ProviderAstType.PrivateService, [], componentDirMeta.sourceSpan);\n    }\n    return null;\n}\n/**\n * @param {?} eventAst\n * @param {?} dirAst\n * @return {?}\n */\nfunction elementEventNameAndTarget(eventAst, dirAst) {\n    if (eventAst.isAnimation) {\n        return {\n            name: \"@\" + eventAst.name + \".\" + eventAst.phase,\n            target: dirAst && dirAst.directive.isComponent ? 'component' : null\n        };\n    }\n    else {\n        return eventAst;\n    }\n}\n/**\n * @param {?} queryIds\n * @param {?} queryId\n * @param {?} isFirst\n * @return {?}\n */\nfunction calcStaticDynamicQueryFlags(queryIds, queryId, isFirst) {\n    var /** @type {?} */ flags = 0;\n    // Note: We only make queries static that query for a single item.\n    // This is because of backwards compatibility with the old view compiler...\n    if (isFirst && (queryIds.staticQueryIds.has(queryId) || !queryIds.dynamicQueryIds.has(queryId))) {\n        flags |= 134217728 /* StaticQuery */;\n    }\n    else {\n        flags |= 268435456 /* DynamicQuery */;\n    }\n    return flags;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar GeneratedFile = (function () {\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} genFileUrl\n     * @param {?} source\n     */\n    function GeneratedFile(srcFileUrl, genFileUrl, source) {\n        this.srcFileUrl = srcFileUrl;\n        this.genFileUrl = genFileUrl;\n        this.source = source;\n    }\n    return GeneratedFile;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} summaryResolver\n * @param {?} symbolResolver\n * @param {?} symbols\n * @param {?} types\n * @return {?}\n */\nfunction serializeSummaries(summaryResolver, symbolResolver, symbols, types) {\n    var /** @type {?} */ serializer = new Serializer$1(symbolResolver, summaryResolver);\n    // for symbols, we use everything except for the class metadata itself\n    // (we keep the statics though), as the class metadata is contained in the\n    // CompileTypeSummary.\n    symbols.forEach(function (resolvedSymbol) { return serializer.addOrMergeSummary({ symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata }); });\n    // Add summaries that are referenced by the given symbols (transitively)\n    // Note: the serializer.symbols array might be growing while\n    // we execute the loop!\n    for (var /** @type {?} */ processedIndex = 0; processedIndex < serializer.symbols.length; processedIndex++) {\n        var /** @type {?} */ symbol = serializer.symbols[processedIndex];\n        if (summaryResolver.isLibraryFile(symbol.filePath)) {\n            var /** @type {?} */ summary = summaryResolver.resolveSummary(symbol);\n            if (!summary) {\n                // some symbols might originate from a plain typescript library\n                // that just exported .d.ts and .metadata.json files, i.e. where no summary\n                // files were created.\n                var /** @type {?} */ resolvedSymbol = symbolResolver.resolveSymbol(symbol);\n                if (resolvedSymbol) {\n                    summary = { symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata };\n                }\n            }\n            if (summary) {\n                serializer.addOrMergeSummary(summary);\n            }\n        }\n    }\n    // Add type summaries.\n    // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,\n    // as the type summaries already contain the transitive data that they require\n    // (in a minimal way).\n    types.forEach(function (typeSummary) {\n        serializer.addOrMergeSummary({ symbol: typeSummary.type.reference, metadata: null, type: typeSummary });\n        if (typeSummary.summaryKind === CompileSummaryKind.NgModule) {\n            var /** @type {?} */ ngModuleSummary = (typeSummary);\n            ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach(function (id) {\n                var /** @type {?} */ symbol = id.reference;\n                if (summaryResolver.isLibraryFile(symbol.filePath)) {\n                    var /** @type {?} */ summary = summaryResolver.resolveSummary(symbol);\n                    if (summary) {\n                        serializer.addOrMergeSummary(summary);\n                    }\n                }\n            });\n        }\n    });\n    return serializer.serialize();\n}\n/**\n * @param {?} symbolCache\n * @param {?} json\n * @return {?}\n */\nfunction deserializeSummaries(symbolCache, json) {\n    var /** @type {?} */ deserializer = new Deserializer(symbolCache);\n    return deserializer.deserialize(json);\n}\nvar Serializer$1 = (function (_super) {\n    __extends(Serializer$1, _super);\n    /**\n     * @param {?} symbolResolver\n     * @param {?} summaryResolver\n     */\n    function Serializer$1(symbolResolver, summaryResolver) {\n        var _this = _super.call(this) || this;\n        _this.symbolResolver = symbolResolver;\n        _this.summaryResolver = summaryResolver;\n        // Note: This only contains symbols without members.\n        _this.symbols = [];\n        _this.indexBySymbol = new Map();\n        _this.processedSummaryBySymbol = new Map();\n        _this.processedSummaries = [];\n        return _this;\n    }\n    /**\n     * @param {?} summary\n     * @return {?}\n     */\n    Serializer$1.prototype.addOrMergeSummary = function (summary) {\n        var /** @type {?} */ symbolMeta = summary.metadata;\n        if (symbolMeta && symbolMeta.__symbolic === 'class') {\n            // For classes, we keep everything except their class decorators.\n            // We need to keep e.g. the ctor args, method names, method decorators\n            // so that the class can be extended in another compilation unit.\n            // We don't keep the class decorators as\n            // 1) they refer to data\n            //   that should not cause a rebuild of downstream compilation units\n            //   (e.g. inline templates of @Component, or @NgModule.declarations)\n            // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.\n            var /** @type {?} */ clone_1 = {};\n            Object.keys(symbolMeta).forEach(function (propName) {\n                if (propName !== 'decorators') {\n                    clone_1[propName] = symbolMeta[propName];\n                }\n            });\n            symbolMeta = clone_1;\n        }\n        var /** @type {?} */ processedSummary = this.processedSummaryBySymbol.get(summary.symbol);\n        if (!processedSummary) {\n            processedSummary = this.processValue({ symbol: summary.symbol });\n            this.processedSummaries.push(processedSummary);\n            this.processedSummaryBySymbol.set(summary.symbol, processedSummary);\n        }\n        // Note: == on purpose to compare with undefined!\n        if (processedSummary.metadata == null && symbolMeta != null) {\n            processedSummary.metadata = this.processValue(symbolMeta);\n        }\n        // Note: == on purpose to compare with undefined!\n        if (processedSummary.type == null && summary.type != null) {\n            processedSummary.type = this.processValue(summary.type);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    Serializer$1.prototype.serialize = function () {\n        var _this = this;\n        var /** @type {?} */ exportAs = [];\n        var /** @type {?} */ json = JSON.stringify({\n            summaries: this.processedSummaries,\n            symbols: this.symbols.map(function (symbol, index) {\n                symbol.assertNoMembers();\n                var /** @type {?} */ importAs;\n                if (_this.summaryResolver.isLibraryFile(symbol.filePath)) {\n                    importAs = symbol.name + \"_\" + index;\n                    exportAs.push({ symbol: symbol, exportAs: importAs });\n                }\n                return {\n                    __symbol: index,\n                    name: symbol.name,\n                    // We convert the source filenames tinto output filenames,\n                    // as the generated summary file will be used when teh current\n                    // compilation unit is used as a library\n                    filePath: _this.summaryResolver.getLibraryFileName(symbol.filePath),\n                    importAs: importAs\n                };\n            })\n        });\n        return { json: json, exportAs: exportAs };\n    };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    Serializer$1.prototype.processValue = function (value) { return visitValue(value, this, null); };\n    /**\n     * @param {?} value\n     * @param {?} context\n     * @return {?}\n     */\n    Serializer$1.prototype.visitOther = function (value, context) {\n        if (value instanceof StaticSymbol) {\n            var /** @type {?} */ baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);\n            var /** @type {?} */ index = this.indexBySymbol.get(baseSymbol);\n            // Note: == on purpose to compare with undefined!\n            if (index == null) {\n                index = this.indexBySymbol.size;\n                this.indexBySymbol.set(baseSymbol, index);\n                this.symbols.push(baseSymbol);\n            }\n            return { __symbol: index, members: value.members };\n        }\n    };\n    return Serializer$1;\n}(ValueTransformer));\nvar Deserializer = (function (_super) {\n    __extends(Deserializer, _super);\n    /**\n     * @param {?} symbolCache\n     */\n    function Deserializer(symbolCache) {\n        var _this = _super.call(this) || this;\n        _this.symbolCache = symbolCache;\n        return _this;\n    }\n    /**\n     * @param {?} json\n     * @return {?}\n     */\n    Deserializer.prototype.deserialize = function (json) {\n        var _this = this;\n        var /** @type {?} */ data = JSON.parse(json);\n        var /** @type {?} */ importAs = [];\n        this.symbols = [];\n        data.symbols.forEach(function (serializedSymbol) {\n            var /** @type {?} */ symbol = _this.symbolCache.get(serializedSymbol.filePath, serializedSymbol.name);\n            _this.symbols.push(symbol);\n            if (serializedSymbol.importAs) {\n                importAs.push({ symbol: symbol, importAs: serializedSymbol.importAs });\n            }\n        });\n        var /** @type {?} */ summaries = visitValue(data.summaries, this, null);\n        return { summaries: summaries, importAs: importAs };\n    };\n    /**\n     * @param {?} map\n     * @param {?} context\n     * @return {?}\n     */\n    Deserializer.prototype.visitStringMap = function (map, context) {\n        if ('__symbol' in map) {\n            var /** @type {?} */ baseSymbol = this.symbols[map['__symbol']];\n            var /** @type {?} */ members = map['members'];\n            return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) :\n                baseSymbol;\n        }\n        else {\n            return _super.prototype.visitStringMap.call(this, map, context);\n        }\n    };\n    return Deserializer;\n}(ValueTransformer));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AotCompiler = (function () {\n    /**\n     * @param {?} _config\n     * @param {?} _host\n     * @param {?} _metadataResolver\n     * @param {?} _templateParser\n     * @param {?} _styleCompiler\n     * @param {?} _viewCompiler\n     * @param {?} _ngModuleCompiler\n     * @param {?} _outputEmitter\n     * @param {?} _summaryResolver\n     * @param {?} _localeId\n     * @param {?} _translationFormat\n     * @param {?} _genFilePreamble\n     * @param {?} _symbolResolver\n     */\n    function AotCompiler(_config, _host, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _outputEmitter, _summaryResolver, _localeId, _translationFormat, _genFilePreamble, _symbolResolver) {\n        this._config = _config;\n        this._host = _host;\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._outputEmitter = _outputEmitter;\n        this._summaryResolver = _summaryResolver;\n        this._localeId = _localeId;\n        this._translationFormat = _translationFormat;\n        this._genFilePreamble = _genFilePreamble;\n        this._symbolResolver = _symbolResolver;\n    }\n    /**\n     * @return {?}\n     */\n    AotCompiler.prototype.clearCache = function () { this._metadataResolver.clearCache(); };\n    /**\n     * @param {?} rootFiles\n     * @return {?}\n     */\n    AotCompiler.prototype.compileAll = function (rootFiles) {\n        var _this = this;\n        var /** @type {?} */ programSymbols = extractProgramSymbols(this._symbolResolver, rootFiles, this._host);\n        var _a = analyzeAndValidateNgModules(programSymbols, this._host, this._metadataResolver), ngModuleByPipeOrDirective = _a.ngModuleByPipeOrDirective, files = _a.files, ngModules = _a.ngModules;\n        return Promise\n            .all(ngModules.map(function (ngModule) { return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))\n            .then(function () {\n            var /** @type {?} */ sourceModules = files.map(function (file) { return _this._compileSrcFile(file.srcUrl, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables); });\n            return flatten(sourceModules);\n        });\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} ngModuleByPipeOrDirective\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} ngModules\n     * @param {?} injectables\n     * @return {?}\n     */\n    AotCompiler.prototype._compileSrcFile = function (srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {\n        var _this = this;\n        var /** @type {?} */ fileSuffix = splitTypescriptSuffix(srcFileUrl)[1];\n        var /** @type {?} */ statements = [];\n        var /** @type {?} */ exportedVars = [];\n        var /** @type {?} */ generatedFiles = [];\n        generatedFiles.push(this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, statements, exportedVars));\n        // compile all ng modules\n        exportedVars.push.apply(exportedVars, ngModules.map(function (ngModuleType) { return _this._compileModule(ngModuleType, statements); }));\n        // compile components\n        directives.forEach(function (dirType) {\n            var /** @type {?} */ compMeta = _this._metadataResolver.getDirectiveMetadata(/** @type {?} */ (dirType));\n            if (!compMeta.isComponent) {\n                return Promise.resolve(null);\n            }\n            var /** @type {?} */ ngModule = ngModuleByPipeOrDirective.get(dirType);\n            if (!ngModule) {\n                throw new Error(\"Internal Error: cannot determine the module for component \" + identifierName(compMeta.type) + \"!\");\n            }\n            _assertComponent(compMeta);\n            // compile styles\n            var /** @type {?} */ stylesCompileResults = _this._styleCompiler.compileComponent(compMeta);\n            stylesCompileResults.externalStylesheets.forEach(function (compiledStyleSheet) {\n                generatedFiles.push(_this._codgenStyles(srcFileUrl, compiledStyleSheet, fileSuffix));\n            });\n            // compile components\n            var /** @type {?} */ compViewVars = _this._compileComponent(compMeta, ngModule, ngModule.transitiveModule.directives, stylesCompileResults.componentStylesheet, fileSuffix, statements);\n            exportedVars.push(_this._compileComponentFactory(compMeta, ngModule, fileSuffix, statements), compViewVars.viewClassVar, compViewVars.compRenderTypeVar);\n        });\n        if (statements.length > 0) {\n            var /** @type {?} */ srcModule = this._codegenSourceModule(srcFileUrl, ngfactoryFilePath(srcFileUrl), statements, exportedVars);\n            generatedFiles.unshift(srcModule);\n        }\n        return generatedFiles;\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} directives\n     * @param {?} pipes\n     * @param {?} ngModules\n     * @param {?} injectables\n     * @param {?} targetStatements\n     * @param {?} targetExportedVars\n     * @return {?}\n     */\n    AotCompiler.prototype._createSummary = function (srcFileUrl, directives, pipes, ngModules, injectables, targetStatements, targetExportedVars) {\n        var _this = this;\n        var /** @type {?} */ symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileUrl)\n            .map(function (symbol) { return _this._symbolResolver.resolveSymbol(symbol); });\n        var /** @type {?} */ typeSummaries = ngModules.map(function (ref) { return _this._metadataResolver.getNgModuleSummary(ref); }).concat(directives.map(function (ref) { return _this._metadataResolver.getDirectiveSummary(ref); }), pipes.map(function (ref) { return _this._metadataResolver.getPipeSummary(ref); }), injectables.map(function (ref) { return _this._metadataResolver.getInjectableSummary(ref); }));\n        var _a = serializeSummaries(this._summaryResolver, this._symbolResolver, symbolSummaries, typeSummaries), json = _a.json, exportAs = _a.exportAs;\n        exportAs.forEach(function (entry) {\n            targetStatements.push(variable(entry.exportAs).set(importExpr({ reference: entry.symbol })).toDeclStmt());\n            targetExportedVars.push(entry.exportAs);\n        });\n        return new GeneratedFile(srcFileUrl, summaryFileName(srcFileUrl), json);\n    };\n    /**\n     * @param {?} ngModuleType\n     * @param {?} targetStatements\n     * @return {?}\n     */\n    AotCompiler.prototype._compileModule = function (ngModuleType, targetStatements) {\n        var /** @type {?} */ ngModule = this._metadataResolver.getNgModuleMetadata(ngModuleType);\n        var /** @type {?} */ providers = [];\n        if (this._localeId) {\n            providers.push({\n                token: createIdentifierToken(Identifiers.LOCALE_ID),\n                useValue: this._localeId,\n            });\n        }\n        if (this._translationFormat) {\n            providers.push({\n                token: createIdentifierToken(Identifiers.TRANSLATIONS_FORMAT),\n                useValue: this._translationFormat\n            });\n        }\n        var /** @type {?} */ appCompileResult = this._ngModuleCompiler.compile(ngModule, providers);\n        targetStatements.push.apply(targetStatements, appCompileResult.statements);\n        return appCompileResult.ngModuleFactoryVar;\n    };\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} fileSuffix\n     * @param {?} targetStatements\n     * @return {?}\n     */\n    AotCompiler.prototype._compileComponentFactory = function (compMeta, ngModule, fileSuffix, targetStatements) {\n        var /** @type {?} */ hostType = this._metadataResolver.getHostComponentType(compMeta.type.reference);\n        var /** @type {?} */ hostMeta = createHostComponentMeta(hostType, compMeta, this._metadataResolver.getHostComponentViewClass(hostType));\n        var /** @type {?} */ hostViewFactoryVar = this._compileComponent(hostMeta, ngModule, [compMeta.type], null, fileSuffix, targetStatements)\n            .viewClassVar;\n        var /** @type {?} */ compFactoryVar = componentFactoryName(compMeta.type.reference);\n        var /** @type {?} */ inputsExprs = [];\n        for (var /** @type {?} */ propName in compMeta.inputs) {\n            var /** @type {?} */ templateName = compMeta.inputs[propName];\n            // Don't quote so that the key gets minified...\n            inputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n        }\n        var /** @type {?} */ outputsExprs = [];\n        for (var /** @type {?} */ propName in compMeta.outputs) {\n            var /** @type {?} */ templateName = compMeta.outputs[propName];\n            // Don't quote so that the key gets minified...\n            outputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n        }\n        targetStatements.push(variable(compFactoryVar)\n            .set(importExpr(createIdentifier(Identifiers.createComponentFactory)).callFn([\n            literal(compMeta.selector), importExpr(compMeta.type),\n            variable(hostViewFactoryVar), new LiteralMapExpr(inputsExprs),\n            new LiteralMapExpr(outputsExprs),\n            literalArr(compMeta.template.ngContentSelectors.map(function (selector) { return literal(selector); }))\n        ]))\n            .toDeclStmt(importType(createIdentifier(Identifiers.ComponentFactory), [importType(compMeta.type)], [TypeModifier.Const]), [StmtModifier.Final]));\n        return compFactoryVar;\n    };\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} directiveIdentifiers\n     * @param {?} componentStyles\n     * @param {?} fileSuffix\n     * @param {?} targetStatements\n     * @return {?}\n     */\n    AotCompiler.prototype._compileComponent = function (compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix, targetStatements) {\n        var _this = this;\n        var /** @type {?} */ directives = directiveIdentifiers.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n        var /** @type {?} */ pipes = ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        var _a = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template)), parsedTemplate = _a.template, usedPipes = _a.pipes;\n        var /** @type {?} */ stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);\n        var /** @type {?} */ viewResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, stylesExpr, usedPipes);\n        if (componentStyles) {\n            targetStatements.push.apply(targetStatements, _resolveStyleStatements(this._symbolResolver, componentStyles, fileSuffix));\n        }\n        targetStatements.push.apply(targetStatements, viewResult.statements);\n        return { viewClassVar: viewResult.viewClassVar, compRenderTypeVar: viewResult.rendererTypeVar };\n    };\n    /**\n     * @param {?} fileUrl\n     * @param {?} stylesCompileResult\n     * @param {?} fileSuffix\n     * @return {?}\n     */\n    AotCompiler.prototype._codgenStyles = function (fileUrl, stylesCompileResult, fileSuffix) {\n        _resolveStyleStatements(this._symbolResolver, stylesCompileResult, fileSuffix);\n        return this._codegenSourceModule(fileUrl, _stylesModuleUrl(stylesCompileResult.meta.moduleUrl, stylesCompileResult.isShimmed, fileSuffix), stylesCompileResult.statements, [stylesCompileResult.stylesVar]);\n    };\n    /**\n     * @param {?} srcFileUrl\n     * @param {?} genFileUrl\n     * @param {?} statements\n     * @param {?} exportedVars\n     * @return {?}\n     */\n    AotCompiler.prototype._codegenSourceModule = function (srcFileUrl, genFileUrl, statements, exportedVars) {\n        return new GeneratedFile(srcFileUrl, genFileUrl, this._outputEmitter.emitStatements(sourceUrl(srcFileUrl), genFileUrl, statements, exportedVars, this._genFilePreamble));\n    };\n    return AotCompiler;\n}());\n/**\n * @param {?} reflector\n * @param {?} compileResult\n * @param {?} fileSuffix\n * @return {?}\n */\nfunction _resolveStyleStatements(reflector, compileResult, fileSuffix) {\n    compileResult.dependencies.forEach(function (dep) {\n        dep.valuePlaceholder.reference = reflector.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, dep.isShimmed, fileSuffix), dep.name);\n    });\n    return compileResult.statements;\n}\n/**\n * @param {?} stylesheetUrl\n * @param {?} shim\n * @param {?} suffix\n * @return {?}\n */\nfunction _stylesModuleUrl(stylesheetUrl, shim, suffix) {\n    return \"\" + stylesheetUrl + (shim ? '.shim' : '') + \".ngstyle\" + suffix;\n}\n/**\n * @param {?} meta\n * @return {?}\n */\nfunction _assertComponent(meta) {\n    if (!meta.isComponent) {\n        throw new Error(\"Could not compile '\" + identifierName(meta.type) + \"' because it is not a component.\");\n    }\n}\n/**\n * @param {?} programStaticSymbols\n * @param {?} host\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction analyzeNgModules(programStaticSymbols, host, metadataResolver) {\n    var _a = _createNgModules(programStaticSymbols, host, metadataResolver), ngModules = _a.ngModules, symbolsMissingModule = _a.symbolsMissingModule;\n    return _analyzeNgModules(programStaticSymbols, ngModules, symbolsMissingModule, metadataResolver);\n}\n/**\n * @param {?} programStaticSymbols\n * @param {?} host\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction analyzeAndValidateNgModules(programStaticSymbols, host, metadataResolver) {\n    var /** @type {?} */ result = analyzeNgModules(programStaticSymbols, host, metadataResolver);\n    if (result.symbolsMissingModule && result.symbolsMissingModule.length) {\n        var /** @type {?} */ messages = result.symbolsMissingModule.map(function (s) { return \"Cannot determine the module for class \" + s.name + \" in \" + s.filePath + \"! Add \" + s.name + \" to the NgModule to fix it.\"; });\n        throw syntaxError(messages.join('\\n'));\n    }\n    return result;\n}\n/**\n * @param {?} programSymbols\n * @param {?} ngModuleMetas\n * @param {?} symbolsMissingModule\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction _analyzeNgModules(programSymbols, ngModuleMetas, symbolsMissingModule, metadataResolver) {\n    var /** @type {?} */ moduleMetasByRef = new Map();\n    ngModuleMetas.forEach(function (ngModule) { return moduleMetasByRef.set(ngModule.type.reference, ngModule); });\n    var /** @type {?} */ ngModuleByPipeOrDirective = new Map();\n    var /** @type {?} */ ngModulesByFile = new Map();\n    var /** @type {?} */ ngDirectivesByFile = new Map();\n    var /** @type {?} */ ngPipesByFile = new Map();\n    var /** @type {?} */ ngInjectablesByFile = new Map();\n    var /** @type {?} */ filePaths = new Set();\n    // Make sure we produce an analyzed file for each input file\n    programSymbols.forEach(function (symbol) {\n        var /** @type {?} */ filePath = symbol.filePath;\n        filePaths.add(filePath);\n        if (metadataResolver.isInjectable(symbol)) {\n            ngInjectablesByFile.set(filePath, (ngInjectablesByFile.get(filePath) || []).concat(symbol));\n        }\n    });\n    // Looping over all modules to construct:\n    // - a map from file to modules `ngModulesByFile`,\n    // - a map from file to directives `ngDirectivesByFile`,\n    // - a map from file to pipes `ngPipesByFile`,\n    // - a map from directive/pipe to module `ngModuleByPipeOrDirective`.\n    ngModuleMetas.forEach(function (ngModuleMeta) {\n        var /** @type {?} */ srcFileUrl = ngModuleMeta.type.reference.filePath;\n        filePaths.add(srcFileUrl);\n        ngModulesByFile.set(srcFileUrl, (ngModulesByFile.get(srcFileUrl) || []).concat(ngModuleMeta.type.reference));\n        ngModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n            var /** @type {?} */ fileUrl = dirIdentifier.reference.filePath;\n            filePaths.add(fileUrl);\n            ngDirectivesByFile.set(fileUrl, (ngDirectivesByFile.get(fileUrl) || []).concat(dirIdentifier.reference));\n            ngModuleByPipeOrDirective.set(dirIdentifier.reference, ngModuleMeta);\n        });\n        ngModuleMeta.declaredPipes.forEach(function (pipeIdentifier) {\n            var /** @type {?} */ fileUrl = pipeIdentifier.reference.filePath;\n            filePaths.add(fileUrl);\n            ngPipesByFile.set(fileUrl, (ngPipesByFile.get(fileUrl) || []).concat(pipeIdentifier.reference));\n            ngModuleByPipeOrDirective.set(pipeIdentifier.reference, ngModuleMeta);\n        });\n    });\n    var /** @type {?} */ files = [];\n    filePaths.forEach(function (srcUrl) {\n        var /** @type {?} */ directives = ngDirectivesByFile.get(srcUrl) || [];\n        var /** @type {?} */ pipes = ngPipesByFile.get(srcUrl) || [];\n        var /** @type {?} */ ngModules = ngModulesByFile.get(srcUrl) || [];\n        var /** @type {?} */ injectables = ngInjectablesByFile.get(srcUrl) || [];\n        files.push({ srcUrl: srcUrl, directives: directives, pipes: pipes, ngModules: ngModules, injectables: injectables });\n    });\n    return {\n        // map directive/pipe to module\n        ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,\n        // list modules and directives for every source file\n        files: files,\n        ngModules: ngModuleMetas, symbolsMissingModule: symbolsMissingModule\n    };\n}\n/**\n * @param {?} staticSymbolResolver\n * @param {?} files\n * @param {?} host\n * @return {?}\n */\nfunction extractProgramSymbols(staticSymbolResolver, files, host) {\n    var /** @type {?} */ staticSymbols = [];\n    files.filter(function (fileName) { return host.isSourceFile(fileName); }).forEach(function (sourceFile) {\n        staticSymbolResolver.getSymbolsOf(sourceFile).forEach(function (symbol) {\n            var /** @type {?} */ resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n            var /** @type {?} */ symbolMeta = resolvedSymbol.metadata;\n            if (symbolMeta) {\n                if (symbolMeta.__symbolic != 'error') {\n                    // Ignore symbols that are only included to record error information.\n                    staticSymbols.push(resolvedSymbol.symbol);\n                }\n            }\n        });\n    });\n    return staticSymbols;\n}\n/**\n * @param {?} programStaticSymbols\n * @param {?} host\n * @param {?} metadataResolver\n * @return {?}\n */\nfunction _createNgModules(programStaticSymbols, host, metadataResolver) {\n    var /** @type {?} */ ngModules = new Map();\n    var /** @type {?} */ programPipesAndDirectives = [];\n    var /** @type {?} */ ngModulePipesAndDirective = new Set();\n    var /** @type {?} */ addNgModule = function (staticSymbol) {\n        if (ngModules.has(staticSymbol) || !host.isSourceFile(staticSymbol.filePath)) {\n            return false;\n        }\n        var /** @type {?} */ ngModule = metadataResolver.getNgModuleMetadata(staticSymbol, false);\n        if (ngModule) {\n            ngModules.set(ngModule.type.reference, ngModule);\n            ngModule.declaredDirectives.forEach(function (dir) { return ngModulePipesAndDirective.add(dir.reference); });\n            ngModule.declaredPipes.forEach(function (pipe) { return ngModulePipesAndDirective.add(pipe.reference); });\n            // For every input module add the list of transitively included modules\n            ngModule.transitiveModule.modules.forEach(function (modMeta) { return addNgModule(modMeta.reference); });\n        }\n        return !!ngModule;\n    };\n    programStaticSymbols.forEach(function (staticSymbol) {\n        if (!addNgModule(staticSymbol) &&\n            (metadataResolver.isDirective(staticSymbol) || metadataResolver.isPipe(staticSymbol))) {\n            programPipesAndDirectives.push(staticSymbol);\n        }\n    });\n    // Throw an error if any of the program pipe or directives is not declared by a module\n    var /** @type {?} */ symbolsMissingModule = programPipesAndDirectives.filter(function (s) { return !ngModulePipesAndDirective.has(s); });\n    return { ngModules: Array.from(ngModules.values()), symbolsMissingModule: symbolsMissingModule };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar StaticAndDynamicReflectionCapabilities = (function () {\n    /**\n     * @param {?} staticDelegate\n     */\n    function StaticAndDynamicReflectionCapabilities(staticDelegate) {\n        this.staticDelegate = staticDelegate;\n        this.dynamicDelegate = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_48\" /* ɵReflectionCapabilities */]();\n    }\n    /**\n     * @param {?} staticDelegate\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.install = function (staticDelegate) {\n        __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */].updateCapabilities(new StaticAndDynamicReflectionCapabilities(staticDelegate));\n    };\n    /**\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.factory = function (type) { return this.dynamicDelegate.factory(type); };\n    /**\n     * @param {?} type\n     * @param {?} lcProperty\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {\n        return isStaticType(type) ? this.staticDelegate.hasLifecycleHook(type, lcProperty) :\n            this.dynamicDelegate.hasLifecycleHook(type, lcProperty);\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.parameters = function (type) {\n        return isStaticType(type) ? this.staticDelegate.parameters(type) :\n            this.dynamicDelegate.parameters(type);\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.annotations = function (type) {\n        return isStaticType(type) ? this.staticDelegate.annotations(type) :\n            this.dynamicDelegate.annotations(type);\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {\n        return isStaticType(typeOrFunc) ? this.staticDelegate.propMetadata(typeOrFunc) :\n            this.dynamicDelegate.propMetadata(typeOrFunc);\n    };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.getter = function (name) { return this.dynamicDelegate.getter(name); };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.setter = function (name) { return this.dynamicDelegate.setter(name); };\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.method = function (name) { return this.dynamicDelegate.method(name); };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.importUri = function (type) { return this.staticDelegate.importUri(type); };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.resourceUri = function (type) { return this.staticDelegate.resourceUri(type); };\n    /**\n     * @param {?} name\n     * @param {?} moduleUrl\n     * @param {?} members\n     * @param {?} runtime\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, members, runtime) {\n        return this.staticDelegate.resolveIdentifier(name, moduleUrl, members);\n    };\n    /**\n     * @param {?} enumIdentifier\n     * @param {?} name\n     * @return {?}\n     */\n    StaticAndDynamicReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) {\n        if (isStaticType(enumIdentifier)) {\n            return this.staticDelegate.resolveEnum(enumIdentifier, name);\n        }\n        else {\n            return null;\n        }\n    };\n    return StaticAndDynamicReflectionCapabilities;\n}());\n/**\n * @param {?} type\n * @return {?}\n */\nfunction isStaticType(type) {\n    return typeof type === 'object' && type.name && type.filePath;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ANGULAR_CORE = '@angular/core';\nvar HIDDEN_KEY = /^\\$.*\\$$/;\nvar IGNORE = {\n    __symbolic: 'ignore'\n};\n/**\n * @param {?} value\n * @return {?}\n */\nfunction shouldIgnore(value) {\n    return value && value.__symbolic == 'ignore';\n}\n/**\n * A static reflector implements enough of the Reflector API that is necessary to compile\n * templates statically.\n */\nvar StaticReflector = (function () {\n    /**\n     * @param {?} summaryResolver\n     * @param {?} symbolResolver\n     * @param {?=} knownMetadataClasses\n     * @param {?=} knownMetadataFunctions\n     * @param {?=} errorRecorder\n     */\n    function StaticReflector(summaryResolver, symbolResolver, knownMetadataClasses, knownMetadataFunctions, errorRecorder) {\n        if (knownMetadataClasses === void 0) { knownMetadataClasses = []; }\n        if (knownMetadataFunctions === void 0) { knownMetadataFunctions = []; }\n        var _this = this;\n        this.summaryResolver = summaryResolver;\n        this.symbolResolver = symbolResolver;\n        this.errorRecorder = errorRecorder;\n        this.annotationCache = new Map();\n        this.propertyCache = new Map();\n        this.parameterCache = new Map();\n        this.methodCache = new Map();\n        this.conversionMap = new Map();\n        this.annotationForParentClassWithSummaryKind = new Map();\n        this.annotationNames = new Map();\n        this.initializeConversionMap();\n        knownMetadataClasses.forEach(function (kc) { return _this._registerDecoratorOrConstructor(_this.getStaticSymbol(kc.filePath, kc.name), kc.ctor); });\n        knownMetadataFunctions.forEach(function (kf) { return _this._registerFunction(_this.getStaticSymbol(kf.filePath, kf.name), kf.fn); });\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Directive, [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"H\" /* Directive */], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */]]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* Pipe */]]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"a\" /* NgModule */]]);\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Injectable, [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"e\" /* Injectable */], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* Pipe */], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"H\" /* Directive */], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */], __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"a\" /* NgModule */]]);\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"H\" /* Directive */], 'Directive');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */], 'Component');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* Pipe */], 'Pipe');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"a\" /* NgModule */], 'NgModule');\n        this.annotationNames.set(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"e\" /* Injectable */], 'Injectable');\n    }\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    StaticReflector.prototype.importUri = function (typeOrFunc) {\n        var /** @type {?} */ staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n        return staticSymbol ? staticSymbol.filePath : null;\n    };\n    /**\n     * @param {?} typeOrFunc\n     * @return {?}\n     */\n    StaticReflector.prototype.resourceUri = function (typeOrFunc) {\n        var /** @type {?} */ staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n        return this.symbolResolver.getResourcePath(staticSymbol);\n    };\n    /**\n     * @param {?} name\n     * @param {?} moduleUrl\n     * @param {?} members\n     * @return {?}\n     */\n    StaticReflector.prototype.resolveIdentifier = function (name, moduleUrl, members) {\n        var /** @type {?} */ importSymbol = this.getStaticSymbol(moduleUrl, name);\n        var /** @type {?} */ rootSymbol = this.findDeclaration(moduleUrl, name);\n        if (importSymbol != rootSymbol) {\n            this.symbolResolver.recordImportAs(rootSymbol, importSymbol);\n        }\n        if (members && members.length) {\n            return this.getStaticSymbol(rootSymbol.filePath, rootSymbol.name, members);\n        }\n        return rootSymbol;\n    };\n    /**\n     * @param {?} moduleUrl\n     * @param {?} name\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    StaticReflector.prototype.findDeclaration = function (moduleUrl, name, containingFile) {\n        return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));\n    };\n    /**\n     * @param {?} symbol\n     * @return {?}\n     */\n    StaticReflector.prototype.findSymbolDeclaration = function (symbol) {\n        var /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n        if (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n            return this.findSymbolDeclaration(resolvedSymbol.metadata);\n        }\n        else {\n            return symbol;\n        }\n    };\n    /**\n     * @param {?} enumIdentifier\n     * @param {?} name\n     * @return {?}\n     */\n    StaticReflector.prototype.resolveEnum = function (enumIdentifier, name) {\n        var /** @type {?} */ staticSymbol = enumIdentifier;\n        var /** @type {?} */ members = (staticSymbol.members || []).concat(name);\n        return this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name, members);\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.annotations = function (type) {\n        var _this = this;\n        var /** @type {?} */ annotations = this.annotationCache.get(type);\n        if (!annotations) {\n            annotations = [];\n            var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var /** @type {?} */ parentAnnotations = this.annotations(parentType);\n                annotations.push.apply(annotations, parentAnnotations);\n            }\n            var /** @type {?} */ ownAnnotations_1 = [];\n            if (classMetadata['decorators']) {\n                ownAnnotations_1 = this.simplify(type, classMetadata['decorators']);\n                annotations.push.apply(annotations, ownAnnotations_1);\n            }\n            if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) &&\n                this.summaryResolver.isLibraryFile(parentType.filePath)) {\n                var /** @type {?} */ summary = this.summaryResolver.resolveSummary(parentType);\n                if (summary && summary.type) {\n                    var /** @type {?} */ requiredAnnotationTypes = this.annotationForParentClassWithSummaryKind.get(summary.type.summaryKind);\n                    var /** @type {?} */ typeHasRequiredAnnotation = requiredAnnotationTypes.some(function (requiredType) { return ownAnnotations_1.some(function (ann) { return ann instanceof requiredType; }); });\n                    if (!typeHasRequiredAnnotation) {\n                        this.reportError(syntaxError(\"Class \" + type.name + \" in \" + type.filePath + \" extends from a \" + CompileSummaryKind[summary.type.summaryKind] + \" in another compilation unit without duplicating the decorator. \" +\n                            (\"Please add a \" + requiredAnnotationTypes.map(function (type) { return _this.annotationNames.get(type); }).join(' or ') + \" decorator to the class.\")), type);\n                    }\n                }\n            }\n            this.annotationCache.set(type, annotations.filter(function (ann) { return !!ann; }));\n        }\n        return annotations;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.propMetadata = function (type) {\n        var _this = this;\n        var /** @type {?} */ propMetadata = this.propertyCache.get(type);\n        if (!propMetadata) {\n            var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            propMetadata = {};\n            var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var /** @type {?} */ parentPropMetadata_1 = this.propMetadata(parentType);\n                Object.keys(parentPropMetadata_1).forEach(function (parentProp) {\n                    propMetadata[parentProp] = parentPropMetadata_1[parentProp];\n                });\n            }\n            var /** @type {?} */ members_1 = classMetadata['members'] || {};\n            Object.keys(members_1).forEach(function (propName) {\n                var /** @type {?} */ propData = members_1[propName];\n                var /** @type {?} */ prop = ((propData))\n                    .find(function (a) { return a['__symbolic'] == 'property' || a['__symbolic'] == 'method'; });\n                var /** @type {?} */ decorators = [];\n                if (propMetadata[propName]) {\n                    decorators.push.apply(decorators, propMetadata[propName]);\n                }\n                propMetadata[propName] = decorators;\n                if (prop && prop['decorators']) {\n                    decorators.push.apply(decorators, _this.simplify(type, prop['decorators']));\n                }\n            });\n            this.propertyCache.set(type, propMetadata);\n        }\n        return propMetadata;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.parameters = function (type) {\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"parameters received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n            return [];\n        }\n        try {\n            var /** @type {?} */ parameters_1 = this.parameterCache.get(type);\n            if (!parameters_1) {\n                var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n                var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n                var /** @type {?} */ members = classMetadata ? classMetadata['members'] : null;\n                var /** @type {?} */ ctorData = members ? members['__ctor__'] : null;\n                if (ctorData) {\n                    var /** @type {?} */ ctor = ((ctorData)).find(function (a) { return a['__symbolic'] == 'constructor'; });\n                    var /** @type {?} */ parameterTypes = (this.simplify(type, ctor['parameters'] || []));\n                    var /** @type {?} */ parameterDecorators_1 = (this.simplify(type, ctor['parameterDecorators'] || []));\n                    parameters_1 = [];\n                    parameterTypes.forEach(function (paramType, index) {\n                        var /** @type {?} */ nestedResult = [];\n                        if (paramType) {\n                            nestedResult.push(paramType);\n                        }\n                        var /** @type {?} */ decorators = parameterDecorators_1 ? parameterDecorators_1[index] : null;\n                        if (decorators) {\n                            nestedResult.push.apply(nestedResult, decorators);\n                        }\n                        parameters_1.push(nestedResult);\n                    });\n                }\n                else if (parentType) {\n                    parameters_1 = this.parameters(parentType);\n                }\n                if (!parameters_1) {\n                    parameters_1 = [];\n                }\n                this.parameterCache.set(type, parameters_1);\n            }\n            return parameters_1;\n        }\n        catch (e) {\n            console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n            throw e;\n        }\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype._methodNames = function (type) {\n        var /** @type {?} */ methodNames = this.methodCache.get(type);\n        if (!methodNames) {\n            var /** @type {?} */ classMetadata = this.getTypeMetadata(type);\n            methodNames = {};\n            var /** @type {?} */ parentType = this.findParentType(type, classMetadata);\n            if (parentType) {\n                var /** @type {?} */ parentMethodNames_1 = this._methodNames(parentType);\n                Object.keys(parentMethodNames_1).forEach(function (parentProp) {\n                    methodNames[parentProp] = parentMethodNames_1[parentProp];\n                });\n            }\n            var /** @type {?} */ members_2 = classMetadata['members'] || {};\n            Object.keys(members_2).forEach(function (propName) {\n                var /** @type {?} */ propData = members_2[propName];\n                var /** @type {?} */ isMethod = ((propData)).some(function (a) { return a['__symbolic'] == 'method'; });\n                methodNames[propName] = methodNames[propName] || isMethod;\n            });\n            this.methodCache.set(type, methodNames);\n        }\n        return methodNames;\n    };\n    /**\n     * @param {?} type\n     * @param {?} classMetadata\n     * @return {?}\n     */\n    StaticReflector.prototype.findParentType = function (type, classMetadata) {\n        var /** @type {?} */ parentType = this.trySimplify(type, classMetadata['extends']);\n        if (parentType instanceof StaticSymbol) {\n            return parentType;\n        }\n    };\n    /**\n     * @param {?} type\n     * @param {?} lcProperty\n     * @return {?}\n     */\n    StaticReflector.prototype.hasLifecycleHook = function (type, lcProperty) {\n        if (!(type instanceof StaticSymbol)) {\n            this.reportError(new Error(\"hasLifecycleHook received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n        }\n        try {\n            return !!this._methodNames(type)[lcProperty];\n        }\n        catch (e) {\n            console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n            throw e;\n        }\n    };\n    /**\n     * @param {?} type\n     * @param {?} ctor\n     * @return {?}\n     */\n    StaticReflector.prototype._registerDecoratorOrConstructor = function (type, ctor) {\n        this.conversionMap.set(type, function (context, args) { return new (ctor.bind.apply(ctor, [void 0].concat(args)))(); });\n    };\n    /**\n     * @param {?} type\n     * @param {?} fn\n     * @return {?}\n     */\n    StaticReflector.prototype._registerFunction = function (type, fn) {\n        this.conversionMap.set(type, function (context, args) { return fn.apply(undefined, args); });\n    };\n    /**\n     * @return {?}\n     */\n    StaticReflector.prototype.initializeConversionMap = function () {\n        this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');\n        this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"R\" /* Host */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"e\" /* Injectable */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_42\" /* Self */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"B\" /* SkipSelf */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"S\" /* Attribute */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_49\" /* ContentChild */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_50\" /* ContentChildren */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_51\" /* ViewChild */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_52\" /* ViewChildren */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"M\" /* Input */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_35\" /* Output */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"W\" /* Pipe */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_36\" /* HostBinding */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_37\" /* HostListener */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"H\" /* Directive */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"a\" /* NgModule */]);\n        // Note: Some metadata classes can be used directly with Provider.deps.\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"R\" /* Host */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_42\" /* Self */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"B\" /* SkipSelf */]);\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'trigger'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_53\" /* trigger */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'state'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_54\" /* state */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'transition'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_55\" /* transition */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'style'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_56\" /* style */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'animate'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_57\" /* animate */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'keyframes'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_58\" /* keyframes */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'sequence'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_59\" /* sequence */]);\n        this._registerFunction(this.findDeclaration(ANGULAR_CORE, 'group'), __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_60\" /* group */]);\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param {?} declarationFile the absolute path of the file where the symbol is declared\n     * @param {?} name the name of the type.\n     * @param {?=} members\n     * @return {?}\n     */\n    StaticReflector.prototype.getStaticSymbol = function (declarationFile, name, members) {\n        return this.symbolResolver.getStaticSymbol(declarationFile, name, members);\n    };\n    /**\n     * @param {?} error\n     * @param {?} context\n     * @param {?=} path\n     * @return {?}\n     */\n    StaticReflector.prototype.reportError = function (error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(error, (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    };\n    /**\n     * Simplify but discard any errors\n     * @param {?} context\n     * @param {?} value\n     * @return {?}\n     */\n    StaticReflector.prototype.trySimplify = function (context, value) {\n        var /** @type {?} */ originalRecorder = this.errorRecorder;\n        this.errorRecorder = function (error, fileName) { };\n        var /** @type {?} */ result = this.simplify(context, value);\n        this.errorRecorder = originalRecorder;\n        return result;\n    };\n    /**\n     * \\@internal\n     * @param {?} context\n     * @param {?} value\n     * @return {?}\n     */\n    StaticReflector.prototype.simplify = function (context, value) {\n        var _this = this;\n        var /** @type {?} */ self = this;\n        var /** @type {?} */ scope = BindingScope.empty;\n        var /** @type {?} */ calling = new Map();\n        /**\n         * @param {?} context\n         * @param {?} value\n         * @param {?} depth\n         * @return {?}\n         */\n        function simplifyInContext(context, value, depth) {\n            /**\n             * @param {?} staticSymbol\n             * @return {?}\n             */\n            function resolveReferenceValue(staticSymbol) {\n                var /** @type {?} */ resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);\n                return resolvedSymbol ? resolvedSymbol.metadata : null;\n            }\n            /**\n             * @param {?} functionSymbol\n             * @param {?} targetFunction\n             * @param {?} args\n             * @return {?}\n             */\n            function simplifyCall(functionSymbol, targetFunction, args) {\n                if (targetFunction && targetFunction['__symbolic'] == 'function') {\n                    if (calling.get(functionSymbol)) {\n                        throw new Error('Recursion not supported');\n                    }\n                    calling.set(functionSymbol, true);\n                    try {\n                        var /** @type {?} */ value_1 = targetFunction['value'];\n                        if (value_1 && (depth != 0 || value_1.__symbolic != 'error')) {\n                            var /** @type {?} */ parameters = targetFunction['parameters'];\n                            var /** @type {?} */ defaults = targetFunction.defaults;\n                            args = args.map(function (arg) { return simplifyInContext(context, arg, depth + 1); })\n                                .map(function (arg) { return shouldIgnore(arg) ? undefined : arg; });\n                            if (defaults && defaults.length > args.length) {\n                                args.push.apply(args, defaults.slice(args.length).map(function (value) { return simplify(value); }));\n                            }\n                            var /** @type {?} */ functionScope = BindingScope.build();\n                            for (var /** @type {?} */ i = 0; i < parameters.length; i++) {\n                                functionScope.define(parameters[i], args[i]);\n                            }\n                            var /** @type {?} */ oldScope = scope;\n                            var /** @type {?} */ result_1;\n                            try {\n                                scope = functionScope.done();\n                                result_1 = simplifyInContext(functionSymbol, value_1, depth + 1);\n                            }\n                            finally {\n                                scope = oldScope;\n                            }\n                            return result_1;\n                        }\n                    }\n                    finally {\n                        calling.delete(functionSymbol);\n                    }\n                }\n                if (depth === 0) {\n                    // If depth is 0 we are evaluating the top level expression that is describing element\n                    // decorator. In this case, it is a decorator we don't understand, such as a custom\n                    // non-angular decorator, and we should just ignore it.\n                    return IGNORE;\n                }\n                return simplify({ __symbolic: 'error', message: 'Function call not supported', context: functionSymbol });\n            }\n            /**\n             * @param {?} expression\n             * @return {?}\n             */\n            function simplify(expression) {\n                if (isPrimitive(expression)) {\n                    return expression;\n                }\n                if (expression instanceof Array) {\n                    var /** @type {?} */ result_2 = [];\n                    for (var _i = 0, _a = ((expression)); _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        // Check for a spread expression\n                        if (item && item.__symbolic === 'spread') {\n                            var /** @type {?} */ spreadArray = simplify(item.expression);\n                            if (Array.isArray(spreadArray)) {\n                                for (var _b = 0, spreadArray_1 = spreadArray; _b < spreadArray_1.length; _b++) {\n                                    var spreadItem = spreadArray_1[_b];\n                                    result_2.push(spreadItem);\n                                }\n                                continue;\n                            }\n                        }\n                        var /** @type {?} */ value_2 = simplify(item);\n                        if (shouldIgnore(value_2)) {\n                            continue;\n                        }\n                        result_2.push(value_2);\n                    }\n                    return result_2;\n                }\n                if (expression instanceof StaticSymbol) {\n                    // Stop simplification at builtin symbols\n                    if (expression === self.injectionToken || expression === self.opaqueToken ||\n                        self.conversionMap.has(expression)) {\n                        return expression;\n                    }\n                    else {\n                        var /** @type {?} */ staticSymbol = expression;\n                        var /** @type {?} */ declarationValue = resolveReferenceValue(staticSymbol);\n                        if (declarationValue) {\n                            return simplifyInContext(staticSymbol, declarationValue, depth + 1);\n                        }\n                        else {\n                            return staticSymbol;\n                        }\n                    }\n                }\n                if (expression) {\n                    if (expression['__symbolic']) {\n                        var /** @type {?} */ staticSymbol = void 0;\n                        switch (expression['__symbolic']) {\n                            case 'binop':\n                                var /** @type {?} */ left = simplify(expression['left']);\n                                if (shouldIgnore(left))\n                                    return left;\n                                var /** @type {?} */ right = simplify(expression['right']);\n                                if (shouldIgnore(right))\n                                    return right;\n                                switch (expression['operator']) {\n                                    case '&&':\n                                        return left && right;\n                                    case '||':\n                                        return left || right;\n                                    case '|':\n                                        return left | right;\n                                    case '^':\n                                        return left ^ right;\n                                    case '&':\n                                        return left & right;\n                                    case '==':\n                                        return left == right;\n                                    case '!=':\n                                        return left != right;\n                                    case '===':\n                                        return left === right;\n                                    case '!==':\n                                        return left !== right;\n                                    case '<':\n                                        return left < right;\n                                    case '>':\n                                        return left > right;\n                                    case '<=':\n                                        return left <= right;\n                                    case '>=':\n                                        return left >= right;\n                                    case '<<':\n                                        return left << right;\n                                    case '>>':\n                                        return left >> right;\n                                    case '+':\n                                        return left + right;\n                                    case '-':\n                                        return left - right;\n                                    case '*':\n                                        return left * right;\n                                    case '/':\n                                        return left / right;\n                                    case '%':\n                                        return left % right;\n                                }\n                                return null;\n                            case 'if':\n                                var /** @type {?} */ condition = simplify(expression['condition']);\n                                return condition ? simplify(expression['thenExpression']) :\n                                    simplify(expression['elseExpression']);\n                            case 'pre':\n                                var /** @type {?} */ operand = simplify(expression['operand']);\n                                if (shouldIgnore(operand))\n                                    return operand;\n                                switch (expression['operator']) {\n                                    case '+':\n                                        return operand;\n                                    case '-':\n                                        return -operand;\n                                    case '!':\n                                        return !operand;\n                                    case '~':\n                                        return ~operand;\n                                }\n                                return null;\n                            case 'index':\n                                var /** @type {?} */ indexTarget = simplify(expression['expression']);\n                                var /** @type {?} */ index = simplify(expression['index']);\n                                if (indexTarget && isPrimitive(index))\n                                    return indexTarget[index];\n                                return null;\n                            case 'select':\n                                var /** @type {?} */ member = expression['member'];\n                                var /** @type {?} */ selectContext = context;\n                                var /** @type {?} */ selectTarget = simplify(expression['expression']);\n                                if (selectTarget instanceof StaticSymbol) {\n                                    var /** @type {?} */ members = selectTarget.members.concat(member);\n                                    selectContext =\n                                        self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);\n                                    var /** @type {?} */ declarationValue = resolveReferenceValue(selectContext);\n                                    if (declarationValue) {\n                                        return simplifyInContext(selectContext, declarationValue, depth + 1);\n                                    }\n                                    else {\n                                        return selectContext;\n                                    }\n                                }\n                                if (selectTarget && isPrimitive(member))\n                                    return simplifyInContext(selectContext, selectTarget[member], depth + 1);\n                                return null;\n                            case 'reference':\n                                // Note: This only has to deal with variable references,\n                                // as symbol references have been converted into StaticSymbols already\n                                // in the StaticSymbolResolver!\n                                var /** @type {?} */ name = expression['name'];\n                                var /** @type {?} */ localValue = scope.resolve(name);\n                                if (localValue != BindingScope.missing) {\n                                    return localValue;\n                                }\n                                break;\n                            case 'class':\n                                return context;\n                            case 'function':\n                                return context;\n                            case 'new':\n                            case 'call':\n                                // Determine if the function is a built-in conversion\n                                staticSymbol = simplifyInContext(context, expression['expression'], depth + 1);\n                                if (staticSymbol instanceof StaticSymbol) {\n                                    if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {\n                                        // if somebody calls new InjectionToken, don't create an InjectionToken,\n                                        // but rather return the symbol to which the InjectionToken is assigned to.\n                                        return context;\n                                    }\n                                    var /** @type {?} */ argExpressions = expression['arguments'] || [];\n                                    var /** @type {?} */ converter = self.conversionMap.get(staticSymbol);\n                                    if (converter) {\n                                        var /** @type {?} */ args = argExpressions.map(function (arg) { return simplifyInContext(context, arg, depth + 1); })\n                                            .map(function (arg) { return shouldIgnore(arg) ? undefined : arg; });\n                                        return converter(context, args);\n                                    }\n                                    else {\n                                        // Determine if the function is one we can simplify.\n                                        var /** @type {?} */ targetFunction = resolveReferenceValue(staticSymbol);\n                                        return simplifyCall(staticSymbol, targetFunction, argExpressions);\n                                    }\n                                }\n                                break;\n                            case 'error':\n                                var /** @type {?} */ message = produceErrorMessage(expression);\n                                if (expression['line']) {\n                                    message =\n                                        message + \" (position \" + (expression['line'] + 1) + \":\" + (expression['character'] + 1) + \" in the original .ts file)\";\n                                    self.reportError(positionalError(message, context.filePath, expression['line'], expression['character']), context);\n                                }\n                                else {\n                                    self.reportError(new Error(message), context);\n                                }\n                                return IGNORE;\n                            case 'ignore':\n                                return expression;\n                        }\n                        return null;\n                    }\n                    return mapStringMap(expression, function (value, name) { return simplify(value); });\n                }\n                return IGNORE;\n            }\n            try {\n                return simplify(value);\n            }\n            catch (e) {\n                var /** @type {?} */ members = context.members.length ? \".\" + context.members.join('.') : '';\n                var /** @type {?} */ message = e.message + \", resolving symbol \" + context.name + members + \" in \" + context.filePath;\n                if (e.fileName) {\n                    throw positionalError(message, e.fileName, e.line, e.column);\n                }\n                throw syntaxError(message);\n            }\n        }\n        var /** @type {?} */ recordedSimplifyInContext = function (context, value, depth) {\n            try {\n                return simplifyInContext(context, value, depth);\n            }\n            catch (e) {\n                _this.reportError(e, context);\n            }\n        };\n        var /** @type {?} */ result = this.errorRecorder ? recordedSimplifyInContext(context, value, 0) :\n            simplifyInContext(context, value, 0);\n        if (shouldIgnore(result)) {\n            return undefined;\n        }\n        return result;\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    StaticReflector.prototype.getTypeMetadata = function (type) {\n        var /** @type {?} */ resolvedSymbol = this.symbolResolver.resolveSymbol(type);\n        return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata :\n            { __symbolic: 'class' };\n    };\n    return StaticReflector;\n}());\n/**\n * @param {?} error\n * @return {?}\n */\nfunction expandedMessage(error) {\n    switch (error.message) {\n        case 'Reference to non-exported class':\n            if (error.context && error.context.className) {\n                return \"Reference to a non-exported class \" + error.context.className + \". Consider exporting the class\";\n            }\n            break;\n        case 'Variable not initialized':\n            return 'Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler';\n        case 'Destructuring not supported':\n            return 'Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring';\n        case 'Could not resolve type':\n            if (error.context && error.context.typeName) {\n                return \"Could not resolve type \" + error.context.typeName;\n            }\n            break;\n        case 'Function call not supported':\n            var /** @type {?} */ prefix = error.context && error.context.name ? \"Calling function '\" + error.context.name + \"', f\" : 'F';\n            return prefix +\n                'unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function';\n        case 'Reference to a local symbol':\n            if (error.context && error.context.name) {\n                return \"Reference to a local (non-exported) symbol '\" + error.context.name + \"'. Consider exporting the symbol\";\n            }\n            break;\n    }\n    return error.message;\n}\n/**\n * @param {?} error\n * @return {?}\n */\nfunction produceErrorMessage(error) {\n    return \"Error encountered resolving symbol values statically. \" + expandedMessage(error);\n}\n/**\n * @param {?} input\n * @param {?} transform\n * @return {?}\n */\nfunction mapStringMap(input, transform) {\n    if (!input)\n        return {};\n    var /** @type {?} */ result = {};\n    Object.keys(input).forEach(function (key) {\n        var /** @type {?} */ value = transform(input[key], key);\n        if (!shouldIgnore(value)) {\n            if (HIDDEN_KEY.test(key)) {\n                Object.defineProperty(result, key, { enumerable: false, configurable: true, value: value });\n            }\n            else {\n                result[key] = value;\n            }\n        }\n    });\n    return result;\n}\n/**\n * @param {?} o\n * @return {?}\n */\nfunction isPrimitive(o) {\n    return o === null || (typeof o !== 'function' && typeof o !== 'object');\n}\n/**\n * @abstract\n */\nvar BindingScope = (function () {\n    function BindingScope() {\n    }\n    /**\n     * @abstract\n     * @param {?} name\n     * @return {?}\n     */\n    BindingScope.prototype.resolve = function (name) { };\n    /**\n     * @return {?}\n     */\n    BindingScope.build = function () {\n        var /** @type {?} */ current = new Map();\n        return {\n            define: function (name, value) {\n                current.set(name, value);\n                return this;\n            },\n            done: function () {\n                return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;\n            }\n        };\n    };\n    return BindingScope;\n}());\nBindingScope.missing = {};\nBindingScope.empty = { resolve: function (name) { return BindingScope.missing; } };\nvar PopulatedScope = (function (_super) {\n    __extends(PopulatedScope, _super);\n    /**\n     * @param {?} bindings\n     */\n    function PopulatedScope(bindings) {\n        var _this = _super.call(this) || this;\n        _this.bindings = bindings;\n        return _this;\n    }\n    /**\n     * @param {?} name\n     * @return {?}\n     */\n    PopulatedScope.prototype.resolve = function (name) {\n        return this.bindings.has(name) ? this.bindings.get(name) : BindingScope.missing;\n    };\n    return PopulatedScope;\n}(BindingScope));\n/**\n * @param {?} message\n * @param {?} fileName\n * @param {?} line\n * @param {?} column\n * @return {?}\n */\nfunction positionalError(message, fileName, line, column) {\n    var /** @type {?} */ result = new Error(message);\n    ((result)).fileName = fileName;\n    ((result)).line = line;\n    ((result)).column = column;\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar ResolvedStaticSymbol = (function () {\n    /**\n     * @param {?} symbol\n     * @param {?} metadata\n     */\n    function ResolvedStaticSymbol(symbol, metadata) {\n        this.symbol = symbol;\n        this.metadata = metadata;\n    }\n    return ResolvedStaticSymbol;\n}());\nvar SUPPORTED_SCHEMA_VERSION = 3;\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n *\n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nvar StaticSymbolResolver = (function () {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolCache\n     * @param {?} summaryResolver\n     * @param {?=} errorRecorder\n     */\n    function StaticSymbolResolver(host, staticSymbolCache, summaryResolver, errorRecorder) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        this.summaryResolver = summaryResolver;\n        this.errorRecorder = errorRecorder;\n        this.metadataCache = new Map();\n        this.resolvedSymbols = new Map();\n        this.resolvedFilePaths = new Set();\n        this.importAs = new Map();\n        this.symbolResourcePaths = new Map();\n        this.symbolFromFile = new Map();\n    }\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.resolveSymbol = function (staticSymbol) {\n        if (staticSymbol.members.length > 0) {\n            return this._resolveSymbolMembers(staticSymbol);\n        }\n        var /** @type {?} */ result = this.resolvedSymbols.get(staticSymbol);\n        if (result) {\n            return result;\n        }\n        result = this._resolveSymbolFromSummary(staticSymbol);\n        if (result) {\n            return result;\n        }\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files. So we always need to check both, the summary\n        // and metadata.\n        this._createSymbolsOf(staticSymbol.filePath);\n        result = this.resolvedSymbols.get(staticSymbol);\n        return result;\n    };\n    /**\n     * getImportAs produces a symbol that can be used to import the given symbol.\n     * The import might be different than the symbol if the symbol is exported from\n     * a library with a summary; in which case we want to import the symbol from the\n     * ngfactory re-export instead of directly to avoid introducing a direct dependency\n     * on an otherwise indirect dependency.\n     *\n     * @param {?} staticSymbol the symbol for which to generate a import symbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getImportAs = function (staticSymbol) {\n        if (staticSymbol.members.length) {\n            var /** @type {?} */ baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n            var /** @type {?} */ baseImportAs = this.getImportAs(baseSymbol);\n            return baseImportAs ?\n                this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n                null;\n        }\n        var /** @type {?} */ result = this.summaryResolver.getImportAs(staticSymbol);\n        if (!result) {\n            result = this.importAs.get(staticSymbol);\n        }\n        return result;\n    };\n    /**\n     * getResourcePath produces the path to the original location of the symbol and should\n     * be used to determine the relative location of resource references recorded in\n     * symbol metadata.\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getResourcePath = function (staticSymbol) {\n        return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n    };\n    /**\n     * getTypeArity returns the number of generic type parameters the given symbol\n     * has. If the symbol is not a type the result is null.\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getTypeArity = function (staticSymbol) {\n        // If the file is a factory file, don't resolve the symbol as doing so would\n        // cause the metadata for an factory file to be loaded which doesn't exist.\n        // All references to generated classes must include the correct arity whenever\n        // generating code.\n        if (isNgFactoryFile(staticSymbol.filePath)) {\n            return null;\n        }\n        var /** @type {?} */ resolvedSymbol = this.resolveSymbol(staticSymbol);\n        while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n            resolvedSymbol = this.resolveSymbol(resolvedSymbol.metadata);\n        }\n        return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n    };\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} targetSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.recordImportAs = function (sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        this.importAs.set(sourceSymbol, targetSymbol);\n    };\n    /**\n     * Invalidate all information derived from the given file.\n     *\n     * @param {?} fileName the file to invalidate\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.invalidateFile = function (fileName) {\n        this.metadataCache.delete(fileName);\n        this.resolvedFilePaths.delete(fileName);\n        var /** @type {?} */ symbols = this.symbolFromFile.get(fileName);\n        if (symbols) {\n            this.symbolFromFile.delete(fileName);\n            for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {\n                var symbol = symbols_1[_i];\n                this.resolvedSymbols.delete(symbol);\n                this.importAs.delete(symbol);\n                this.symbolResourcePaths.delete(symbol);\n            }\n        }\n    };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype._resolveSymbolMembers = function (staticSymbol) {\n        var /** @type {?} */ members = staticSymbol.members;\n        var /** @type {?} */ baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n        if (!baseResolvedSymbol) {\n            return null;\n        }\n        var /** @type {?} */ baseMetadata = baseResolvedSymbol.metadata;\n        if (baseMetadata instanceof StaticSymbol) {\n            return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n        }\n        else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n            if (baseMetadata.statics && members.length === 1) {\n                return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n            }\n        }\n        else {\n            var /** @type {?} */ value = baseMetadata;\n            for (var /** @type {?} */ i = 0; i < members.length && value; i++) {\n                value = value[members[i]];\n            }\n            return new ResolvedStaticSymbol(staticSymbol, value);\n        }\n        return null;\n    };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype._resolveSymbolFromSummary = function (staticSymbol) {\n        var /** @type {?} */ summary = this.summaryResolver.resolveSummary(staticSymbol);\n        return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param {?} declarationFile the absolute path of the file where the symbol is declared\n     * @param {?} name the name of the type.\n     * @param {?=} members a symbol for a static member of the named type\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getStaticSymbol = function (declarationFile, name, members) {\n        return this.staticSymbolCache.get(declarationFile, name, members);\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getSymbolsOf = function (filePath) {\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n        // have summaries, only .d.ts files. So we always need to check both, the summary\n        // and metadata.\n        var /** @type {?} */ symbols = new Set(this.summaryResolver.getSymbolsOf(filePath));\n        this._createSymbolsOf(filePath);\n        this.resolvedSymbols.forEach(function (resolvedSymbol) {\n            if (resolvedSymbol.symbol.filePath === filePath) {\n                symbols.add(resolvedSymbol.symbol);\n            }\n        });\n        return Array.from(symbols);\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype._createSymbolsOf = function (filePath) {\n        var _this = this;\n        if (this.resolvedFilePaths.has(filePath)) {\n            return;\n        }\n        this.resolvedFilePaths.add(filePath);\n        var /** @type {?} */ resolvedSymbols = [];\n        var /** @type {?} */ metadata = this.getModuleMetadata(filePath);\n        if (metadata['metadata']) {\n            // handle direct declarations of the symbol\n            var /** @type {?} */ topLevelSymbolNames_1 = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n            var /** @type {?} */ origins_1 = metadata['origins'] || {};\n            Object.keys(metadata['metadata']).forEach(function (metadataKey) {\n                var /** @type {?} */ symbolMeta = metadata['metadata'][metadataKey];\n                var /** @type {?} */ name = unescapeIdentifier(metadataKey);\n                var /** @type {?} */ symbol = _this.getStaticSymbol(filePath, name);\n                var /** @type {?} */ importSymbol = undefined;\n                if (metadata['importAs']) {\n                    // Index bundle indexes should use the importAs module name instead of a reference\n                    // to the .d.ts file directly.\n                    importSymbol = _this.getStaticSymbol(metadata['importAs'], name);\n                    _this.recordImportAs(symbol, importSymbol);\n                }\n                var /** @type {?} */ origin = origins_1.hasOwnProperty(metadataKey) && origins_1[metadataKey];\n                if (origin) {\n                    // If the symbol is from a bundled index, use the declaration location of the\n                    // symbol so relative references (such as './my.html') will be calculated\n                    // correctly.\n                    var /** @type {?} */ originFilePath = _this.resolveModule(origin, filePath);\n                    if (!originFilePath) {\n                        _this.reportError(new Error(\"Couldn't resolve original symbol for \" + origin + \" from \" + filePath), null);\n                    }\n                    else {\n                        _this.symbolResourcePaths.set(symbol, originFilePath);\n                    }\n                }\n                resolvedSymbols.push(_this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames_1, symbolMeta));\n            });\n        }\n        // handle the symbols in one of the re-export location\n        if (metadata['exports']) {\n            var _loop_1 = function (moduleExport) {\n                // handle the symbols in the list of explicitly re-exported symbols.\n                if (moduleExport.export) {\n                    moduleExport.export.forEach(function (exportSymbol) {\n                        var /** @type {?} */ symbolName;\n                        if (typeof exportSymbol === 'string') {\n                            symbolName = exportSymbol;\n                        }\n                        else {\n                            symbolName = exportSymbol.as;\n                        }\n                        symbolName = unescapeIdentifier(symbolName);\n                        var /** @type {?} */ symName = symbolName;\n                        if (typeof exportSymbol !== 'string') {\n                            symName = unescapeIdentifier(exportSymbol.name);\n                        }\n                        var /** @type {?} */ resolvedModule = _this.resolveModule(moduleExport.from, filePath);\n                        if (resolvedModule) {\n                            var /** @type {?} */ targetSymbol = _this.getStaticSymbol(resolvedModule, symName);\n                            var /** @type {?} */ sourceSymbol = _this.getStaticSymbol(filePath, symbolName);\n                            resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n                        }\n                    });\n                }\n                else {\n                    // handle the symbols via export * directives.\n                    var /** @type {?} */ resolvedModule = this_1.resolveModule(moduleExport.from, filePath);\n                    if (resolvedModule) {\n                        var /** @type {?} */ nestedExports = this_1.getSymbolsOf(resolvedModule);\n                        nestedExports.forEach(function (targetSymbol) {\n                            var /** @type {?} */ sourceSymbol = _this.getStaticSymbol(filePath, targetSymbol.name);\n                            resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n                        });\n                    }\n                }\n            };\n            var this_1 = this;\n            for (var _i = 0, _a = metadata['exports']; _i < _a.length; _i++) {\n                var moduleExport = _a[_i];\n                _loop_1(/** @type {?} */ moduleExport);\n            }\n        }\n        resolvedSymbols.forEach(function (resolvedSymbol) { return _this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol); });\n        this.symbolFromFile.set(filePath, resolvedSymbols.map(function (resolvedSymbol) { return resolvedSymbol.symbol; }));\n    };\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} topLevelPath\n     * @param {?} topLevelSymbolNames\n     * @param {?} metadata\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.createResolvedSymbol = function (sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {\n        // For classes that don't have Angular summaries / metadata,\n        // we only keep their arity, but nothing else\n        // (e.g. their constructor parameters).\n        // We do this to prevent introducing deep imports\n        // as we didn't generate .ngfactory.ts files with proper reexports.\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && metadata &&\n            metadata['__symbolic'] === 'class') {\n            var /** @type {?} */ transformedMeta_1 = { __symbolic: 'class', arity: metadata.arity };\n            return new ResolvedStaticSymbol(sourceSymbol, transformedMeta_1);\n        }\n        var /** @type {?} */ self = this;\n        var ReferenceTransformer = (function (_super) {\n            __extends(ReferenceTransformer, _super);\n            function ReferenceTransformer() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            /**\n             * @param {?} map\n             * @param {?} functionParams\n             * @return {?}\n             */\n            ReferenceTransformer.prototype.visitStringMap = function (map, functionParams) {\n                var /** @type {?} */ symbolic = map['__symbolic'];\n                if (symbolic === 'function') {\n                    var /** @type {?} */ oldLen = functionParams.length;\n                    functionParams.push.apply(functionParams, (map['parameters'] || []));\n                    var /** @type {?} */ result = _super.prototype.visitStringMap.call(this, map, functionParams);\n                    functionParams.length = oldLen;\n                    return result;\n                }\n                else if (symbolic === 'reference') {\n                    var /** @type {?} */ module_1 = map['module'];\n                    var /** @type {?} */ name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n                    if (!name) {\n                        return null;\n                    }\n                    var /** @type {?} */ filePath = void 0;\n                    if (module_1) {\n                        filePath = self.resolveModule(module_1, sourceSymbol.filePath);\n                        if (!filePath) {\n                            return {\n                                __symbolic: 'error',\n                                message: \"Could not resolve \" + module_1 + \" relative to \" + sourceSymbol.filePath + \".\"\n                            };\n                        }\n                        return self.getStaticSymbol(filePath, name);\n                    }\n                    else if (functionParams.indexOf(name) >= 0) {\n                        // reference to a function parameter\n                        return { __symbolic: 'reference', name: name };\n                    }\n                    else {\n                        if (topLevelSymbolNames.has(name)) {\n                            return self.getStaticSymbol(topLevelPath, name);\n                        }\n                        // ambient value\n                        null;\n                    }\n                }\n                else {\n                    return _super.prototype.visitStringMap.call(this, map, functionParams);\n                }\n            };\n            return ReferenceTransformer;\n        }(ValueTransformer));\n        var /** @type {?} */ transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n        if (transformedMeta instanceof StaticSymbol) {\n            return this.createExport(sourceSymbol, transformedMeta);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    };\n    /**\n     * @param {?} sourceSymbol\n     * @param {?} targetSymbol\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.createExport = function (sourceSymbol, targetSymbol) {\n        sourceSymbol.assertNoMembers();\n        targetSymbol.assertNoMembers();\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath)) {\n            // This case is for an ng library importing symbols from a plain ts library\n            // transitively.\n            // Note: We rely on the fact that we discover symbols in the direction\n            // from source files to library files\n            this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n        }\n        return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n    };\n    /**\n     * @param {?} error\n     * @param {?} context\n     * @param {?=} path\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.reportError = function (error, context, path) {\n        if (this.errorRecorder) {\n            this.errorRecorder(error, (context && context.filePath) || path);\n        }\n        else {\n            throw error;\n        }\n    };\n    /**\n     * @param {?} module an absolute path to a module file.\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getModuleMetadata = function (module) {\n        var /** @type {?} */ moduleMetadata = this.metadataCache.get(module);\n        if (!moduleMetadata) {\n            var /** @type {?} */ moduleMetadatas = this.host.getMetadataFor(module);\n            if (moduleMetadatas) {\n                var /** @type {?} */ maxVersion_1 = -1;\n                moduleMetadatas.forEach(function (md) {\n                    if (md['version'] > maxVersion_1) {\n                        maxVersion_1 = md['version'];\n                        moduleMetadata = md;\n                    }\n                });\n            }\n            if (!moduleMetadata) {\n                moduleMetadata =\n                    { __symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {} };\n            }\n            if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n                var /** @type {?} */ errorMessage = moduleMetadata['version'] == 2 ?\n                    \"Unsupported metadata version \" + moduleMetadata['version'] + \" for module \" + module + \". This module should be compiled with a newer version of ngc\" :\n                    \"Metadata version mismatch for module \" + module + \", found version \" + moduleMetadata['version'] + \", expected \" + SUPPORTED_SCHEMA_VERSION;\n                this.reportError(new Error(errorMessage), null);\n            }\n            this.metadataCache.set(module, moduleMetadata);\n        }\n        return moduleMetadata;\n    };\n    /**\n     * @param {?} module\n     * @param {?} symbolName\n     * @param {?=} containingFile\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.getSymbolByModule = function (module, symbolName, containingFile) {\n        var /** @type {?} */ filePath = this.resolveModule(module, containingFile);\n        if (!filePath) {\n            this.reportError(new Error(\"Could not resolve module \" + module + (containingFile ? \" relative to $ {\\n            containingFile\\n          } \" : '')), null);\n            return this.getStaticSymbol(\"ERROR:\" + module, symbolName);\n        }\n        return this.getStaticSymbol(filePath, symbolName);\n    };\n    /**\n     * @param {?} module\n     * @param {?} containingFile\n     * @return {?}\n     */\n    StaticSymbolResolver.prototype.resolveModule = function (module, containingFile) {\n        try {\n            return this.host.moduleNameToFileName(module, containingFile);\n        }\n        catch (e) {\n            console.error(\"Could not resolve module '\" + module + \"' relative to file \" + containingFile);\n            this.reportError(e, null, containingFile);\n        }\n    };\n    return StaticSymbolResolver;\n}());\n/**\n * @param {?} identifier\n * @return {?}\n */\nfunction unescapeIdentifier(identifier) {\n    return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar AotSummaryResolver = (function () {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolCache\n     */\n    function AotSummaryResolver(host, staticSymbolCache) {\n        this.host = host;\n        this.staticSymbolCache = staticSymbolCache;\n        this.summaryCache = new Map();\n        this.loadedFilePaths = new Set();\n        this.importAs = new Map();\n    }\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.isLibraryFile = function (filePath) {\n        // Note: We need to strip the .ngfactory. file path,\n        // so this method also works for generated files\n        // (for which host.isSourceFile will always return false).\n        return !this.host.isSourceFile(stripNgFactory(filePath));\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.getLibraryFileName = function (filePath) { return this.host.getOutputFileName(filePath); };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.resolveSummary = function (staticSymbol) {\n        staticSymbol.assertNoMembers();\n        var /** @type {?} */ summary = this.summaryCache.get(staticSymbol);\n        if (!summary) {\n            this._loadSummaryFile(staticSymbol.filePath);\n            summary = this.summaryCache.get(staticSymbol);\n        }\n        return summary;\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.getSymbolsOf = function (filePath) {\n        this._loadSummaryFile(filePath);\n        return Array.from(this.summaryCache.keys()).filter(function (symbol) { return symbol.filePath === filePath; });\n    };\n    /**\n     * @param {?} staticSymbol\n     * @return {?}\n     */\n    AotSummaryResolver.prototype.getImportAs = function (staticSymbol) {\n        staticSymbol.assertNoMembers();\n        return this.importAs.get(staticSymbol);\n    };\n    /**\n     * @param {?} filePath\n     * @return {?}\n     */\n    AotSummaryResolver.prototype._loadSummaryFile = function (filePath) {\n        var _this = this;\n        if (this.loadedFilePaths.has(filePath)) {\n            return;\n        }\n        this.loadedFilePaths.add(filePath);\n        if (this.isLibraryFile(filePath)) {\n            var /** @type {?} */ summaryFilePath = summaryFileName(filePath);\n            var /** @type {?} */ json = void 0;\n            try {\n                json = this.host.loadSummary(summaryFilePath);\n            }\n            catch (e) {\n                console.error(\"Error loading summary file \" + summaryFilePath);\n                throw e;\n            }\n            if (json) {\n                var _a = deserializeSummaries(this.staticSymbolCache, json), summaries = _a.summaries, importAs = _a.importAs;\n                summaries.forEach(function (summary) { return _this.summaryCache.set(summary.symbol, summary); });\n                importAs.forEach(function (importAs) {\n                    _this.importAs.set(importAs.symbol, _this.staticSymbolCache.get(ngfactoryFilePath(filePath), importAs.importAs));\n                });\n            }\n        }\n    };\n    return AotSummaryResolver;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Creates a new AotCompiler based on options and a host.\n * @param {?} compilerHost\n * @param {?} options\n * @return {?}\n */\nfunction createAotCompiler(compilerHost, options) {\n    var /** @type {?} */ translations = options.translations || '';\n    var /** @type {?} */ urlResolver = createOfflineCompileUrlResolver();\n    var /** @type {?} */ symbolCache = new StaticSymbolCache();\n    var /** @type {?} */ summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);\n    var /** @type {?} */ symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);\n    var /** @type {?} */ staticReflector = new StaticReflector(summaryResolver, symbolResolver);\n    StaticAndDynamicReflectionCapabilities.install(staticReflector);\n    var /** @type {?} */ console = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */]();\n    var /** @type {?} */ htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat, __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_1\" /* MissingTranslationStrategy */].Warning, console);\n    var /** @type {?} */ config = new CompilerConfig({\n        defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].Emulated,\n        useJit: false,\n        enableLegacyTemplate: options.enableLegacyTemplate !== false,\n    });\n    var /** @type {?} */ normalizer = new DirectiveNormalizer({ get: function (url) { return compilerHost.loadResource(url); } }, urlResolver, htmlParser, config);\n    var /** @type {?} */ expressionParser = new Parser(new Lexer());\n    var /** @type {?} */ elementSchemaRegistry = new DomElementSchemaRegistry();\n    var /** @type {?} */ tmplParser = new TemplateParser(config, expressionParser, elementSchemaRegistry, htmlParser, console, []);\n    var /** @type {?} */ resolver = new CompileMetadataResolver(config, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector);\n    // TODO(vicb): do not pass options.i18nFormat here\n    var /** @type {?} */ importResolver = {\n        getImportAs: function (symbol) { return symbolResolver.getImportAs(symbol); },\n        fileNameToModuleName: function (fileName, containingFilePath) { return compilerHost.fileNameToModuleName(fileName, containingFilePath); },\n        getTypeArity: function (symbol) { return symbolResolver.getTypeArity(symbol); }\n    };\n    var /** @type {?} */ viewCompiler = new ViewCompiler(config, elementSchemaRegistry);\n    var /** @type {?} */ compiler = new AotCompiler(config, compilerHost, resolver, tmplParser, new StyleCompiler(urlResolver), viewCompiler, new NgModuleCompiler(), new TypeScriptEmitter(importResolver), summaryResolver, options.locale, options.i18nFormat, options.genFilePreamble, symbolResolver);\n    return { compiler: compiler, reflector: staticReflector };\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} statements\n * @param {?} resultVars\n * @return {?}\n */\nfunction interpretStatements(statements, resultVars) {\n    var /** @type {?} */ stmtsWithReturn = statements.concat([new ReturnStatement(literalArr(resultVars.map(function (resultVar) { return variable(resultVar); })))]);\n    var /** @type {?} */ ctx = new _ExecutionContext(null, null, null, new Map());\n    var /** @type {?} */ visitor = new StatementInterpreter();\n    var /** @type {?} */ result = visitor.visitAllStatements(stmtsWithReturn, ctx);\n    return result != null ? result.value : null;\n}\n/**\n * @param {?} varNames\n * @param {?} varValues\n * @param {?} statements\n * @param {?} ctx\n * @param {?} visitor\n * @return {?}\n */\nfunction _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {\n    var /** @type {?} */ childCtx = ctx.createChildWihtLocalVars();\n    for (var /** @type {?} */ i = 0; i < varNames.length; i++) {\n        childCtx.vars.set(varNames[i], varValues[i]);\n    }\n    var /** @type {?} */ result = visitor.visitAllStatements(statements, childCtx);\n    return result ? result.value : null;\n}\nvar _ExecutionContext = (function () {\n    /**\n     * @param {?} parent\n     * @param {?} instance\n     * @param {?} className\n     * @param {?} vars\n     */\n    function _ExecutionContext(parent, instance, className, vars) {\n        this.parent = parent;\n        this.instance = instance;\n        this.className = className;\n        this.vars = vars;\n    }\n    /**\n     * @return {?}\n     */\n    _ExecutionContext.prototype.createChildWihtLocalVars = function () {\n        return new _ExecutionContext(this, this.instance, this.className, new Map());\n    };\n    return _ExecutionContext;\n}());\nvar ReturnValue = (function () {\n    /**\n     * @param {?} value\n     */\n    function ReturnValue(value) {\n        this.value = value;\n    }\n    return ReturnValue;\n}());\n/**\n * @param {?} _classStmt\n * @param {?} _ctx\n * @param {?} _visitor\n * @return {?}\n */\nfunction createDynamicClass(_classStmt, _ctx, _visitor) {\n    var /** @type {?} */ propertyDescriptors = {};\n    _classStmt.getters.forEach(function (getter) {\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[getter.name] = {\n            configurable: false,\n            get: function () {\n                var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    _classStmt.methods.forEach(function (method) {\n        var /** @type {?} */ paramNames = method.params.map(function (param) { return param.name; });\n        // Note: use `function` instead of arrow function to capture `this`\n        propertyDescriptors[method.name] = {\n            writable: false,\n            configurable: false,\n            value: function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n                return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\n            }\n        };\n    });\n    var /** @type {?} */ ctorParamNames = _classStmt.constructorMethod.params.map(function (param) { return param.name; });\n    // Note: use `function` instead of arrow function to capture `this`\n    var /** @type {?} */ ctor = function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var /** @type {?} */ instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n        _classStmt.fields.forEach(function (field) { _this[field.name] = undefined; });\n        _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\n    };\n    var /** @type {?} */ superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\n    ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\n    return ctor;\n}\nvar StatementInterpreter = (function () {\n    function StatementInterpreter() {\n    }\n    /**\n     * @param {?} ast\n     * @return {?}\n     */\n    StatementInterpreter.prototype.debugAst = function (ast) { return debugOutputAstAsTypeScript(ast); };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        ctx.vars.set(stmt.name, stmt.value.visitExpression(this, ctx));\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {\n        var /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        var /** @type {?} */ currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(expr.name)) {\n                currCtx.vars.set(expr.name, value);\n                return value;\n            }\n            currCtx = currCtx.parent;\n        }\n        throw new Error(\"Not declared variable \" + expr.name);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {\n        var /** @type {?} */ varName = ast.name;\n        if (ast.builtin != null) {\n            switch (ast.builtin) {\n                case BuiltinVar.Super:\n                    return ctx.instance.__proto__;\n                case BuiltinVar.This:\n                    return ctx.instance;\n                case BuiltinVar.CatchError:\n                    varName = CATCH_ERROR_VAR$2;\n                    break;\n                case BuiltinVar.CatchStack:\n                    varName = CATCH_STACK_VAR$2;\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin variable \" + ast.builtin);\n            }\n        }\n        var /** @type {?} */ currCtx = ctx;\n        while (currCtx != null) {\n            if (currCtx.vars.has(varName)) {\n                return currCtx.vars.get(varName);\n            }\n            currCtx = currCtx.parent;\n        }\n        throw new Error(\"Not declared variable \" + varName);\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {\n        var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ index = expr.index.visitExpression(this, ctx);\n        var /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        receiver[index] = value;\n        return value;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {\n        var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ value = expr.value.visitExpression(this, ctx);\n        receiver[expr.name] = value;\n        return value;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n        var /** @type {?} */ receiver = expr.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ args = this.visitAllExpressions(expr.args, ctx);\n        var /** @type {?} */ result;\n        if (expr.builtin != null) {\n            switch (expr.builtin) {\n                case BuiltinMethod.ConcatArray:\n                    result = receiver.concat.apply(receiver, args);\n                    break;\n                case BuiltinMethod.SubscribeObservable:\n                    result = receiver.subscribe({ next: args[0] });\n                    break;\n                case BuiltinMethod.Bind:\n                    result = receiver.bind.apply(receiver, args);\n                    break;\n                default:\n                    throw new Error(\"Unknown builtin method \" + expr.builtin);\n            }\n        }\n        else {\n            result = receiver[expr.name].apply(receiver, args);\n        }\n        return result;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {\n        var /** @type {?} */ args = this.visitAllExpressions(stmt.args, ctx);\n        var /** @type {?} */ fnExpr = stmt.fn;\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n            ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);\n            return null;\n        }\n        else {\n            var /** @type {?} */ fn$$1 = stmt.fn.visitExpression(this, ctx);\n            return fn$$1.apply(null, args);\n        }\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {\n        return new ReturnValue(stmt.value.visitExpression(this, ctx));\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var /** @type {?} */ clazz = createDynamicClass(stmt, ctx, this);\n        ctx.vars.set(stmt.name, clazz);\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {\n        return stmt.expr.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {\n        var /** @type {?} */ condition = stmt.condition.visitExpression(this, ctx);\n        if (condition) {\n            return this.visitAllStatements(stmt.trueCase, ctx);\n        }\n        else if (stmt.falseCase != null) {\n            return this.visitAllStatements(stmt.falseCase, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        try {\n            return this.visitAllStatements(stmt.bodyStmts, ctx);\n        }\n        catch (e) {\n            var /** @type {?} */ childCtx = ctx.createChildWihtLocalVars();\n            childCtx.vars.set(CATCH_ERROR_VAR$2, e);\n            childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);\n            return this.visitAllStatements(stmt.catchStmts, childCtx);\n        }\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {\n        throw stmt.error.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?=} context\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitCommentStmt = function (stmt, context) { return null; };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {\n        var /** @type {?} */ args = this.visitAllExpressions(ast.args, ctx);\n        var /** @type {?} */ clazz = ast.classExpr.visitExpression(this, ctx);\n        return new (clazz.bind.apply(clazz, [void 0].concat(args)))();\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) { return ast.value; };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) {\n        return ast.value.reference;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {\n        if (ast.condition.visitExpression(this, ctx)) {\n            return ast.trueCase.visitExpression(this, ctx);\n        }\n        else if (ast.falseCase != null) {\n            return ast.falseCase.visitExpression(this, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {\n        return !ast.condition.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {\n        return ast.value.visitExpression(this, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {\n        var /** @type {?} */ paramNames = ast.params.map(function (param) { return param.name; });\n        return _declareFn(paramNames, ast.statements, ctx, this);\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        var /** @type {?} */ paramNames = stmt.params.map(function (param) { return param.name; });\n        ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n        var _this = this;\n        var /** @type {?} */ lhs = function () { return ast.lhs.visitExpression(_this, ctx); };\n        var /** @type {?} */ rhs = function () { return ast.rhs.visitExpression(_this, ctx); };\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                return lhs() == rhs();\n            case BinaryOperator.Identical:\n                return lhs() === rhs();\n            case BinaryOperator.NotEquals:\n                return lhs() != rhs();\n            case BinaryOperator.NotIdentical:\n                return lhs() !== rhs();\n            case BinaryOperator.And:\n                return lhs() && rhs();\n            case BinaryOperator.Or:\n                return lhs() || rhs();\n            case BinaryOperator.Plus:\n                return lhs() + rhs();\n            case BinaryOperator.Minus:\n                return lhs() - rhs();\n            case BinaryOperator.Divide:\n                return lhs() / rhs();\n            case BinaryOperator.Multiply:\n                return lhs() * rhs();\n            case BinaryOperator.Modulo:\n                return lhs() % rhs();\n            case BinaryOperator.Lower:\n                return lhs() < rhs();\n            case BinaryOperator.LowerEquals:\n                return lhs() <= rhs();\n            case BinaryOperator.Bigger:\n                return lhs() > rhs();\n            case BinaryOperator.BiggerEquals:\n                return lhs() >= rhs();\n            default:\n                throw new Error(\"Unknown operator \" + ast.operator);\n        }\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {\n        var /** @type {?} */ result;\n        var /** @type {?} */ receiver = ast.receiver.visitExpression(this, ctx);\n        result = receiver[ast.name];\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {\n        var /** @type {?} */ receiver = ast.receiver.visitExpression(this, ctx);\n        var /** @type {?} */ prop = ast.index.visitExpression(this, ctx);\n        return receiver[prop];\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n        return this.visitAllExpressions(ast.entries, ctx);\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {\n        var _this = this;\n        var /** @type {?} */ result = {};\n        ast.entries.forEach(function (entry) { return ((result))[entry.key] = entry.value.visitExpression(_this, ctx); });\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} context\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitCommaExpr = function (ast, context) {\n        var /** @type {?} */ values = this.visitAllExpressions(ast.parts, context);\n        return values[values.length - 1];\n    };\n    /**\n     * @param {?} expressions\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {\n        var _this = this;\n        return expressions.map(function (expr) { return expr.visitExpression(_this, ctx); });\n    };\n    /**\n     * @param {?} statements\n     * @param {?} ctx\n     * @return {?}\n     */\n    StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {\n        for (var /** @type {?} */ i = 0; i < statements.length; i++) {\n            var /** @type {?} */ stmt = statements[i];\n            var /** @type {?} */ val = stmt.visitStatement(this, ctx);\n            if (val instanceof ReturnValue) {\n                return val;\n            }\n        }\n        return null;\n    };\n    return StatementInterpreter;\n}());\n/**\n * @param {?} varNames\n * @param {?} statements\n * @param {?} ctx\n * @param {?} visitor\n * @return {?}\n */\nfunction _declareFn(varNames, statements, ctx, visitor) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return _executeFunctionStatements(varNames, args, statements, ctx, visitor);\n    };\n}\nvar CATCH_ERROR_VAR$2 = 'error';\nvar CATCH_STACK_VAR$2 = 'stack';\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @abstract\n */\nvar AbstractJsEmitterVisitor = (function (_super) {\n    __extends(AbstractJsEmitterVisitor, _super);\n    function AbstractJsEmitterVisitor() {\n        return _super.call(this, false) || this;\n    }\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n        var _this = this;\n        ctx.pushClass(stmt);\n        this._visitClassConstructor(stmt, ctx);\n        if (stmt.parent != null) {\n            ctx.print(stmt, stmt.name + \".prototype = Object.create(\");\n            stmt.parent.visitExpression(this, ctx);\n            ctx.println(stmt, \".prototype);\");\n        }\n        stmt.getters.forEach(function (getter) { return _this._visitClassGetter(stmt, getter, ctx); });\n        stmt.methods.forEach(function (method) { return _this._visitClassMethod(stmt, method, ctx); });\n        ctx.popClass();\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        if (stmt.constructorMethod != null) {\n            this._visitParams(stmt.constructorMethod.params, ctx);\n        }\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        if (stmt.constructorMethod != null) {\n            if (stmt.constructorMethod.body.length > 0) {\n                ctx.println(stmt, \"var self = this;\");\n                this.visitAllStatements(stmt.constructorMethod.body, ctx);\n            }\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} getter\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitClassGetter = function (stmt, getter, ctx) {\n        ctx.println(stmt, \"Object.defineProperty(\" + stmt.name + \".prototype, '\" + getter.name + \"', { get: function() {\");\n        ctx.incIndent();\n        if (getter.body.length > 0) {\n            ctx.println(stmt, \"var self = this;\");\n            this.visitAllStatements(getter.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"}});\");\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} method\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitClassMethod = function (stmt, method, ctx) {\n        ctx.print(stmt, stmt.name + \".prototype.\" + method.name + \" = function(\");\n        this._visitParams(method.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        if (method.body.length > 0) {\n            ctx.println(stmt, \"var self = this;\");\n            this.visitAllStatements(method.body, ctx);\n        }\n        ctx.decIndent();\n        ctx.println(stmt, \"};\");\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n        if (ast.builtin === BuiltinVar.This) {\n            ctx.print(ast, 'self');\n        }\n        else if (ast.builtin === BuiltinVar.Super) {\n            throw new Error(\"'super' needs to be handled at a parent ast node, not at the variable level!\");\n        }\n        else {\n            _super.prototype.visitReadVarExpr.call(this, ast, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"var \" + stmt.name + \" = \");\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, \";\");\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n        ast.value.visitExpression(this, ctx);\n        return null;\n    };\n    /**\n     * @param {?} expr\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n        var /** @type {?} */ fnExpr = expr.fn;\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n            ctx.currentClass.parent.visitExpression(this, ctx);\n            ctx.print(expr, \".call(this\");\n            if (expr.args.length > 0) {\n                ctx.print(expr, \", \");\n                this.visitAllExpressions(expr.args, ctx, ',');\n            }\n            ctx.print(expr, \")\");\n        }\n        else {\n            _super.prototype.visitInvokeFunctionExpr.call(this, expr, ctx);\n        }\n        return null;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n        ctx.print(ast, \"function(\");\n        this._visitParams(ast.params, ctx);\n        ctx.println(ast, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n        ctx.print(stmt, \"function \" + stmt.name + \"(\");\n        this._visitParams(stmt.params, ctx);\n        ctx.println(stmt, \") {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} stmt\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n        ctx.println(stmt, \"try {\");\n        ctx.incIndent();\n        this.visitAllStatements(stmt.bodyStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"} catch (\" + CATCH_ERROR_VAR$1.name + \") {\");\n        ctx.incIndent();\n        var /** @type {?} */ catchStmts = [/** @type {?} */ (CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [\n                StmtModifier.Final\n            ]))].concat(stmt.catchStmts);\n        this.visitAllStatements(catchStmts, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, \"}\");\n        return null;\n    };\n    /**\n     * @param {?} params\n     * @param {?} ctx\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n        this.visitAllObjects(function (param) { return ctx.print(null, param.name); }, params, ctx, ',');\n    };\n    /**\n     * @param {?} method\n     * @return {?}\n     */\n    AbstractJsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n        var /** @type {?} */ name;\n        switch (method) {\n            case BuiltinMethod.ConcatArray:\n                name = 'concat';\n                break;\n            case BuiltinMethod.SubscribeObservable:\n                name = 'subscribe';\n                break;\n            case BuiltinMethod.Bind:\n                name = 'bind';\n                break;\n            default:\n                throw new Error(\"Unknown builtin method: \" + method);\n        }\n        return name;\n    };\n    return AbstractJsEmitterVisitor;\n}(AbstractEmitterVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @param {?} sourceUrl\n * @param {?} ctx\n * @param {?} vars\n * @return {?}\n */\nfunction evalExpression(sourceUrl$$1, ctx, vars) {\n    var /** @type {?} */ fnBody = ctx.toSource() + \"\\n//# sourceURL=\" + sourceUrl$$1;\n    var /** @type {?} */ fnArgNames = [];\n    var /** @type {?} */ fnArgValues = [];\n    for (var /** @type {?} */ argName in vars) {\n        fnArgNames.push(argName);\n        fnArgValues.push(vars[argName]);\n    }\n    if (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"p\" /* isDevMode */])()) {\n        // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n        // E.g. ```\n        // function anonymous(a,b,c\n        // /**/) { ... }```\n        // We don't want to hard code this fact, so we auto detect it via an empty function first.\n        var /** @type {?} */ emptyFn = new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat('return null;'))))().toString();\n        var /** @type {?} */ headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n        fnBody += \"\\n\" + ctx.toSourceMapGenerator(sourceUrl$$1, sourceUrl$$1, headerLines).toJsComment();\n    }\n    return new (Function.bind.apply(Function, [void 0].concat(fnArgNames.concat(fnBody))))().apply(void 0, fnArgValues);\n}\n/**\n * @param {?} sourceUrl\n * @param {?} statements\n * @param {?} resultVars\n * @return {?}\n */\nfunction jitStatements(sourceUrl$$1, statements, resultVars) {\n    var /** @type {?} */ converter = new JitEmitterVisitor();\n    var /** @type {?} */ ctx = EmitterVisitorContext.createRoot(resultVars);\n    var /** @type {?} */ returnStmt = new ReturnStatement(literalArr(resultVars.map(function (resultVar) { return variable(resultVar); })));\n    converter.visitAllStatements(statements.concat([returnStmt]), ctx);\n    return evalExpression(sourceUrl$$1, ctx, converter.getArgs());\n}\nvar JitEmitterVisitor = (function (_super) {\n    __extends(JitEmitterVisitor, _super);\n    function JitEmitterVisitor() {\n        var _this = _super.apply(this, arguments) || this;\n        _this._evalArgNames = [];\n        _this._evalArgValues = [];\n        return _this;\n    }\n    /**\n     * @return {?}\n     */\n    JitEmitterVisitor.prototype.getArgs = function () {\n        var /** @type {?} */ result = {};\n        for (var /** @type {?} */ i = 0; i < this._evalArgNames.length; i++) {\n            result[this._evalArgNames[i]] = this._evalArgValues[i];\n        }\n        return result;\n    };\n    /**\n     * @param {?} ast\n     * @param {?} ctx\n     * @return {?}\n     */\n    JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n        var /** @type {?} */ value = ast.value.reference;\n        var /** @type {?} */ id = this._evalArgValues.indexOf(value);\n        if (id === -1) {\n            id = this._evalArgValues.length;\n            this._evalArgValues.push(value);\n            var /** @type {?} */ name = identifierName(ast.value) || 'val';\n            this._evalArgNames.push(\"jit_\" + name + id);\n        }\n        ctx.print(ast, this._evalArgNames[id]);\n        return null;\n    };\n    return JitEmitterVisitor;\n}(AbstractJsEmitterVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An internal module of the Angular compiler that begins with component types,\n * extracts templates, and eventually produces a compiled version of the component\n * ready for linking into an application.\n *\n * \\@security When compiling templates at runtime, you must ensure that the entire template comes\n * from a trusted source. Attacker-controlled data introduced by a template could expose your\n * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).\n */\nvar JitCompiler = (function () {\n    /**\n     * @param {?} _injector\n     * @param {?} _metadataResolver\n     * @param {?} _templateParser\n     * @param {?} _styleCompiler\n     * @param {?} _viewCompiler\n     * @param {?} _ngModuleCompiler\n     * @param {?} _compilerConfig\n     * @param {?} _console\n     */\n    function JitCompiler(_injector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _compilerConfig, _console) {\n        this._injector = _injector;\n        this._metadataResolver = _metadataResolver;\n        this._templateParser = _templateParser;\n        this._styleCompiler = _styleCompiler;\n        this._viewCompiler = _viewCompiler;\n        this._ngModuleCompiler = _ngModuleCompiler;\n        this._compilerConfig = _compilerConfig;\n        this._console = _console;\n        this._compiledTemplateCache = new Map();\n        this._compiledHostTemplateCache = new Map();\n        this._compiledDirectiveWrapperCache = new Map();\n        this._compiledNgModuleCache = new Map();\n        this._sharedStylesheetCount = 0;\n    }\n    Object.defineProperty(JitCompiler.prototype, \"injector\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._injector; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleSync = function (moduleType) {\n        return this._compileModuleAndComponents(moduleType, true).syncResult;\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleAsync = function (moduleType) {\n        return this._compileModuleAndComponents(moduleType, false).asyncResult;\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n        return this._compileModuleAndAllComponents(moduleType, true).syncResult;\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n        return this._compileModuleAndAllComponents(moduleType, false).asyncResult;\n    };\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    JitCompiler.prototype.getNgContentSelectors = function (component) {\n        this._console.warn('Compiler.getNgContentSelectors is deprecated. Use ComponentFactory.ngContentSelectors instead!');\n        var /** @type {?} */ template = this._compiledTemplateCache.get(component);\n        if (!template) {\n            throw new Error(\"The component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(component) + \" is not yet compiled!\");\n        }\n        return template.compMeta.template.ngContentSelectors;\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @return {?}\n     */\n    JitCompiler.prototype._compileModuleAndComponents = function (moduleType, isSync) {\n        var _this = this;\n        var /** @type {?} */ loadingPromise = this._loadModules(moduleType, isSync);\n        var /** @type {?} */ createResult = function () {\n            _this._compileComponents(moduleType, null);\n            return _this._compileModule(moduleType);\n        };\n        if (isSync) {\n            return new SyncAsyncResult(createResult());\n        }\n        else {\n            return new SyncAsyncResult(null, loadingPromise.then(createResult));\n        }\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @param {?} isSync\n     * @return {?}\n     */\n    JitCompiler.prototype._compileModuleAndAllComponents = function (moduleType, isSync) {\n        var _this = this;\n        var /** @type {?} */ loadingPromise = this._loadModules(moduleType, isSync);\n        var /** @type {?} */ createResult = function () {\n            var /** @type {?} */ componentFactories = [];\n            _this._compileComponents(moduleType, componentFactories);\n            return new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_61\" /* ModuleWithComponentFactories */](_this._compileModule(moduleType), componentFactories);\n        };\n        if (isSync) {\n            return new SyncAsyncResult(createResult());\n        }\n        else {\n            return new SyncAsyncResult(null, loadingPromise.then(createResult));\n        }\n    };\n    /**\n     * @param {?} mainModule\n     * @param {?} isSync\n     * @return {?}\n     */\n    JitCompiler.prototype._loadModules = function (mainModule, isSync) {\n        var _this = this;\n        var /** @type {?} */ loadingPromises = [];\n        var /** @type {?} */ ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);\n        // Note: the loadingPromise for a module only includes the loading of the exported directives\n        // of imported modules.\n        // However, for runtime compilation, we want to transitively compile all modules,\n        // so we also need to call loadNgModuleDirectiveAndPipeMetadata for all nested modules.\n        ngModule.transitiveModule.modules.forEach(function (localModuleMeta) {\n            loadingPromises.push(_this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(localModuleMeta.reference, isSync));\n        });\n        return Promise.all(loadingPromises);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    JitCompiler.prototype._compileModule = function (moduleType) {\n        var _this = this;\n        var /** @type {?} */ ngModuleFactory = this._compiledNgModuleCache.get(moduleType);\n        if (!ngModuleFactory) {\n            var /** @type {?} */ moduleMeta_1 = this._metadataResolver.getNgModuleMetadata(moduleType);\n            // Always provide a bound Compiler\n            var /** @type {?} */ extraProviders = [this._metadataResolver.getProviderMetadata(new ProviderMeta(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_62\" /* Compiler */], { useFactory: function () { return new ModuleBoundCompiler(_this, moduleMeta_1.type.reference); } }))];\n            var /** @type {?} */ compileResult = this._ngModuleCompiler.compile(moduleMeta_1, extraProviders);\n            if (!this._compilerConfig.useJit) {\n                ngModuleFactory =\n                    interpretStatements(compileResult.statements, [compileResult.ngModuleFactoryVar])[0];\n            }\n            else {\n                ngModuleFactory = jitStatements(ngModuleJitUrl(moduleMeta_1), compileResult.statements, [compileResult.ngModuleFactoryVar])[0];\n            }\n            this._compiledNgModuleCache.set(moduleMeta_1.type.reference, ngModuleFactory);\n        }\n        return ngModuleFactory;\n    };\n    /**\n     * \\@internal\n     * @param {?} mainModule\n     * @param {?} allComponentFactories\n     * @return {?}\n     */\n    JitCompiler.prototype._compileComponents = function (mainModule, allComponentFactories) {\n        var _this = this;\n        var /** @type {?} */ ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);\n        var /** @type {?} */ moduleByDirective = new Map();\n        var /** @type {?} */ templates = new Set();\n        ngModule.transitiveModule.modules.forEach(function (localModuleSummary) {\n            var /** @type {?} */ localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localModuleSummary.reference);\n            localModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n                moduleByDirective.set(dirIdentifier.reference, localModuleMeta);\n                var /** @type {?} */ dirMeta = _this._metadataResolver.getDirectiveMetadata(dirIdentifier.reference);\n                if (dirMeta.isComponent) {\n                    templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));\n                    if (allComponentFactories) {\n                        var /** @type {?} */ template = _this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\n                        templates.add(template);\n                        allComponentFactories.push(/** @type {?} */ (dirMeta.componentFactory));\n                    }\n                }\n            });\n        });\n        ngModule.transitiveModule.modules.forEach(function (localModuleSummary) {\n            var /** @type {?} */ localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localModuleSummary.reference);\n            localModuleMeta.declaredDirectives.forEach(function (dirIdentifier) {\n                var /** @type {?} */ dirMeta = _this._metadataResolver.getDirectiveMetadata(dirIdentifier.reference);\n                if (dirMeta.isComponent) {\n                    dirMeta.entryComponents.forEach(function (entryComponentType) {\n                        var /** @type {?} */ moduleMeta = moduleByDirective.get(entryComponentType.componentType);\n                        templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n                    });\n                }\n            });\n            localModuleMeta.entryComponents.forEach(function (entryComponentType) {\n                var /** @type {?} */ moduleMeta = moduleByDirective.get(entryComponentType.componentType);\n                templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n            });\n        });\n        templates.forEach(function (template) { return _this._compileTemplate(template); });\n    };\n    /**\n     * @param {?} type\n     * @return {?}\n     */\n    JitCompiler.prototype.clearCacheFor = function (type) {\n        this._compiledNgModuleCache.delete(type);\n        this._metadataResolver.clearCacheFor(type);\n        this._compiledHostTemplateCache.delete(type);\n        var /** @type {?} */ compiledTemplate = this._compiledTemplateCache.get(type);\n        if (compiledTemplate) {\n            this._compiledTemplateCache.delete(type);\n        }\n    };\n    /**\n     * @return {?}\n     */\n    JitCompiler.prototype.clearCache = function () {\n        this._metadataResolver.clearCache();\n        this._compiledTemplateCache.clear();\n        this._compiledHostTemplateCache.clear();\n        this._compiledNgModuleCache.clear();\n    };\n    /**\n     * @param {?} compType\n     * @param {?} ngModule\n     * @return {?}\n     */\n    JitCompiler.prototype._createCompiledHostTemplate = function (compType, ngModule) {\n        if (!ngModule) {\n            throw new Error(\"Component \" + __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"G\" /* ɵstringify */])(compType) + \" is not part of any NgModule or the module has not been imported into your module.\");\n        }\n        var /** @type {?} */ compiledTemplate = this._compiledHostTemplateCache.get(compType);\n        if (!compiledTemplate) {\n            var /** @type {?} */ compMeta = this._metadataResolver.getDirectiveMetadata(compType);\n            assertComponent(compMeta);\n            var /** @type {?} */ componentFactory = (compMeta.componentFactory);\n            var /** @type {?} */ hostClass = this._metadataResolver.getHostComponentType(compType);\n            var /** @type {?} */ hostMeta = createHostComponentMeta(hostClass, compMeta, /** @type {?} */ (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_63\" /* ɵgetComponentViewDefinitionFactory */])(componentFactory)));\n            compiledTemplate =\n                new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);\n            this._compiledHostTemplateCache.set(compType, compiledTemplate);\n        }\n        return compiledTemplate;\n    };\n    /**\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @return {?}\n     */\n    JitCompiler.prototype._createCompiledTemplate = function (compMeta, ngModule) {\n        var /** @type {?} */ compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\n        if (!compiledTemplate) {\n            assertComponent(compMeta);\n            compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\n            this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\n        }\n        return compiledTemplate;\n    };\n    /**\n     * @param {?} template\n     * @return {?}\n     */\n    JitCompiler.prototype._compileTemplate = function (template) {\n        var _this = this;\n        if (template.isCompiled) {\n            return;\n        }\n        var /** @type {?} */ compMeta = template.compMeta;\n        var /** @type {?} */ externalStylesheetsByModuleUrl = new Map();\n        var /** @type {?} */ stylesCompileResult = this._styleCompiler.compileComponent(compMeta);\n        stylesCompileResult.externalStylesheets.forEach(function (r) { externalStylesheetsByModuleUrl.set(r.meta.moduleUrl, r); });\n        this._resolveStylesCompileResult(stylesCompileResult.componentStylesheet, externalStylesheetsByModuleUrl);\n        var /** @type {?} */ directives = template.directives.map(function (dir) { return _this._metadataResolver.getDirectiveSummary(dir.reference); });\n        var /** @type {?} */ pipes = template.ngModule.transitiveModule.pipes.map(function (pipe) { return _this._metadataResolver.getPipeSummary(pipe.reference); });\n        var _a = this._templateParser.parse(compMeta, compMeta.template.template, directives, pipes, template.ngModule.schemas, templateSourceUrl(template.ngModule.type, template.compMeta, template.compMeta.template)), parsedTemplate = _a.template, usedPipes = _a.pipes;\n        var /** @type {?} */ compileResult = this._viewCompiler.compileComponent(compMeta, parsedTemplate, variable(stylesCompileResult.componentStylesheet.stylesVar), usedPipes);\n        var /** @type {?} */ statements = stylesCompileResult.componentStylesheet.statements.concat(compileResult.statements);\n        var /** @type {?} */ viewClassAndRendererTypeVars = compMeta.isHost ?\n            [compileResult.viewClassVar] :\n            [compileResult.viewClassVar, compileResult.rendererTypeVar];\n        var /** @type {?} */ viewClass;\n        var /** @type {?} */ rendererType;\n        if (!this._compilerConfig.useJit) {\n            _b = interpretStatements(statements, viewClassAndRendererTypeVars), viewClass = _b[0], rendererType = _b[1];\n        }\n        else {\n            _c = jitStatements(templateJitUrl(template.ngModule.type, template.compMeta), statements, viewClassAndRendererTypeVars), viewClass = _c[0], rendererType = _c[1];\n        }\n        template.compiled(viewClass, rendererType);\n        var _b, _c;\n    };\n    /**\n     * @param {?} result\n     * @param {?} externalStylesheetsByModuleUrl\n     * @return {?}\n     */\n    JitCompiler.prototype._resolveStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n        var _this = this;\n        result.dependencies.forEach(function (dep, i) {\n            var /** @type {?} */ nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);\n            var /** @type {?} */ nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);\n            dep.valuePlaceholder.reference = nestedStylesArr;\n        });\n    };\n    /**\n     * @param {?} result\n     * @param {?} externalStylesheetsByModuleUrl\n     * @return {?}\n     */\n    JitCompiler.prototype._resolveAndEvalStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n        this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\n        if (!this._compilerConfig.useJit) {\n            return interpretStatements(result.statements, [result.stylesVar])[0];\n        }\n        else {\n            return jitStatements(sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.statements, [result.stylesVar])[0];\n        }\n    };\n    return JitCompiler;\n}());\nJitCompiler.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nJitCompiler.ctorParameters = function () { return [\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_10\" /* Injector */], },\n    { type: CompileMetadataResolver, },\n    { type: TemplateParser, },\n    { type: StyleCompiler, },\n    { type: ViewCompiler, },\n    { type: NgModuleCompiler, },\n    { type: CompilerConfig, },\n    { type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */], },\n]; };\nvar CompiledTemplate = (function () {\n    /**\n     * @param {?} isHost\n     * @param {?} compType\n     * @param {?} compMeta\n     * @param {?} ngModule\n     * @param {?} directives\n     */\n    function CompiledTemplate(isHost, compType, compMeta, ngModule, directives) {\n        this.isHost = isHost;\n        this.compType = compType;\n        this.compMeta = compMeta;\n        this.ngModule = ngModule;\n        this.directives = directives;\n        this._viewClass = null;\n        this.isCompiled = false;\n    }\n    /**\n     * @param {?} viewClass\n     * @param {?} rendererType\n     * @return {?}\n     */\n    CompiledTemplate.prototype.compiled = function (viewClass, rendererType) {\n        this._viewClass = viewClass;\n        ((this.compMeta.componentViewType)).setDelegate(viewClass);\n        for (var /** @type {?} */ prop in rendererType) {\n            ((this.compMeta.rendererType))[prop] = rendererType[prop];\n        }\n        this.isCompiled = true;\n    };\n    return CompiledTemplate;\n}());\n/**\n * @param {?} meta\n * @return {?}\n */\nfunction assertComponent(meta) {\n    if (!meta.isComponent) {\n        throw new Error(\"Could not compile '\" + identifierName(meta.type) + \"' because it is not a component.\");\n    }\n}\n/**\n * Implements `Compiler` by delegating to the JitCompiler using a known module.\n */\nvar ModuleBoundCompiler = (function () {\n    /**\n     * @param {?} _delegate\n     * @param {?} _ngModule\n     */\n    function ModuleBoundCompiler(_delegate, _ngModule) {\n        this._delegate = _delegate;\n        this._ngModule = _ngModule;\n    }\n    Object.defineProperty(ModuleBoundCompiler.prototype, \"_injector\", {\n        /**\n         * @return {?}\n         */\n        get: function () { return this._delegate.injector; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleSync = function (moduleType) {\n        return this._delegate.compileModuleSync(moduleType);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleAsync = function (moduleType) {\n        return this._delegate.compileModuleAsync(moduleType);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n        return this._delegate.compileModuleAndAllComponentsSync(moduleType);\n    };\n    /**\n     * @template T\n     * @param {?} moduleType\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n        return this._delegate.compileModuleAndAllComponentsAsync(moduleType);\n    };\n    /**\n     * @param {?} component\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.getNgContentSelectors = function (component) {\n        return this._delegate.getNgContentSelectors(component);\n    };\n    /**\n     * Clears all caches\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.clearCache = function () { this._delegate.clearCache(); };\n    /**\n     * Clears the cache for the given component/ngModule.\n     * @param {?} type\n     * @return {?}\n     */\n    ModuleBoundCompiler.prototype.clearCacheFor = function (type) { this._delegate.clearCacheFor(type); };\n    return ModuleBoundCompiler;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for message extracted from the templates.\n */\nvar MessageBundle = (function () {\n    /**\n     * @param {?} _htmlParser\n     * @param {?} _implicitTags\n     * @param {?} _implicitAttrs\n     * @param {?=} _locale\n     */\n    function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs, _locale) {\n        if (_locale === void 0) { _locale = null; }\n        this._htmlParser = _htmlParser;\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n        this._locale = _locale;\n        this._messages = [];\n    }\n    /**\n     * @param {?} html\n     * @param {?} url\n     * @param {?} interpolationConfig\n     * @return {?}\n     */\n    MessageBundle.prototype.updateFromTemplate = function (html, url, interpolationConfig) {\n        var /** @type {?} */ htmlParserResult = this._htmlParser.parse(html, url, true, interpolationConfig);\n        if (htmlParserResult.errors.length) {\n            return htmlParserResult.errors;\n        }\n        var /** @type {?} */ i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n        if (i18nParserResult.errors.length) {\n            return i18nParserResult.errors;\n        }\n        (_a = this._messages).push.apply(_a, i18nParserResult.messages);\n        var _a;\n    };\n    /**\n     * @return {?}\n     */\n    MessageBundle.prototype.getMessages = function () { return this._messages; };\n    /**\n     * @param {?} serializer\n     * @return {?}\n     */\n    MessageBundle.prototype.write = function (serializer) {\n        var /** @type {?} */ messages = {};\n        var /** @type {?} */ mapperVisitor = new MapPlaceholderNames();\n        // Deduplicate messages based on their ID\n        this._messages.forEach(function (message) {\n            var /** @type {?} */ id = serializer.digest(message);\n            if (!messages.hasOwnProperty(id)) {\n                messages[id] = message;\n            }\n        });\n        // Transform placeholder names using the serializer mapping\n        var /** @type {?} */ msgList = Object.keys(messages).map(function (id) {\n            var /** @type {?} */ mapper = serializer.createNameMapper(messages[id]);\n            var /** @type {?} */ src = messages[id];\n            var /** @type {?} */ nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n            return new Message(nodes, {}, {}, src.meaning, src.description, id);\n        });\n        return serializer.write(msgList, this._locale);\n    };\n    return MessageBundle;\n}());\nvar MapPlaceholderNames = (function (_super) {\n    __extends(MapPlaceholderNames, _super);\n    function MapPlaceholderNames() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @param {?} nodes\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.convert = function (nodes, mapper) {\n        var _this = this;\n        return mapper ? nodes.map(function (n) { return n.visit(_this, mapper); }) : nodes;\n    };\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.visitTagPlaceholder = function (ph, mapper) {\n        var _this = this;\n        var /** @type {?} */ startName = mapper.toPublicName(ph.startName);\n        var /** @type {?} */ closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n        var /** @type {?} */ children = ph.children.map(function (n) { return n.visit(_this, mapper); });\n        return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.visitPlaceholder = function (ph, mapper) {\n        return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    };\n    /**\n     * @param {?} ph\n     * @param {?} mapper\n     * @return {?}\n     */\n    MapPlaceholderNames.prototype.visitIcuPlaceholder = function (ph, mapper) {\n        return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    };\n    return MapPlaceholderNames;\n}(CloneVisitor));\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Extract i18n messages from source code\n */\nvar Extractor = (function () {\n    /**\n     * @param {?} host\n     * @param {?} staticSymbolResolver\n     * @param {?} messageBundle\n     * @param {?} metadataResolver\n     */\n    function Extractor(host, staticSymbolResolver, messageBundle, metadataResolver) {\n        this.host = host;\n        this.staticSymbolResolver = staticSymbolResolver;\n        this.messageBundle = messageBundle;\n        this.metadataResolver = metadataResolver;\n    }\n    /**\n     * @param {?} rootFiles\n     * @return {?}\n     */\n    Extractor.prototype.extract = function (rootFiles) {\n        var _this = this;\n        var /** @type {?} */ programSymbols = extractProgramSymbols(this.staticSymbolResolver, rootFiles, this.host);\n        var _a = analyzeAndValidateNgModules(programSymbols, this.host, this.metadataResolver), files = _a.files, ngModules = _a.ngModules;\n        return Promise\n            .all(ngModules.map(function (ngModule) { return _this.metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false); }))\n            .then(function () {\n            var /** @type {?} */ errors = [];\n            files.forEach(function (file) {\n                var /** @type {?} */ compMetas = [];\n                file.directives.forEach(function (directiveType) {\n                    var /** @type {?} */ dirMeta = _this.metadataResolver.getDirectiveMetadata(directiveType);\n                    if (dirMeta && dirMeta.isComponent) {\n                        compMetas.push(dirMeta);\n                    }\n                });\n                compMetas.forEach(function (compMeta) {\n                    var /** @type {?} */ html = compMeta.template.template;\n                    var /** @type {?} */ interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);\n                    errors.push.apply(errors, _this.messageBundle.updateFromTemplate(html, file.srcUrl, interpolationConfig));\n                });\n            });\n            if (errors.length) {\n                throw new Error(errors.map(function (e) { return e.toString(); }).join('\\n'));\n            }\n            return _this.messageBundle;\n        });\n    };\n    /**\n     * @param {?} host\n     * @param {?} locale\n     * @return {?}\n     */\n    Extractor.create = function (host, locale) {\n        var /** @type {?} */ htmlParser = new I18NHtmlParser(new HtmlParser());\n        var /** @type {?} */ urlResolver = createOfflineCompileUrlResolver();\n        var /** @type {?} */ symbolCache = new StaticSymbolCache();\n        var /** @type {?} */ summaryResolver = new AotSummaryResolver(host, symbolCache);\n        var /** @type {?} */ staticSymbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver);\n        var /** @type {?} */ staticReflector = new StaticReflector(summaryResolver, staticSymbolResolver);\n        StaticAndDynamicReflectionCapabilities.install(staticReflector);\n        var /** @type {?} */ config = new CompilerConfig({ defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].Emulated, useJit: false });\n        var /** @type {?} */ normalizer = new DirectiveNormalizer({ get: function (url) { return host.loadResource(url); } }, urlResolver, htmlParser, config);\n        var /** @type {?} */ elementSchemaRegistry = new DomElementSchemaRegistry();\n        var /** @type {?} */ resolver = new CompileMetadataResolver(config, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */](), symbolCache, staticReflector);\n        // TODO(vicb): implicit tags & attributes\n        var /** @type {?} */ messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n        var /** @type {?} */ extractor = new Extractor(host, staticSymbolResolver, messageBundle, resolver);\n        return { extractor: extractor, staticReflector: staticReflector };\n    };\n    return Extractor;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _NO_RESOURCE_LOADER = {\n    /**\n     * @param {?} url\n     * @return {?}\n     */\n    get: function (url) {\n        throw new Error(\"No ResourceLoader implementation has been provided. Can't read the url \\\"\" + url + \"\\\"\");\n    }\n};\nvar baseHtmlParser = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"d\" /* InjectionToken */]('HtmlParser');\n/**\n * A set of providers that provide `JitCompiler` and its dependencies to use for\n * template compilation.\n */\nvar COMPILER_PROVIDERS = [\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_64\" /* ɵReflector */], useValue: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */] },\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_39\" /* ɵReflectorReader */], useExisting: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_64\" /* ɵReflector */] },\n    { provide: ResourceLoader, useValue: _NO_RESOURCE_LOADER },\n    SummaryResolver,\n    __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */],\n    Lexer,\n    Parser,\n    {\n        provide: baseHtmlParser,\n        useClass: HtmlParser,\n    },\n    {\n        provide: I18NHtmlParser,\n        useFactory: function (parser, translations, format, config, console) { return new I18NHtmlParser(parser, translations, format, config.missingTranslation, console); },\n        deps: [\n            baseHtmlParser,\n            [new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */](), new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */](__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_65\" /* TRANSLATIONS */])],\n            [new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"l\" /* Optional */](), new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */](__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_11\" /* TRANSLATIONS_FORMAT */])],\n            [CompilerConfig],\n            [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_32\" /* ɵConsole */]],\n        ]\n    },\n    {\n        provide: HtmlParser,\n        useExisting: I18NHtmlParser,\n    },\n    TemplateParser,\n    DirectiveNormalizer,\n    CompileMetadataResolver,\n    DEFAULT_PACKAGE_URL_PROVIDER,\n    StyleCompiler,\n    ViewCompiler,\n    NgModuleCompiler,\n    { provide: CompilerConfig, useValue: new CompilerConfig() },\n    JitCompiler,\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_62\" /* Compiler */], useExisting: JitCompiler },\n    DomElementSchemaRegistry,\n    { provide: ElementSchemaRegistry, useExisting: DomElementSchemaRegistry },\n    UrlResolver,\n    DirectiveResolver,\n    PipeResolver,\n    NgModuleResolver,\n];\nvar JitCompilerFactory = (function () {\n    /**\n     * @param {?} defaultOptions\n     */\n    function JitCompilerFactory(defaultOptions) {\n        var compilerOptions = {\n            useDebug: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"p\" /* isDevMode */])(),\n            useJit: true,\n            defaultEncapsulation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"n\" /* ViewEncapsulation */].Emulated,\n            missingTranslation: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_1\" /* MissingTranslationStrategy */].Warning,\n            enableLegacyTemplate: true,\n        };\n        this._defaultOptions = [compilerOptions].concat(defaultOptions);\n    }\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    JitCompilerFactory.prototype.createCompiler = function (options) {\n        if (options === void 0) { options = []; }\n        var /** @type {?} */ opts = _mergeOptions(this._defaultOptions.concat(options));\n        var /** @type {?} */ injector = __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_66\" /* ReflectiveInjector */].resolveAndCreate([\n            COMPILER_PROVIDERS, {\n                provide: CompilerConfig,\n                useFactory: function () {\n                    return new CompilerConfig({\n                        // let explicit values from the compiler options overwrite options\n                        // from the app providers\n                        useJit: opts.useJit,\n                        // let explicit values from the compiler options overwrite options\n                        // from the app providers\n                        defaultEncapsulation: opts.defaultEncapsulation,\n                        missingTranslation: opts.missingTranslation,\n                        enableLegacyTemplate: opts.enableLegacyTemplate,\n                    });\n                },\n                deps: []\n            },\n            opts.providers\n        ]);\n        return injector.get(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_62\" /* Compiler */]);\n    };\n    return JitCompilerFactory;\n}());\nJitCompilerFactory.decorators = [\n    { type: CompilerInjectable },\n];\n/**\n * @nocollapse\n */\nJitCompilerFactory.ctorParameters = function () { return [\n    { type: Array, decorators: [{ type: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"f\" /* Inject */], args: [__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Y\" /* COMPILER_OPTIONS */],] },] },\n]; };\n/**\n * @return {?}\n */\nfunction _initReflector() {\n    __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Z\" /* ɵreflector */].reflectionCapabilities = new __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_48\" /* ɵReflectionCapabilities */]();\n}\n/**\n * A platform that included corePlatform and the compiler.\n *\n * \\@experimental\n */\nvar platformCoreDynamic = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"u\" /* createPlatformFactory */])(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"v\" /* platformCore */], 'coreDynamic', [\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"Y\" /* COMPILER_OPTIONS */], useValue: {}, multi: true },\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"_67\" /* CompilerFactory */], useClass: JitCompilerFactory },\n    { provide: __WEBPACK_IMPORTED_MODULE_0__angular_core__[\"s\" /* PLATFORM_INITIALIZER */], useValue: _initReflector, multi: true },\n]);\n/**\n * @param {?} optionsArr\n * @return {?}\n */\nfunction _mergeOptions(optionsArr) {\n    return {\n        useJit: _lastDefined(optionsArr.map(function (options) { return options.useJit; })),\n        defaultEncapsulation: _lastDefined(optionsArr.map(function (options) { return options.defaultEncapsulation; })),\n        providers: _mergeArrays(optionsArr.map(function (options) { return options.providers; })),\n        missingTranslation: _lastDefined(optionsArr.map(function (options) { return options.missingTranslation; })),\n    };\n}\n/**\n * @template T\n * @param {?} args\n * @return {?}\n */\nfunction _lastDefined(args) {\n    for (var /** @type {?} */ i = args.length - 1; i >= 0; i--) {\n        if (args[i] !== undefined) {\n            return args[i];\n        }\n    }\n    return undefined;\n}\n/**\n * @param {?} parts\n * @return {?}\n */\nfunction _mergeArrays(parts) {\n    var /** @type {?} */ result = [];\n    parts.forEach(function (part) { return part && result.push.apply(result, part); });\n    return result;\n}\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Interface that defines how import statements should be generated.\n * @abstract\n */\nvar ImportResolver = (function () {\n    function ImportResolver() {\n    }\n    /**\n     * Converts a file path to a module name that can be used as an `import.\n     * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.\n     * @abstract\n     * @param {?} importedFilePath\n     * @param {?} containingFilePath\n     * @return {?}\n     */\n    ImportResolver.prototype.fileNameToModuleName = function (importedFilePath, containingFilePath) { };\n    /**\n     * Converts the given StaticSymbol into another StaticSymbol that should be used\n     * to generate the import from.\n     * @abstract\n     * @param {?} symbol\n     * @return {?}\n     */\n    ImportResolver.prototype.getImportAs = function (symbol) { };\n    /**\n     * Determine the arity of a type.\n     * @abstract\n     * @param {?} symbol\n     * @return {?}\n     */\n    ImportResolver.prototype.getTypeArity = function (symbol) { };\n    return ImportResolver;\n}());\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all APIs of the compiler package.\n *\n * <div class=\"callout is-critical\">\n *   <header>Unstable APIs</header>\n *   <p>\n *     All compiler apis are currently considered experimental and private!\n *   </p>\n *   <p>\n *     We expect the APIs in this package to keep on changing. Do not rely on them.\n *   </p>\n * </div>\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @module\n * @description\n * Entry point for all public APIs of the compiler package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n//# sourceMappingURL=compiler.js.map\n//# sourceMappingURL=compiler.es5.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9jb21waWxlci9AYW5ndWxhci9jb21waWxlci5lczUuanM/ZDBjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2NC4wLjJcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5pbXBvcnQgeyBBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTLCBBdHRyaWJ1dGUsIENPTVBJTEVSX09QVElPTlMsIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcGlsZXIsIENvbXBpbGVyRmFjdG9yeSwgQ29tcG9uZW50LCBDb21wb25lbnRGYWN0b3J5LCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbXBvbmVudFJlZiwgQ29udGVudENoaWxkLCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdCwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0b3IsIElucHV0LCBMT0NBTEVfSUQsIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBNb2R1bGVXaXRoQ29tcG9uZW50RmFjdG9yaWVzLCBOT19FUlJPUlNfU0NIRU1BLCBOZ01vZHVsZSwgTmdNb2R1bGVGYWN0b3J5LCBOZ01vZHVsZVJlZiwgT3B0aW9uYWwsIE91dHB1dCwgUEFDS0FHRV9ST09UX1VSTCwgUExBVEZPUk1fSU5JVElBTElaRVIsIFBpcGUsIFF1ZXJ5LCBRdWVyeUxpc3QsIFJlZmxlY3RpdmVJbmplY3RvciwgUmVuZGVyZXIsIFNlY3VyaXR5Q29udGV4dCwgU2VsZiwgU2tpcFNlbGYsIFRSQU5TTEFUSU9OUywgVFJBTlNMQVRJT05TX0ZPUk1BVCwgVGVtcGxhdGVSZWYsIFR5cGUsIFZlcnNpb24sIFZpZXdDaGlsZCwgVmlld0NoaWxkcmVuLCBWaWV3Q29udGFpbmVyUmVmLCBWaWV3RW5jYXBzdWxhdGlvbiwgYW5pbWF0ZSwgY3JlYXRlUGxhdGZvcm1GYWN0b3J5LCBncm91cCwgaXNEZXZNb2RlLCBrZXlmcmFtZXMsIHBsYXRmb3JtQ29yZSwgcmVzb2x2ZUZvcndhcmRSZWYsIHNlcXVlbmNlLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIsIMm1Q29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgybVDb25zb2xlLCDJtUVNUFRZX0FSUkFZLCDJtUVNUFRZX01BUCwgybVFUlJPUl9DT01QT05FTlRfVFlQRSwgybVMSUZFQ1lDTEVfSE9PS1NfVkFMVUVTLCDJtUxpZmVjeWNsZUhvb2tzLCDJtU5nTW9kdWxlSW5qZWN0b3IsIMm1UmVmbGVjdGlvbkNhcGFiaWxpdGllcywgybVSZWZsZWN0b3IsIMm1UmVmbGVjdG9yUmVhZGVyLCDJtWFuZCwgybVjY2YsIMm1Y3J0LCDJtWRpZCwgybVlbGQsIMm1ZWxlbWVudEV2ZW50RnVsbE5hbWUsIMm1Z2V0Q29tcG9uZW50Vmlld0RlZmluaXRpb25GYWN0b3J5LCDJtWlubGluZUludGVycG9sYXRlLCDJtWludGVycG9sYXRlLCDJtW5jZCwgybVub3YsIMm1cGFkLCDJtXBpZCwgybVwb2QsIMm1cHBkLCDJtXByZCwgybVxdWQsIMm1cmVmbGVjdG9yLCDJtXJlZ2lzdGVyTW9kdWxlRmFjdG9yeSwgybVzdHJpbmdpZnksIMm1dGVkLCDJtXVudiwgybV2aWQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoZSBjb21tb24gcGFja2FnZS5cbiAqL1xuLyoqXG4gKiBcXEBzdGFibGVcbiAqL1xudmFyIFZFUlNJT04gPSBuZXcgVmVyc2lvbignNC4wLjInKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBzZWdtZW50IG9mIHRleHQgd2l0aGluIHRoZSB0ZW1wbGF0ZS5cbiAqL1xudmFyIFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5nQ29udGVudEluZGV4XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGV4dEFzdCh2YWx1ZSwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGV4dEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRleHRBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIGJvdW5kIGV4cHJlc3Npb24gd2l0aGluIHRoZSB0ZXh0IG9mIGEgdGVtcGxhdGUuXG4gKi9cbnZhciBCb3VuZFRleHRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5nQ29udGVudEluZGV4XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm91bmRUZXh0QXN0KHZhbHVlLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCb3VuZFRleHRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZFRleHQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQm91bmRUZXh0QXN0O1xufSgpKTtcbi8qKlxuICogQSBwbGFpbiBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudC5cbiAqL1xudmFyIEF0dHJBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBdHRyQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBdHRyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0QXR0cih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gQXR0ckFzdDtcbn0oKSk7XG4vKipcbiAqIEEgYmluZGluZyBmb3IgYW4gZWxlbWVudCBwcm9wZXJ0eSAoZS5nLiBgW3Byb3BlcnR5XT1cImV4cHJlc3Npb25cImApIG9yIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIChlLmcuXG4gKiBgW1xcQHRyaWdnZXJdPVwic3RhdGVFeHBcImApXG4gKi9cbnZhciBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBzZWN1cml0eUNvbnRleHRcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSB1bml0XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQm91bmRFbGVtZW50UHJvcGVydHlBc3QobmFtZSwgdHlwZSwgc2VjdXJpdHlDb250ZXh0LCB2YWx1ZSwgdW5pdCwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNlY3VyaXR5Q29udGV4dCA9IHNlY3VyaXR5Q29udGV4dDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVuaXQgPSB1bml0O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJvdW5kRWxlbWVudFByb3BlcnR5QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudFByb3BlcnR5KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kRWxlbWVudFByb3BlcnR5QXN0LnByb3RvdHlwZSwgXCJpc0FuaW1hdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT09IFByb3BlcnR5QmluZGluZ1R5cGUuQW5pbWF0aW9uOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQm91bmRFbGVtZW50UHJvcGVydHlBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIGJpbmRpbmcgZm9yIGFuIGVsZW1lbnQgZXZlbnQgKGUuZy4gYChldmVudCk9XCJoYW5kbGVyKClcImApIG9yIGFuIGFuaW1hdGlvbiB0cmlnZ2VyIGV2ZW50IChlLmcuXG4gKiBgKFxcQHRyaWdnZXIucGhhc2UpPVwiY2FsbGJhY2soJGV2ZW50KVwiYCkuXG4gKi9cbnZhciBCb3VuZEV2ZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFxuICAgICAqIEBwYXJhbSB7P30gcGhhc2VcbiAgICAgKiBAcGFyYW0gez99IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZEV2ZW50QXN0KG5hbWUsIHRhcmdldCwgcGhhc2UsIGhhbmRsZXIsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucGhhc2UgPSBwaGFzZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gez99IHBoYXNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCb3VuZEV2ZW50QXN0LmNhbGNGdWxsTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCB0YXJnZXQsIHBoYXNlKSB7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQgKyBcIjpcIiArIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGhhc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkBcIiArIG5hbWUgKyBcIi5cIiArIHBoYXNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQm91bmRFdmVudEFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV2ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kRXZlbnRBc3QucHJvdG90eXBlLCBcImZ1bGxOYW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJvdW5kRXZlbnRBc3QuY2FsY0Z1bGxOYW1lKHRoaXMubmFtZSwgdGhpcy50YXJnZXQsIHRoaXMucGhhc2UpOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQm91bmRFdmVudEFzdC5wcm90b3R5cGUsIFwiaXNBbmltYXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gISF0aGlzLnBoYXNlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQm91bmRFdmVudEFzdDtcbn0oKSk7XG4vKipcbiAqIEEgcmVmZXJlbmNlIGRlY2xhcmF0aW9uIG9uIGFuIGVsZW1lbnQgKGUuZy4gYGxldCBzb21lTmFtZT1cImV4cHJlc3Npb25cImApLlxuICovXG52YXIgUmVmZXJlbmNlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlQXN0KG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWZlcmVuY2VBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2UodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVmZXJlbmNlQXN0O1xufSgpKTtcbi8qKlxuICogQSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBvbiBhIDxuZy10ZW1wbGF0ZT4gKGUuZy4gYHZhci1zb21lTmFtZT1cInNvbWVMb2NhbE5hbWVcImApLlxuICovXG52YXIgVmFyaWFibGVBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWYXJpYWJsZUFzdChuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmFyaWFibGVBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWYXJpYWJsZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBWYXJpYWJsZUFzdDtcbn0oKSk7XG4vKipcbiAqIEFuIGVsZW1lbnQgZGVjbGFyYXRpb24gaW4gYSB0ZW1wbGF0ZS5cbiAqL1xudmFyIEVsZW1lbnRBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXR0cnNcbiAgICAgKiBAcGFyYW0gez99IGlucHV0c1xuICAgICAqIEBwYXJhbSB7P30gb3V0cHV0c1xuICAgICAqIEBwYXJhbSB7P30gcmVmZXJlbmNlc1xuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gICAgICogQHBhcmFtIHs/fSBoYXNWaWV3Q29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/fSBxdWVyeU1hdGNoZXNcbiAgICAgKiBAcGFyYW0gez99IGNoaWxkcmVuXG4gICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRJbmRleFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gZW5kU291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRBc3QobmFtZSwgYXR0cnMsIGlucHV0cywgb3V0cHV0cywgcmVmZXJlbmNlcywgZGlyZWN0aXZlcywgcHJvdmlkZXJzLCBoYXNWaWV3Q29udGFpbmVyLCBxdWVyeU1hdGNoZXMsIGNoaWxkcmVuLCBuZ0NvbnRlbnRJbmRleCwgc291cmNlU3BhbiwgZW5kU291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IHByb3ZpZGVycztcbiAgICAgICAgdGhpcy5oYXNWaWV3Q29udGFpbmVyID0gaGFzVmlld0NvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5xdWVyeU1hdGNoZXMgPSBxdWVyeU1hdGNoZXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5uZ0NvbnRlbnRJbmRleCA9IG5nQ29udGVudEluZGV4O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbGVtZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIGA8bmctdGVtcGxhdGU+YCBlbGVtZW50IGluY2x1ZGVkIGluIGFuIEFuZ3VsYXIgdGVtcGxhdGUuXG4gKi9cbnZhciBFbWJlZGRlZFRlbXBsYXRlQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBvdXRwdXRzXG4gICAgICogQHBhcmFtIHs/fSByZWZlcmVuY2VzXG4gICAgICogQHBhcmFtIHs/fSB2YXJpYWJsZXNcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICAgICAqIEBwYXJhbSB7P30gaGFzVmlld0NvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7P30gcXVlcnlNYXRjaGVzXG4gICAgICogQHBhcmFtIHs/fSBjaGlsZHJlblxuICAgICAqIEBwYXJhbSB7P30gbmdDb250ZW50SW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbWJlZGRlZFRlbXBsYXRlQXN0KGF0dHJzLCBvdXRwdXRzLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIGRpcmVjdGl2ZXMsIHByb3ZpZGVycywgaGFzVmlld0NvbnRhaW5lciwgcXVlcnlNYXRjaGVzLCBjaGlsZHJlbiwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgICAgIHRoaXMuaGFzVmlld0NvbnRhaW5lciA9IGhhc1ZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMucXVlcnlNYXRjaGVzID0gcXVlcnlNYXRjaGVzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMubmdDb250ZW50SW5kZXggPSBuZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWJlZGRlZFRlbXBsYXRlQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RW1iZWRkZWRUZW1wbGF0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFbWJlZGRlZFRlbXBsYXRlQXN0O1xufSgpKTtcbi8qKlxuICogQSBkaXJlY3RpdmUgcHJvcGVydHkgd2l0aCBhIGJvdW5kIHZhbHVlIChlLmcuIGAqbmdJZj1cImNvbmRpdGlvblwiKS5cbiAqL1xudmFyIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlTmFtZVxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVOYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QoZGlyZWN0aXZlTmFtZSwgdGVtcGxhdGVOYW1lLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVOYW1lO1xuICAgICAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCb3VuZERpcmVjdGl2ZVByb3BlcnR5QXN0O1xufSgpKTtcbi8qKlxuICogQSBkaXJlY3RpdmUgZGVjbGFyZWQgb24gYW4gZWxlbWVudC5cbiAqL1xudmFyIERpcmVjdGl2ZUFzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVcbiAgICAgKiBAcGFyYW0gez99IGlucHV0c1xuICAgICAqIEBwYXJhbSB7P30gaG9zdFByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0gez99IGhvc3RFdmVudHNcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRRdWVyeVN0YXJ0SWRcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVBc3QoZGlyZWN0aXZlLCBpbnB1dHMsIGhvc3RQcm9wZXJ0aWVzLCBob3N0RXZlbnRzLCBjb250ZW50UXVlcnlTdGFydElkLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgICAgICAgdGhpcy5ob3N0UHJvcGVydGllcyA9IGhvc3RQcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLmhvc3RFdmVudHMgPSBob3N0RXZlbnRzO1xuICAgICAgICB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQgPSBjb250ZW50UXVlcnlTdGFydElkO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZUFzdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERpcmVjdGl2ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBEaXJlY3RpdmVBc3Q7XG59KCkpO1xuLyoqXG4gKiBBIHByb3ZpZGVyIGRlY2xhcmVkIG9uIGFuIGVsZW1lbnRcbiAqL1xudmFyIFByb3ZpZGVyQXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHBhcmFtIHs/fSBtdWx0aVByb3ZpZGVyXG4gICAgICogQHBhcmFtIHs/fSBlYWdlclxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJzXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclR5cGVcbiAgICAgKiBAcGFyYW0gez99IGxpZmVjeWNsZUhvb2tzXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvdmlkZXJBc3QodG9rZW4sIG11bHRpUHJvdmlkZXIsIGVhZ2VyLCBwcm92aWRlcnMsIHByb3ZpZGVyVHlwZSwgbGlmZWN5Y2xlSG9va3MsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLm11bHRpUHJvdmlkZXIgPSBtdWx0aVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmVhZ2VyID0gZWFnZXI7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuICAgICAgICB0aGlzLnByb3ZpZGVyVHlwZSA9IHByb3ZpZGVyVHlwZTtcbiAgICAgICAgdGhpcy5saWZlY3ljbGVIb29rcyA9IGxpZmVjeWNsZUhvb2tzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyQXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIE5vIHZpc2l0IG1ldGhvZCBpbiB0aGUgdmlzaXRvciBmb3Igbm93Li4uXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3ZpZGVyQXN0O1xufSgpKTtcbnZhciBQcm92aWRlckFzdFR5cGUgPSB7fTtcblByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlID0gMDtcblByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSA9IDE7XG5Qcm92aWRlckFzdFR5cGUuQ29tcG9uZW50ID0gMjtcblByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUgPSAzO1xuUHJvdmlkZXJBc3RUeXBlLkJ1aWx0aW4gPSA0O1xuUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlXSA9IFwiUHVibGljU2VydmljZVwiO1xuUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZV0gPSBcIlByaXZhdGVTZXJ2aWNlXCI7XG5Qcm92aWRlckFzdFR5cGVbUHJvdmlkZXJBc3RUeXBlLkNvbXBvbmVudF0gPSBcIkNvbXBvbmVudFwiO1xuUHJvdmlkZXJBc3RUeXBlW1Byb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmVdID0gXCJEaXJlY3RpdmVcIjtcblByb3ZpZGVyQXN0VHlwZVtQcm92aWRlckFzdFR5cGUuQnVpbHRpbl0gPSBcIkJ1aWx0aW5cIjtcbi8qKlxuICogUG9zaXRpb24gd2hlcmUgY29udGVudCBpcyB0byBiZSBwcm9qZWN0ZWQgKGluc3RhbmNlIG9mIGA8bmctY29udGVudD5gIGluIGEgdGVtcGxhdGUpLlxuICovXG52YXIgTmdDb250ZW50QXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRJbmRleFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5nQ29udGVudEFzdChpbmRleCwgbmdDb250ZW50SW5kZXgsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLm5nQ29udGVudEluZGV4ID0gbmdDb250ZW50SW5kZXg7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdDb250ZW50QXN0LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TmdDb250ZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE5nQ29udGVudEFzdDtcbn0oKSk7XG52YXIgUHJvcGVydHlCaW5kaW5nVHlwZSA9IHt9O1xuUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eSA9IDA7XG5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkF0dHJpYnV0ZSA9IDE7XG5Qcm9wZXJ0eUJpbmRpbmdUeXBlLkNsYXNzID0gMjtcblByb3BlcnR5QmluZGluZ1R5cGUuU3R5bGUgPSAzO1xuUHJvcGVydHlCaW5kaW5nVHlwZS5BbmltYXRpb24gPSA0O1xuUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlLlByb3BlcnR5XSA9IFwiUHJvcGVydHlcIjtcblByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGVdID0gXCJBdHRyaWJ1dGVcIjtcblByb3BlcnR5QmluZGluZ1R5cGVbUHJvcGVydHlCaW5kaW5nVHlwZS5DbGFzc10gPSBcIkNsYXNzXCI7XG5Qcm9wZXJ0eUJpbmRpbmdUeXBlW1Byb3BlcnR5QmluZGluZ1R5cGUuU3R5bGVdID0gXCJTdHlsZVwiO1xuUHJvcGVydHlCaW5kaW5nVHlwZVtQcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbl0gPSBcIkFuaW1hdGlvblwiO1xuLyoqXG4gKiBWaXNpdCBldmVyeSBub2RlIGluIGEgbGlzdCBvZiB7XFxAbGluayBUZW1wbGF0ZUFzdH1zIHdpdGggdGhlIGdpdmVuIHtcXEBsaW5rIFRlbXBsYXRlQXN0VmlzaXRvcn0uXG4gKiBAcGFyYW0gez99IHZpc2l0b3JcbiAqIEBwYXJhbSB7P30gYXN0c1xuICogQHBhcmFtIHs/PX0gY29udGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGVWaXNpdEFsbCh2aXNpdG9yLCBhc3RzLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0ID0gdmlzaXRvci52aXNpdCA/XG4gICAgICAgIGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXQoYXN0LCBjb250ZXh0KSB8fCBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7IH0gOlxuICAgICAgICBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7IH07XG4gICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0UmVzdWx0ID0gdmlzaXQoYXN0KTtcbiAgICAgICAgaWYgKGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXN0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEEgdG9rZW4gcmVwcmVzZW50aW5nIHRoZSBhIHJlZmVyZW5jZSB0byBhIHN0YXRpYyB0eXBlLlxuICpcbiAqIFRoaXMgdG9rZW4gaXMgdW5pcXVlIGZvciBhIGZpbGVQYXRoIGFuZCBuYW1lIGFuZCBjYW4gYmUgdXNlZCBhcyBhIGhhc2ggdGFibGUga2V5LlxuICovXG52YXIgU3RhdGljU3ltYm9sID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBtZW1iZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGljU3ltYm9sKGZpbGVQYXRoLCBuYW1lLCBtZW1iZXJzKSB7XG4gICAgICAgIHRoaXMuZmlsZVBhdGggPSBmaWxlUGF0aDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2wucHJvdG90eXBlLmFzc2VydE5vTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IHN5bWJvbCB3aXRob3V0IG1lbWJlcnMgZXhwZWN0ZWQsIGJ1dCBnb3QgXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzKSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY1N5bWJvbDtcbn0oKSk7XG4vKipcbiAqIEEgY2FjaGUgb2Ygc3RhdGljIHN5bWJvbCB1c2VkIGJ5IHRoZSBTdGF0aWNSZWZsZWN0b3IgdG8gcmV0dXJuIHRoZSBzYW1lIHN5bWJvbCBmb3IgdGhlXG4gKiBzYW1lIHN5bWJvbCB2YWx1ZXMuXG4gKi9cbnZhciBTdGF0aWNTeW1ib2xDYWNoZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljU3ltYm9sQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVjbGFyYXRpb25GaWxlXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gbWVtYmVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChkZWNsYXJhdGlvbkZpbGUsIG5hbWUsIG1lbWJlcnMpIHtcbiAgICAgICAgbWVtYmVycyA9IG1lbWJlcnMgfHwgW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlclN1ZmZpeCA9IG1lbWJlcnMubGVuZ3RoID8gXCIuXCIgKyBtZW1iZXJzLmpvaW4oJy4nKSA6ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBrZXkgPSBcIlxcXCJcIiArIGRlY2xhcmF0aW9uRmlsZSArIFwiXFxcIi5cIiArIG5hbWUgKyBtZW1iZXJTdWZmaXg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgU3RhdGljU3ltYm9sKGRlY2xhcmF0aW9uRmlsZSwgbmFtZSwgbWVtYmVycyk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNTeW1ib2xDYWNoZTtcbn0oKSk7XG52YXIgVGFnQ29udGVudFR5cGUgPSB7fTtcblRhZ0NvbnRlbnRUeXBlLlJBV19URVhUID0gMDtcblRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCA9IDE7XG5UYWdDb250ZW50VHlwZS5QQVJTQUJMRV9EQVRBID0gMjtcblRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlLlJBV19URVhUXSA9IFwiUkFXX1RFWFRcIjtcblRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVF0gPSBcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiO1xuVGFnQ29udGVudFR5cGVbVGFnQ29udGVudFR5cGUuUEFSU0FCTEVfREFUQV0gPSBcIlBBUlNBQkxFX0RBVEFcIjtcbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50TmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3BsaXROc05hbWUoZWxlbWVudE5hbWUpIHtcbiAgICBpZiAoZWxlbWVudE5hbWVbMF0gIT0gJzonKSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgZWxlbWVudE5hbWVdO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xvbkluZGV4ID0gZWxlbWVudE5hbWUuaW5kZXhPZignOicsIDEpO1xuICAgIGlmIChjb2xvbkluZGV4ID09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGZvcm1hdCBcXFwiXCIgKyBlbGVtZW50TmFtZSArIFwiXFxcIiBleHBlY3RpbmcgXFxcIjpuYW1lc3BhY2U6bmFtZVxcXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBbZWxlbWVudE5hbWUuc2xpY2UoMSwgY29sb25JbmRleCksIGVsZW1lbnROYW1lLnNsaWNlKGNvbG9uSW5kZXggKyAxKV07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZnVsbE5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldE5zUHJlZml4KGZ1bGxOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bGxOYW1lID09PSBudWxsID8gbnVsbCA6IHNwbGl0TnNOYW1lKGZ1bGxOYW1lKVswXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwcmVmaXhcbiAqIEBwYXJhbSB7P30gbG9jYWxOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtZXJnZU5zQW5kTmFtZShwcmVmaXgsIGxvY2FsTmFtZSkge1xuICAgIHJldHVybiBwcmVmaXggPyBcIjpcIiArIHByZWZpeCArIFwiOlwiICsgbG9jYWxOYW1lIDogbG9jYWxOYW1lO1xufVxuLy8gc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCNuYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlc1xuLy8gc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VudGl0aWVzLmpzb25cbi8vIFRoaXMgbGlzdCBpcyBub3QgZXhoYXVzdGl2ZSB0byBrZWVwIHRoZSBjb21waWxlciBmb290cHJpbnQgbG93LlxuLy8gVGhlIGAmIzEyMztgIC8gYCYjeDFhYjtgIHN5bnRheCBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlIGRvZXMgbm90IGV4aXN0LlxudmFyIE5BTUVEX0VOVElUSUVTID0ge1xuICAgICdBYWN1dGUnOiAnXFx1MDBDMScsXG4gICAgJ2FhY3V0ZSc6ICdcXHUwMEUxJyxcbiAgICAnQWNpcmMnOiAnXFx1MDBDMicsXG4gICAgJ2FjaXJjJzogJ1xcdTAwRTInLFxuICAgICdhY3V0ZSc6ICdcXHUwMEI0JyxcbiAgICAnQUVsaWcnOiAnXFx1MDBDNicsXG4gICAgJ2FlbGlnJzogJ1xcdTAwRTYnLFxuICAgICdBZ3JhdmUnOiAnXFx1MDBDMCcsXG4gICAgJ2FncmF2ZSc6ICdcXHUwMEUwJyxcbiAgICAnYWxlZnN5bSc6ICdcXHUyMTM1JyxcbiAgICAnQWxwaGEnOiAnXFx1MDM5MScsXG4gICAgJ2FscGhhJzogJ1xcdTAzQjEnLFxuICAgICdhbXAnOiAnJicsXG4gICAgJ2FuZCc6ICdcXHUyMjI3JyxcbiAgICAnYW5nJzogJ1xcdTIyMjAnLFxuICAgICdhcG9zJzogJ1xcdTAwMjcnLFxuICAgICdBcmluZyc6ICdcXHUwMEM1JyxcbiAgICAnYXJpbmcnOiAnXFx1MDBFNScsXG4gICAgJ2FzeW1wJzogJ1xcdTIyNDgnLFxuICAgICdBdGlsZGUnOiAnXFx1MDBDMycsXG4gICAgJ2F0aWxkZSc6ICdcXHUwMEUzJyxcbiAgICAnQXVtbCc6ICdcXHUwMEM0JyxcbiAgICAnYXVtbCc6ICdcXHUwMEU0JyxcbiAgICAnYmRxdW8nOiAnXFx1MjAxRScsXG4gICAgJ0JldGEnOiAnXFx1MDM5MicsXG4gICAgJ2JldGEnOiAnXFx1MDNCMicsXG4gICAgJ2JydmJhcic6ICdcXHUwMEE2JyxcbiAgICAnYnVsbCc6ICdcXHUyMDIyJyxcbiAgICAnY2FwJzogJ1xcdTIyMjknLFxuICAgICdDY2VkaWwnOiAnXFx1MDBDNycsXG4gICAgJ2NjZWRpbCc6ICdcXHUwMEU3JyxcbiAgICAnY2VkaWwnOiAnXFx1MDBCOCcsXG4gICAgJ2NlbnQnOiAnXFx1MDBBMicsXG4gICAgJ0NoaSc6ICdcXHUwM0E3JyxcbiAgICAnY2hpJzogJ1xcdTAzQzcnLFxuICAgICdjaXJjJzogJ1xcdTAyQzYnLFxuICAgICdjbHVicyc6ICdcXHUyNjYzJyxcbiAgICAnY29uZyc6ICdcXHUyMjQ1JyxcbiAgICAnY29weSc6ICdcXHUwMEE5JyxcbiAgICAnY3JhcnInOiAnXFx1MjFCNScsXG4gICAgJ2N1cCc6ICdcXHUyMjJBJyxcbiAgICAnY3VycmVuJzogJ1xcdTAwQTQnLFxuICAgICdkYWdnZXInOiAnXFx1MjAyMCcsXG4gICAgJ0RhZ2dlcic6ICdcXHUyMDIxJyxcbiAgICAnZGFycic6ICdcXHUyMTkzJyxcbiAgICAnZEFycic6ICdcXHUyMUQzJyxcbiAgICAnZGVnJzogJ1xcdTAwQjAnLFxuICAgICdEZWx0YSc6ICdcXHUwMzk0JyxcbiAgICAnZGVsdGEnOiAnXFx1MDNCNCcsXG4gICAgJ2RpYW1zJzogJ1xcdTI2NjYnLFxuICAgICdkaXZpZGUnOiAnXFx1MDBGNycsXG4gICAgJ0VhY3V0ZSc6ICdcXHUwMEM5JyxcbiAgICAnZWFjdXRlJzogJ1xcdTAwRTknLFxuICAgICdFY2lyYyc6ICdcXHUwMENBJyxcbiAgICAnZWNpcmMnOiAnXFx1MDBFQScsXG4gICAgJ0VncmF2ZSc6ICdcXHUwMEM4JyxcbiAgICAnZWdyYXZlJzogJ1xcdTAwRTgnLFxuICAgICdlbXB0eSc6ICdcXHUyMjA1JyxcbiAgICAnZW1zcCc6ICdcXHUyMDAzJyxcbiAgICAnZW5zcCc6ICdcXHUyMDAyJyxcbiAgICAnRXBzaWxvbic6ICdcXHUwMzk1JyxcbiAgICAnZXBzaWxvbic6ICdcXHUwM0I1JyxcbiAgICAnZXF1aXYnOiAnXFx1MjI2MScsXG4gICAgJ0V0YSc6ICdcXHUwMzk3JyxcbiAgICAnZXRhJzogJ1xcdTAzQjcnLFxuICAgICdFVEgnOiAnXFx1MDBEMCcsXG4gICAgJ2V0aCc6ICdcXHUwMEYwJyxcbiAgICAnRXVtbCc6ICdcXHUwMENCJyxcbiAgICAnZXVtbCc6ICdcXHUwMEVCJyxcbiAgICAnZXVybyc6ICdcXHUyMEFDJyxcbiAgICAnZXhpc3QnOiAnXFx1MjIwMycsXG4gICAgJ2Zub2YnOiAnXFx1MDE5MicsXG4gICAgJ2ZvcmFsbCc6ICdcXHUyMjAwJyxcbiAgICAnZnJhYzEyJzogJ1xcdTAwQkQnLFxuICAgICdmcmFjMTQnOiAnXFx1MDBCQycsXG4gICAgJ2ZyYWMzNCc6ICdcXHUwMEJFJyxcbiAgICAnZnJhc2wnOiAnXFx1MjA0NCcsXG4gICAgJ0dhbW1hJzogJ1xcdTAzOTMnLFxuICAgICdnYW1tYSc6ICdcXHUwM0IzJyxcbiAgICAnZ2UnOiAnXFx1MjI2NScsXG4gICAgJ2d0JzogJz4nLFxuICAgICdoYXJyJzogJ1xcdTIxOTQnLFxuICAgICdoQXJyJzogJ1xcdTIxRDQnLFxuICAgICdoZWFydHMnOiAnXFx1MjY2NScsXG4gICAgJ2hlbGxpcCc6ICdcXHUyMDI2JyxcbiAgICAnSWFjdXRlJzogJ1xcdTAwQ0QnLFxuICAgICdpYWN1dGUnOiAnXFx1MDBFRCcsXG4gICAgJ0ljaXJjJzogJ1xcdTAwQ0UnLFxuICAgICdpY2lyYyc6ICdcXHUwMEVFJyxcbiAgICAnaWV4Y2wnOiAnXFx1MDBBMScsXG4gICAgJ0lncmF2ZSc6ICdcXHUwMENDJyxcbiAgICAnaWdyYXZlJzogJ1xcdTAwRUMnLFxuICAgICdpbWFnZSc6ICdcXHUyMTExJyxcbiAgICAnaW5maW4nOiAnXFx1MjIxRScsXG4gICAgJ2ludCc6ICdcXHUyMjJCJyxcbiAgICAnSW90YSc6ICdcXHUwMzk5JyxcbiAgICAnaW90YSc6ICdcXHUwM0I5JyxcbiAgICAnaXF1ZXN0JzogJ1xcdTAwQkYnLFxuICAgICdpc2luJzogJ1xcdTIyMDgnLFxuICAgICdJdW1sJzogJ1xcdTAwQ0YnLFxuICAgICdpdW1sJzogJ1xcdTAwRUYnLFxuICAgICdLYXBwYSc6ICdcXHUwMzlBJyxcbiAgICAna2FwcGEnOiAnXFx1MDNCQScsXG4gICAgJ0xhbWJkYSc6ICdcXHUwMzlCJyxcbiAgICAnbGFtYmRhJzogJ1xcdTAzQkInLFxuICAgICdsYW5nJzogJ1xcdTI3RTgnLFxuICAgICdsYXF1byc6ICdcXHUwMEFCJyxcbiAgICAnbGFycic6ICdcXHUyMTkwJyxcbiAgICAnbEFycic6ICdcXHUyMUQwJyxcbiAgICAnbGNlaWwnOiAnXFx1MjMwOCcsXG4gICAgJ2xkcXVvJzogJ1xcdTIwMUMnLFxuICAgICdsZSc6ICdcXHUyMjY0JyxcbiAgICAnbGZsb29yJzogJ1xcdTIzMEEnLFxuICAgICdsb3dhc3QnOiAnXFx1MjIxNycsXG4gICAgJ2xveic6ICdcXHUyNUNBJyxcbiAgICAnbHJtJzogJ1xcdTIwMEUnLFxuICAgICdsc2FxdW8nOiAnXFx1MjAzOScsXG4gICAgJ2xzcXVvJzogJ1xcdTIwMTgnLFxuICAgICdsdCc6ICc8JyxcbiAgICAnbWFjcic6ICdcXHUwMEFGJyxcbiAgICAnbWRhc2gnOiAnXFx1MjAxNCcsXG4gICAgJ21pY3JvJzogJ1xcdTAwQjUnLFxuICAgICdtaWRkb3QnOiAnXFx1MDBCNycsXG4gICAgJ21pbnVzJzogJ1xcdTIyMTInLFxuICAgICdNdSc6ICdcXHUwMzlDJyxcbiAgICAnbXUnOiAnXFx1MDNCQycsXG4gICAgJ25hYmxhJzogJ1xcdTIyMDcnLFxuICAgICduYnNwJzogJ1xcdTAwQTAnLFxuICAgICduZGFzaCc6ICdcXHUyMDEzJyxcbiAgICAnbmUnOiAnXFx1MjI2MCcsXG4gICAgJ25pJzogJ1xcdTIyMEInLFxuICAgICdub3QnOiAnXFx1MDBBQycsXG4gICAgJ25vdGluJzogJ1xcdTIyMDknLFxuICAgICduc3ViJzogJ1xcdTIyODQnLFxuICAgICdOdGlsZGUnOiAnXFx1MDBEMScsXG4gICAgJ250aWxkZSc6ICdcXHUwMEYxJyxcbiAgICAnTnUnOiAnXFx1MDM5RCcsXG4gICAgJ251JzogJ1xcdTAzQkQnLFxuICAgICdPYWN1dGUnOiAnXFx1MDBEMycsXG4gICAgJ29hY3V0ZSc6ICdcXHUwMEYzJyxcbiAgICAnT2NpcmMnOiAnXFx1MDBENCcsXG4gICAgJ29jaXJjJzogJ1xcdTAwRjQnLFxuICAgICdPRWxpZyc6ICdcXHUwMTUyJyxcbiAgICAnb2VsaWcnOiAnXFx1MDE1MycsXG4gICAgJ09ncmF2ZSc6ICdcXHUwMEQyJyxcbiAgICAnb2dyYXZlJzogJ1xcdTAwRjInLFxuICAgICdvbGluZSc6ICdcXHUyMDNFJyxcbiAgICAnT21lZ2EnOiAnXFx1MDNBOScsXG4gICAgJ29tZWdhJzogJ1xcdTAzQzknLFxuICAgICdPbWljcm9uJzogJ1xcdTAzOUYnLFxuICAgICdvbWljcm9uJzogJ1xcdTAzQkYnLFxuICAgICdvcGx1cyc6ICdcXHUyMjk1JyxcbiAgICAnb3InOiAnXFx1MjIyOCcsXG4gICAgJ29yZGYnOiAnXFx1MDBBQScsXG4gICAgJ29yZG0nOiAnXFx1MDBCQScsXG4gICAgJ09zbGFzaCc6ICdcXHUwMEQ4JyxcbiAgICAnb3NsYXNoJzogJ1xcdTAwRjgnLFxuICAgICdPdGlsZGUnOiAnXFx1MDBENScsXG4gICAgJ290aWxkZSc6ICdcXHUwMEY1JyxcbiAgICAnb3RpbWVzJzogJ1xcdTIyOTcnLFxuICAgICdPdW1sJzogJ1xcdTAwRDYnLFxuICAgICdvdW1sJzogJ1xcdTAwRjYnLFxuICAgICdwYXJhJzogJ1xcdTAwQjYnLFxuICAgICdwZXJtaWwnOiAnXFx1MjAzMCcsXG4gICAgJ3BlcnAnOiAnXFx1MjJBNScsXG4gICAgJ1BoaSc6ICdcXHUwM0E2JyxcbiAgICAncGhpJzogJ1xcdTAzQzYnLFxuICAgICdQaSc6ICdcXHUwM0EwJyxcbiAgICAncGknOiAnXFx1MDNDMCcsXG4gICAgJ3Bpdic6ICdcXHUwM0Q2JyxcbiAgICAncGx1c21uJzogJ1xcdTAwQjEnLFxuICAgICdwb3VuZCc6ICdcXHUwMEEzJyxcbiAgICAncHJpbWUnOiAnXFx1MjAzMicsXG4gICAgJ1ByaW1lJzogJ1xcdTIwMzMnLFxuICAgICdwcm9kJzogJ1xcdTIyMEYnLFxuICAgICdwcm9wJzogJ1xcdTIyMUQnLFxuICAgICdQc2knOiAnXFx1MDNBOCcsXG4gICAgJ3BzaSc6ICdcXHUwM0M4JyxcbiAgICAncXVvdCc6ICdcXHUwMDIyJyxcbiAgICAncmFkaWMnOiAnXFx1MjIxQScsXG4gICAgJ3JhbmcnOiAnXFx1MjdFOScsXG4gICAgJ3JhcXVvJzogJ1xcdTAwQkInLFxuICAgICdyYXJyJzogJ1xcdTIxOTInLFxuICAgICdyQXJyJzogJ1xcdTIxRDInLFxuICAgICdyY2VpbCc6ICdcXHUyMzA5JyxcbiAgICAncmRxdW8nOiAnXFx1MjAxRCcsXG4gICAgJ3JlYWwnOiAnXFx1MjExQycsXG4gICAgJ3JlZyc6ICdcXHUwMEFFJyxcbiAgICAncmZsb29yJzogJ1xcdTIzMEInLFxuICAgICdSaG8nOiAnXFx1MDNBMScsXG4gICAgJ3Jobyc6ICdcXHUwM0MxJyxcbiAgICAncmxtJzogJ1xcdTIwMEYnLFxuICAgICdyc2FxdW8nOiAnXFx1MjAzQScsXG4gICAgJ3JzcXVvJzogJ1xcdTIwMTknLFxuICAgICdzYnF1byc6ICdcXHUyMDFBJyxcbiAgICAnU2Nhcm9uJzogJ1xcdTAxNjAnLFxuICAgICdzY2Fyb24nOiAnXFx1MDE2MScsXG4gICAgJ3Nkb3QnOiAnXFx1MjJDNScsXG4gICAgJ3NlY3QnOiAnXFx1MDBBNycsXG4gICAgJ3NoeSc6ICdcXHUwMEFEJyxcbiAgICAnU2lnbWEnOiAnXFx1MDNBMycsXG4gICAgJ3NpZ21hJzogJ1xcdTAzQzMnLFxuICAgICdzaWdtYWYnOiAnXFx1MDNDMicsXG4gICAgJ3NpbSc6ICdcXHUyMjNDJyxcbiAgICAnc3BhZGVzJzogJ1xcdTI2NjAnLFxuICAgICdzdWInOiAnXFx1MjI4MicsXG4gICAgJ3N1YmUnOiAnXFx1MjI4NicsXG4gICAgJ3N1bSc6ICdcXHUyMjExJyxcbiAgICAnc3VwJzogJ1xcdTIyODMnLFxuICAgICdzdXAxJzogJ1xcdTAwQjknLFxuICAgICdzdXAyJzogJ1xcdTAwQjInLFxuICAgICdzdXAzJzogJ1xcdTAwQjMnLFxuICAgICdzdXBlJzogJ1xcdTIyODcnLFxuICAgICdzemxpZyc6ICdcXHUwMERGJyxcbiAgICAnVGF1JzogJ1xcdTAzQTQnLFxuICAgICd0YXUnOiAnXFx1MDNDNCcsXG4gICAgJ3RoZXJlNCc6ICdcXHUyMjM0JyxcbiAgICAnVGhldGEnOiAnXFx1MDM5OCcsXG4gICAgJ3RoZXRhJzogJ1xcdTAzQjgnLFxuICAgICd0aGV0YXN5bSc6ICdcXHUwM0QxJyxcbiAgICAndGhpbnNwJzogJ1xcdTIwMDknLFxuICAgICdUSE9STic6ICdcXHUwMERFJyxcbiAgICAndGhvcm4nOiAnXFx1MDBGRScsXG4gICAgJ3RpbGRlJzogJ1xcdTAyREMnLFxuICAgICd0aW1lcyc6ICdcXHUwMEQ3JyxcbiAgICAndHJhZGUnOiAnXFx1MjEyMicsXG4gICAgJ1VhY3V0ZSc6ICdcXHUwMERBJyxcbiAgICAndWFjdXRlJzogJ1xcdTAwRkEnLFxuICAgICd1YXJyJzogJ1xcdTIxOTEnLFxuICAgICd1QXJyJzogJ1xcdTIxRDEnLFxuICAgICdVY2lyYyc6ICdcXHUwMERCJyxcbiAgICAndWNpcmMnOiAnXFx1MDBGQicsXG4gICAgJ1VncmF2ZSc6ICdcXHUwMEQ5JyxcbiAgICAndWdyYXZlJzogJ1xcdTAwRjknLFxuICAgICd1bWwnOiAnXFx1MDBBOCcsXG4gICAgJ3Vwc2loJzogJ1xcdTAzRDInLFxuICAgICdVcHNpbG9uJzogJ1xcdTAzQTUnLFxuICAgICd1cHNpbG9uJzogJ1xcdTAzQzUnLFxuICAgICdVdW1sJzogJ1xcdTAwREMnLFxuICAgICd1dW1sJzogJ1xcdTAwRkMnLFxuICAgICd3ZWllcnAnOiAnXFx1MjExOCcsXG4gICAgJ1hpJzogJ1xcdTAzOUUnLFxuICAgICd4aSc6ICdcXHUwM0JFJyxcbiAgICAnWWFjdXRlJzogJ1xcdTAwREQnLFxuICAgICd5YWN1dGUnOiAnXFx1MDBGRCcsXG4gICAgJ3llbic6ICdcXHUwMEE1JyxcbiAgICAneXVtbCc6ICdcXHUwMEZGJyxcbiAgICAnWXVtbCc6ICdcXHUwMTc4JyxcbiAgICAnWmV0YSc6ICdcXHUwMzk2JyxcbiAgICAnemV0YSc6ICdcXHUwM0I2JyxcbiAgICAnendqJzogJ1xcdTIwMEQnLFxuICAgICd6d25qJzogJ1xcdTIwMEMnLFxufTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBIdG1sVGFnRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICovXG4gICAgZnVuY3Rpb24gSHRtbFRhZ0RlZmluaXRpb24oX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGNsb3NlZEJ5Q2hpbGRyZW4gPSBfYi5jbG9zZWRCeUNoaWxkcmVuLCByZXF1aXJlZFBhcmVudHMgPSBfYi5yZXF1aXJlZFBhcmVudHMsIGltcGxpY2l0TmFtZXNwYWNlUHJlZml4ID0gX2IuaW1wbGljaXROYW1lc3BhY2VQcmVmaXgsIF9jID0gX2IuY29udGVudFR5cGUsIGNvbnRlbnRUeXBlID0gX2MgPT09IHZvaWQgMCA/IFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEEgOiBfYywgX2QgPSBfYi5jbG9zZWRCeVBhcmVudCwgY2xvc2VkQnlQYXJlbnQgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBfYi5pc1ZvaWQsIGlzVm9pZCA9IF9lID09PSB2b2lkIDAgPyBmYWxzZSA6IF9lLCBfZiA9IF9iLmlnbm9yZUZpcnN0TGYsIGlnbm9yZUZpcnN0TGYgPSBfZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZjtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbG9zZWRCeUNoaWxkcmVuID0ge307XG4gICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5TZWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNsb3NlZEJ5Q2hpbGRyZW4gJiYgY2xvc2VkQnlDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjbG9zZWRCeUNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKHRhZ05hbWUpIHsgcmV0dXJuIF90aGlzLmNsb3NlZEJ5Q2hpbGRyZW5bdGFnTmFtZV0gPSB0cnVlOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGNsb3NlZEJ5UGFyZW50IHx8IGlzVm9pZDtcbiAgICAgICAgaWYgKHJlcXVpcmVkUGFyZW50cyAmJiByZXF1aXJlZFBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZFBhcmVudHMgPSB7fTtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwYXJlbnQgaXMgdGhlIGxpc3QgaXMgYXV0b21hdGljYWxseSB3aGVuIG5vbmUgb2YgdGhlIGxpc3RlZCBwYXJlbnRzIGFyZSBwcmVzZW50XG4gICAgICAgICAgICB0aGlzLnBhcmVudFRvQWRkID0gcmVxdWlyZWRQYXJlbnRzWzBdO1xuICAgICAgICAgICAgcmVxdWlyZWRQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhZ05hbWUpIHsgcmV0dXJuIF90aGlzLnJlcXVpcmVkUGFyZW50c1t0YWdOYW1lXSA9IHRydWU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW1wbGljaXROYW1lc3BhY2VQcmVmaXggPSBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBpZ25vcmVGaXJzdExmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRQYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0bWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5yZXF1aXJlRXh0cmFQYXJlbnQgPSBmdW5jdGlvbiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICBpZiAoIXRoaXMucmVxdWlyZWRQYXJlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsY1BhcmVudCA9IGN1cnJlbnRQYXJlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNQYXJlbnRUZW1wbGF0ZSA9IGxjUGFyZW50ID09PSAndGVtcGxhdGUnIHx8IGN1cnJlbnRQYXJlbnQgPT09ICduZy10ZW1wbGF0ZSc7XG4gICAgICAgIHJldHVybiAhaXNQYXJlbnRUZW1wbGF0ZSAmJiB0aGlzLnJlcXVpcmVkUGFyZW50c1tsY1BhcmVudF0gIT0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSHRtbFRhZ0RlZmluaXRpb24ucHJvdG90eXBlLmlzQ2xvc2VkQnlDaGlsZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVm9pZCB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gdGhpcy5jbG9zZWRCeUNoaWxkcmVuO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWxUYWdEZWZpbml0aW9uO1xufSgpKTtcbi8vIHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjb3B0aW9uYWwtdGFnc1xuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBmdWxseSBjb25mb3JtIHRvIHRoZSBIVE1MNSBzcGVjLlxudmFyIFRBR19ERUZJTklUSU9OUyA9IHtcbiAgICAnYmFzZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnbWV0YSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnYXJlYSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnZW1iZWQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ2xpbmsnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ2ltZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnaW5wdXQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ3BhcmFtJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICdocic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnYnInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ3NvdXJjZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAndHJhY2snOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgJ3dicic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAncCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7XG4gICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW46IFtcbiAgICAgICAgICAgICdhZGRyZXNzJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmxvY2txdW90ZScsICdkaXYnLCAnZGwnLCAnZmllbGRzZXQnLCAnZm9vdGVyJywgJ2Zvcm0nLFxuICAgICAgICAgICAgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLFxuICAgICAgICAgICAgJ21haW4nLCAnbmF2JywgJ29sJywgJ3AnLCAncHJlJywgJ3NlY3Rpb24nLCAndGFibGUnLCAndWwnXG4gICAgICAgIF0sXG4gICAgICAgIGNsb3NlZEJ5UGFyZW50OiB0cnVlXG4gICAgfSksXG4gICAgJ3RoZWFkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keScsICd0Zm9vdCddIH0pLFxuICAgICd0Ym9keSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGJvZHknLCAndGZvb3QnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ3Rmb290JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keSddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAndHInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RyJ10sXG4gICAgICAgIHJlcXVpcmVkUGFyZW50czogWyd0Ym9keScsICd0Zm9vdCcsICd0aGVhZCddLFxuICAgICAgICBjbG9zZWRCeVBhcmVudDogdHJ1ZVxuICAgIH0pLFxuICAgICd0ZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGQnLCAndGgnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgJ3RoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ZCcsICd0aCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAnY29sJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgcmVxdWlyZWRQYXJlbnRzOiBbJ2NvbGdyb3VwJ10sIGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAnc3ZnJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdzdmcnIH0pLFxuICAgICdtYXRoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdtYXRoJyB9KSxcbiAgICAnbGknOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2xpJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdkdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSB9KSxcbiAgICAnZGQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2R0JywgJ2RkJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdyYic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdydCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdydGMnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAncnAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAnb3B0Z3JvdXAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICdvcHRpb24nOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGlvbicsICdvcHRncm91cCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAncHJlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaWdub3JlRmlyc3RMZjogdHJ1ZSB9KSxcbiAgICAnbGlzdGluZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgJ3N0eWxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUIH0pLFxuICAgICdzY3JpcHQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgfSksXG4gICAgJ3RpdGxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCB9KSxcbiAgICAndGV4dGFyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhULCBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxufTtcbnZhciBfREVGQVVMVF9UQUdfREVGSU5JVElPTiA9IG5ldyBIdG1sVGFnRGVmaW5pdGlvbigpO1xuLyoqXG4gKiBAcGFyYW0gez99IHRhZ05hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldEh0bWxUYWdEZWZpbml0aW9uKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gVEFHX0RFRklOSVRJT05TW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHwgX0RFRkFVTFRfVEFHX0RFRklOSVRJT047XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX1NFTEVDVE9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoJyhcXFxcOm5vdFxcXFwoKXwnICtcbiAgICAnKFstXFxcXHddKyl8JyArXG4gICAgJyg/OlxcXFwuKFstXFxcXHddKykpfCcgK1xuICAgIC8vIFwiLVwiIHNob3VsZCBhcHBlYXIgZmlyc3QgaW4gdGhlIHJlZ2V4cCBiZWxvdyBhcyBGRjMxIHBhcnNlcyBcIlsuLVxcd11cIiBhcyBhIHJhbmdlXG4gICAgJyg/OlxcXFxbKFstLlxcXFx3Kl0rKSg/Oj0oW1xcXCJcXCddPykoW15cXFxcXVxcXCJcXCddKilcXFxcNSk/XFxcXF0pfCcgK1xuICAgIC8vIFwiW25hbWU9XCJ2YWx1ZVwiXVwiLFxuICAgIC8vIFwiW25hbWU9J3ZhbHVlJ11cIlxuICAgICcoXFxcXCkpfCcgK1xuICAgICcoXFxcXHMqLFxcXFxzKiknLCAvLyBcIixcIlxuJ2cnKTtcbi8qKlxuICogQSBjc3Mgc2VsZWN0b3IgY29udGFpbnMgYW4gZWxlbWVudCBuYW1lLFxuICogY3NzIGNsYXNzZXMgYW5kIGF0dHJpYnV0ZS92YWx1ZSBwYWlycyB3aXRoIHRoZSBwdXJwb3NlXG4gKiBvZiBzZWxlY3Rpbmcgc3Vic2V0cyBvdXQgb2YgdGhlbS5cbiAqL1xudmFyIENzc1NlbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDc3NTZWxlY3RvcigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGFzc05hbWVzID0gW107XG4gICAgICAgIHRoaXMuYXR0cnMgPSBbXTtcbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucGFyc2UgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfYWRkUmVzdWx0ID0gZnVuY3Rpb24gKHJlcywgY3NzU2VsKSB7XG4gICAgICAgICAgICBpZiAoY3NzU2VsLm5vdFNlbGVjdG9ycy5sZW5ndGggPiAwICYmICFjc3NTZWwuZWxlbWVudCAmJiBjc3NTZWwuY2xhc3NOYW1lcy5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgIGNzc1NlbC5hdHRycy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGNzc1NlbC5lbGVtZW50ID0gJyonO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnB1c2goY3NzU2VsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3NzU2VsZWN0b3IgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2g7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5Ob3QgPSBmYWxzZTtcbiAgICAgICAgX1NFTEVDVE9SX1JFR0VYUC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAobWF0Y2ggPSBfU0VMRUNUT1JfUkVHRVhQLmV4ZWMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5Ob3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXN0aW5nIDpub3QgaXMgbm90IGFsbG93ZWQgaW4gYSBzZWxlY3RvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbk5vdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yLm5vdFNlbGVjdG9ycy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5zZXRFbGVtZW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQ2xhc3NOYW1lKG1hdGNoWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQXR0cmlidXRlKG1hdGNoWzRdLCBtYXRjaFs2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbN10pIHtcbiAgICAgICAgICAgICAgICBpbk5vdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs4XSkge1xuICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIHNlbGVjdG9ycyBpbiA6bm90IGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yID0gY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmlzRWxlbWVudFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNFbGVtZW50U2VsZWN0b3IoKSAmJiB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoID09IDAgJiYgdGhpcy5hdHRycy5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuaGFzRWxlbWVudFNlbGVjdG9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gISF0aGlzLmVsZW1lbnQ7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gZWxlbWVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdm9pZCAwKSB7IGVsZW1lbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgdGVtcGxhdGUgc3RyaW5nIGZvciBhbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUuZ2V0TWF0Y2hpbmdFbGVtZW50VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZ05hbWUgPSB0aGlzLmVsZW1lbnQgfHwgJ2Rpdic7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzQXR0ciA9IHRoaXMuY2xhc3NOYW1lcy5sZW5ndGggPiAwID8gXCIgY2xhc3M9XFxcIlwiICsgdGhpcy5jbGFzc05hbWVzLmpvaW4oJyAnKSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0gJyc7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyTmFtZSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyVmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXSAhPT0gJycgPyBcIj1cXFwiXCIgKyB0aGlzLmF0dHJzW2kgKyAxXSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICBhdHRycyArPSBcIiBcIiArIGF0dHJOYW1lICsgYXR0clZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRIdG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKS5pc1ZvaWQgPyBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiLz5cIiA6XG4gICAgICAgICAgICBcIjxcIiArIHRhZ05hbWUgKyBjbGFzc0F0dHIgKyBhdHRycyArIFwiPjwvXCIgKyB0YWdOYW1lICsgXCI+XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9ICcnOyB9XG4gICAgICAgIHRoaXMuYXR0cnMucHVzaChuYW1lLCB2YWx1ZSAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpIHx8ICcnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ3NzU2VsZWN0b3IucHJvdG90eXBlLmFkZENsYXNzTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7IHRoaXMuY2xhc3NOYW1lcy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSk7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDc3NTZWxlY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9IHRoaXMuZWxlbWVudCB8fCAnJztcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWVzLmZvckVhY2goZnVuY3Rpb24gKGtsYXNzKSB7IHJldHVybiByZXMgKz0gXCIuXCIgKyBrbGFzczsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICByZXMgKz0gXCJbXCIgKyBuYW1lICsgKHZhbHVlID8gJz0nICsgdmFsdWUgOiAnJykgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChub3RTZWxlY3RvcikgeyByZXR1cm4gcmVzICs9IFwiOm5vdChcIiArIG5vdFNlbGVjdG9yICsgXCIpXCI7IH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIENzc1NlbGVjdG9yO1xufSgpKTtcbi8qKlxuICogUmVhZHMgYSBsaXN0IG9mIENzc1NlbGVjdG9ycyBhbmQgYWxsb3dzIHRvIGNhbGN1bGF0ZSB3aGljaCBvbmVzXG4gKiBhcmUgY29udGFpbmVkIGluIGEgZ2l2ZW4gQ3NzU2VsZWN0b3IuXG4gKi9cbnZhciBTZWxlY3Rvck1hdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlbGVjdG9yTWF0Y2hlcigpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFBhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NsYXNzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jbGFzc1BhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dHJWYWx1ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm90U2VsZWN0b3JzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlciA9IGZ1bmN0aW9uIChub3RTZWxlY3RvcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm90TWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgbm90TWF0Y2hlci5hZGRTZWxlY3RhYmxlcyhub3RTZWxlY3RvcnMsIG51bGwpO1xuICAgICAgICByZXR1cm4gbm90TWF0Y2hlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzU2VsZWN0b3JzXG4gICAgICogQHBhcmFtIHs/PX0gY2FsbGJhY2tDdHh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLmFkZFNlbGVjdGFibGVzID0gZnVuY3Rpb24gKGNzc1NlbGVjdG9ycywgY2FsbGJhY2tDdHh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpc3RDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgaWYgKGNzc1NlbGVjdG9ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsaXN0Q29udGV4dCA9IG5ldyBTZWxlY3Rvckxpc3RDb250ZXh0KGNzc1NlbGVjdG9ycyk7XG4gICAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHMucHVzaChsaXN0Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNzc1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fYWRkU2VsZWN0YWJsZShjc3NTZWxlY3RvcnNbaV0sIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIGZvdW5kIGxhdGVyIG9uIGJ5IGNhbGxpbmcgYG1hdGNoYC5cbiAgICAgKiBAcGFyYW0gez99IGNzc1NlbGVjdG9yIEEgY3NzIHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBjYWxsYmFja0N0eHQgQW4gb3BhcXVlIG9iamVjdCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIG9mIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBsaXN0Q29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVyID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGNzc1NlbGVjdG9yLmVsZW1lbnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTmFtZXMgPSBjc3NTZWxlY3Rvci5jbGFzc05hbWVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRycyA9IGNzc1NlbGVjdG9yLmF0dHJzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RhYmxlID0gbmV3IFNlbGVjdG9yQ29udGV4dChjc3NTZWxlY3RvciwgY2FsbGJhY2tDdHh0LCBsaXN0Q29udGV4dCk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGNsYXNzTmFtZXMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbChtYXRjaGVyLl9lbGVtZW50TWFwLCBlbGVtZW50LCBzZWxlY3RhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoZXIgPSB0aGlzLl9hZGRQYXJ0aWFsKG1hdGNoZXIuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGkgPT09IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKG1hdGNoZXIuX2NsYXNzTWFwLCBjbGFzc05hbWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwobWF0Y2hlci5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzVGVybWluYWwgPSBpID09PSBhdHRycy5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBhdHRyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXJtaW5hbE1hcCA9IG1hdGNoZXIuX2F0dHJWYWx1ZU1hcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVybWluYWxWYWx1ZXNNYXAgPSB0ZXJtaW5hbE1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWxWYWx1ZXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmFsVmFsdWVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWxNYXAuc2V0KG5hbWUsIHRlcm1pbmFsVmFsdWVzTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgdmFsdWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydGlhbE1hcCA9IG1hdGNoZXIuX2F0dHJWYWx1ZVBhcnRpYWxNYXA7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRpYWxWYWx1ZXNNYXAgPSBwYXJ0aWFsTWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0aWFsVmFsdWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsVmFsdWVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbE1hcC5zZXQobmFtZSwgcGFydGlhbFZhbHVlc01hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYXBcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdGFibGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX2FkZFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgc2VsZWN0YWJsZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXJtaW5hbExpc3QgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXRlcm1pbmFsTGlzdCkge1xuICAgICAgICAgICAgdGVybWluYWxMaXN0ID0gW107XG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHRlcm1pbmFsTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYWxMaXN0LnB1c2goc2VsZWN0YWJsZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1hcFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VsZWN0b3JNYXRjaGVyLnByb3RvdHlwZS5fYWRkUGFydGlhbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICAgIG1hcC5zZXQobmFtZSwgbWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHZpYSBgYWRkU2VsZWN0YWJsZWBcbiAgICAgKiB3aG9zZSBjc3Mgc2VsZWN0b3IgaXMgY29udGFpbmVkIGluIHRoZSBnaXZlbiBjc3Mgc2VsZWN0b3IuXG4gICAgICogQHBhcmFtIHs/fSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbWF0Y2hlZENhbGxiYWNrIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgb2JqZWN0IGhhbmRlZCBpbnRvIGBhZGRTZWxlY3RhYmxlYFxuICAgICAqIEByZXR1cm4gez99IGJvb2xlYW4gdHJ1ZSBpZiBhIG1hdGNoIHdhcyBmb3VuZFxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudCA9IGNzc1NlbGVjdG9yLmVsZW1lbnQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTmFtZXMgPSBjc3NTZWxlY3Rvci5jbGFzc05hbWVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRycyA9IGNzc1NlbGVjdG9yLmF0dHJzO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdGhpcy5fbGlzdENvbnRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0Q29udGV4dHNbaV0uYWxyZWFkeU1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFRlcm1pbmFsKHRoaXMuX2VsZW1lbnRNYXAsIGVsZW1lbnQsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hQYXJ0aWFsKHRoaXMuX2VsZW1lbnRQYXJ0aWFsTWFwLCBlbGVtZW50LCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fFxuICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICBpZiAoY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fY2xhc3NNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9jbGFzc1BhcnRpYWxNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBhdHRyc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXJtaW5hbFZhbHVlc01hcCA9IHRoaXMuX2F0dHJWYWx1ZU1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCAnJywgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCB2YWx1ZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRpYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVQYXJ0aWFsTWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fbWF0Y2hQYXJ0aWFsKHBhcnRpYWxWYWx1ZXNNYXAsICcnLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCB2YWx1ZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBjc3NTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gbWF0Y2hlZENhbGxiYWNrXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZWxlY3Rvck1hdGNoZXIucHJvdG90eXBlLl9tYXRjaFRlcm1pbmFsID0gZnVuY3Rpb24gKG1hcCwgbmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICBpZiAoIW1hcCB8fCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RhYmxlcyA9IG1hcC5nZXQobmFtZSkgfHwgW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJTZWxlY3RhYmxlcyA9IG1hcC5nZXQoJyonKTtcbiAgICAgICAgaWYgKHN0YXJTZWxlY3RhYmxlcykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZXMgPSBzZWxlY3RhYmxlcy5jb25jYXQoc3RhclNlbGVjdGFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0YWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0YWJsZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzZWxlY3RhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZSA9IHNlbGVjdGFibGVzW2ldO1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VsZWN0YWJsZS5maW5hbGl6ZShjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSBtYXBcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNzc1NlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBtYXRjaGVkQ2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdG9yTWF0Y2hlci5wcm90b3R5cGUuX21hdGNoUGFydGlhbCA9IGZ1bmN0aW9uIChtYXAsIG5hbWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFtYXAgfHwgdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmVzdGVkU2VsZWN0b3IgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIW5lc3RlZFNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhwZXJmKTogZ2V0IHJpZCBvZiByZWN1cnNpb24gYW5kIG1lYXN1cmUgYWdhaW5cbiAgICAgICAgLy8gVE9ETyhwZXJmKTogZG9uJ3QgcGFzcyB0aGUgd2hvbGUgc2VsZWN0b3IgaW50byB0aGUgcmVjdXJzaW9uLFxuICAgICAgICAvLyBidXQgb25seSB0aGUgbm90IHByb2Nlc3NlZCBwYXJ0c1xuICAgICAgICByZXR1cm4gbmVzdGVkU2VsZWN0b3IubWF0Y2goY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0b3JNYXRjaGVyO1xufSgpKTtcbnZhciBTZWxlY3Rvckxpc3RDb250ZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlbGVjdG9yTGlzdENvbnRleHQoc2VsZWN0b3JzKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JzID0gc2VsZWN0b3JzO1xuICAgICAgICB0aGlzLmFscmVhZHlNYXRjaGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBTZWxlY3Rvckxpc3RDb250ZXh0O1xufSgpKTtcbnZhciBTZWxlY3RvckNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGNiQ29udGV4dFxuICAgICAqIEBwYXJhbSB7P30gbGlzdENvbnRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZWxlY3RvckNvbnRleHQoc2VsZWN0b3IsIGNiQ29udGV4dCwgbGlzdENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNiQ29udGV4dCA9IGNiQ29udGV4dDtcbiAgICAgICAgdGhpcy5saXN0Q29udGV4dCA9IGxpc3RDb250ZXh0O1xuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IHNlbGVjdG9yLm5vdFNlbGVjdG9ycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlbGVjdG9yQ29udGV4dC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm5vdFNlbGVjdG9ycy5sZW5ndGggPiAwICYmICghdGhpcy5saXN0Q29udGV4dCB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vdE1hdGNoZXIgPSBTZWxlY3Rvck1hdGNoZXIuY3JlYXRlTm90TWF0Y2hlcih0aGlzLm5vdFNlbGVjdG9ycyk7XG4gICAgICAgICAgICByZXN1bHQgPSAhbm90TWF0Y2hlci5tYXRjaChjc3NTZWxlY3RvciwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCAmJiBjYWxsYmFjayAmJiAoIXRoaXMubGlzdENvbnRleHQgfHwgIXRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdENvbnRleHQuYWxyZWFkeU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5zZWxlY3RvciwgdGhpcy5jYkNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gU2VsZWN0b3JDb250ZXh0O1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBNT0RVTEVfU1VGRklYID0gJyc7XG52YXIgREFTSF9DQVNFX1JFR0VYUCA9IC8tKyhbYS16MC05XSkvZztcbi8qKlxuICogQHBhcmFtIHs/fSBpbnB1dFxuICogQHJldHVybiB7P31cbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoREFTSF9DQVNFX1JFR0VYUCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gZGVmYXVsdFZhbHVlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3BsaXRBdENvbG9uKGlucHV0LCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgcmV0dXJuIF9zcGxpdEF0KGlucHV0LCAnOicsIGRlZmF1bHRWYWx1ZXMpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcGFyYW0gez99IGRlZmF1bHRWYWx1ZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNwbGl0QXRQZXJpb2QoaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICByZXR1cm4gX3NwbGl0QXQoaW5wdXQsICcuJywgZGVmYXVsdFZhbHVlcyk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gY2hhcmFjdGVyXG4gKiBAcGFyYW0gez99IGRlZmF1bHRWYWx1ZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9zcGxpdEF0KGlucHV0LCBjaGFyYWN0ZXIsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFyYWN0ZXJJbmRleCA9IGlucHV0LmluZGV4T2YoY2hhcmFjdGVyKTtcbiAgICBpZiAoY2hhcmFjdGVySW5kZXggPT0gLTEpXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWVzO1xuICAgIHJldHVybiBbaW5wdXQuc2xpY2UoMCwgY2hhcmFjdGVySW5kZXgpLnRyaW0oKSwgaW5wdXQuc2xpY2UoY2hhcmFjdGVySW5kZXggKyAxKS50cmltKCldO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcGFyYW0gez99IHZpc2l0b3JcbiAqIEBwYXJhbSB7P30gY29udGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdmlzaXRWYWx1ZSh2YWx1ZSwgdmlzaXRvciwgY29udGV4dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFycmF5KC8qKiBAdHlwZSB7P30gKi8gKHZhbHVlKSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChpc1N0cmljdFN0cmluZ01hcCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdHJpbmdNYXAoLyoqIEB0eXBlIHs/fSAqLyAodmFsdWUpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJpbWl0aXZlKHZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc2l0b3IudmlzaXRPdGhlcih2YWx1ZSwgY29udGV4dCk7XG59XG52YXIgVmFsdWVUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFsdWVUcmFuc2Zvcm1lcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhcnJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmlzaXRWYWx1ZSh2YWx1ZSwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcCA9IGZ1bmN0aW9uIChtYXAsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJlc3VsdFtrZXldID0gdmlzaXRWYWx1ZShtYXBba2V5XSwgX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZhbHVlVHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWYWx1ZVRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE90aGVyID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7IHJldHVybiB2YWx1ZTsgfTtcbiAgICByZXR1cm4gVmFsdWVUcmFuc2Zvcm1lcjtcbn0oKSk7XG52YXIgU3luY0FzeW5jUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN5bmNSZXN1bHRcbiAgICAgKiBAcGFyYW0gez89fSBhc3luY1Jlc3VsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN5bmNBc3luY1Jlc3VsdChzeW5jUmVzdWx0LCBhc3luY1Jlc3VsdCkge1xuICAgICAgICBpZiAoYXN5bmNSZXN1bHQgPT09IHZvaWQgMCkgeyBhc3luY1Jlc3VsdCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5zeW5jUmVzdWx0ID0gc3luY1Jlc3VsdDtcbiAgICAgICAgdGhpcy5hc3luY1Jlc3VsdCA9IGFzeW5jUmVzdWx0O1xuICAgICAgICBpZiAoIWFzeW5jUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmFzeW5jUmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKHN5bmNSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTeW5jQXN5bmNSZXN1bHQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IG1zZ1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3ludGF4RXJyb3IobXNnKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3IgPSBFcnJvcihtc2cpO1xuICAgICgoZXJyb3IpKVtFUlJPUl9TWU5UQVhfRVJST1JdID0gdHJ1ZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG52YXIgRVJST1JfU1lOVEFYX0VSUk9SID0gJ25nU3ludGF4RXJyb3InO1xuLyoqXG4gKiBAcGFyYW0gez99IGVycm9yXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1N5bnRheEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuICgoZXJyb3IpKVtFUlJPUl9TWU5UQVhfRVJST1JdO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvKFsuKis/Xj0hOiR7fSgpfFtcXF1cXC9cXFxcXSkvZywgJ1xcXFwkMScpO1xufVxudmFyIFNUUklOR19NQVBfUFJPVE8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoe30pO1xuLyoqXG4gKiBAcGFyYW0gez99IG9ialxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RTdHJpbmdNYXAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gU1RSSU5HX01BUF9QUk9UTztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHV0ZjhFbmNvZGUoc3RyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5jb2RlZCA9ICcnO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSAwOyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29kZVBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAvLyBkZWNvZGUgc3Vycm9nYXRlXG4gICAgICAgIC8vIHNlZSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAweGQ4MDAgJiYgY29kZVBvaW50IDw9IDB4ZGJmZiAmJiBzdHIubGVuZ3RoID4gKGluZGV4ICsgMSkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvdyA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAobG93ID49IDB4ZGMwMCAmJiBsb3cgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAoKGNvZGVQb2ludCAtIDB4ZDgwMCkgPDwgMTApICsgbG93IC0gMHhkYzAwICsgMHgxMDAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4N2YpIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDdmZikge1xuICAgICAgICAgICAgZW5jb2RlZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweGMwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGVQb2ludCA+PiAxMikgfCAweGUwLCAoKGNvZGVQb2ludCA+PiA2KSAmIDB4M2YpIHwgMHg4MCwgKGNvZGVQb2ludCAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweGYwLCAoKGNvZGVQb2ludCA+PiAxMikgJiAweDNmKSB8IDB4ODAsICgoY29kZVBvaW50ID4+IDYpICYgMHgzZikgfCAweDgwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIGdyb3VwIDA6IFwiW3Byb3BdIG9yIChldmVudCkgb3IgQHRyaWdnZXJcIlxuLy8gZ3JvdXAgMTogXCJwcm9wXCIgZnJvbSBcIltwcm9wXVwiXG4vLyBncm91cCAyOiBcImV2ZW50XCIgZnJvbSBcIihldmVudClcIlxuLy8gZ3JvdXAgMzogXCJAdHJpZ2dlclwiIGZyb20gXCJAdHJpZ2dlclwiXG52YXIgSE9TVF9SRUdfRVhQID0gL14oPzooPzpcXFsoW15cXF1dKylcXF0pfCg/OlxcKChbXlxcKV0rKVxcKSkpfChcXEBbLVxcd10rKSQvO1xudmFyIENvbXBpbGVBbmltYXRpb25FbnRyeU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gZGVmaW5pdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YShuYW1lLCBkZWZpbml0aW9ucykge1xuICAgICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSBudWxsOyB9XG4gICAgICAgIGlmIChkZWZpbml0aW9ucyA9PT0gdm9pZCAwKSB7IGRlZmluaXRpb25zID0gbnVsbDsgfVxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhKCkge1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGE7XG59KCkpO1xudmFyIENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uU3RhdGVEZWNsYXJhdGlvbk1ldGFkYXRhLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVOYW1lRXhwclxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YShzdGF0ZU5hbWVFeHByLCBzdHlsZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGVOYW1lRXhwciA9IHN0YXRlTmFtZUV4cHI7XG4gICAgICAgIF90aGlzLnN0eWxlcyA9IHN0eWxlcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcGlsZUFuaW1hdGlvblN0YXRlRGVjbGFyYXRpb25NZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEpKTtcbnZhciBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZUNoYW5nZUV4cHJcbiAgICAgKiBAcGFyYW0gez99IHN0ZXBzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0YXRlVHJhbnNpdGlvbk1ldGFkYXRhKHN0YXRlQ2hhbmdlRXhwciwgc3RlcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGVDaGFuZ2VFeHByID0gc3RhdGVDaGFuZ2VFeHByO1xuICAgICAgICBfdGhpcy5zdGVwcyA9IHN0ZXBzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU3RhdGVUcmFuc2l0aW9uTWV0YWRhdGE7XG59KENvbXBpbGVBbmltYXRpb25TdGF0ZU1ldGFkYXRhKSk7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEoKSB7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uTWV0YWRhdGE7XG59KCkpO1xudmFyIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tcGlsZUFuaW1hdGlvbktleWZyYW1lc1NlcXVlbmNlTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gc3RlcHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YShzdGVwcykge1xuICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IFtdOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25LZXlmcmFtZXNTZXF1ZW5jZU1ldGFkYXRhO1xufShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbnZhciBDb21waWxlQW5pbWF0aW9uU3R5bGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHBhcmFtIHs/PX0gc3R5bGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEob2Zmc2V0LCBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHN0eWxlcyA9PT0gdm9pZCAwKSB7IHN0eWxlcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBfdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25TdHlsZU1ldGFkYXRhO1xufShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbnZhciBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB0aW1pbmdzXG4gICAgICogQHBhcmFtIHs/PX0gc3R5bGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZUFuaW1hdGlvbkFuaW1hdGVNZXRhZGF0YSh0aW1pbmdzLCBzdHlsZXMpIHtcbiAgICAgICAgaWYgKHRpbWluZ3MgPT09IHZvaWQgMCkgeyB0aW1pbmdzID0gMDsgfVxuICAgICAgICBpZiAoc3R5bGVzID09PSB2b2lkIDApIHsgc3R5bGVzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50aW1pbmdzID0gdGltaW5ncztcbiAgICAgICAgX3RoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uQW5pbWF0ZU1ldGFkYXRhO1xufShDb21waWxlQW5pbWF0aW9uTWV0YWRhdGEpKTtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gc3RlcHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlQW5pbWF0aW9uV2l0aFN0ZXBzTWV0YWRhdGEoc3RlcHMpIHtcbiAgICAgICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHsgc3RlcHMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0ZXBzID0gc3RlcHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhKSk7XG52YXIgQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBzdGVwc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25TZXF1ZW5jZU1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uU2VxdWVuY2VNZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG52YXIgQ29tcGlsZUFuaW1hdGlvbkdyb3VwTWV0YWRhdGEgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBzdGVwc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhKHN0ZXBzKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc3RlcHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlQW5pbWF0aW9uR3JvdXBNZXRhZGF0YTtcbn0oQ29tcGlsZUFuaW1hdGlvbldpdGhTdGVwc01ldGFkYXRhKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gbmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3Nhbml0aXplSWRlbnRpZmllcihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXFxXL2csICdfJyk7XG59XG52YXIgX2Fub255bW91c1R5cGVJbmRleCA9IDA7XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcGlsZUlkZW50aWZpZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlkZW50aWZpZXJOYW1lKGNvbXBpbGVJZGVudGlmaWVyKSB7XG4gICAgaWYgKCFjb21waWxlSWRlbnRpZmllciB8fCAhY29tcGlsZUlkZW50aWZpZXIucmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWYgPSBjb21waWxlSWRlbnRpZmllci5yZWZlcmVuY2U7XG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICByZXR1cm4gcmVmLm5hbWU7XG4gICAgfVxuICAgIGlmIChyZWZbJ19fYW5vbnltb3VzVHlwZSddKSB7XG4gICAgICAgIHJldHVybiByZWZbJ19fYW5vbnltb3VzVHlwZSddO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZGVudGlmaWVyID0gybVzdHJpbmdpZnkocmVmKTtcbiAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICAvLyBjYXNlOiBhbm9ueW1vdXMgZnVuY3Rpb25zIVxuICAgICAgICBpZGVudGlmaWVyID0gXCJhbm9ueW1vdXNfXCIgKyBfYW5vbnltb3VzVHlwZUluZGV4Kys7XG4gICAgICAgIHJlZlsnX19hbm9ueW1vdXNUeXBlJ10gPSBpZGVudGlmaWVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWRlbnRpZmllciA9IF9zYW5pdGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIHJldHVybiBpZGVudGlmaWVyO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBpbGVJZGVudGlmaWVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpZGVudGlmaWVyTW9kdWxlVXJsKGNvbXBpbGVJZGVudGlmaWVyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVmID0gY29tcGlsZUlkZW50aWZpZXIucmVmZXJlbmNlO1xuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHJlZi5maWxlUGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIMm1cmVmbGVjdG9yLmltcG9ydFVyaShyZWYpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gKiBAcGFyYW0gez99IGVtYmVkZGVkVGVtcGxhdGVJbmRleFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdmlld0NsYXNzTmFtZShjb21wVHlwZSwgZW1iZWRkZWRUZW1wbGF0ZUluZGV4KSB7XG4gICAgcmV0dXJuIFwiVmlld19cIiArIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KSArIFwiX1wiICsgZW1iZWRkZWRUZW1wbGF0ZUluZGV4O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZW5kZXJlclR5cGVOYW1lKGNvbXBUeXBlKSB7XG4gICAgcmV0dXJuIFwiUmVuZGVyVHlwZV9cIiArIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb21wVHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaG9zdFZpZXdDbGFzc05hbWUoY29tcFR5cGUpIHtcbiAgICByZXR1cm4gXCJIb3N0Vmlld19cIiArIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBkaXJUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkaXJXcmFwcGVyQ2xhc3NOYW1lKGRpclR5cGUpIHtcbiAgICByZXR1cm4gXCJXcmFwcGVyX1wiICsgaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IGRpclR5cGUgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcFR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbXBvbmVudEZhY3RvcnlOYW1lKGNvbXBUeXBlKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXJOYW1lKHsgcmVmZXJlbmNlOiBjb21wVHlwZSB9KSArIFwiTmdGYWN0b3J5XCI7XG59XG52YXIgQ29tcGlsZVN1bW1hcnlLaW5kID0ge307XG5Db21waWxlU3VtbWFyeUtpbmQuUGlwZSA9IDA7XG5Db21waWxlU3VtbWFyeUtpbmQuRGlyZWN0aXZlID0gMTtcbkNvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSA9IDI7XG5Db21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSA9IDM7XG5Db21waWxlU3VtbWFyeUtpbmRbQ29tcGlsZVN1bW1hcnlLaW5kLlBpcGVdID0gXCJQaXBlXCI7XG5Db21waWxlU3VtbWFyeUtpbmRbQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZV0gPSBcIkRpcmVjdGl2ZVwiO1xuQ29tcGlsZVN1bW1hcnlLaW5kW0NvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZV0gPSBcIk5nTW9kdWxlXCI7XG5Db21waWxlU3VtbWFyeUtpbmRbQ29tcGlsZVN1bW1hcnlLaW5kLkluamVjdGFibGVdID0gXCJJbmplY3RhYmxlXCI7XG4vKipcbiAqIEBwYXJhbSB7P30gdG9rZW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRva2VuTmFtZSh0b2tlbikge1xuICAgIHJldHVybiB0b2tlbi52YWx1ZSAhPSBudWxsID8gX3Nhbml0aXplSWRlbnRpZmllcih0b2tlbi52YWx1ZSkgOiBpZGVudGlmaWVyTmFtZSh0b2tlbi5pZGVudGlmaWVyKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB0b2tlblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9rZW5SZWZlcmVuY2UodG9rZW4pIHtcbiAgICBpZiAodG9rZW4uaWRlbnRpZmllciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0b2tlbi5pZGVudGlmaWVyLnJlZmVyZW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbi52YWx1ZTtcbiAgICB9XG59XG4vKipcbiAqIE1ldGFkYXRhIGFib3V0IGEgc3R5bGVzaGVldFxuICovXG52YXIgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbW9kdWxlVXJsID0gX2IubW9kdWxlVXJsLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscztcbiAgICAgICAgdGhpcy5tb2R1bGVVcmwgPSBtb2R1bGVVcmw7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlcyk7XG4gICAgICAgIHRoaXMuc3R5bGVVcmxzID0gX25vcm1hbGl6ZUFycmF5KHN0eWxlVXJscyk7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhO1xufSgpKTtcbi8qKlxuICogTWV0YWRhdGEgcmVnYXJkaW5nIGNvbXBpbGF0aW9uIG9mIGEgdGVtcGxhdGUuXG4gKi9cbnZhciBDb21waWxlVGVtcGxhdGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX18wXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGVuY2Fwc3VsYXRpb24gPSBfYi5lbmNhcHN1bGF0aW9uLCB0ZW1wbGF0ZSA9IF9iLnRlbXBsYXRlLCB0ZW1wbGF0ZVVybCA9IF9iLnRlbXBsYXRlVXJsLCBzdHlsZXMgPSBfYi5zdHlsZXMsIHN0eWxlVXJscyA9IF9iLnN0eWxlVXJscywgZXh0ZXJuYWxTdHlsZXNoZWV0cyA9IF9iLmV4dGVybmFsU3R5bGVzaGVldHMsIGFuaW1hdGlvbnMgPSBfYi5hbmltYXRpb25zLCBuZ0NvbnRlbnRTZWxlY3RvcnMgPSBfYi5uZ0NvbnRlbnRTZWxlY3RvcnMsIGludGVycG9sYXRpb24gPSBfYi5pbnRlcnBvbGF0aW9uLCBpc0lubGluZSA9IF9iLmlzSW5saW5lO1xuICAgICAgICB0aGlzLmVuY2Fwc3VsYXRpb24gPSBlbmNhcHN1bGF0aW9uO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMudGVtcGxhdGVVcmwgPSB0ZW1wbGF0ZVVybDtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBfbm9ybWFsaXplQXJyYXkoc3R5bGVzKTtcbiAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBfbm9ybWFsaXplQXJyYXkoc3R5bGVVcmxzKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbFN0eWxlc2hlZXRzID0gX25vcm1hbGl6ZUFycmF5KGV4dGVybmFsU3R5bGVzaGVldHMpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zID8gZmxhdHRlbihhbmltYXRpb25zKSA6IFtdO1xuICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IG5nQ29udGVudFNlbGVjdG9ycyB8fCBbXTtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb24gJiYgaW50ZXJwb2xhdGlvbi5sZW5ndGggIT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2ludGVycG9sYXRpb24nIHNob3VsZCBoYXZlIGEgc3RhcnQgYW5kIGFuIGVuZCBzeW1ib2wuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG4gICAgICAgIHRoaXMuaXNJbmxpbmUgPSBpc0lubGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlVGVtcGxhdGVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW5pbWF0aW9uczogdGhpcy5hbmltYXRpb25zLm1hcChmdW5jdGlvbiAoYW5pbSkgeyByZXR1cm4gYW5pbS5uYW1lOyB9KSxcbiAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogdGhpcy5uZ0NvbnRlbnRTZWxlY3RvcnMsXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiB0aGlzLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGE7XG59KCkpO1xuLyoqXG4gKiBNZXRhZGF0YSByZWdhcmRpbmcgY29tcGlsYXRpb24gb2YgYSBkaXJlY3RpdmUuXG4gKi9cbnZhciBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgaXNIb3N0ID0gX2IuaXNIb3N0LCB0eXBlID0gX2IudHlwZSwgaXNDb21wb25lbnQgPSBfYi5pc0NvbXBvbmVudCwgc2VsZWN0b3IgPSBfYi5zZWxlY3RvciwgZXhwb3J0QXMgPSBfYi5leHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uID0gX2IuY2hhbmdlRGV0ZWN0aW9uLCBpbnB1dHMgPSBfYi5pbnB1dHMsIG91dHB1dHMgPSBfYi5vdXRwdXRzLCBob3N0TGlzdGVuZXJzID0gX2IuaG9zdExpc3RlbmVycywgaG9zdFByb3BlcnRpZXMgPSBfYi5ob3N0UHJvcGVydGllcywgaG9zdEF0dHJpYnV0ZXMgPSBfYi5ob3N0QXR0cmlidXRlcywgcHJvdmlkZXJzID0gX2IucHJvdmlkZXJzLCB2aWV3UHJvdmlkZXJzID0gX2Iudmlld1Byb3ZpZGVycywgcXVlcmllcyA9IF9iLnF1ZXJpZXMsIHZpZXdRdWVyaWVzID0gX2Iudmlld1F1ZXJpZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9iLmVudHJ5Q29tcG9uZW50cywgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZSwgY29tcG9uZW50Vmlld1R5cGUgPSBfYi5jb21wb25lbnRWaWV3VHlwZSwgcmVuZGVyZXJUeXBlID0gX2IucmVuZGVyZXJUeXBlLCBjb21wb25lbnRGYWN0b3J5ID0gX2IuY29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgdGhpcy5pc0hvc3QgPSAhIWlzSG9zdDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pc0NvbXBvbmVudCA9IGlzQ29tcG9uZW50O1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZXhwb3J0QXMgPSBleHBvcnRBcztcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rpb24gPSBjaGFuZ2VEZXRlY3Rpb247XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLmhvc3RMaXN0ZW5lcnMgPSBob3N0TGlzdGVuZXJzO1xuICAgICAgICB0aGlzLmhvc3RQcm9wZXJ0aWVzID0gaG9zdFByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuaG9zdEF0dHJpYnV0ZXMgPSBob3N0QXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBfbm9ybWFsaXplQXJyYXkocHJvdmlkZXJzKTtcbiAgICAgICAgdGhpcy52aWV3UHJvdmlkZXJzID0gX25vcm1hbGl6ZUFycmF5KHZpZXdQcm92aWRlcnMpO1xuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBfbm9ybWFsaXplQXJyYXkocXVlcmllcyk7XG4gICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfbm9ybWFsaXplQXJyYXkodmlld1F1ZXJpZXMpO1xuICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50cyA9IF9ub3JtYWxpemVBcnJheShlbnRyeUNvbXBvbmVudHMpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Vmlld1R5cGUgPSBjb21wb25lbnRWaWV3VHlwZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlclR5cGUgPSByZW5kZXJlclR5cGU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeSA9IGNvbXBvbmVudEZhY3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgaXNIb3N0ID0gX2IuaXNIb3N0LCB0eXBlID0gX2IudHlwZSwgaXNDb21wb25lbnQgPSBfYi5pc0NvbXBvbmVudCwgc2VsZWN0b3IgPSBfYi5zZWxlY3RvciwgZXhwb3J0QXMgPSBfYi5leHBvcnRBcywgY2hhbmdlRGV0ZWN0aW9uID0gX2IuY2hhbmdlRGV0ZWN0aW9uLCBpbnB1dHMgPSBfYi5pbnB1dHMsIG91dHB1dHMgPSBfYi5vdXRwdXRzLCBob3N0ID0gX2IuaG9zdCwgcHJvdmlkZXJzID0gX2IucHJvdmlkZXJzLCB2aWV3UHJvdmlkZXJzID0gX2Iudmlld1Byb3ZpZGVycywgcXVlcmllcyA9IF9iLnF1ZXJpZXMsIHZpZXdRdWVyaWVzID0gX2Iudmlld1F1ZXJpZXMsIGVudHJ5Q29tcG9uZW50cyA9IF9iLmVudHJ5Q29tcG9uZW50cywgdGVtcGxhdGUgPSBfYi50ZW1wbGF0ZSwgY29tcG9uZW50Vmlld1R5cGUgPSBfYi5jb21wb25lbnRWaWV3VHlwZSwgcmVuZGVyZXJUeXBlID0gX2IucmVuZGVyZXJUeXBlLCBjb21wb25lbnRGYWN0b3J5ID0gX2IuY29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdExpc3RlbmVycyA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0UHJvcGVydGllcyA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0QXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAoaG9zdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhob3N0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGhvc3Rba2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGVzID0ga2V5Lm1hdGNoKEhPU1RfUkVHX0VYUCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGVzWzFdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdFByb3BlcnRpZXNbbWF0Y2hlc1sxXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hlc1syXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnNbbWF0Y2hlc1syXV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dHNNYXAgPSB7fTtcbiAgICAgICAgaWYgKGlucHV0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoYmluZENvbmZpZykge1xuICAgICAgICAgICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBlbFByb3BgXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gc3BsaXRBdENvbG9uKGJpbmRDb25maWcsIFtiaW5kQ29uZmlnLCBiaW5kQ29uZmlnXSk7XG4gICAgICAgICAgICAgICAgaW5wdXRzTWFwW3BhcnRzWzBdXSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0c01hcCA9IHt9O1xuICAgICAgICBpZiAob3V0cHV0cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXRwdXRzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRDb25maWcpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5vbmljYWwgc3ludGF4OiBgZGlyUHJvcDogZWxQcm9wYFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGA6YCwgdXNlIGRpclByb3AgPSBlbFByb3BcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IHNwbGl0QXRDb2xvbihiaW5kQ29uZmlnLCBbYmluZENvbmZpZywgYmluZENvbmZpZ10pO1xuICAgICAgICAgICAgICAgIG91dHB1dHNNYXBbcGFydHNbMF1dID0gcGFydHNbMV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSh7XG4gICAgICAgICAgICBpc0hvc3Q6IGlzSG9zdCxcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBpc0NvbXBvbmVudDogISFpc0NvbXBvbmVudCwgc2VsZWN0b3I6IHNlbGVjdG9yLCBleHBvcnRBczogZXhwb3J0QXMsIGNoYW5nZURldGVjdGlvbjogY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHNNYXAsXG4gICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzTWFwLFxuICAgICAgICAgICAgaG9zdExpc3RlbmVyczogaG9zdExpc3RlbmVycyxcbiAgICAgICAgICAgIGhvc3RQcm9wZXJ0aWVzOiBob3N0UHJvcGVydGllcyxcbiAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzOiBob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzLFxuICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogdmlld1Byb3ZpZGVycyxcbiAgICAgICAgICAgIHF1ZXJpZXM6IHF1ZXJpZXMsXG4gICAgICAgICAgICB2aWV3UXVlcmllczogdmlld1F1ZXJpZXMsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IGVudHJ5Q29tcG9uZW50cyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXdUeXBlOiBjb21wb25lbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZTogcmVuZGVyZXJUeXBlLFxuICAgICAgICAgICAgY29tcG9uZW50RmFjdG9yeTogY29tcG9uZW50RmFjdG9yeSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VtbWFyeUtpbmQ6IENvbXBpbGVTdW1tYXJ5S2luZC5EaXJlY3RpdmUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBpc0NvbXBvbmVudDogdGhpcy5pc0NvbXBvbmVudCxcbiAgICAgICAgICAgIHNlbGVjdG9yOiB0aGlzLnNlbGVjdG9yLFxuICAgICAgICAgICAgZXhwb3J0QXM6IHRoaXMuZXhwb3J0QXMsXG4gICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLFxuICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgaG9zdExpc3RlbmVyczogdGhpcy5ob3N0TGlzdGVuZXJzLFxuICAgICAgICAgICAgaG9zdFByb3BlcnRpZXM6IHRoaXMuaG9zdFByb3BlcnRpZXMsXG4gICAgICAgICAgICBob3N0QXR0cmlidXRlczogdGhpcy5ob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogdGhpcy5wcm92aWRlcnMsXG4gICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiB0aGlzLnZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICBxdWVyaWVzOiB0aGlzLnF1ZXJpZXMsXG4gICAgICAgICAgICB2aWV3UXVlcmllczogdGhpcy52aWV3UXVlcmllcyxcbiAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogdGhpcy5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IHRoaXMuY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMudGVtcGxhdGUgJiYgdGhpcy50ZW1wbGF0ZS50b1N1bW1hcnkoKSxcbiAgICAgICAgICAgIGNvbXBvbmVudFZpZXdUeXBlOiB0aGlzLmNvbXBvbmVudFZpZXdUeXBlLFxuICAgICAgICAgICAgcmVuZGVyZXJUeXBlOiB0aGlzLnJlbmRlcmVyVHlwZSxcbiAgICAgICAgICAgIGNvbXBvbmVudEZhY3Rvcnk6IHRoaXMuY29tcG9uZW50RmFjdG9yeVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIENvbnN0cnVjdCB7XFxAbGluayBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGF9IGZyb20ge1xcQGxpbmsgQ29tcG9uZW50VHlwZU1ldGFkYXRhfSBhbmQgYSBzZWxlY3Rvci5cbiAqIEBwYXJhbSB7P30gaG9zdFR5cGVSZWZlcmVuY2VcbiAqIEBwYXJhbSB7P30gY29tcE1ldGFcbiAqIEBwYXJhbSB7P30gaG9zdFZpZXdUeXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YShob3N0VHlwZVJlZmVyZW5jZSwgY29tcE1ldGEsIGhvc3RWaWV3VHlwZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlID0gQ3NzU2VsZWN0b3IucGFyc2UoY29tcE1ldGEuc2VsZWN0b3IpWzBdLmdldE1hdGNoaW5nRWxlbWVudFRlbXBsYXRlKCk7XG4gICAgcmV0dXJuIENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YS5jcmVhdGUoe1xuICAgICAgICBpc0hvc3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IHsgcmVmZXJlbmNlOiBob3N0VHlwZVJlZmVyZW5jZSwgZGlEZXBzOiBbXSwgbGlmZWN5Y2xlSG9va3M6IFtdIH0sXG4gICAgICAgIHRlbXBsYXRlOiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnJyxcbiAgICAgICAgICAgIHN0eWxlczogW10sXG4gICAgICAgICAgICBzdHlsZVVybHM6IFtdLFxuICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiBbXSxcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgICAgICAgICAgaXNJbmxpbmU6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsXG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgICBob3N0OiB7fSxcbiAgICAgICAgaXNDb21wb25lbnQ6IHRydWUsXG4gICAgICAgIHNlbGVjdG9yOiAnKicsXG4gICAgICAgIHByb3ZpZGVyczogW10sXG4gICAgICAgIHZpZXdQcm92aWRlcnM6IFtdLFxuICAgICAgICBxdWVyaWVzOiBbXSxcbiAgICAgICAgdmlld1F1ZXJpZXM6IFtdLFxuICAgICAgICBjb21wb25lbnRWaWV3VHlwZTogaG9zdFZpZXdUeXBlLFxuICAgICAgICByZW5kZXJlclR5cGU6IHsgaWQ6ICdfX0hvc3RfXycsIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsIHN0eWxlczogW10sIGRhdGE6IHt9IH1cbiAgICB9KTtcbn1cbnZhciBDb21waWxlUGlwZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBfXzBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlUGlwZU1ldGFkYXRhKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0eXBlID0gX2IudHlwZSwgbmFtZSA9IF9iLm5hbWUsIHB1cmUgPSBfYi5wdXJlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnB1cmUgPSAhIXB1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZVBpcGVNZXRhZGF0YS5wcm90b3R5cGUudG9TdW1tYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VtbWFyeUtpbmQ6IENvbXBpbGVTdW1tYXJ5S2luZC5QaXBlLFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgcHVyZTogdGhpcy5wdXJlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZVBpcGVNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIE1ldGFkYXRhIHJlZ2FyZGluZyBjb21waWxhdGlvbiBvZiBhIG1vZHVsZS5cbiAqL1xudmFyIENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBfXzBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb21waWxlTmdNb2R1bGVNZXRhZGF0YShfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgdHlwZSA9IF9iLnR5cGUsIHByb3ZpZGVycyA9IF9iLnByb3ZpZGVycywgZGVjbGFyZWREaXJlY3RpdmVzID0gX2IuZGVjbGFyZWREaXJlY3RpdmVzLCBleHBvcnRlZERpcmVjdGl2ZXMgPSBfYi5leHBvcnRlZERpcmVjdGl2ZXMsIGRlY2xhcmVkUGlwZXMgPSBfYi5kZWNsYXJlZFBpcGVzLCBleHBvcnRlZFBpcGVzID0gX2IuZXhwb3J0ZWRQaXBlcywgZW50cnlDb21wb25lbnRzID0gX2IuZW50cnlDb21wb25lbnRzLCBib290c3RyYXBDb21wb25lbnRzID0gX2IuYm9vdHN0cmFwQ29tcG9uZW50cywgaW1wb3J0ZWRNb2R1bGVzID0gX2IuaW1wb3J0ZWRNb2R1bGVzLCBleHBvcnRlZE1vZHVsZXMgPSBfYi5leHBvcnRlZE1vZHVsZXMsIHNjaGVtYXMgPSBfYi5zY2hlbWFzLCB0cmFuc2l0aXZlTW9kdWxlID0gX2IudHJhbnNpdGl2ZU1vZHVsZSwgaWQgPSBfYi5pZDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5kZWNsYXJlZERpcmVjdGl2ZXMgPSBfbm9ybWFsaXplQXJyYXkoZGVjbGFyZWREaXJlY3RpdmVzKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWREaXJlY3RpdmVzKTtcbiAgICAgICAgdGhpcy5kZWNsYXJlZFBpcGVzID0gX25vcm1hbGl6ZUFycmF5KGRlY2xhcmVkUGlwZXMpO1xuICAgICAgICB0aGlzLmV4cG9ydGVkUGlwZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWRQaXBlcyk7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gX25vcm1hbGl6ZUFycmF5KHByb3ZpZGVycyk7XG4gICAgICAgIHRoaXMuZW50cnlDb21wb25lbnRzID0gX25vcm1hbGl6ZUFycmF5KGVudHJ5Q29tcG9uZW50cyk7XG4gICAgICAgIHRoaXMuYm9vdHN0cmFwQ29tcG9uZW50cyA9IF9ub3JtYWxpemVBcnJheShib290c3RyYXBDb21wb25lbnRzKTtcbiAgICAgICAgdGhpcy5pbXBvcnRlZE1vZHVsZXMgPSBfbm9ybWFsaXplQXJyYXkoaW1wb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZE1vZHVsZXMgPSBfbm9ybWFsaXplQXJyYXkoZXhwb3J0ZWRNb2R1bGVzKTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gX25vcm1hbGl6ZUFycmF5KHNjaGVtYXMpO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHJhbnNpdGl2ZU1vZHVsZSA9IHRyYW5zaXRpdmVNb2R1bGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLnRvU3VtbWFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1bW1hcnlLaW5kOiBDb21waWxlU3VtbWFyeUtpbmQuTmdNb2R1bGUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IHRoaXMudHJhbnNpdGl2ZU1vZHVsZS5lbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICBwcm92aWRlcnM6IHRoaXMudHJhbnNpdGl2ZU1vZHVsZS5wcm92aWRlcnMsXG4gICAgICAgICAgICBtb2R1bGVzOiB0aGlzLnRyYW5zaXRpdmVNb2R1bGUubW9kdWxlcyxcbiAgICAgICAgICAgIGV4cG9ydGVkRGlyZWN0aXZlczogdGhpcy50cmFuc2l0aXZlTW9kdWxlLmV4cG9ydGVkRGlyZWN0aXZlcyxcbiAgICAgICAgICAgIGV4cG9ydGVkUGlwZXM6IHRoaXMudHJhbnNpdGl2ZU1vZHVsZS5leHBvcnRlZFBpcGVzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGE7XG59KCkpO1xudmFyIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKCkge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICB0aGlzLmV4cG9ydGVkRGlyZWN0aXZlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5waXBlc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5waXBlcyA9IFtdO1xuICAgICAgICB0aGlzLmV4cG9ydGVkUGlwZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZXhwb3J0ZWRQaXBlcyA9IFtdO1xuICAgICAgICB0aGlzLm1vZHVsZXNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMubW9kdWxlcyA9IFtdO1xuICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50c1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5lbnRyeUNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZFByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyLCBtb2R1bGUpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMucHVzaCh7IHByb3ZpZGVyOiBwcm92aWRlciwgbW9kdWxlOiBtb2R1bGUgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZERpcmVjdGl2ZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlyZWN0aXZlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZEV4cG9ydGVkRGlyZWN0aXZlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5leHBvcnRlZERpcmVjdGl2ZXNTZXQuaGFzKGlkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZERpcmVjdGl2ZXMucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YS5wcm90b3R5cGUuYWRkUGlwZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMucGlwZXNTZXQuaGFzKGlkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgIHRoaXMucGlwZXNTZXQuYWRkKGlkLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICB0aGlzLnBpcGVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZEV4cG9ydGVkUGlwZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuZXhwb3J0ZWRQaXBlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5leHBvcnRlZFBpcGVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZE1vZHVsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMubW9kdWxlc1NldC5oYXMoaWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5tb2R1bGVzU2V0LmFkZChpZC5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgdGhpcy5tb2R1bGVzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVjXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEucHJvdG90eXBlLmFkZEVudHJ5Q29tcG9uZW50ID0gZnVuY3Rpb24gKGVjKSB7XG4gICAgICAgIGlmICghdGhpcy5lbnRyeUNvbXBvbmVudHNTZXQuaGFzKGVjLmNvbXBvbmVudFR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50c1NldC5hZGQoZWMuY29tcG9uZW50VHlwZSk7XG4gICAgICAgICAgICB0aGlzLmVudHJ5Q29tcG9uZW50cy5wdXNoKGVjKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zaXRpdmVDb21waWxlTmdNb2R1bGVNZXRhZGF0YTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gb2JqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfbm9ybWFsaXplQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIG9iaiB8fCBbXTtcbn1cbnZhciBQcm92aWRlck1ldGEgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcGFyYW0gez99IF9fMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByb3ZpZGVyTWV0YSh0b2tlbiwgX2EpIHtcbiAgICAgICAgdmFyIHVzZUNsYXNzID0gX2EudXNlQ2xhc3MsIHVzZVZhbHVlID0gX2EudXNlVmFsdWUsIHVzZUV4aXN0aW5nID0gX2EudXNlRXhpc3RpbmcsIHVzZUZhY3RvcnkgPSBfYS51c2VGYWN0b3J5LCBkZXBzID0gX2EuZGVwcywgbXVsdGkgPSBfYS5tdWx0aTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLnVzZUNsYXNzID0gdXNlQ2xhc3M7XG4gICAgICAgIHRoaXMudXNlVmFsdWUgPSB1c2VWYWx1ZTtcbiAgICAgICAgdGhpcy51c2VFeGlzdGluZyA9IHVzZUV4aXN0aW5nO1xuICAgICAgICB0aGlzLnVzZUZhY3RvcnkgPSB1c2VGYWN0b3J5O1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcHM7XG4gICAgICAgIHRoaXMubXVsdGkgPSAhIW11bHRpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJNZXRhO1xufSgpKTtcbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7P30gbGlzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihsaXN0KSB7XG4gICAgcmV0dXJuIGxpc3QucmVkdWNlKGZ1bmN0aW9uIChmbGF0LCBpdGVtKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYXRJdGVtID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IGZsYXR0ZW4oaXRlbSkgOiBpdGVtO1xuICAgICAgICByZXR1cm4gKChmbGF0KSkuY29uY2F0KGZsYXRJdGVtKTtcbiAgICB9LCBbXSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdXJsXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzb3VyY2VVcmwodXJsKSB7XG4gICAgLy8gTm90ZTogV2UgbmVlZCAzIFwiL1wiIHNvIHRoYXQgbmcgc2hvd3MgdXAgYXMgYSBzZXBhcmF0ZSBkb21haW5cbiAgICAvLyBpbiB0aGUgY2hyb21lIGRldiB0b29scy5cbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoLyhcXHcrOlxcL1xcL1tcXHc6LV0rKT8oXFwvKyk/LywgJ25nOi8vLycpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5nTW9kdWxlVHlwZVxuICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICogQHBhcmFtIHs/fSB0ZW1wbGF0ZU1ldGFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlU291cmNlVXJsKG5nTW9kdWxlVHlwZSwgY29tcE1ldGEsIHRlbXBsYXRlTWV0YSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybDtcbiAgICBpZiAodGVtcGxhdGVNZXRhLmlzSW5saW5lKSB7XG4gICAgICAgIGlmIChjb21wTWV0YS50eXBlLnJlZmVyZW5jZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgLy8gTm90ZTogYSAudHMgZmlsZSBtaWdodCBjb250YWluIG11bHRpcGxlIGNvbXBvbmVudHMgd2l0aCBpbmxpbmUgdGVtcGxhdGVzLFxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBnaXZlIHRoZW0gdW5pcXVlIHVybHMsIGFzIHRoZXNlIHdpbGwgYmUgdXNlZCBmb3Igc291cmNlbWFwcy5cbiAgICAgICAgICAgIHVybCA9IGNvbXBNZXRhLnR5cGUucmVmZXJlbmNlLmZpbGVQYXRoICsgXCIuXCIgKyBjb21wTWV0YS50eXBlLnJlZmVyZW5jZS5uYW1lICsgXCIuaHRtbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXJsID0gaWRlbnRpZmllck5hbWUobmdNb2R1bGVUeXBlKSArIFwiL1wiICsgaWRlbnRpZmllck5hbWUoY29tcE1ldGEudHlwZSkgKyBcIi5odG1sXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVybCA9IHRlbXBsYXRlTWV0YS50ZW1wbGF0ZVVybDtcbiAgICB9XG4gICAgLy8gYWx3YXlzIHByZXBlbmQgbmc6Ly8gdG8gbWFrZSBhbmd1bGFyIHJlc291cmNlcyBlYXN5IHRvIGZpbmQgYW5kIG5vdCBjbG9iYmVyXG4gICAgLy8gdXNlciByZXNvdXJjZXMuXG4gICAgcmV0dXJuIHNvdXJjZVVybCh1cmwpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG1ldGFcbiAqIEBwYXJhbSB7P30gaWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNoYXJlZFN0eWxlc2hlZXRKaXRVcmwobWV0YSwgaWQpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXRoUGFydHMgPSBtZXRhLm1vZHVsZVVybC5zcGxpdCgvXFwvXFxcXC9nKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlTmFtZSA9IHBhdGhQYXJ0c1twYXRoUGFydHMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHNvdXJjZVVybChcImNzcy9cIiArIGlkICsgYmFzZU5hbWUgKyBcIi5uZ3N0eWxlLmpzXCIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG1vZHVsZU1ldGFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5nTW9kdWxlSml0VXJsKG1vZHVsZU1ldGEpIHtcbiAgICByZXR1cm4gc291cmNlVXJsKGlkZW50aWZpZXJOYW1lKG1vZHVsZU1ldGEudHlwZSkgKyBcIi9tb2R1bGUubmdmYWN0b3J5LmpzXCIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5nTW9kdWxlVHlwZVxuICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGVKaXRVcmwobmdNb2R1bGVUeXBlLCBjb21wTWV0YSkge1xuICAgIHJldHVybiBzb3VyY2VVcmwoaWRlbnRpZmllck5hbWUobmdNb2R1bGVUeXBlKSArIFwiL1wiICsgaWRlbnRpZmllck5hbWUoY29tcE1ldGEudHlwZSkgKyBcIi5uZ2ZhY3RvcnkuanNcIik7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQ29tcGlsZXJDb25maWcgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVyQ29uZmlnKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLmRlZmF1bHRFbmNhcHN1bGF0aW9uLCBkZWZhdWx0RW5jYXBzdWxhdGlvbiA9IF9jID09PSB2b2lkIDAgPyBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCA6IF9jLCBfZCA9IF9iLnVzZUppdCwgdXNlSml0ID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZCwgbWlzc2luZ1RyYW5zbGF0aW9uID0gX2IubWlzc2luZ1RyYW5zbGF0aW9uLCBlbmFibGVMZWdhY3lUZW1wbGF0ZSA9IF9iLmVuYWJsZUxlZ2FjeVRlbXBsYXRlO1xuICAgICAgICB0aGlzLmRlZmF1bHRFbmNhcHN1bGF0aW9uID0gZGVmYXVsdEVuY2Fwc3VsYXRpb247XG4gICAgICAgIHRoaXMudXNlSml0ID0gdXNlSml0O1xuICAgICAgICB0aGlzLm1pc3NpbmdUcmFuc2xhdGlvbiA9IG1pc3NpbmdUcmFuc2xhdGlvbjtcbiAgICAgICAgdGhpcy5lbmFibGVMZWdhY3lUZW1wbGF0ZSA9IGVuYWJsZUxlZ2FjeVRlbXBsYXRlICE9PSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVyQ29uZmlnO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBQYXJzZXJFcnJvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gZXJyTG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBjdHhMb2NhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmVyckxvY2F0aW9uID0gZXJyTG9jYXRpb247XG4gICAgICAgIHRoaXMuY3R4TG9jYXRpb24gPSBjdHhMb2NhdGlvbjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJQYXJzZXIgRXJyb3I6IFwiICsgbWVzc2FnZSArIFwiIFwiICsgZXJyTG9jYXRpb24gKyBcIiBbXCIgKyBpbnB1dCArIFwiXSBpbiBcIiArIGN0eExvY2F0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VyRXJyb3I7XG59KCkpO1xudmFyIFBhcnNlU3BhbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEBwYXJhbSB7P30gZW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VTcGFuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlU3Bhbjtcbn0oKSk7XG52YXIgQVNUID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBU1Qoc3Bhbikge1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBU1QucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQVNULnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdBU1QnOyB9O1xuICAgIHJldHVybiBBU1Q7XG59KCkpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcXVvdGVkIGV4cHJlc3Npb24gb2YgdGhlIGZvcm06XG4gKlxuICogcXVvdGUgPSBwcmVmaXggYDpgIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uXG4gKiBwcmVmaXggPSBpZGVudGlmaWVyXG4gKiB1bmludGVycHJldGVkRXhwcmVzc2lvbiA9IGFyYml0cmFyeSBzdHJpbmdcbiAqXG4gKiBBIHF1b3RlZCBleHByZXNzaW9uIGlzIG1lYW50IHRvIGJlIHByZS1wcm9jZXNzZWQgYnkgYW4gQVNUIHRyYW5zZm9ybWVyIHRoYXRcbiAqIGNvbnZlcnRzIGl0IGludG8gYW5vdGhlciBBU1QgdGhhdCBubyBsb25nZXIgY29udGFpbnMgcXVvdGVkIGV4cHJlc3Npb25zLlxuICogSXQgaXMgbWVhbnQgdG8gYWxsb3cgdGhpcmQtcGFydHkgZGV2ZWxvcGVycyB0byBleHRlbmQgQW5ndWxhciB0ZW1wbGF0ZVxuICogZXhwcmVzc2lvbiBsYW5ndWFnZS4gVGhlIGB1bmludGVycHJldGVkRXhwcmVzc2lvbmAgcGFydCBvZiB0aGUgcXVvdGUgaXNcbiAqIHRoZXJlZm9yZSBub3QgaW50ZXJwcmV0ZWQgYnkgdGhlIEFuZ3VsYXIncyBvd24gZXhwcmVzc2lvbiBwYXJzZXIuXG4gKi9cbnZhciBRdW90ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFF1b3RlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gcHJlZml4XG4gICAgICogQHBhcmFtIHs/fSB1bmludGVycHJldGVkRXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBRdW90ZShzcGFuLCBwcmVmaXgsIHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uLCBsb2NhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIF90aGlzLnVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uID0gdW5pbnRlcnByZXRlZEV4cHJlc3Npb247XG4gICAgICAgIF90aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUXVvdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFF1b3RlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBRdW90ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnUXVvdGUnOyB9O1xuICAgIHJldHVybiBRdW90ZTtcbn0oQVNUKSk7XG52YXIgRW1wdHlFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW1wdHlFeHByLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtcHR5RXhwcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbXB0eUV4cHIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfTtcbiAgICByZXR1cm4gRW1wdHlFeHByO1xufShBU1QpKTtcbnZhciBJbXBsaWNpdFJlY2VpdmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW1wbGljaXRSZWNlaXZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbXBsaWNpdFJlY2VpdmVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEltcGxpY2l0UmVjZWl2ZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEltcGxpY2l0UmVjZWl2ZXIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW1wbGljaXRSZWNlaXZlcjtcbn0oQVNUKSk7XG4vKipcbiAqIE11bHRpcGxlIGV4cHJlc3Npb25zIHNlcGFyYXRlZCBieSBhIHNlbWljb2xvbi5cbiAqL1xudmFyIENoYWluID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2hhaW4sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENoYWluKHNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2hhaW4ucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENoYWluKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENoYWluO1xufShBU1QpKTtcbnZhciBDb25kaXRpb25hbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmRpdGlvbmFsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHs/fSB0cnVlRXhwXG4gICAgICogQHBhcmFtIHs/fSBmYWxzZUV4cFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsKHNwYW4sIGNvbmRpdGlvbiwgdHJ1ZUV4cCwgZmFsc2VFeHApIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICBfdGhpcy50cnVlRXhwID0gdHJ1ZUV4cDtcbiAgICAgICAgX3RoaXMuZmFsc2VFeHAgPSBmYWxzZUV4cDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25kaXRpb25hbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWwodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uZGl0aW9uYWw7XG59KEFTVCkpO1xudmFyIFByb3BlcnR5UmVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3BlcnR5UmVhZCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3BlcnR5UmVhZC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJvcGVydHlSZWFkKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3BlcnR5UmVhZDtcbn0oQVNUKSk7XG52YXIgUHJvcGVydHlXcml0ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3BlcnR5V3JpdGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSByZWNlaXZlclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcm9wZXJ0eVdyaXRlKHNwYW4sIHJlY2VpdmVyLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcm9wZXJ0eVdyaXRlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVdyaXRlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3BlcnR5V3JpdGU7XG59KEFTVCkpO1xudmFyIFNhZmVQcm9wZXJ0eVJlYWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYWZlUHJvcGVydHlSZWFkLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTYWZlUHJvcGVydHlSZWFkKHNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNhZmVQcm9wZXJ0eVJlYWQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FmZVByb3BlcnR5UmVhZDtcbn0oQVNUKSk7XG52YXIgS2V5ZWRSZWFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5ZWRSZWFkLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gb2JqXG4gICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBLZXllZFJlYWQoc3Bhbiwgb2JqLCBrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub2JqID0gb2JqO1xuICAgICAgICBfdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgS2V5ZWRSZWFkLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5ZWRSZWFkO1xufShBU1QpKTtcbnZhciBLZXllZFdyaXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5ZWRXcml0ZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG9ialxuICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEtleWVkV3JpdGUoc3Bhbiwgb2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9iaiA9IG9iajtcbiAgICAgICAgX3RoaXMua2V5ID0ga2V5O1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEtleWVkV3JpdGUucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWVkV3JpdGUodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gS2V5ZWRXcml0ZTtcbn0oQVNUKSk7XG52YXIgQmluZGluZ1BpcGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaW5kaW5nUGlwZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGV4cFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJpbmRpbmdQaXBlKHNwYW4sIGV4cCwgbmFtZSwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5leHAgPSBleHA7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGlwZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UGlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5kaW5nUGlwZTtcbn0oQVNUKSk7XG52YXIgTGl0ZXJhbFByaW1pdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxQcmltaXRpdmUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxQcmltaXRpdmUoc3BhbiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXRlcmFsUHJpbWl0aXZlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsUHJpbWl0aXZlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIExpdGVyYWxQcmltaXRpdmU7XG59KEFTVCkpO1xudmFyIExpdGVyYWxBcnJheSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxBcnJheSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGl0ZXJhbEFycmF5KHNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGl0ZXJhbEFycmF5LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsQXJyYXkodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTGl0ZXJhbEFycmF5O1xufShBU1QpKTtcbnZhciBMaXRlcmFsTWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGl0ZXJhbE1hcCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGtleXNcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxNYXAoc3Bhbiwga2V5cywgdmFsdWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmtleXMgPSBrZXlzO1xuICAgICAgICBfdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGl0ZXJhbE1hcC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsTWFwO1xufShBU1QpKTtcbnZhciBJbnRlcnBvbGF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW50ZXJwb2xhdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHN0cmluZ3NcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW50ZXJwb2xhdGlvbihzcGFuLCBzdHJpbmdzLCBleHByZXNzaW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgX3RoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJbnRlcnBvbGF0aW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnRlcnBvbGF0aW9uKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEludGVycG9sYXRpb247XG59KEFTVCkpO1xudmFyIEJpbmFyeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJpbmFyeSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7P30gbGVmdFxuICAgICAqIEBwYXJhbSB7P30gcmlnaHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCaW5hcnkoc3Bhbiwgb3BlcmF0aW9uLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIF90aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICBfdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmFyeS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmFyeTtcbn0oQVNUKSk7XG52YXIgUHJlZml4Tm90ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJlZml4Tm90LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByZWZpeE5vdChzcGFuLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByZWZpeE5vdC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJlZml4Tm90KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFByZWZpeE5vdDtcbn0oQVNUKSk7XG52YXIgTWV0aG9kQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1ldGhvZENhbGwsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSByZWNlaXZlclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXJnc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1ldGhvZENhbGwucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE1ldGhvZENhbGwodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWV0aG9kQ2FsbDtcbn0oQVNUKSk7XG52YXIgU2FmZU1ldGhvZENhbGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYWZlTWV0aG9kQ2FsbCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2FmZU1ldGhvZENhbGwoc3BhbiwgcmVjZWl2ZXIsIG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNhZmVNZXRob2RDYWxsLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlTWV0aG9kQ2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBTYWZlTWV0aG9kQ2FsbDtcbn0oQVNUKSk7XG52YXIgRnVuY3Rpb25DYWxsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVuY3Rpb25DYWxsLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRnVuY3Rpb25DYWxsKHNwYW4sIHRhcmdldCwgYXJncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25DYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bmN0aW9uQ2FsbDtcbn0oQVNUKSk7XG52YXIgQVNUV2l0aFNvdXJjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFTVFdpdGhTb3VyY2UsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFTVFdpdGhTb3VyY2UoYXN0LCBzb3VyY2UsIGxvY2F0aW9uLCBlcnJvcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV3IFBhcnNlU3BhbigwLCBzb3VyY2UgPT0gbnVsbCA/IDAgOiBzb3VyY2UubGVuZ3RoKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYXN0ID0gYXN0O1xuICAgICAgICBfdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIF90aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIF90aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBU1RXaXRoU291cmNlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBU1RXaXRoU291cmNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc291cmNlICsgXCIgaW4gXCIgKyB0aGlzLmxvY2F0aW9uOyB9O1xuICAgIHJldHVybiBBU1RXaXRoU291cmNlO1xufShBU1QpKTtcbnZhciBUZW1wbGF0ZUJpbmRpbmcgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3BhblxuICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICogQHBhcmFtIHs/fSBrZXlJc1ZhclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlQmluZGluZyhzcGFuLCBrZXksIGtleUlzVmFyLCBuYW1lLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmtleUlzVmFyID0ga2V5SXNWYXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHJldHVybiBUZW1wbGF0ZUJpbmRpbmc7XG59KCkpO1xudmFyIFJlY3Vyc2l2ZUFzdFZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZUFzdFZpc2l0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmxlZnQudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC5yaWdodC52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgYXN0LnRydWVFeHAudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuZXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC50YXJnZXQudmlzaXQodGhpcyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5vYmoudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC5rZXkudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0Lm9iai52aXNpdCh0aGlzKTtcbiAgICAgICAgYXN0LmtleS52aXNpdCh0aGlzKTtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXAgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMsIGNvbnRleHQpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZU1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGFzdHMuZm9yRWFjaChmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgcmV0dXJuIFJlY3Vyc2l2ZUFzdFZpc2l0b3I7XG59KCkpO1xudmFyIEFzdFRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBc3RUcmFuc2Zvcm1lcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEltcGxpY2l0UmVjZWl2ZXIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiBhc3Q7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbihhc3Quc3BhbiwgYXN0LnN0cmluZ3MsIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKGFzdC5zcGFuLCBhc3QudmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVJlYWQoYXN0LnNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlXcml0ZShhc3Quc3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgYXN0LnZhbHVlLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTYWZlUHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVQcm9wZXJ0eVJlYWQoYXN0LnNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTWV0aG9kQ2FsbChhc3Quc3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVNZXRob2RDYWxsKGFzdC5zcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25DYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQ2FsbChhc3Quc3BhbiwgYXN0LnRhcmdldC52aXNpdCh0aGlzKSwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsQXJyYXkoYXN0LnNwYW4sIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwKGFzdC5zcGFuLCBhc3Qua2V5cywgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QmluYXJ5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShhc3Quc3BhbiwgYXN0Lm9wZXJhdGlvbiwgYXN0LmxlZnQudmlzaXQodGhpcyksIGFzdC5yaWdodC52aXNpdCh0aGlzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJlZml4Tm90ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFByZWZpeE5vdChhc3Quc3BhbiwgYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKGFzdC5zcGFuLCBhc3QuY29uZGl0aW9uLnZpc2l0KHRoaXMpLCBhc3QudHJ1ZUV4cC52aXNpdCh0aGlzKSwgYXN0LmZhbHNlRXhwLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdQaXBlKGFzdC5zcGFuLCBhc3QuZXhwLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgdGhpcy52aXNpdEFsbChhc3QuYXJncykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBLZXllZFJlYWQoYXN0LnNwYW4sIGFzdC5vYmoudmlzaXQodGhpcyksIGFzdC5rZXkudmlzaXQodGhpcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgS2V5ZWRXcml0ZShhc3Quc3BhbiwgYXN0Lm9iai52aXNpdCh0aGlzKSwgYXN0LmtleS52aXNpdCh0aGlzKSwgYXN0LnZhbHVlLnZpc2l0KHRoaXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKGFzdHMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzID0gbmV3IEFycmF5KGFzdHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGFzdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGFzdHNbaV0udmlzaXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFpbihhc3Quc3BhbiwgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdW90ZShhc3Quc3BhbiwgYXN0LnByZWZpeCwgYXN0LnVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uLCBhc3QubG9jYXRpb24pO1xuICAgIH07XG4gICAgcmV0dXJuIEFzdFRyYW5zZm9ybWVyO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciAkRU9GID0gMDtcbnZhciAkVEFCID0gOTtcbnZhciAkTEYgPSAxMDtcbnZhciAkVlRBQiA9IDExO1xudmFyICRGRiA9IDEyO1xudmFyICRDUiA9IDEzO1xudmFyICRTUEFDRSA9IDMyO1xudmFyICRCQU5HID0gMzM7XG52YXIgJERRID0gMzQ7XG52YXIgJEhBU0ggPSAzNTtcbnZhciAkJCA9IDM2O1xudmFyICRQRVJDRU5UID0gMzc7XG52YXIgJEFNUEVSU0FORCA9IDM4O1xudmFyICRTUSA9IDM5O1xudmFyICRMUEFSRU4gPSA0MDtcbnZhciAkUlBBUkVOID0gNDE7XG52YXIgJFNUQVIgPSA0MjtcbnZhciAkUExVUyA9IDQzO1xudmFyICRDT01NQSA9IDQ0O1xudmFyICRNSU5VUyA9IDQ1O1xudmFyICRQRVJJT0QgPSA0NjtcbnZhciAkU0xBU0ggPSA0NztcbnZhciAkQ09MT04gPSA1ODtcbnZhciAkU0VNSUNPTE9OID0gNTk7XG52YXIgJExUID0gNjA7XG52YXIgJEVRID0gNjE7XG52YXIgJEdUID0gNjI7XG52YXIgJFFVRVNUSU9OID0gNjM7XG52YXIgJDAgPSA0ODtcbnZhciAkOSA9IDU3O1xudmFyICRBID0gNjU7XG52YXIgJEUgPSA2OTtcbnZhciAkRiA9IDcwO1xudmFyICRYID0gODg7XG52YXIgJFogPSA5MDtcbnZhciAkTEJSQUNLRVQgPSA5MTtcbnZhciAkQkFDS1NMQVNIID0gOTI7XG52YXIgJFJCUkFDS0VUID0gOTM7XG52YXIgJENBUkVUID0gOTQ7XG52YXIgJF8gPSA5NTtcbnZhciAkYSA9IDk3O1xudmFyICRlID0gMTAxO1xudmFyICRmID0gMTAyO1xudmFyICRuID0gMTEwO1xudmFyICRyID0gMTE0O1xudmFyICR0ID0gMTE2O1xudmFyICR1ID0gMTE3O1xudmFyICR2ID0gMTE4O1xudmFyICR4ID0gMTIwO1xudmFyICR6ID0gMTIyO1xudmFyICRMQlJBQ0UgPSAxMjM7XG52YXIgJEJBUiA9IDEyNDtcbnZhciAkUkJSQUNFID0gMTI1O1xudmFyICROQlNQID0gMTYwO1xudmFyICRCVCA9IDk2O1xuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjb2RlKSB7XG4gICAgcmV0dXJuIChjb2RlID49ICRUQUIgJiYgY29kZSA8PSAkU1BBQ0UpIHx8IChjb2RlID09ICROQlNQKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0RpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gJDAgPD0gY29kZSAmJiBjb2RlIDw9ICQ5O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzQXNjaWlMZXR0ZXIoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogfHwgY29kZSA+PSAkQSAmJiBjb2RlIDw9ICRaO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzQXNjaWlIZXhEaWdpdChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkZiB8fCBjb2RlID49ICRBICYmIGNvZGUgPD0gJEYgfHwgaXNEaWdpdChjb2RlKTtcbn1cbi8qKlxuICogQSByZXBsYWNlbWVudCBmb3IgXFxASW5qZWN0YWJsZSB0byBiZSB1c2VkIGluIHRoZSBjb21waWxlciwgc28gdGhhdFxuICogd2UgZG9uJ3QgdHJ5IHRvIGV2YWx1YXRlIHRoZSBtZXRhZGF0YSBpbiB0aGUgY29tcGlsZXIgZHVyaW5nIEFvVC5cbiAqIFRoaXMgZGVjb3JhdG9yIGlzIGVub3VnaCB0byBtYWtlIHRoZSBjb21waWxlciB3b3JrIHdpdGggdGhlIFJlZmxlY3RpdmVJbmplY3RvciB0aG91Z2guXG4gKiBcXEBBbm5vdGF0aW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBDb21waWxlckluamVjdGFibGUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFzc2VydEFycmF5T2ZTdHJpbmdzKGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0Rldk1vZGUoKSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBpZGVudGlmaWVyICsgXCInIHRvIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MuXCIpO1xuICAgIH1cbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkZW50aWZpZXIgKyBcIicgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgSU5URVJQT0xBVElPTl9CTEFDS0xJU1RfUkVHRVhQUyA9IFtcbiAgICAvXlxccyokLyxcbiAgICAvWzw+XS8sXG4gICAgL15be31dJC8sXG4gICAgLyYoI3xbYS16XSkvaSxcbiAgICAvXlxcL1xcLy8sXG5dO1xuLyoqXG4gKiBAcGFyYW0gez99IGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFzc2VydEludGVycG9sYXRpb25TeW1ib2xzKGlkZW50aWZpZXIsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgIShBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT0gMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgaWRlbnRpZmllciArIFwiJyB0byBiZSBhbiBhcnJheSwgW3N0YXJ0LCBlbmRdLlwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZXZNb2RlKCkgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydF8xID0gKHZhbHVlWzBdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kXzEgPSAodmFsdWVbMV0pO1xuICAgICAgICAvLyBibGFjayBsaXN0IGNoZWNraW5nXG4gICAgICAgIElOVEVSUE9MQVRJT05fQkxBQ0tMSVNUX1JFR0VYUFMuZm9yRWFjaChmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICAgICAgICBpZiAocmVnZXhwLnRlc3Qoc3RhcnRfMSkgfHwgcmVnZXhwLnRlc3QoZW5kXzEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWydcIiArIHN0YXJ0XzEgKyBcIicsICdcIiArIGVuZF8xICsgXCInXSBjb250YWlucyB1bnVzYWJsZSBpbnRlcnBvbGF0aW9uIHN5bWJvbC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBJbnRlcnBvbGF0aW9uQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHBhcmFtIHs/fSBlbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbnRlcnBvbGF0aW9uQ29uZmlnKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYXJrZXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheSA9IGZ1bmN0aW9uIChtYXJrZXJzKSB7XG4gICAgICAgIGlmICghbWFya2Vycykge1xuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoJ2ludGVycG9sYXRpb24nLCBtYXJrZXJzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uQ29uZmlnKG1hcmtlcnNbMF0sIG1hcmtlcnNbMV0pO1xuICAgIH07XG4gICAgO1xuICAgIHJldHVybiBJbnRlcnBvbGF0aW9uQ29uZmlnO1xufSgpKTtcbnZhciBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHID0gbmV3IEludGVycG9sYXRpb25Db25maWcoJ3t7JywgJ319Jyk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVG9rZW5UeXBlID0ge307XG5Ub2tlblR5cGUuQ2hhcmFjdGVyID0gMDtcblRva2VuVHlwZS5JZGVudGlmaWVyID0gMTtcblRva2VuVHlwZS5LZXl3b3JkID0gMjtcblRva2VuVHlwZS5TdHJpbmcgPSAzO1xuVG9rZW5UeXBlLk9wZXJhdG9yID0gNDtcblRva2VuVHlwZS5OdW1iZXIgPSA1O1xuVG9rZW5UeXBlLkVycm9yID0gNjtcblRva2VuVHlwZVtUb2tlblR5cGUuQ2hhcmFjdGVyXSA9IFwiQ2hhcmFjdGVyXCI7XG5Ub2tlblR5cGVbVG9rZW5UeXBlLklkZW50aWZpZXJdID0gXCJJZGVudGlmaWVyXCI7XG5Ub2tlblR5cGVbVG9rZW5UeXBlLktleXdvcmRdID0gXCJLZXl3b3JkXCI7XG5Ub2tlblR5cGVbVG9rZW5UeXBlLlN0cmluZ10gPSBcIlN0cmluZ1wiO1xuVG9rZW5UeXBlW1Rva2VuVHlwZS5PcGVyYXRvcl0gPSBcIk9wZXJhdG9yXCI7XG5Ub2tlblR5cGVbVG9rZW5UeXBlLk51bWJlcl0gPSBcIk51bWJlclwiO1xuVG9rZW5UeXBlW1Rva2VuVHlwZS5FcnJvcl0gPSBcIkVycm9yXCI7XG52YXIgS0VZV09SRFMgPSBbJ3ZhcicsICdsZXQnLCAnYXMnLCAnbnVsbCcsICd1bmRlZmluZWQnLCAndHJ1ZScsICdmYWxzZScsICdpZicsICdlbHNlJywgJ3RoaXMnXTtcbnZhciBMZXhlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGV4ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTGV4ZXIucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2Nhbm5lciA9IG5ldyBfU2Nhbm5lcih0ZXh0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW5zID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgd2hpbGUgKHRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG4gICAgcmV0dXJuIExleGVyO1xufSgpKTtcbkxleGVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkxleGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgVG9rZW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IG51bVZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzdHJWYWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRva2VuKGluZGV4LCB0eXBlLCBudW1WYWx1ZSwgc3RyVmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm51bVZhbHVlID0gbnVtVmFsdWU7XG4gICAgICAgIHRoaXMuc3RyVmFsdWUgPSBzdHJWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5DaGFyYWN0ZXIgJiYgdGhpcy5udW1WYWx1ZSA9PSBjb2RlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNOdW1iZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLk51bWJlcjsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuU3RyaW5nOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3BlcmF0ZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc09wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLk9wZXJhdG9yICYmIHRoaXMuc3RyVmFsdWUgPT0gb3BlcmF0ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0lkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLklkZW50aWZpZXI7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZExldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdsZXQnOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZEFzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2FzJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmROdWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ251bGwnOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLmlzS2V5d29yZFVuZGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICd1bmRlZmluZWQnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVHJ1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICd0cnVlJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0tleXdvcmRGYWxzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdmYWxzZSc7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUb2tlbi5wcm90b3R5cGUuaXNLZXl3b3JkVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICd0aGlzJzsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS5pc0Vycm9yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5FcnJvcjsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRva2VuLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuTnVtYmVyID8gdGhpcy5udW1WYWx1ZSA6IC0xOyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuQ2hhcmFjdGVyOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLktleXdvcmQ6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5PcGVyYXRvcjpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLlN0cmluZzpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLkVycm9yOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0clZhbHVlO1xuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuTnVtYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm51bVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVG9rZW47XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGluZGV4XG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5ld0NoYXJhY3RlclRva2VuKGluZGV4LCBjb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLkNoYXJhY3RlciwgY29kZSwgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gdGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbmV3SWRlbnRpZmllclRva2VuKGluZGV4LCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLklkZW50aWZpZXIsIDAsIHRleHQpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGluZGV4XG4gKiBAcGFyYW0gez99IHRleHRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5ld0tleXdvcmRUb2tlbihpbmRleCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5LZXl3b3JkLCAwLCB0ZXh0KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbmRleFxuICogQHBhcmFtIHs/fSB0ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZXdPcGVyYXRvclRva2VuKGluZGV4LCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLk9wZXJhdG9yLCAwLCB0ZXh0KTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpbmRleFxuICogQHBhcmFtIHs/fSB0ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZXdTdHJpbmdUb2tlbihpbmRleCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIFRva2VuVHlwZS5TdHJpbmcsIDAsIHRleHQpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGluZGV4XG4gKiBAcGFyYW0gez99IG5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5ld051bWJlclRva2VuKGluZGV4LCBuKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgVG9rZW5UeXBlLk51bWJlciwgbiwgJycpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGluZGV4XG4gKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG5ld0Vycm9yVG9rZW4oaW5kZXgsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBUb2tlblR5cGUuRXJyb3IsIDAsIG1lc3NhZ2UpO1xufVxudmFyIEVPRiA9IG5ldyBUb2tlbigtMSwgVG9rZW5UeXBlLkNoYXJhY3RlciwgMCwgJycpO1xudmFyIF9TY2FubmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICovXG4gICAgZnVuY3Rpb24gX1NjYW5uZXIoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnBlZWsgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wZWVrID0gKyt0aGlzLmluZGV4ID49IHRoaXMubGVuZ3RoID8gJEVPRiA6IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NjYW5uZXIucHJvdG90eXBlLnNjYW5Ub2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXQgPSB0aGlzLmlucHV0LCAvKiogQHR5cGUgez99ICovIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwZWVrID0gdGhpcy5wZWVrLCAvKiogQHR5cGUgez99ICovIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlLlxuICAgICAgICB3aGlsZSAocGVlayA8PSAkU1BBQ0UpIHtcbiAgICAgICAgICAgIGlmICgrK2luZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBlZWsgPSAkRU9GO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVlayA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVlayA9IHBlZWs7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGlkZW50aWZpZXJzIGFuZCBudW1iZXJzLlxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQocGVlaykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSWRlbnRpZmllcigpO1xuICAgICAgICBpZiAoaXNEaWdpdChwZWVrKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1iZXIoaW5kZXgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IGluZGV4O1xuICAgICAgICBzd2l0Y2ggKHBlZWspIHtcbiAgICAgICAgICAgIGNhc2UgJFBFUklPRDpcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNEaWdpdCh0aGlzLnBlZWspID8gdGhpcy5zY2FuTnVtYmVyKHN0YXJ0KSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoYXJhY3RlclRva2VuKHN0YXJ0LCAkUEVSSU9EKTtcbiAgICAgICAgICAgIGNhc2UgJExQQVJFTjpcbiAgICAgICAgICAgIGNhc2UgJFJQQVJFTjpcbiAgICAgICAgICAgIGNhc2UgJExCUkFDRTpcbiAgICAgICAgICAgIGNhc2UgJFJCUkFDRTpcbiAgICAgICAgICAgIGNhc2UgJExCUkFDS0VUOlxuICAgICAgICAgICAgY2FzZSAkUkJSQUNLRVQ6XG4gICAgICAgICAgICBjYXNlICRDT01NQTpcbiAgICAgICAgICAgIGNhc2UgJENPTE9OOlxuICAgICAgICAgICAgY2FzZSAkU0VNSUNPTE9OOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5DaGFyYWN0ZXIoc3RhcnQsIHBlZWspO1xuICAgICAgICAgICAgY2FzZSAkU1E6XG4gICAgICAgICAgICBjYXNlICREUTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuU3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlICRIQVNIOlxuICAgICAgICAgICAgY2FzZSAkUExVUzpcbiAgICAgICAgICAgIGNhc2UgJE1JTlVTOlxuICAgICAgICAgICAgY2FzZSAkU1RBUjpcbiAgICAgICAgICAgIGNhc2UgJFNMQVNIOlxuICAgICAgICAgICAgY2FzZSAkUEVSQ0VOVDpcbiAgICAgICAgICAgIGNhc2UgJENBUkVUOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PcGVyYXRvcihzdGFydCwgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSk7XG4gICAgICAgICAgICBjYXNlICRRVUVTVElPTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnPycsICRQRVJJT0QsICcuJyk7XG4gICAgICAgICAgICBjYXNlICRMVDpcbiAgICAgICAgICAgIGNhc2UgJEdUOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlayksICRFUSwgJz0nKTtcbiAgICAgICAgICAgIGNhc2UgJEJBTkc6XG4gICAgICAgICAgICBjYXNlICRFUTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspLCAkRVEsICc9JywgJEVRLCAnPScpO1xuICAgICAgICAgICAgY2FzZSAkQU1QRVJTQU5EOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICcmJywgJEFNUEVSU0FORCwgJyYnKTtcbiAgICAgICAgICAgIGNhc2UgJEJBUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnfCcsICRCQVIsICd8Jyk7XG4gICAgICAgICAgICBjYXNlICROQlNQOlxuICAgICAgICAgICAgICAgIHdoaWxlIChpc1doaXRlc3BhY2UodGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgW1wiICsgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSArIFwiXVwiLCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcGFyYW0gez99IGNvZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuQ2hhcmFjdGVyID0gZnVuY3Rpb24gKHN0YXJ0LCBjb2RlKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gbmV3Q2hhcmFjdGVyVG9rZW4oc3RhcnQsIGNvZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEBwYXJhbSB7P30gc3RyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk9wZXJhdG9yID0gZnVuY3Rpb24gKHN0YXJ0LCBzdHIpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCBzdHIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVG9rZW5pemUgYSAyLzMgY2hhciBsb25nIG9wZXJhdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0IHN0YXJ0IGluZGV4IGluIHRoZSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBvbmUgZmlyc3Qgc3ltYm9sIChhbHdheXMgcGFydCBvZiB0aGUgb3BlcmF0b3IpXG4gICAgICogQHBhcmFtIHs/fSB0d29Db2RlIGNvZGUgcG9pbnQgZm9yIHRoZSBzZWNvbmQgc3ltYm9sXG4gICAgICogQHBhcmFtIHs/fSB0d28gc2Vjb25kIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiB0aGUgc2Vjb25kIGNvZGUgcG9pbnQgbWF0Y2hlcylcbiAgICAgKiBAcGFyYW0gez89fSB0aHJlZUNvZGUgY29kZSBwb2ludCBmb3IgdGhlIHRoaXJkIHN5bWJvbFxuICAgICAqIEBwYXJhbSB7Pz19IHRocmVlIHRoaXJkIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiBwcm92aWRlZCBhbmQgbWF0Y2hlcyBzb3VyY2UgZXhwcmVzc2lvbilcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuQ29tcGxleE9wZXJhdG9yID0gZnVuY3Rpb24gKHN0YXJ0LCBvbmUsIHR3b0NvZGUsIHR3bywgdGhyZWVDb2RlLCB0aHJlZSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyID0gb25lO1xuICAgICAgICBpZiAodGhpcy5wZWVrID09IHR3b0NvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgc3RyICs9IHR3bztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyZWVDb2RlICE9IG51bGwgJiYgdGhpcy5wZWVrID09IHRocmVlQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICBzdHIgKz0gdGhyZWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09wZXJhdG9yVG9rZW4oc3RhcnQsIHN0cik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TY2FubmVyLnByb3RvdHlwZS5zY2FuSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgd2hpbGUgKGlzSWRlbnRpZmllclBhcnQodGhpcy5wZWVrKSlcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHIgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiBLRVlXT1JEUy5pbmRleE9mKHN0cikgPiAtMSA/IG5ld0tleXdvcmRUb2tlbihzdGFydCwgc3RyKSA6XG4gICAgICAgICAgICBuZXdJZGVudGlmaWVyVG9rZW4oc3RhcnQsIHN0cik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2Nhbk51bWJlciA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaW1wbGUgPSAodGhpcy5pbmRleCA9PT0gc3RhcnQpO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCBpbml0aWFsIGRpZ2l0LlxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGlzRGlnaXQodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09ICRQRVJJT0QpIHtcbiAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRXhwb25lbnRTdGFydCh0aGlzLnBlZWspKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXhwb25lbnRTaWduKHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNEaWdpdCh0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignSW52YWxpZCBleHBvbmVudCcsIC0xKTtcbiAgICAgICAgICAgICAgICBzaW1wbGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHNpbXBsZSA/IHBhcnNlSW50QXV0b1JhZGl4KHN0cikgOiBwYXJzZUZsb2F0KHN0cik7XG4gICAgICAgIHJldHVybiBuZXdOdW1iZXJUb2tlbihzdGFydCwgdmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuc2NhblN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdW90ZSA9IHRoaXMucGVlaztcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgaW5pdGlhbCBxdW90ZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYnVmZmVyID0gJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcmtlciA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICAgICAgd2hpbGUgKHRoaXMucGVlayAhPSBxdW90ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVlayA9PSAkQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuZXNjYXBlZENvZGUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgVFMyLjEtaW50cm9kdWNlZCB0eXBlIHN0cmljdG5lc3NcbiAgICAgICAgICAgICAgICB0aGlzLnBlZWsgPSB0aGlzLnBlZWs7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVlayA9PSAkdSkge1xuICAgICAgICAgICAgICAgICAgICAvLyA0IGNoYXJhY3RlciBoZXggY29kZSBmb3IgdW5pY29kZSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhleCA9IGlucHV0LnN1YnN0cmluZyh0aGlzLmluZGV4ICsgMSwgdGhpcy5pbmRleCArIDUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoL15bMC05YS1mXSskL2kudGVzdChoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWRDb2RlID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIkludmFsaWQgdW5pY29kZSBlc2NhcGUgW1xcXFx1XCIgKyBoZXggKyBcIl1cIiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZENvZGUgPSB1bmVzY2FwZSh0aGlzLnBlZWspO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodW5lc2NhcGVkQ29kZSk7XG4gICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVlayA9PSAkRU9GKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1VudGVybWluYXRlZCBxdW90ZScsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdCA9IGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCB0ZXJtaW5hdGluZyBxdW90ZS5cbiAgICAgICAgcmV0dXJuIG5ld1N0cmluZ1Rva2VuKHN0YXJ0LCBidWZmZXIgKyBsYXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2Nhbm5lci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBvc2l0aW9uID0gdGhpcy5pbmRleCArIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5ld0Vycm9yVG9rZW4ocG9zaXRpb24sIFwiTGV4ZXIgRXJyb3I6IFwiICsgbWVzc2FnZSArIFwiIGF0IGNvbHVtbiBcIiArIHBvc2l0aW9uICsgXCIgaW4gZXhwcmVzc2lvbiBbXCIgKyB0aGlzLmlucHV0ICsgXCJdXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIF9TY2FubmVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XG4gICAgcmV0dXJuICgkYSA8PSBjb2RlICYmIGNvZGUgPD0gJHopIHx8ICgkQSA8PSBjb2RlICYmIGNvZGUgPD0gJFopIHx8XG4gICAgICAgIChjb2RlID09ICRfKSB8fCAoY29kZSA9PSAkJCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzSWRlbnRpZmllcihpbnB1dCkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjYW5uZXIgPSBuZXcgX1NjYW5uZXIoaW5wdXQpO1xuICAgIGlmICghaXNJZGVudGlmaWVyU3RhcnQoc2Nhbm5lci5wZWVrKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHNjYW5uZXIuYWR2YW5jZSgpO1xuICAgIHdoaWxlIChzY2FubmVyLnBlZWsgIT09ICRFT0YpIHtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KHNjYW5uZXIucGVlaykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHNjYW5uZXIuYWR2YW5jZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNvZGUpIHtcbiAgICByZXR1cm4gaXNBc2NpaUxldHRlcihjb2RlKSB8fCBpc0RpZ2l0KGNvZGUpIHx8IChjb2RlID09ICRfKSB8fFxuICAgICAgICAoY29kZSA9PSAkJCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNFeHBvbmVudFN0YXJ0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PSAkZSB8fCBjb2RlID09ICRFO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRXhwb25lbnRTaWduKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PSAkTUlOVVMgfHwgY29kZSA9PSAkUExVUztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1F1b3RlKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gJFNRIHx8IGNvZGUgPT09ICREUSB8fCBjb2RlID09PSAkQlQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGUoY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlICRuOlxuICAgICAgICAgICAgcmV0dXJuICRMRjtcbiAgICAgICAgY2FzZSAkZjpcbiAgICAgICAgICAgIHJldHVybiAkRkY7XG4gICAgICAgIGNhc2UgJHI6XG4gICAgICAgICAgICByZXR1cm4gJENSO1xuICAgICAgICBjYXNlICR0OlxuICAgICAgICAgICAgcmV0dXJuICRUQUI7XG4gICAgICAgIGNhc2UgJHY6XG4gICAgICAgICAgICByZXR1cm4gJFZUQUI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcGFyc2VJbnRBdXRvUmFkaXgodGV4dCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHBhcnNlSW50KHRleHQpO1xuICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBTcGxpdEludGVycG9sYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RyaW5nc1xuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbnNcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTcGxpdEludGVycG9sYXRpb24oc3RyaW5ncywgZXhwcmVzc2lvbnMsIG9mZnNldHMpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICB0aGlzLm9mZnNldHMgPSBvZmZzZXRzO1xuICAgIH1cbiAgICByZXR1cm4gU3BsaXRJbnRlcnBvbGF0aW9uO1xufSgpKTtcbnZhciBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZUJpbmRpbmdzXG4gICAgICogQHBhcmFtIHs/fSB3YXJuaW5nc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQodGVtcGxhdGVCaW5kaW5ncywgd2FybmluZ3MsIGVycm9ycykge1xuICAgICAgICB0aGlzLnRlbXBsYXRlQmluZGluZ3MgPSB0ZW1wbGF0ZUJpbmRpbmdzO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGNvbmZpZ1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUludGVycG9sYXRlUmVnRXhwKGNvbmZpZykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhdHRlcm4gPSBlc2NhcGVSZWdFeHAoY29uZmlnLnN0YXJ0KSArICcoW1xcXFxzXFxcXFNdKj8pJyArIGVzY2FwZVJlZ0V4cChjb25maWcuZW5kKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCAnZycpO1xufVxudmFyIFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfbGV4ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJzZXIoX2xleGVyKSB7XG4gICAgICAgIHRoaXMuX2xleGVyID0gX2xleGVyO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBY3Rpb24gPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUodGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBzb3VyY2VUb0xleC5sZW5ndGgsIHRydWUsIHRoaXMuZXJyb3JzLCBpbnB1dC5sZW5ndGggLSBzb3VyY2VUb0xleC5sZW5ndGgpXG4gICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJpbmRpbmcgPSBmdW5jdGlvbiAoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIGlucHV0LCBsb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlU2ltcGxlQmluZGluZyA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB0aGlzLl9wYXJzZUJpbmRpbmdBc3QoaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIuY2hlY2soYXN0KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkhvc3QgYmluZGluZyBleHByZXNzaW9uIGNhbm5vdCBjb250YWluIFwiICsgZXJyb3JzLmpvaW4oJyAnKSwgaW5wdXQsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGVyckxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gY3R4TG9jYXRpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VyRXJyb3IobWVzc2FnZSwgaW5wdXQsIGVyckxvY2F0aW9uLCBjdHhMb2NhdGlvbikpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlci5wcm90b3R5cGUuX3BhcnNlQmluZGluZ0FzdCA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgLy8gUXVvdGVzIGV4cHJlc3Npb25zIHVzZSAzcmQtcGFydHkgZXhwcmVzc2lvbiBsYW5ndWFnZS4gV2UgZG9uJ3Qgd2FudCB0byB1c2VcbiAgICAgICAgLy8gb3VyIGxleGVyIG9yIHBhcnNlciBmb3IgdGhhdCwgc28gd2UgY2hlY2sgZm9yIHRoYXQgYWhlYWQgb2YgdGltZS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVvdGUgPSB0aGlzLl9wYXJzZVF1b3RlKGlucHV0LCBsb2NhdGlvbik7XG4gICAgICAgIGlmIChxdW90ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVvdGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoc291cmNlVG9MZXgpO1xuICAgICAgICByZXR1cm4gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2Vucywgc291cmNlVG9MZXgubGVuZ3RoLCBmYWxzZSwgdGhpcy5lcnJvcnMsIGlucHV0Lmxlbmd0aCAtIHNvdXJjZVRvTGV4Lmxlbmd0aClcbiAgICAgICAgICAgIC5wYXJzZUNoYWluKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhdGlvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VRdW90ZSA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24pIHtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4U2VwYXJhdG9ySW5kZXggPSBpbnB1dC5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGlmIChwcmVmaXhTZXBhcmF0b3JJbmRleCA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVmaXggPSBpbnB1dC5zdWJzdHJpbmcoMCwgcHJlZml4U2VwYXJhdG9ySW5kZXgpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXIocHJlZml4KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1bmludGVycHJldGVkRXhwcmVzc2lvbiA9IGlucHV0LnN1YnN0cmluZyhwcmVmaXhTZXBhcmF0b3JJbmRleCArIDEpO1xuICAgICAgICByZXR1cm4gbmV3IFF1b3RlKG5ldyBQYXJzZVNwYW4oMCwgaW5wdXQubGVuZ3RoKSwgcHJlZml4LCB1bmludGVycHJldGVkRXhwcmVzc2lvbiwgbG9jYXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcmVmaXhUb2tlblxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uIChwcmVmaXhUb2tlbiwgaW5wdXQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKGlucHV0KTtcbiAgICAgICAgaWYgKHByZWZpeFRva2VuKSB7XG4gICAgICAgICAgICAvLyBQcmVmaXggdGhlIHRva2VucyB3aXRoIHRoZSB0b2tlbnMgZnJvbSBwcmVmaXhUb2tlbiBidXQgaGF2ZSB0aGVtIHRha2Ugbm8gc3BhY2UgKDAgaW5kZXgpLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4VG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUocHJlZml4VG9rZW4pLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHQuaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b2tlbnMudW5zaGlmdC5hcHBseSh0b2tlbnMsIHByZWZpeFRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCB0b2tlbnMsIGlucHV0Lmxlbmd0aCwgZmFsc2UsIHRoaXMuZXJyb3JzLCAwKVxuICAgICAgICAgICAgLnBhcnNlVGVtcGxhdGVCaW5kaW5ncygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGxpdCA9IHRoaXMuc3BsaXRJbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmIChzcGxpdCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzcGxpdC5leHByZXNzaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcmVzc2lvblRleHQgPSBzcGxpdC5leHByZXNzaW9uc1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhleHByZXNzaW9uVGV4dCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZSh0aGlzLl9zdHJpcENvbW1lbnRzKHNwbGl0LmV4cHJlc3Npb25zW2ldKSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgdG9rZW5zLCBzb3VyY2VUb0xleC5sZW5ndGgsIGZhbHNlLCB0aGlzLmVycm9ycywgc3BsaXQub2Zmc2V0c1tpXSArIChleHByZXNzaW9uVGV4dC5sZW5ndGggLSBzb3VyY2VUb0xleC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIC5wYXJzZUNoYWluKCk7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKG5ldyBJbnRlcnBvbGF0aW9uKG5ldyBQYXJzZVNwYW4oMCwgaW5wdXQgPT0gbnVsbCA/IDAgOiBpbnB1dC5sZW5ndGgpLCBzcGxpdC5zdHJpbmdzLCBleHByZXNzaW9ucyksIGlucHV0LCBsb2NhdGlvbiwgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLnNwbGl0SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRzsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWdleHAgPSBfY3JlYXRlSW50ZXJwb2xhdGVSZWdFeHAoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gaW5wdXQuc3BsaXQocmVnZXhwKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJpbmdzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9mZnNldHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBmaXhlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydC50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBpbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBwYXJ0Lmxlbmd0aCArIGludGVycG9sYXRpb25Db25maWcuZW5kLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKCdCbGFuayBleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gaW50ZXJwb2xhdGVkIHN0cmluZ3MnLCBpbnB1dCwgXCJhdCBjb2x1bW4gXCIgKyB0aGlzLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uKHBhcnRzLCBpLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSArIFwiIGluXCIsIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKCckaW1wbGljdCcpO1xuICAgICAgICAgICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3BsaXRJbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zLCBvZmZzZXRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLndyYXBMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGlucHV0LCBsb2NhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UobmV3IExpdGVyYWxQcmltaXRpdmUobmV3IFBhcnNlU3BhbigwLCBpbnB1dCA9PSBudWxsID8gMCA6IGlucHV0Lmxlbmd0aCksIGlucHV0KSwgaW5wdXQsIGxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlucHV0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLl9zdHJpcENvbW1lbnRzID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkgPSB0aGlzLl9jb21tZW50U3RhcnQoaW5wdXQpO1xuICAgICAgICByZXR1cm4gaSAhPSBudWxsID8gaW5wdXQuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKSA6IGlucHV0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VyLnByb3RvdHlwZS5fY29tbWVudFN0YXJ0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dGVyUXVvdGUgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFyID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHRDaGFyID0gaW5wdXQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJFNMQVNIICYmIG5leHRDaGFyID09ICRTTEFTSCAmJiBvdXRlclF1b3RlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICBpZiAob3V0ZXJRdW90ZSA9PT0gY2hhcikge1xuICAgICAgICAgICAgICAgIG91dGVyUXVvdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3V0ZXJRdW90ZSA9PSBudWxsICYmIGlzUXVvdGUoY2hhcikpIHtcbiAgICAgICAgICAgICAgICBvdXRlclF1b3RlID0gY2hhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcGFyYW0gez99IGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLl9jaGVja05vSW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVnZXhwID0gX2NyZWF0ZUludGVycG9sYXRlUmVnRXhwKGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IGlucHV0LnNwbGl0KHJlZ2V4cCk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkdvdCBpbnRlcnBvbGF0aW9uIChcIiArIGludGVycG9sYXRpb25Db25maWcuc3RhcnQgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCArIFwiKSB3aGVyZSBleHByZXNzaW9uIHdhcyBleHBlY3RlZFwiLCBpbnB1dCwgXCJhdCBjb2x1bW4gXCIgKyB0aGlzLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uKHBhcnRzLCAxLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSArIFwiIGluXCIsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJ0c1xuICAgICAqIEBwYXJhbSB7P30gcGFydEluRXJySWR4XG4gICAgICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZXIucHJvdG90eXBlLl9maW5kSW50ZXJwb2xhdGlvbkVycm9yQ29sdW1uID0gZnVuY3Rpb24gKHBhcnRzLCBwYXJ0SW5FcnJJZHgsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyTG9jYXRpb24gPSAnJztcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBqID0gMDsgaiA8IHBhcnRJbkVycklkeDsgaisrKSB7XG4gICAgICAgICAgICBlcnJMb2NhdGlvbiArPSBqICUgMiA9PT0gMCA/XG4gICAgICAgICAgICAgICAgcGFydHNbal0gOlxuICAgICAgICAgICAgICAgIFwiXCIgKyBpbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0ICsgcGFydHNbal0gKyBpbnRlcnBvbGF0aW9uQ29uZmlnLmVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyTG9jYXRpb24ubGVuZ3RoO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlcjtcbn0oKSk7XG5QYXJzZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuUGFyc2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogTGV4ZXIsIH0sXG5dOyB9O1xudmFyIF9QYXJzZUFTVCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7P30gbG9jYXRpb25cbiAgICAgKiBAcGFyYW0gez99IHRva2Vuc1xuICAgICAqIEBwYXJhbSB7P30gaW5wdXRMZW5ndGhcbiAgICAgKiBAcGFyYW0gez99IHBhcnNlQWN0aW9uXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcGFyYW0gez99IG9mZnNldFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIHRva2VucywgaW5wdXRMZW5ndGgsIHBhcnNlQWN0aW9uLCBlcnJvcnMsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuaW5wdXRMZW5ndGggPSBpbnB1dExlbmd0aDtcbiAgICAgICAgdGhpcy5wYXJzZUFjdGlvbiA9IHBhcnNlQWN0aW9uO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkID0gMDtcbiAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCA9IDA7XG4gICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkgPSB0aGlzLmluZGV4ICsgb2Zmc2V0O1xuICAgICAgICByZXR1cm4gaSA8IHRoaXMudG9rZW5zLmxlbmd0aCA/IHRoaXMudG9rZW5zW2ldIDogRU9GO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9QYXJzZUFTVC5wcm90b3R5cGUsIFwibmV4dFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBlZWsoMCk7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfUGFyc2VBU1QucHJvdG90eXBlLCBcImlucHV0SW5kZXhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSA/IHRoaXMubmV4dC5pbmRleCArIHRoaXMub2Zmc2V0IDpcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0TGVuZ3RoICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuc3BhbiA9IGZ1bmN0aW9uIChzdGFydCkgeyByZXR1cm4gbmV3IFBhcnNlU3BhbihzdGFydCwgdGhpcy5pbnB1dEluZGV4KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuYWR2YW5jZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5pbmRleCsrOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5vcHRpb25hbENoYXJhY3RlciA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoY29kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wZWVrS2V5d29yZExldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubmV4dC5pc0tleXdvcmRMZXQoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGVla0tleXdvcmRBcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubmV4dC5pc0tleXdvcmRBcygpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RDaGFyYWN0ZXIgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3Rlcihjb2RlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lcnJvcihcIk1pc3NpbmcgZXhwZWN0ZWQgXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3BcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUub3B0aW9uYWxPcGVyYXRvciA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0LmlzT3BlcmF0b3Iob3ApKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9wZXJhdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmV4cGVjdE9wZXJhdG9yID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3Iob3BlcmF0b3IpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVycm9yKFwiTWlzc2luZyBleHBlY3RlZCBvcGVyYXRvciBcIiArIG9wZXJhdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAoIW4uaXNJZGVudGlmaWVyKCkgJiYgIW4uaXNLZXl3b3JkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgbiArIFwiLCBleHBlY3RlZCBpZGVudGlmaWVyIG9yIGtleXdvcmRcIik7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZE9yU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAoIW4uaXNJZGVudGlmaWVyKCkgJiYgIW4uaXNLZXl3b3JkKCkgJiYgIW4uaXNTdHJpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW4gXCIgKyBuICsgXCIsIGV4cGVjdGVkIGlkZW50aWZpZXIsIGtleXdvcmQsIG9yIHN0cmluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIG4udG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUNoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHIgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgZXhwcnMucHVzaChleHByKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0JpbmRpbmcgZXhwcmVzc2lvbiBjYW5ub3QgY29udGFpbiBjaGFpbmVkIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFNFTUlDT0xPTikpIHtcbiAgICAgICAgICAgICAgICB9IC8vIHJlYWQgYWxsIHNlbWljb2xvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5leHBlY3RlZCB0b2tlbiAnXCIgKyB0aGlzLm5leHQgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSk7XG4gICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByc1swXTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFpbih0aGlzLnNwYW4oc3RhcnQpLCBleHBycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VQaXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCd8JykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcnNlQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcignQ2Fubm90IGhhdmUgYSBwaXBlIGluIGFuIGFjdGlvbiBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmRpbmdQaXBlKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwgbmFtZSwgYXJncyk7XG4gICAgICAgICAgICB9IHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3wnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VDb25kaXRpb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsT3IoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPycpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB5ZXMgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm8gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTE9OKSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9uID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihcIkNvbmRpdGlvbmFsIGV4cHJlc3Npb24gXCIgKyBleHByZXNzaW9uICsgXCIgcmVxdWlyZXMgYWxsIDMgZXhwcmVzc2lvbnNcIik7XG4gICAgICAgICAgICAgICAgbm8gPSBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm8gPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbCh0aGlzLnNwYW4oc3RhcnQpLCByZXN1bHQsIHllcywgbm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTG9naWNhbE9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAnfHwnXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsQW5kKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJ3x8JykpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpZ2h0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgJ3x8JywgcmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZUxvZ2ljYWxBbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICcmJidcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZUVxdWFsaXR5KCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJyYmJykpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpZ2h0ID0gdGhpcy5wYXJzZUVxdWFsaXR5KCk7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksICcmJicsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFcXVhbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJz09JywnIT0nLCc9PT0nLCchPT0nXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VSZWxhdGlvbmFsKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmlnaHQgPSB0aGlzLnBhcnNlUmVsYXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlUmVsYXRpb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJzwnLCAnPicsICc8PScsICc+PSdcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5wYXJzZUFkZGl0aXZlKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByaWdodCA9IHRoaXMucGFyc2VBZGRpdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQWRkaXRpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICcrJywgJy0nXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VNdWx0aXBsaWNhdGl2ZSgpO1xuICAgICAgICB3aGlsZSAodGhpcy5uZXh0LnR5cGUgPT0gVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpZ2h0ID0gdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VNdWx0aXBsaWNhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gJyonLCAnJScsICcvJ1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmlnaHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VQcmVmaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCBvcGVyYXRvciwgbmV3IExpdGVyYWxQcmltaXRpdmUobmV3IFBhcnNlU3BhbihzdGFydCwgc3RhcnQpLCAwKSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVmaXhOb3QodGhpcy5zcGFuKHN0YXJ0KSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNhbGxDaGFpbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2FsbENoYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFBFUklPRCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbE9wZXJhdG9yKCc/LicpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUFjY2Vzc01lbWJlck9yTWV0aG9kQ2FsbChyZXN1bHQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0tFVCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBLZXllZFdyaXRlKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgS2V5ZWRSZWFkKHRoaXMuc3BhbihyZXN1bHQuc3Bhbi5zdGFydCksIHJlc3VsdCwga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbmFsQ2hhcmFjdGVyKCRMUEFSRU4pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gdGhpcy5wYXJzZUNhbGxBcmd1bWVudHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSUEFSRU4pO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBGdW5jdGlvbkNhbGwodGhpcy5zcGFuKHJlc3VsdC5zcGFuLnN0YXJ0KSwgcmVzdWx0LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVByaW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmROdWxsKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRVbmRlZmluZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkVHJ1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkRmFsc2UoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRUaGlzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbXBsaWNpdFJlY2VpdmVyKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJExCUkFDS0VUKSkge1xuICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbkxpc3QoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0tFVCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheSh0aGlzLnNwYW4oc3RhcnQpLCBlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKCRMQlJBQ0UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWxNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JNZXRob2RDYWxsKG5ldyBJbXBsaWNpdFJlY2VpdmVyKHRoaXMuc3BhbihzdGFydCkpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzTnVtYmVyKCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdGhpcy5uZXh0LnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpdGVyYWxWYWx1ZSA9IHRoaXMubmV4dC50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgbGl0ZXJhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb246IFwiICsgdGhpcy5pbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJVbmV4cGVjdGVkIHRva2VuIFwiICsgdGhpcy5uZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRlcm1pbmF0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uICh0ZXJtaW5hdG9yKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMubmV4dC5pc0NoYXJhY3Rlcih0ZXJtaW5hdG9yKSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlTGl0ZXJhbE1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRMQlJBQ0UpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJFJCUkFDRSkpIHtcbiAgICAgICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkKys7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkQ09MT04pO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkLS07XG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUkJSQUNFKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXAodGhpcy5zcGFuKHN0YXJ0KSwga2V5cywgdmFsdWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez89fSBpc1NhZmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUucGFyc2VBY2Nlc3NNZW1iZXJPck1ldGhvZENhbGwgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIGlzU2FmZSkge1xuICAgICAgICBpZiAoaXNTYWZlID09PSB2b2lkIDApIHsgaXNTYWZlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSByZWNlaXZlci5zcGFuLnN0YXJ0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BhbiA9IHRoaXMuc3BhbihzdGFydCk7XG4gICAgICAgICAgICByZXR1cm4gaXNTYWZlID8gbmV3IFNhZmVNZXRob2RDYWxsKHNwYW4sIHJlY2VpdmVyLCBpZCwgYXJncykgOlxuICAgICAgICAgICAgICAgIG5ldyBNZXRob2RDYWxsKHNwYW4sIHJlY2VpdmVyLCBpZCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNTYWZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1RoZSBcXCc/LlxcJyBvcGVyYXRvciBjYW5ub3QgYmUgdXNlZCBpbiB0aGUgYXNzaWdubWVudCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2FmZVByb3BlcnR5UmVhZCh0aGlzLnNwYW4oc3RhcnQpLCByZWNlaXZlciwgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyc2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0JpbmRpbmdzIGNhbm5vdCBjb250YWluIGFzc2lnbm1lbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRoaXMucGFyc2VDb25kaXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5V3JpdGUodGhpcy5zcGFuKHN0YXJ0KSwgcmVjZWl2ZXIsIGlkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UmVhZCh0aGlzLnNwYW4oc3RhcnQpLCByZWNlaXZlciwgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnBhcnNlQ2FsbEFyZ3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3RlcigkUlBBUkVOKSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zaXRpb25hbHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcG9zaXRpb25hbHMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgcmV0dXJuIChwb3NpdGlvbmFscyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBbiBpZGVudGlmaWVyLCBhIGtleXdvcmQsIGEgc3RyaW5nIHdpdGggYW4gb3B0aW9uYWwgYC1gIGluYmV0d2Vlbi5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmF0b3JGb3VuZCA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgIG9wZXJhdG9yRm91bmQgPSB0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJy0nKTtcbiAgICAgICAgICAgIGlmIChvcGVyYXRvckZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAob3BlcmF0b3JGb3VuZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1BhcnNlQVNULnByb3RvdHlwZS5wYXJzZVRlbXBsYXRlQmluZGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmdzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeCA9IG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdhcm5pbmdzID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleUlzVmFyID0gdGhpcy5wZWVrS2V5d29yZExldCgpO1xuICAgICAgICAgICAgaWYgKGtleUlzVmFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByYXdLZXkgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ga2V5ID0gcmF3S2V5O1xuICAgICAgICAgICAgaWYgKCFrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBwcmVmaXggKyBrZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpb25hbENoYXJhY3RlcigkQ09MT04pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsT3BlcmF0b3IoJz0nKSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnXFwkaW1wbGljaXQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVla0tleXdvcmRBcygpKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGV0U3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIGNvbnN1bWUgYGFzYFxuICAgICAgICAgICAgICAgIG5hbWUgPSByYXdLZXk7XG4gICAgICAgICAgICAgICAga2V5ID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTsgLy8gcmVhZCBsb2NhbCB2YXIgbmFtZVxuICAgICAgICAgICAgICAgIGtleUlzVmFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dCAhPT0gRU9GICYmICF0aGlzLnBlZWtLZXl3b3JkTGV0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydF8yID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnRfMiAtIHRoaXMub2Zmc2V0LCB0aGlzLmlucHV0SW5kZXggLSB0aGlzLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG5ldyBBU1RXaXRoU291cmNlKGFzdCwgc291cmNlLCB0aGlzLmxvY2F0aW9uLCB0aGlzLmVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaW5kaW5ncy5wdXNoKG5ldyBUZW1wbGF0ZUJpbmRpbmcodGhpcy5zcGFuKHN0YXJ0KSwga2V5LCBrZXlJc1ZhciwgbmFtZSwgZXhwcmVzc2lvbikpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVla0tleXdvcmRBcygpICYmICFrZXlJc1Zhcikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxldFN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBjb25zdW1lIGBhc2BcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZXROYW1lID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTsgLy8gcmVhZCBsb2NhbCB2YXIgbmFtZVxuICAgICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobmV3IFRlbXBsYXRlQmluZGluZyh0aGlzLnNwYW4obGV0U3RhcnQpLCBsZXROYW1lLCB0cnVlLCBrZXksIG51bGwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0KGJpbmRpbmdzLCB3YXJuaW5ncywgdGhpcy5lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/PX0gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9QYXJzZUFTVC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHsgaW5kZXggPSBudWxsOyB9XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KGluZGV4KSwgdGhpcy5sb2NhdGlvbikpO1xuICAgICAgICB0aGlzLnNraXAoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IGluZGV4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLmxvY2F0aW9uVGV4dCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IG51bGw7IH1cbiAgICAgICAgaWYgKGluZGV4ID09IG51bGwpXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHJldHVybiAoaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpID8gXCJhdCBjb2x1bW4gXCIgKyAodGhpcy50b2tlbnNbaW5kZXhdLmluZGV4ICsgMSkgKyBcIiBpblwiIDpcbiAgICAgICAgICAgIFwiYXQgdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvblwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfUGFyc2VBU1QucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG4gPSB0aGlzLm5leHQ7XG4gICAgICAgIHdoaWxlICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoICYmICFuLmlzQ2hhcmFjdGVyKCRTRU1JQ09MT04pICYmXG4gICAgICAgICAgICAodGhpcy5ycGFyZW5zRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUlBBUkVOKSkgJiZcbiAgICAgICAgICAgICh0aGlzLnJicmFjZXNFeHBlY3RlZCA8PSAwIHx8ICFuLmlzQ2hhcmFjdGVyKCRSQlJBQ0UpKSAmJlxuICAgICAgICAgICAgKHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUkJSQUNLRVQpKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dC5pc0Vycm9yKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZXJFcnJvcih0aGlzLm5leHQudG9TdHJpbmcoKSwgdGhpcy5pbnB1dCwgdGhpcy5sb2NhdGlvblRleHQoKSwgdGhpcy5sb2NhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICBuID0gdGhpcy5uZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gX1BhcnNlQVNUO1xufSgpKTtcbnZhciBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5jaGVjayA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcyA9IG5ldyBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpO1xuICAgICAgICBhc3QudmlzaXQocyk7XG4gICAgICAgIHJldHVybiBzLmVycm9ycztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRJbXBsaWNpdFJlY2VpdmVyID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFByb3BlcnR5V3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFNhZmVQcm9wZXJ0eVJlYWQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdE1ldGhvZENhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdExpdGVyYWxBcnJheSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRCaW5hcnkgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFByZWZpeE5vdCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHRoaXMuZXJyb3JzLnB1c2goJ3BpcGVzJyk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEtleWVkUmVhZCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXIucHJvdG90eXBlLnZpc2l0S2V5ZWRXcml0ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhc3RzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyLnByb3RvdHlwZS52aXNpdENoYWluID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlci5wcm90b3R5cGUudmlzaXRRdW90ZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICByZXR1cm4gU2ltcGxlRXhwcmVzc2lvbkNoZWNrZXI7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFBhcnNlTG9jYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVxuICAgICAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gICAgICogQHBhcmFtIHs/fSBsaW5lXG4gICAgICogQHBhcmFtIHs/fSBjb2xcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJzZUxvY2F0aW9uKGZpbGUsIG9mZnNldCwgbGluZSwgY29sKSB7XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQYXJzZUxvY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICE9IG51bGwgPyB0aGlzLmZpbGUudXJsICsgXCJAXCIgKyB0aGlzLmxpbmUgKyBcIjpcIiArIHRoaXMuY29sIDogdGhpcy5maWxlLnVybDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVsdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlTG9jYXRpb24ucHJvdG90eXBlLm1vdmVCeSA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2UgPSB0aGlzLmZpbGUuY29udGVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbmUgPSB0aGlzLmxpbmU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbCA9IHRoaXMuY29sO1xuICAgICAgICB3aGlsZSAob2Zmc2V0ID4gMCAmJiBkZWx0YSA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgICAgZGVsdGErKztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoID0gc291cmNlLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChjaCA9PSAkTEYpIHtcbiAgICAgICAgICAgICAgICBsaW5lLS07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJpb3JMaW5lID0gc291cmNlLnN1YnN0cigwLCBvZmZzZXQgLSAxKS5sYXN0SW5kZXhPZihTdHJpbmcuZnJvbUNoYXJDb2RlKCRMRikpO1xuICAgICAgICAgICAgICAgIGNvbCA9IHByaW9yTGluZSA+IDAgPyBvZmZzZXQgLSBwcmlvckxpbmUgOiBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2wtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuICYmIGRlbHRhID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2ggPSBzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBkZWx0YS0tO1xuICAgICAgICAgICAgaWYgKGNoID09ICRMRikge1xuICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgICAgICBjb2wgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUxvY2F0aW9uKHRoaXMuZmlsZSwgb2Zmc2V0LCBsaW5lLCBjb2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYXhDaGFyc1xuICAgICAqIEBwYXJhbSB7P30gbWF4TGluZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlTG9jYXRpb24ucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiAobWF4Q2hhcnMsIG1heExpbmVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnQgPSB0aGlzLmZpbGUuY29udGVudDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzdGFydE9mZnNldCA+IGNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gY29udGVudC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHhDaGFycyA9IDA7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHhMaW5lcyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY3R4Q2hhcnMgPCBtYXhDaGFycyAmJiBzdGFydE9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldC0tO1xuICAgICAgICAgICAgICAgIGN0eENoYXJzKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbc3RhcnRPZmZzZXRdID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2N0eExpbmVzID09IG1heExpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eENoYXJzID0gMDtcbiAgICAgICAgICAgIGN0eExpbmVzID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjdHhDaGFycyA8IG1heENoYXJzICYmIGVuZE9mZnNldCA8IGNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCsrO1xuICAgICAgICAgICAgICAgIGN0eENoYXJzKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbZW5kT2Zmc2V0XSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKytjdHhMaW5lcyA9PSBtYXhMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udGVudC5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIHRoaXMub2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBhZnRlcjogY29udGVudC5zdWJzdHJpbmcodGhpcy5vZmZzZXQsIGVuZE9mZnNldCArIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZUxvY2F0aW9uO1xufSgpKTtcbnZhciBQYXJzZVNvdXJjZUZpbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VTb3VyY2VGaWxlKGNvbnRlbnQsIHVybCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICB9XG4gICAgcmV0dXJuIFBhcnNlU291cmNlRmlsZTtcbn0oKSk7XG52YXIgUGFyc2VTb3VyY2VTcGFuID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHBhcmFtIHs/fSBlbmRcbiAgICAgKiBAcGFyYW0gez89fSBkZXRhaWxzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LCBlbmQsIGRldGFpbHMpIHtcbiAgICAgICAgaWYgKGRldGFpbHMgPT09IHZvaWQgMCkgeyBkZXRhaWxzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlU291cmNlU3Bhbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmZpbGUuY29udGVudC5zdWJzdHJpbmcodGhpcy5zdGFydC5vZmZzZXQsIHRoaXMuZW5kLm9mZnNldCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VTb3VyY2VTcGFuO1xufSgpKTtcbnZhciBQYXJzZUVycm9yTGV2ZWwgPSB7fTtcblBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HID0gMDtcblBhcnNlRXJyb3JMZXZlbC5FUlJPUiA9IDE7XG5QYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsLldBUk5JTkddID0gXCJXQVJOSU5HXCI7XG5QYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsLkVSUk9SXSA9IFwiRVJST1JcIjtcbnZhciBQYXJzZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG1zZ1xuICAgICAqIEBwYXJhbSB7Pz19IGxldmVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VFcnJvcihzcGFuLCBtc2csIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMubXNnID0gbXNnO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGFyc2VFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eCA9IHRoaXMuc3Bhbi5zdGFydC5nZXRDb250ZXh0KDEwMCwgMyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRleHRTdHIgPSBjdHggPyBcIiAoXFxcIlwiICsgY3R4LmJlZm9yZSArIFwiW1wiICsgUGFyc2VFcnJvckxldmVsW3RoaXMubGV2ZWxdICsgXCIgLT5dXCIgKyBjdHguYWZ0ZXIgKyBcIlxcXCIpXCIgOiAnJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGV0YWlscyA9IHRoaXMuc3Bhbi5kZXRhaWxzID8gXCIsIFwiICsgdGhpcy5zcGFuLmRldGFpbHMgOiAnJztcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLm1zZyArIGNvbnRleHRTdHIgKyBcIjogXCIgKyB0aGlzLnNwYW4uc3RhcnQgKyBkZXRhaWxzO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnNlRXJyb3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGtpbmRcbiAqIEBwYXJhbSB7P30gdHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdHlwZVNvdXJjZVNwYW4oa2luZCwgdHlwZSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZVVybCA9IGlkZW50aWZpZXJNb2R1bGVVcmwodHlwZSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlRmlsZU5hbWUgPSBtb2R1bGVVcmwgIT0gbnVsbCA/IFwiaW4gXCIgKyBraW5kICsgXCIgXCIgKyBpZGVudGlmaWVyTmFtZSh0eXBlKSArIFwiIGluIFwiICsgbW9kdWxlVXJsIDpcbiAgICAgICAgXCJpbiBcIiArIGtpbmQgKyBcIiBcIiArIGlkZW50aWZpZXJOYW1lKHR5cGUpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZUZpbGUgPSBuZXcgUGFyc2VTb3VyY2VGaWxlKCcnLCBzb3VyY2VGaWxlTmFtZSk7XG4gICAgcmV0dXJuIG5ldyBQYXJzZVNvdXJjZVNwYW4obmV3IFBhcnNlTG9jYXRpb24oc291cmNlRmlsZSwgbnVsbCwgbnVsbCwgbnVsbCksIG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIG51bGwsIG51bGwsIG51bGwpKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGV4dCh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGV4dC5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRleHQ7XG59KCkpO1xudmFyIEV4cGFuc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzd2l0Y2hWYWx1ZVxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gY2FzZXNcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHN3aXRjaFZhbHVlU291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV4cGFuc2lvbihzd2l0Y2hWYWx1ZSwgdHlwZSwgY2FzZXMsIHNvdXJjZVNwYW4sIHN3aXRjaFZhbHVlU291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnN3aXRjaFZhbHVlID0gc3dpdGNoVmFsdWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4gPSBzd2l0Y2hWYWx1ZVNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwYW5zaW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RXhwYW5zaW9uKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBFeHBhbnNpb247XG59KCkpO1xudmFyIEV4cGFuc2lvbkNhc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlU291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gZXhwU291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV4cGFuc2lvbkNhc2UodmFsdWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHZhbHVlU291cmNlU3BhbiwgZXhwU291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTb3VyY2VTcGFuID0gdmFsdWVTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmV4cFNvdXJjZVNwYW4gPSBleHBTb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cGFuc2lvbkNhc2UucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHBhbnNpb25DYXNlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBFeHBhbnNpb25DYXNlO1xufSgpKTtcbnZhciBBdHRyaWJ1dGUkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7Pz19IHZhbHVlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZSQxKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBdHRyaWJ1dGUkMS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEF0dHJpYnV0ZSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gQXR0cmlidXRlJDE7XG59KCkpO1xudmFyIEVsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gYXR0cnNcbiAgICAgKiBAcGFyYW0gez99IGNoaWxkcmVuXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IGVuZFNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbGVtZW50KG5hbWUsIGF0dHJzLCBjaGlsZHJlbiwgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnN0YXJ0U291cmNlU3BhbiA9IHN0YXJ0U291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50LnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gRWxlbWVudDtcbn0oKSk7XG52YXIgQ29tbWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbW1lbnQodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbW1lbnQucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRDb21tZW50KHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBDb21tZW50O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gKiBAcGFyYW0gez99IG5vZGVzXG4gKiBAcGFyYW0gez89fSBjb250ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2aXNpdEFsbCh2aXNpdG9yLCBub2RlcywgY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IG51bGw7IH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdCA9IHZpc2l0b3IudmlzaXQgP1xuICAgICAgICBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0KGFzdCwgY29udGV4dCkgfHwgYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9IDpcbiAgICAgICAgZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpOyB9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3RSZXN1bHQgPSB2aXNpdChhc3QpO1xuICAgICAgICBpZiAoYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUb2tlblR5cGUkMSA9IHt9O1xuVG9rZW5UeXBlJDEuVEFHX09QRU5fU1RBUlQgPSAwO1xuVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EID0gMTtcblRva2VuVHlwZSQxLlRBR19PUEVOX0VORF9WT0lEID0gMjtcblRva2VuVHlwZSQxLlRBR19DTE9TRSA9IDM7XG5Ub2tlblR5cGUkMS5URVhUID0gNDtcblRva2VuVHlwZSQxLkVTQ0FQQUJMRV9SQVdfVEVYVCA9IDU7XG5Ub2tlblR5cGUkMS5SQVdfVEVYVCA9IDY7XG5Ub2tlblR5cGUkMS5DT01NRU5UX1NUQVJUID0gNztcblRva2VuVHlwZSQxLkNPTU1FTlRfRU5EID0gODtcblRva2VuVHlwZSQxLkNEQVRBX1NUQVJUID0gOTtcblRva2VuVHlwZSQxLkNEQVRBX0VORCA9IDEwO1xuVG9rZW5UeXBlJDEuQVRUUl9OQU1FID0gMTE7XG5Ub2tlblR5cGUkMS5BVFRSX1ZBTFVFID0gMTI7XG5Ub2tlblR5cGUkMS5ET0NfVFlQRSA9IDEzO1xuVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQgPSAxNDtcblRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX1ZBTFVFID0gMTU7XG5Ub2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQgPSAxNjtcblRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9FTkQgPSAxNztcblRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX0VORCA9IDE4O1xuVG9rZW5UeXBlJDEuRU9GID0gMTk7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5UQUdfT1BFTl9TVEFSVF0gPSBcIlRBR19PUEVOX1NUQVJUXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5UQUdfT1BFTl9FTkRdID0gXCJUQUdfT1BFTl9FTkRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLlRBR19PUEVOX0VORF9WT0lEXSA9IFwiVEFHX09QRU5fRU5EX1ZPSURcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLlRBR19DTE9TRV0gPSBcIlRBR19DTE9TRVwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuVEVYVF0gPSBcIlRFWFRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkVTQ0FQQUJMRV9SQVdfVEVYVF0gPSBcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuUkFXX1RFWFRdID0gXCJSQVdfVEVYVFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuQ09NTUVOVF9TVEFSVF0gPSBcIkNPTU1FTlRfU1RBUlRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkNPTU1FTlRfRU5EXSA9IFwiQ09NTUVOVF9FTkRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkNEQVRBX1NUQVJUXSA9IFwiQ0RBVEFfU1RBUlRcIjtcblRva2VuVHlwZSQxW1Rva2VuVHlwZSQxLkNEQVRBX0VORF0gPSBcIkNEQVRBX0VORFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuQVRUUl9OQU1FXSA9IFwiQVRUUl9OQU1FXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5BVFRSX1ZBTFVFXSA9IFwiQVRUUl9WQUxVRVwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRE9DX1RZUEVdID0gXCJET0NfVFlQRVwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlRdID0gXCJFWFBBTlNJT05fRk9STV9TVEFSVFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfVkFMVUVdID0gXCJFWFBBTlNJT05fQ0FTRV9WQUxVRVwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXSA9IFwiRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfRU5EXSA9IFwiRVhQQU5TSU9OX0NBU0VfRVhQX0VORFwiO1xuVG9rZW5UeXBlJDFbVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fRU5EXSA9IFwiRVhQQU5TSU9OX0ZPUk1fRU5EXCI7XG5Ub2tlblR5cGUkMVtUb2tlblR5cGUkMS5FT0ZdID0gXCJFT0ZcIjtcbnZhciBUb2tlbiQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IHBhcnRzXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9rZW4kMSh0eXBlLCBwYXJ0cywgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnBhcnRzID0gcGFydHM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIHJldHVybiBUb2tlbiQxO1xufSgpKTtcbnZhciBUb2tlbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVG9rZW5FcnJvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yTXNnXG4gICAgICogQHBhcmFtIHs/fSB0b2tlblR5cGVcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUb2tlbkVycm9yKGVycm9yTXNnLCB0b2tlblR5cGUsIHNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc3BhbiwgZXJyb3JNc2cpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRva2VuVHlwZSA9IHRva2VuVHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVG9rZW5FcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xudmFyIFRva2VuaXplUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2Vuc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9rZW5pemVSZXN1bHQodG9rZW5zLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gVG9rZW5pemVSZXN1bHQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHNvdXJjZVxuICogQHBhcmFtIHs/fSB1cmxcbiAqIEBwYXJhbSB7P30gZ2V0VGFnRGVmaW5pdGlvblxuICogQHBhcmFtIHs/PX0gdG9rZW5pemVFeHBhbnNpb25Gb3Jtc1xuICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9rZW5pemUoc291cmNlLCB1cmwsIGdldFRhZ0RlZmluaXRpb24sIHRva2VuaXplRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICBpZiAodG9rZW5pemVFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICByZXR1cm4gbmV3IF9Ub2tlbml6ZXIobmV3IFBhcnNlU291cmNlRmlsZShzb3VyY2UsIHVybCksIGdldFRhZ0RlZmluaXRpb24sIHRva2VuaXplRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpXG4gICAgICAgIC50b2tlbml6ZSgpO1xufVxudmFyIF9DUl9PUl9DUkxGX1JFR0VYUCA9IC9cXHJcXG4/L2c7XG4vKipcbiAqIEBwYXJhbSB7P30gY2hhckNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2coY2hhckNvZGUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFyID0gY2hhckNvZGUgPT09ICRFT0YgPyAnRU9GJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIHJldHVybiBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyIFxcXCJcIiArIGNoYXIgKyBcIlxcXCJcIjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbnRpdHlTcmNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF91bmtub3duRW50aXR5RXJyb3JNc2coZW50aXR5U3JjKSB7XG4gICAgcmV0dXJuIFwiVW5rbm93biBlbnRpdHkgXFxcIlwiICsgZW50aXR5U3JjICsgXCJcXFwiIC0gdXNlIHRoZSBcXFwiJiM8ZGVjaW1hbD47XFxcIiBvciAgXFxcIiYjeDxoZXg+O1xcXCIgc3ludGF4XCI7XG59XG52YXIgX0NvbnRyb2xGbG93RXJyb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfQ29udHJvbEZsb3dFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBfQ29udHJvbEZsb3dFcnJvcjtcbn0oKSk7XG52YXIgX1Rva2VuaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZmlsZSBUaGUgaHRtbCBzb3VyY2VcbiAgICAgKiBAcGFyYW0gez99IF9nZXRUYWdEZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHs/fSBfdG9rZW5pemVJY3UgV2hldGhlciB0byB0b2tlbml6ZSBJQ1UgbWVzc2FnZXMgKGNvbnNpZGVyZWQgYXMgdGV4dCBub2RlcyB3aGVuIGZhbHNlKVxuICAgICAqIEBwYXJhbSB7Pz19IF9pbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICovXG4gICAgZnVuY3Rpb24gX1Rva2VuaXplcihfZmlsZSwgX2dldFRhZ0RlZmluaXRpb24sIF90b2tlbml6ZUljdSwgX2ludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgaWYgKF9pbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgX2ludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHRoaXMuX2ZpbGUgPSBfZmlsZTtcbiAgICAgICAgdGhpcy5fZ2V0VGFnRGVmaW5pdGlvbiA9IF9nZXRUYWdEZWZpbml0aW9uO1xuICAgICAgICB0aGlzLl90b2tlbml6ZUljdSA9IF90b2tlbml6ZUljdTtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICB0aGlzLl9wZWVrID0gLTE7XG4gICAgICAgIHRoaXMuX25leHRQZWVrID0gLTE7XG4gICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB0aGlzLl9jb2x1bW4gPSAtMTtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IF9maWxlLmNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IF9maWxlLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgICAgICAgLy8gSW4gb3JkZXIgdG8ga2VlcCB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSwgd2UgY2FuIG5vdFxuICAgICAgICAvLyBwcmUtcHJvY2VzcyBpdC5cbiAgICAgICAgLy8gSW5zdGVhZCBDUnMgYXJlIHByb2Nlc3NlZCByaWdodCBiZWZvcmUgaW5zdGFudGlhdGluZyB0aGUgdG9rZW5zLlxuICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKF9DUl9PUl9DUkxGX1JFR0VYUCwgJ1xcbicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09ICRFT0YpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTFQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEJBTkcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRMQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ2RhdGEoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRNSU5VUykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudChzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRG9jVHlwZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdDbG9zZShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnT3BlbihzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISh0aGlzLl90b2tlbml6ZUljdSAmJiB0aGlzLl90b2tlbml6ZUV4cGFuc2lvbkZvcm0oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRU9GKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuaXplUmVzdWx0KG1lcmdlVGV4dFRva2Vucyh0aGlzLnRva2VucyksIHRoaXMuZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fdG9rZW5pemVFeHBhbnNpb25Gb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNFeHBhbnNpb25Gb3JtU3RhcnQodGhpcy5faW5wdXQsIHRoaXMuX2luZGV4LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKSkge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRXhwYW5zaW9uQ2FzZVN0YXJ0KHRoaXMuX3BlZWspICYmIHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlU3RhcnQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wZWVrID09PSAkUkJSQUNFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25Gb3JtRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VMb2NhdGlvbih0aGlzLl9maWxlLCB0aGlzLl9pbmRleCwgdGhpcy5fbGluZSwgdGhpcy5fY29sdW1uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHN0YXJ0XG4gICAgICogQHBhcmFtIHs/PX0gZW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZ2V0U3BhbiA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYmVnaW5Ub2tlbiA9IGZ1bmN0aW9uICh0eXBlLCBzdGFydCkge1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7IH1cbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IHR5cGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcnRzXG4gICAgICogQHBhcmFtIHs/PX0gZW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZW5kVG9rZW4gPSBmdW5jdGlvbiAocGFydHMsIGVuZCkge1xuICAgICAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gdGhpcy5fZ2V0TG9jYXRpb24oKTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IG5ldyBUb2tlbiQxKHRoaXMuX2N1cnJlbnRUb2tlblR5cGUsIHBhcnRzLCBuZXcgUGFyc2VTb3VyY2VTcGFuKHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0LCBlbmQpKTtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbXNnXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBzcGFuKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICBtc2cgKz0gXCIgKERvIHlvdSBoYXZlIGFuIHVuZXNjYXBlZCBcXFwie1xcXCIgaW4geW91ciB0ZW1wbGF0ZT8gVXNlIFxcXCJ7eyAneycgfX1cXFwiKSB0byBlc2NhcGUgaXQuKVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yID0gbmV3IFRva2VuRXJyb3IobXNnLCB0aGlzLl9jdXJyZW50VG9rZW5UeXBlLCBzcGFuKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBfQ29udHJvbEZsb3dFcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKCRFT0YpLCB0aGlzLl9nZXRTcGFuKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wZWVrID09PSAkTEYpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUrKztcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlayAhPT0gJExGICYmIHRoaXMuX3BlZWsgIT09ICRDUikge1xuICAgICAgICAgICAgdGhpcy5fY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5kZXgrKztcbiAgICAgICAgdGhpcy5fcGVlayA9IHRoaXMuX2luZGV4ID49IHRoaXMuX2xlbmd0aCA/ICRFT0YgOiB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHRoaXMuX2luZGV4KTtcbiAgICAgICAgdGhpcy5fbmV4dFBlZWsgPVxuICAgICAgICAgICAgdGhpcy5faW5kZXggKyAxID49IHRoaXMuX2xlbmd0aCA/ICRFT0YgOiB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHRoaXMuX2luZGV4ICsgMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYXJDb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fYXR0ZW1wdENoYXJDb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZWVrID09PSBjaGFyQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFyQ29kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgICAgICBpZiAoY29tcGFyZUNoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlKHRoaXMuX3BlZWssIGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFyQ29kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlcXVpcmVDaGFyQ29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhdGlvbiA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9wZWVrKSwgdGhpcy5fZ2V0U3Bhbihsb2NhdGlvbiwgbG9jYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjaGFyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2F0dGVtcHRTdHIgPSBmdW5jdGlvbiAoY2hhcnMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5faW5kZXggKyBsZW4gPiB0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbml0aWFsUG9zaXRpb24gPSB0aGlzLl9zYXZlUG9zaXRpb24oKTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZShjaGFycy5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGF0dGVtcHRpbmcgdG8gcGFyc2UgdGhlIHN0cmluZyBmYWlscywgd2Ugd2FudCB0byByZXNldCB0aGUgcGFyc2VyXG4gICAgICAgICAgICAgICAgLy8gdG8gd2hlcmUgaXQgd2FzIGJlZm9yZSB0aGUgYXR0ZW1wdFxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVQb3NpdGlvbihpbml0aWFsUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0U3RyQ2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gKGNoYXJzKSB7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY2hhcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVxdWlyZVN0ciA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhdGlvbiA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdFN0cihjaGFycykpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4obG9jYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcmVkaWNhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICB3aGlsZSAoIXByZWRpY2F0ZSh0aGlzLl9wZWVrKSkge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7P30gbGVuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbiA9IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGxlbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4ocHJlZGljYXRlKTtcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4IC0gc3RhcnQub2Zmc2V0IDwgbGVuKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX3BlZWspLCB0aGlzLl9nZXRTcGFuKHN0YXJ0LCBzdGFydCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoYXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9hdHRlbXB0VW50aWxDaGFyID0gZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09IGNoYXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZWNvZGVFbnRpdGllc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlYWRDaGFyID0gZnVuY3Rpb24gKGRlY29kZUVudGl0aWVzKSB7XG4gICAgICAgIGlmIChkZWNvZGVFbnRpdGllcyAmJiB0aGlzLl9wZWVrID09PSAkQU1QRVJTQU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlRW50aXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmRleCA9IHRoaXMuX2luZGV4O1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0W2luZGV4XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fZGVjb2RlRW50aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuX2dldExvY2F0aW9uKCk7XG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkSEFTSCkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzSGV4ID0gdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCR4KSB8fCB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnVtYmVyU3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpLm9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNEaWdpdEVudGl0eUVuZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlayAhPSAkU0VNSUNPTE9OKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9wZWVrKSwgdGhpcy5fZ2V0U3BhbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ck51bSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhudW1iZXJTdGFydCwgdGhpcy5faW5kZXggLSAxKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hhckNvZGUgPSBwYXJzZUludChzdHJOdW0sIGlzSGV4ID8gMTYgOiAxMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRpdHkgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQub2Zmc2V0ICsgMSwgdGhpcy5faW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5rbm93bkVudGl0eUVycm9yTXNnKGVudGl0eSksIHRoaXMuX2dldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0UG9zaXRpb24gPSB0aGlzLl9zYXZlUG9zaXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOYW1lZEVudGl0eUVuZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlayAhPSAkU0VNSUNPTE9OKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzdG9yZVBvc2l0aW9uKHN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiAnJic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHN0YXJ0Lm9mZnNldCArIDEsIHRoaXMuX2luZGV4IC0gMSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGFyID0gTkFNRURfRU5USVRJRVNbbmFtZV07XG4gICAgICAgICAgICBpZiAoIWNoYXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5rbm93bkVudGl0eUVycm9yTXNnKG5hbWUpLCB0aGlzLl9nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZWNvZGVFbnRpdGllc1xuICAgICAqIEBwYXJhbSB7P30gZmlyc3RDaGFyT2ZFbmRcbiAgICAgKiBAcGFyYW0gez99IGF0dGVtcHRFbmRSZXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVJhd1RleHQgPSBmdW5jdGlvbiAoZGVjb2RlRW50aXRpZXMsIGZpcnN0Q2hhck9mRW5kLCBhdHRlbXB0RW5kUmVzdCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWdDbG9zZVN0YXJ0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0U3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKGRlY29kZUVudGl0aWVzID8gVG9rZW5UeXBlJDEuRVNDQVBBQkxFX1JBV19URVhUIDogVG9rZW5UeXBlJDEuUkFXX1RFWFQsIHRleHRTdGFydCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB0YWdDbG9zZVN0YXJ0ID0gdGhpcy5fZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoZmlyc3RDaGFyT2ZFbmQpICYmIGF0dGVtcHRFbmRSZXN0KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+IHRhZ0Nsb3NlU3RhcnQub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBjaGFyYWN0ZXJzIGNvbnN1bWVkIGJ5IHRoZSBwcmV2aW91cyBpZiBzdGF0ZW1lbnQgdG8gdGhlIG91dHB1dFxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5faW5wdXQuc3Vic3RyaW5nKHRhZ0Nsb3NlU3RhcnQub2Zmc2V0LCB0aGlzLl9pbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09IGZpcnN0Q2hhck9mRW5kKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcihkZWNvZGVFbnRpdGllcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhwYXJ0cy5qb2luKCcnKSldLCB0YWdDbG9zZVN0YXJ0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhcnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lQ29tbWVudCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNPTU1FTlRfU1RBUlQsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRNSU5VUyk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dFRva2VuID0gdGhpcy5fY29uc3VtZVJhd1RleHQoZmFsc2UsICRNSU5VUywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2F0dGVtcHRTdHIoJy0+Jyk7IH0pO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNPTU1FTlRfRU5ELCB0ZXh0VG9rZW4uc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUNkYXRhID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQ0RBVEFfU1RBUlQsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZVN0cignQ0RBVEFbJyk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dFRva2VuID0gdGhpcy5fY29uc3VtZVJhd1RleHQoZmFsc2UsICRSQlJBQ0tFVCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2F0dGVtcHRTdHIoJ10+Jyk7IH0pO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkNEQVRBX0VORCwgdGV4dFRva2VuLnNvdXJjZVNwYW4uZW5kKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVEb2NUeXBlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRE9DX1RZUEUsIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdFVudGlsQ2hhcigkR1QpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQub2Zmc2V0ICsgMiwgdGhpcy5faW5kZXggLSAxKV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVByZWZpeEFuZE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVPclByZWZpeFN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeCA9IG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrICE9PSAkQ09MT04gJiYgIWlzUHJlZml4RW5kKHRoaXMuX3BlZWspKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZVN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5fcGVlayA9PT0gJENPTE9OKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBwcmVmaXggPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcobmFtZU9yUHJlZml4U3RhcnQsIHRoaXMuX2luZGV4IC0gMSk7XG4gICAgICAgICAgICBuYW1lU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVTdGFydCA9IG5hbWVPclByZWZpeFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oaXNOYW1lRW5kLCB0aGlzLl9pbmRleCA9PT0gbmFtZVN0YXJ0ID8gMSA6IDApO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKG5hbWVTdGFydCwgdGhpcy5faW5kZXgpO1xuICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW4gPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2F2ZWRQb3MgPSB0aGlzLl9zYXZlUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFnTmFtZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG93ZXJjYXNlVGFnTmFtZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghaXNBc2NpaUxldHRlcih0aGlzLl9wZWVrKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fcGVlayksIHRoaXMuX2dldFNwYW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuU3RhcnQoc3RhcnQpO1xuICAgICAgICAgICAgdGFnTmFtZSA9IHRoaXMuX2lucHV0LnN1YnN0cmluZyhuYW1lU3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICAgICAgICAgIGxvd2VyY2FzZVRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlayAhPT0gJFNMQVNIICYmIHRoaXMuX3BlZWsgIT09ICRHVCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVBdHRyaWJ1dGVOYW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEVRKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnT3BlbkVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIF9Db250cm9sRmxvd0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgc3RhcnQgdGFnIGlzIGludmFsaWQsIGFzc3VtZSB3ZSB3YW50IGEgXCI8XCJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN0b3JlUG9zaXRpb24oc2F2ZWRQb3MpO1xuICAgICAgICAgICAgICAgIC8vIEJhY2sgdG8gYmFjayB0ZXh0IHRva2VucyBhcmUgbWVyZ2VkIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRFWFQsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbJzwnXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50VG9rZW5UeXBlID0gdGhpcy5fZ2V0VGFnRGVmaW5pdGlvbih0YWdOYW1lKS5jb250ZW50VHlwZTtcbiAgICAgICAgaWYgKGNvbnRlbnRUb2tlblR5cGUgPT09IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShsb3dlcmNhc2VUYWdOYW1lLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGVudFRva2VuVHlwZSA9PT0gVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhUKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShsb3dlcmNhc2VUYWdOYW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBsb3dlcmNhc2VUYWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBkZWNvZGVFbnRpdGllc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlID0gZnVuY3Rpb24gKGxvd2VyY2FzZVRhZ05hbWUsIGRlY29kZUVudGl0aWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHRUb2tlbiA9IHRoaXMuX2NvbnN1bWVSYXdUZXh0KGRlY29kZUVudGl0aWVzLCAkTFQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9hdHRlbXB0U3RyQ2FzZUluc2Vuc2l0aXZlKGxvd2VyY2FzZVRhZ05hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2F0dGVtcHRDaGFyQ29kZSgkR1QpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5UQUdfQ0xPU0UsIHRleHRUb2tlbi5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtudWxsLCBsb3dlcmNhc2VUYWdOYW1lXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ09wZW5TdGFydCA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRBR19PUEVOX1NUQVJULCBzdGFydCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnRzID0gdGhpcy5fY29uc3VtZVByZWZpeEFuZE5hbWUoKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuQVRUUl9OQU1FKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUF0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkFUVFJfVkFMVUUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRTUSB8fCB0aGlzLl9wZWVrID09PSAkRFEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1b3RlQ2hhciA9IHRoaXMuX3BlZWs7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsgIT09IHF1b3RlQ2hhcikge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlU3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oaXNOYW1lRW5kLCAxKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHZhbHVlU3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyh2YWx1ZSldKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVUYWdPcGVuRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlblR5cGUgPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFNMQVNIKSA/IFRva2VuVHlwZSQxLlRBR19PUEVOX0VORF9WT0lEIDogVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKHRva2VuVHlwZSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkR1QpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZVRhZ0Nsb3NlID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuVEFHX0NMT1NFLCBzdGFydCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaChUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuUkFXX1RFWFQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25kaXRpb24gPSB0aGlzLl9yZWFkVW50aWwoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW2NvbmRpdGlvbl0sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlJBV19URVhULCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZSA9IHRoaXMuX3JlYWRVbnRpbCgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdHlwZV0sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkNhc2VTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9WQUxVRSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdGhpcy5fcmVhZFVudGlsKCRMQlJBQ0UpLnRyaW0oKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3ZhbHVlXSwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQsIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJExCUkFDRSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdLCB0aGlzLl9nZXRMb2NhdGlvbigpKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaChUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5fY29uc3VtZUV4cGFuc2lvbkNhc2VFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10sIHRoaXMuX2dldExvY2F0aW9uKCkpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb25Gb3JtRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX0VORCwgdGhpcy5fZ2V0TG9jYXRpb24oKSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucG9wKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9jb25zdW1lVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSB0aGlzLl9nZXRMb2NhdGlvbigpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKFRva2VuVHlwZSQxLlRFWFQsIHN0YXJ0KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgJiYgdGhpcy5fYXR0ZW1wdFN0cih0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5JbnRlcnBvbGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgJiYgdGhpcy5faW5JbnRlcnBvbGF0aW9uICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdFN0cih0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICghdGhpcy5faXNUZXh0RW5kKCkpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhwYXJ0cy5qb2luKCcnKSldKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX2lzVGV4dEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRMVCB8fCB0aGlzLl9wZWVrID09PSAkRU9GKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdG9rZW5pemVJY3UgJiYgIXRoaXMuX2luSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgaWYgKGlzRXhwYW5zaW9uRm9ybVN0YXJ0KHRoaXMuX2lucHV0LCB0aGlzLl9pbmRleCwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBvZiBhbiBleHBhbnNpb24gZm9ybVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsgPT09ICRSQlJBQ0UgJiYgdGhpcy5faXNJbkV4cGFuc2lvbkNhc2UoKSkge1xuICAgICAgICAgICAgICAgIC8vIGVuZCBvZiBhbmQgZXhwYW5zaW9uIGNhc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9zYXZlUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5fcGVlaywgdGhpcy5faW5kZXgsIHRoaXMuX2NvbHVtbiwgdGhpcy5fbGluZSwgdGhpcy50b2tlbnMubGVuZ3RoXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2hhclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Rva2VuaXplci5wcm90b3R5cGUuX3JlYWRVbnRpbCA9IGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoY2hhcik7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuX2luZGV4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcG9zaXRpb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9yZXN0b3JlUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fcGVlayA9IHBvc2l0aW9uWzBdO1xuICAgICAgICB0aGlzLl9pbmRleCA9IHBvc2l0aW9uWzFdO1xuICAgICAgICB0aGlzLl9jb2x1bW4gPSBwb3NpdGlvblsyXTtcbiAgICAgICAgdGhpcy5fbGluZSA9IHBvc2l0aW9uWzNdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYlRva2VucyA9IHBvc2l0aW9uWzRdO1xuICAgICAgICBpZiAobmJUb2tlbnMgPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbnkgZXh0cmEgdG9rZW5zXG4gICAgICAgICAgICB0aGlzLnRva2VucyA9IHRoaXMudG9rZW5zLnNsaWNlKDAsIG5iVG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVG9rZW5pemVyLnByb3RvdHlwZS5faXNJbkV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrW3RoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggLSAxXSA9PT1cbiAgICAgICAgICAgICAgICBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Ub2tlbml6ZXIucHJvdG90eXBlLl9pc0luRXhwYW5zaW9uRm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgIFRva2VuVHlwZSQxLkVYUEFOU0lPTl9GT1JNX1NUQVJUO1xuICAgIH07XG4gICAgcmV0dXJuIF9Ub2tlbml6ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzTm90V2hpdGVzcGFjZShjb2RlKSB7XG4gICAgcmV0dXJuICFpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEVPRjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc05hbWVFbmQoY29kZSkge1xuICAgIHJldHVybiBpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEdUIHx8IGNvZGUgPT09ICRTTEFTSCB8fFxuICAgICAgICBjb2RlID09PSAkU1EgfHwgY29kZSA9PT0gJERRIHx8IGNvZGUgPT09ICRFUTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1ByZWZpeEVuZChjb2RlKSB7XG4gICAgcmV0dXJuIChjb2RlIDwgJGEgfHwgJHogPCBjb2RlKSAmJiAoY29kZSA8ICRBIHx8ICRaIDwgY29kZSkgJiZcbiAgICAgICAgKGNvZGUgPCAkMCB8fCBjb2RlID4gJDkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRGlnaXRFbnRpdHlFbmQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09ICRTRU1JQ09MT04gfHwgY29kZSA9PSAkRU9GIHx8ICFpc0FzY2lpSGV4RGlnaXQoY29kZSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29kZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNOYW1lZEVudGl0eUVuZChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJFNFTUlDT0xPTiB8fCBjb2RlID09ICRFT0YgfHwgIWlzQXNjaWlMZXR0ZXIoY29kZSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gb2Zmc2V0XG4gKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRXhwYW5zaW9uRm9ybVN0YXJ0KGlucHV0LCBvZmZzZXQsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0ludGVycG9sYXRpb25TdGFydCA9IGludGVycG9sYXRpb25Db25maWcgPyBpbnB1dC5pbmRleE9mKGludGVycG9sYXRpb25Db25maWcuc3RhcnQsIG9mZnNldCkgPT0gb2Zmc2V0IDogZmFsc2U7XG4gICAgcmV0dXJuIGlucHV0LmNoYXJDb2RlQXQob2Zmc2V0KSA9PSAkTEJSQUNFICYmICFpc0ludGVycG9sYXRpb25TdGFydDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwZWVrXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0V4cGFuc2lvbkNhc2VTdGFydChwZWVrKSB7XG4gICAgcmV0dXJuIHBlZWsgPT09ICRFUSB8fCBpc0FzY2lpTGV0dGVyKHBlZWspO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGUxXG4gKiBAcGFyYW0gez99IGNvZGUyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb21wYXJlQ2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY29kZTEsIGNvZGUyKSB7XG4gICAgcmV0dXJuIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTEpID09IHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGNvZGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogPyBjb2RlIC0gJGEgKyAkQSA6IGNvZGU7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3JjVG9rZW5zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtZXJnZVRleHRUb2tlbnMoc3JjVG9rZW5zKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZHN0VG9rZW5zID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdERzdFRva2VuO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzcmNUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW4gPSBzcmNUb2tlbnNbaV07XG4gICAgICAgIGlmIChsYXN0RHN0VG9rZW4gJiYgbGFzdERzdFRva2VuLnR5cGUgPT0gVG9rZW5UeXBlJDEuVEVYVCAmJiB0b2tlbi50eXBlID09IFRva2VuVHlwZSQxLlRFWFQpIHtcbiAgICAgICAgICAgIGxhc3REc3RUb2tlbi5wYXJ0c1swXSArPSB0b2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgIGxhc3REc3RUb2tlbi5zb3VyY2VTcGFuLmVuZCA9IHRva2VuLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFzdERzdFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICBkc3RUb2tlbnMucHVzaChsYXN0RHN0VG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkc3RUb2tlbnM7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVHJlZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJlZUVycm9yLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG1zZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1zZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBtc2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyZWVFcnJvci5jcmVhdGUgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUsIHNwYW4sIG1zZykge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKTtcbiAgICB9O1xuICAgIHJldHVybiBUcmVlRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbnZhciBQYXJzZVRyZWVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcm9vdE5vZGVzXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXJzZVRyZWVSZXN1bHQocm9vdE5vZGVzLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy5yb290Tm9kZXMgPSByb290Tm9kZXM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VUcmVlUmVzdWx0O1xufSgpKTtcbnZhciBQYXJzZXIkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBnZXRUYWdEZWZpbml0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyc2VyJDEoZ2V0VGFnRGVmaW5pdGlvbikge1xuICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24gPSBnZXRUYWdEZWZpbml0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gcGFyc2VFeHBhbnNpb25Gb3Jtc1xuICAgICAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBhcnNlciQxLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAocGFyc2VFeHBhbnNpb25Gb3JtcyA9PT0gdm9pZCAwKSB7IHBhcnNlRXhwYW5zaW9uRm9ybXMgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbkNvbmZpZyA9PT0gdm9pZCAwKSB7IGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2Vuc0FuZEVycm9ycyA9IHRva2VuaXplKHNvdXJjZSwgdXJsLCB0aGlzLmdldFRhZ0RlZmluaXRpb24sIHBhcnNlRXhwYW5zaW9uRm9ybXMsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmVlQW5kRXJyb3JzID0gbmV3IF9UcmVlQnVpbGRlcih0b2tlbnNBbmRFcnJvcnMudG9rZW5zLCB0aGlzLmdldFRhZ0RlZmluaXRpb24pLmJ1aWxkKCk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHRyZWVBbmRFcnJvcnMucm9vdE5vZGVzLCAoKHRva2Vuc0FuZEVycm9ycy5lcnJvcnMpKS5jb25jYXQodHJlZUFuZEVycm9ycy5lcnJvcnMpKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXIkMTtcbn0oKSk7XG52YXIgX1RyZWVCdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2Vuc1xuICAgICAqIEBwYXJhbSB7P30gZ2V0VGFnRGVmaW5pdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9UcmVlQnVpbGRlcih0b2tlbnMsIGdldFRhZ0RlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbiA9IGdldFRhZ0RlZmluaXRpb247XG4gICAgICAgIHRoaXMuX2luZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuX3Jvb3ROb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlICE9PSBUb2tlblR5cGUkMS5FT0YpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRBR19PUEVOX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVN0YXJ0VGFnKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlRBR19DTE9TRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFbmRUYWcodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuQ0RBVEFfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVZvaWRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNkYXRhKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkNPTU1FTlRfU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVZvaWRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNvbW1lbnQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuVEVYVCB8fCB0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLlJBV19URVhUIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FU0NBUEFCTEVfUkFXX1RFWFQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVZvaWRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRleHQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGFsbCBvdGhlciB0b2tlbnMuLi5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodGhpcy5fcm9vdE5vZGVzLCB0aGlzLl9lcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9hZHZhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2ID0gdGhpcy5fcGVlaztcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgLy8gTm90ZTogdGhlcmUgaXMgYWx3YXlzIGFuIEVPRiB0b2tlbiBhdCB0aGUgZW5kXG4gICAgICAgICAgICB0aGlzLl9pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BlZWsgPSB0aGlzLnRva2Vuc1t0aGlzLl9pbmRleF07XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9hZHZhbmNlSWYgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFRva2VuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQ2RhdGEgPSBmdW5jdGlvbiAoc3RhcnRUb2tlbikge1xuICAgICAgICB0aGlzLl9jb25zdW1lVGV4dCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlJDEuQ0RBVEFfRU5EKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVDb21tZW50ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHQgPSB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlJDEuUkFXX1RFWFQpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlSWYoVG9rZW5UeXBlJDEuQ09NTUVOVF9FTkQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRleHQgIT0gbnVsbCA/IHRleHQucGFydHNbMF0udHJpbSgpIDogbnVsbDtcbiAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobmV3IENvbW1lbnQodmFsdWUsIHRva2VuLnNvdXJjZVNwYW4pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVFeHBhbnNpb24gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3dpdGNoVmFsdWUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0gW107XG4gICAgICAgIC8vIHJlYWQgPVxuICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9WQUxVRSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwQ2FzZSA9IHRoaXMuX3BhcnNlRXhwYW5zaW9uQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKCFleHBDYXNlKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZXJyb3JcbiAgICAgICAgICAgIGNhc2VzLnB1c2goZXhwQ2FzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZCB0aGUgZmluYWwgfVxuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlICE9PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLCBcIkludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLlwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4odG9rZW4uc291cmNlU3Bhbi5zdGFydCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ldyBFeHBhbnNpb24oc3dpdGNoVmFsdWUucGFydHNbMF0sIHR5cGUucGFydHNbMF0sIGNhc2VzLCBzb3VyY2VTcGFuLCBzd2l0Y2hWYWx1ZS5zb3VyY2VTcGFuKSk7XG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fcGFyc2VFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgLy8gcmVhZCB7XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgIT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCB0aGlzLl9wZWVrLnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAneycuXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWQgdW50aWwgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydCA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwID0gdGhpcy5fY29sbGVjdEV4cGFuc2lvbkV4cFRva2VucyhzdGFydCk7XG4gICAgICAgIGlmICghZXhwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgZXhwLnB1c2gobmV3IFRva2VuJDEoVG9rZW5UeXBlJDEuRU9GLCBbXSwgZW5kLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgLy8gcGFyc2UgZXZlcnl0aGluZyBpbiBiZXR3ZWVuIHsgYW5kIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyc2VkRXhwID0gbmV3IF9UcmVlQnVpbGRlcihleHAsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbikuYnVpbGQoKTtcbiAgICAgICAgaWYgKHBhcnNlZEV4cC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzID0gdGhpcy5fZXJyb3JzLmNvbmNhdCgvKiogQHR5cGUgez99ICovIChwYXJzZWRFeHAuZXJyb3JzKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3Bhbih2YWx1ZS5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBTb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydC5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICByZXR1cm4gbmV3IEV4cGFuc2lvbkNhc2UodmFsdWUucGFydHNbMF0sIHBhcnNlZEV4cC5yb290Tm9kZXMsIHNvdXJjZVNwYW4sIHZhbHVlLnNvdXJjZVNwYW4sIGV4cFNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGFydFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29sbGVjdEV4cGFuc2lvbkV4cFRva2VucyA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHAgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwYW5zaW9uRm9ybVN0YWNrID0gW1Rva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVF07XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FWFBBTlNJT05fRk9STV9TVEFSVCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnB1c2godGhpcy5fcGVlay50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkVYUEFOU0lPTl9DQVNFX0VYUF9FTkQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdE9uU3RhY2soZXhwYW5zaW9uRm9ybVN0YWNrLCBUb2tlblR5cGUkMS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGFuc2lvbkZvcm1TdGFjay5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fRU5EKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RPblN0YWNrKGV4cGFuc2lvbkZvcm1TdGFjaywgVG9rZW5UeXBlJDEuRVhQQU5TSU9OX0ZPUk1fU1RBUlQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgXCJJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5cIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5FT0YpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIFwiSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cC5wdXNoKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRleHQgPSB0b2tlbi5wYXJ0c1swXTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCAmJiB0ZXh0WzBdID09ICdcXG4nKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9IG51bGwgJiYgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uKHBhcmVudC5uYW1lKS5pZ25vcmVGaXJzdExmKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ldyBUZXh0KHRleHQsIHRva2VuLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jbG9zZVZvaWRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsID0gdGhpcy5fZWxlbWVudFN0YWNrW3RoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldFRhZ0RlZmluaXRpb24oZWwubmFtZSkuaXNWb2lkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXJ0VGFnVG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2NvbnN1bWVTdGFydFRhZyA9IGZ1bmN0aW9uIChzdGFydFRhZ1Rva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZWZpeCA9IHN0YXJ0VGFnVG9rZW4ucGFydHNbMF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBzdGFydFRhZ1Rva2VuLnBhcnRzWzFdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRycyA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlID09PSBUb2tlblR5cGUkMS5BVFRSX05BTUUpIHtcbiAgICAgICAgICAgIGF0dHJzLnB1c2godGhpcy5fY29uc3VtZUF0dHIodGhpcy5fYWR2YW5jZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVsbE5hbWUgPSB0aGlzLl9nZXRFbGVtZW50RnVsbE5hbWUocHJlZml4LCBuYW1lLCB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxmQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAvLyBOb3RlOiBUaGVyZSBjb3VsZCBoYXZlIGJlZW4gYSB0b2tlbml6ZXIgZXJyb3JcbiAgICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBnZXQgYSB0b2tlbiBmb3IgdGhlIGVuZCB0YWcuLi5cbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EX1ZPSUQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhZ0RlZiA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihmdWxsTmFtZSk7XG4gICAgICAgICAgICBpZiAoISh0YWdEZWYuY2FuU2VsZkNsb3NlIHx8IGdldE5zUHJlZml4KGZ1bGxOYW1lKSAhPT0gbnVsbCB8fCB0YWdEZWYuaXNWb2lkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIHN0YXJ0VGFnVG9rZW4uc291cmNlU3BhbiwgXCJPbmx5IHZvaWQgYW5kIGZvcmVpZ24gZWxlbWVudHMgY2FuIGJlIHNlbGYgY2xvc2VkIFxcXCJcIiArIHN0YXJ0VGFnVG9rZW4ucGFydHNbMV0gKyBcIlxcXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gVG9rZW5UeXBlJDEuVEFHX09QRU5fRU5EKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBzZWxmQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IHRoaXMuX3BlZWsuc291cmNlU3Bhbi5zdGFydDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbCA9IG5ldyBFbGVtZW50KGZ1bGxOYW1lLCBhdHRycywgW10sIHNwYW4sIHNwYW4sIG51bGwpO1xuICAgICAgICB0aGlzLl9wdXNoRWxlbWVudChlbCk7XG4gICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xuICAgICAgICAgICAgdGhpcy5fcG9wRWxlbWVudChmdWxsTmFtZSk7XG4gICAgICAgICAgICBlbC5lbmRTb3VyY2VTcGFuID0gc3BhbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fcHVzaEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRFbCA9IHRoaXMuX2VsZW1lbnRTdGFja1t0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRUYWdEZWZpbml0aW9uKHBhcmVudEVsLm5hbWUpLmlzQ2xvc2VkQnlDaGlsZChlbC5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWdEZWYgPSB0aGlzLmdldFRhZ0RlZmluaXRpb24oZWwubmFtZSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnRTa2lwcGluZ0NvbnRhaW5lcnMoKSwgcGFyZW50ID0gX2EucGFyZW50LCBjb250YWluZXIgPSBfYS5jb250YWluZXI7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgdGFnRGVmLnJlcXVpcmVFeHRyYVBhcmVudChwYXJlbnQubmFtZSkpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5ld1BhcmVudCA9IG5ldyBFbGVtZW50KHRhZ0RlZi5wYXJlbnRUb0FkZCwgW10sIFtdLCBlbC5zb3VyY2VTcGFuLCBlbC5zdGFydFNvdXJjZVNwYW4sIGVsLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0QmVmb3JlQ29udGFpbmVyKHBhcmVudCwgY29udGFpbmVyLCBuZXdQYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KGVsKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnB1c2goZWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbmRUYWdUb2tlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fY29uc3VtZUVuZFRhZyA9IGZ1bmN0aW9uIChlbmRUYWdUb2tlbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdWxsTmFtZSA9IHRoaXMuX2dldEVsZW1lbnRGdWxsTmFtZShlbmRUYWdUb2tlbi5wYXJ0c1swXSwgZW5kVGFnVG9rZW4ucGFydHNbMV0sIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSk7XG4gICAgICAgIGlmICh0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKS5lbmRTb3VyY2VTcGFuID0gZW5kVGFnVG9rZW4uc291cmNlU3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRUYWdEZWZpbml0aW9uKGZ1bGxOYW1lKS5pc1ZvaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIGVuZFRhZ1Rva2VuLnNvdXJjZVNwYW4sIFwiVm9pZCBlbGVtZW50cyBkbyBub3QgaGF2ZSBlbmQgdGFncyBcXFwiXCIgKyBlbmRUYWdUb2tlbi5wYXJ0c1sxXSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3BvcEVsZW1lbnQoZnVsbE5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJNc2cgPSBcIlVuZXhwZWN0ZWQgY2xvc2luZyB0YWcgXFxcIlwiICsgZnVsbE5hbWUgKyBcIlxcXCIuIEl0IG1heSBoYXBwZW4gd2hlbiB0aGUgdGFnIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ5IGFub3RoZXIgdGFnLiBGb3IgbW9yZSBpbmZvIHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjY2xvc2luZy1lbGVtZW50cy10aGF0LWhhdmUtaW1wbGllZC1lbmQtdGFnc1wiO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbiwgZXJyTXNnKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZnVsbE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX3BvcEVsZW1lbnQgPSBmdW5jdGlvbiAoZnVsbE5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFja0luZGV4ID0gdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIDE7IHN0YWNrSW5kZXggPj0gMDsgc3RhY2tJbmRleC0tKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbCA9IHRoaXMuX2VsZW1lbnRTdGFja1tzdGFja0luZGV4XTtcbiAgICAgICAgICAgIGlmIChlbC5uYW1lID09IGZ1bGxOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnNwbGljZShzdGFja0luZGV4LCB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gc3RhY2tJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0VGFnRGVmaW5pdGlvbihlbC5uYW1lKS5jbG9zZWRCeVBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHJlZUJ1aWxkZXIucHJvdG90eXBlLl9jb25zdW1lQXR0ciA9IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdWxsTmFtZSA9IG1lcmdlTnNBbmROYW1lKGF0dHJOYW1lLnBhcnRzWzBdLCBhdHRyTmFtZS5wYXJ0c1sxXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IGF0dHJOYW1lLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZVNwYW47XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IFRva2VuVHlwZSQxLkFUVFJfVkFMVUUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlVG9rZW4gPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlVG9rZW4ucGFydHNbMF07XG4gICAgICAgICAgICBlbmQgPSB2YWx1ZVRva2VuLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAgICAgdmFsdWVTcGFuID0gdmFsdWVUb2tlbi5zb3VyY2VTcGFuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlJDEoZnVsbE5hbWUsIHZhbHVlLCBuZXcgUGFyc2VTb3VyY2VTcGFuKGF0dHJOYW1lLnNvdXJjZVNwYW4uc3RhcnQsIGVuZCksIHZhbHVlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldFBhcmVudEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoID4gMCA/IHRoaXMuX2VsZW1lbnRTdGFja1t0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyZW50IGluIHRoZSBET00gYW5kIHRoZSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBgPG5nLWNvbnRhaW5lcj5gIGVsZW1lbnRzIGFyZSBza2lwcGVkIGFzIHRoZXkgYXJlIG5vdCByZW5kZXJlZCBhcyBET00gZWxlbWVudC5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldFBhcmVudEVsZW1lbnRTa2lwcGluZ0NvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRTdGFja1tpXS5uYW1lICE9PSAnbmctY29udGFpbmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHBhcmVudDogdGhpcy5fZWxlbWVudFN0YWNrW2ldLCBjb250YWluZXI6IGNvbnRhaW5lciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5fZWxlbWVudFN0YWNrW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHBhcmVudDogdGhpcy5fZWxlbWVudFN0YWNrW3RoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXSwgY29udGFpbmVyOiBjb250YWluZXIgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RyZWVCdWlsZGVyLnByb3RvdHlwZS5fYWRkVG9QYXJlbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgbm9kZSBiZXR3ZWVuIHRoZSBwYXJlbnQgYW5kIHRoZSBjb250YWluZXIuXG4gICAgICogV2hlbiBubyBjb250YWluZXIgaXMgZ2l2ZW4sIHRoZSBub2RlIGlzIGFwcGVuZGVkIGFzIGEgY2hpbGQgb2YgdGhlIHBhcmVudC5cbiAgICAgKiBBbHNvIHVwZGF0ZXMgdGhlIGVsZW1lbnQgc3RhY2sgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2luc2VydEJlZm9yZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnQsIGNvbnRhaW5lciwgbm9kZSkge1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBjb250YWluZXIgd2l0aCB0aGUgbmV3IG5vZGUgaW4gdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbltpbmRleF0gPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goY29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5zcGxpY2UodGhpcy5fZWxlbWVudFN0YWNrLmluZGV4T2YoY29udGFpbmVyKSwgMCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlZml4XG4gICAgICogQHBhcmFtIHs/fSBsb2NhbE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudEVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9UcmVlQnVpbGRlci5wcm90b3R5cGUuX2dldEVsZW1lbnRGdWxsTmFtZSA9IGZ1bmN0aW9uIChwcmVmaXgsIGxvY2FsTmFtZSwgcGFyZW50RWxlbWVudCkge1xuICAgICAgICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihsb2NhbE5hbWUpLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4O1xuICAgICAgICAgICAgaWYgKHByZWZpeCA9PSBudWxsICYmIHBhcmVudEVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IGdldE5zUHJlZml4KHBhcmVudEVsZW1lbnQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlTnNBbmROYW1lKHByZWZpeCwgbG9jYWxOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBfVHJlZUJ1aWxkZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHN0YWNrXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGxhc3RPblN0YWNrKHN0YWNrLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IGVsZW1lbnQ7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgTWVzc2FnZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlcyBtZXNzYWdlIEFTVFxuICAgICAqIEBwYXJhbSB7P30gcGxhY2Vob2xkZXJzIG1hcHMgcGxhY2Vob2xkZXIgbmFtZXMgdG8gc3RhdGljIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHBsYWNlaG9sZGVyVG9NZXNzYWdlIG1hcHMgcGxhY2Vob2xkZXIgbmFtZXMgdG8gbWVzc2FnZXMgKHVzZWQgZm9yIG5lc3RlZCBJQ1UgbWVzc2FnZXMpXG4gICAgICogQHBhcmFtIHs/fSBtZWFuaW5nXG4gICAgICogQHBhcmFtIHs/fSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZXNzYWdlKG5vZGVzLCBwbGFjZWhvbGRlcnMsIHBsYWNlaG9sZGVyVG9NZXNzYWdlLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpIHtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IHBsYWNlaG9sZGVycztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlclRvTWVzc2FnZSA9IHBsYWNlaG9sZGVyVG9NZXNzYWdlO1xuICAgICAgICB0aGlzLm1lYW5pbmcgPSBtZWFuaW5nO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2U7XG59KCkpO1xudmFyIFRleHQkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRleHQkMSh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRleHQkMS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIFRleHQkMTtcbn0oKSk7XG52YXIgQ29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNoaWxkcmVuXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29udGFpbmVyKGNoaWxkcmVuLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29udGFpbmVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0Q29udGFpbmVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBDb250YWluZXI7XG59KCkpO1xudmFyIEljdSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjYXNlc1xuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEljdShleHByZXNzaW9uLCB0eXBlLCBjYXNlcywgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEljdS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdEljdSh0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gSWN1O1xufSgpKTtcbnZhciBUYWdQbGFjZWhvbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBzdGFydE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGNsb3NlTmFtZVxuICAgICAqIEBwYXJhbSB7P30gY2hpbGRyZW5cbiAgICAgKiBAcGFyYW0gez99IGlzVm9pZFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRhZ1BsYWNlaG9sZGVyKHRhZywgYXR0cnMsIHN0YXJ0TmFtZSwgY2xvc2VOYW1lLCBjaGlsZHJlbiwgaXNWb2lkLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3RhcnROYW1lID0gc3RhcnROYW1lO1xuICAgICAgICB0aGlzLmNsb3NlTmFtZSA9IGNsb3NlTmFtZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGFnUGxhY2Vob2xkZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWdQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTsgfTtcbiAgICByZXR1cm4gVGFnUGxhY2Vob2xkZXI7XG59KCkpO1xudmFyIFBsYWNlaG9sZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGxhY2Vob2xkZXIodmFsdWUsIG5hbWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkgeyByZXR1cm4gdmlzaXRvci52aXNpdFBsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBQbGFjZWhvbGRlcjtcbn0oKSk7XG52YXIgSWN1UGxhY2Vob2xkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJY3VQbGFjZWhvbGRlcih2YWx1ZSwgbmFtZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEljdVBsYWNlaG9sZGVyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IHJldHVybiB2aXNpdG9yLnZpc2l0SWN1UGxhY2Vob2xkZXIodGhpcywgY29udGV4dCk7IH07XG4gICAgcmV0dXJuIEljdVBsYWNlaG9sZGVyO1xufSgpKTtcbnZhciBDbG9uZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsb25lVmlzaXRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gbmV3IFRleHQkMSh0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSBjb250YWluZXIuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnZpc2l0KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQ29udGFpbmVyKGNoaWxkcmVuLCBjb250YWluZXIuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENsb25lVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjYXNlc1trZXldID0gaWN1LmNhc2VzW2tleV0udmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbXNnID0gbmV3IEljdShpY3UuZXhwcmVzc2lvbiwgaWN1LnR5cGUsIGNhc2VzLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIG1zZy5leHByZXNzaW9uUGxhY2Vob2xkZXIgPSBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyO1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENsb25lVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IFRhZ1BsYWNlaG9sZGVyKHBoLnRhZywgcGguYXR0cnMsIHBoLnN0YXJ0TmFtZSwgcGguY2xvc2VOYW1lLCBjaGlsZHJlbiwgcGguaXNWb2lkLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDbG9uZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcihwaC52YWx1ZSwgcGgubmFtZSwgcGguc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ2xvbmVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgSWN1UGxhY2Vob2xkZXIocGgudmFsdWUsIHBoLm5hbWUsIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIENsb25lVmlzaXRvcjtcbn0oKSk7XG52YXIgUmVjdXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2VWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2hpbGQudmlzaXQoX3RoaXMpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcGguY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHsgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7IH07XG4gICAgO1xuICAgIHJldHVybiBSZWN1cnNlVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTID0ge1xuICAgICdBJzogJ0xJTksnLFxuICAgICdCJzogJ0JPTERfVEVYVCcsXG4gICAgJ0JSJzogJ0xJTkVfQlJFQUsnLFxuICAgICdFTSc6ICdFTVBIQVNJU0VEX1RFWFQnLFxuICAgICdIMSc6ICdIRUFESU5HX0xFVkVMMScsXG4gICAgJ0gyJzogJ0hFQURJTkdfTEVWRUwyJyxcbiAgICAnSDMnOiAnSEVBRElOR19MRVZFTDMnLFxuICAgICdINCc6ICdIRUFESU5HX0xFVkVMNCcsXG4gICAgJ0g1JzogJ0hFQURJTkdfTEVWRUw1JyxcbiAgICAnSDYnOiAnSEVBRElOR19MRVZFTDYnLFxuICAgICdIUic6ICdIT1JJWk9OVEFMX1JVTEUnLFxuICAgICdJJzogJ0lUQUxJQ19URVhUJyxcbiAgICAnTEknOiAnTElTVF9JVEVNJyxcbiAgICAnTElOSyc6ICdNRURJQV9MSU5LJyxcbiAgICAnT0wnOiAnT1JERVJFRF9MSVNUJyxcbiAgICAnUCc6ICdQQVJBR1JBUEgnLFxuICAgICdRJzogJ1FVT1RBVElPTicsXG4gICAgJ1MnOiAnU1RSSUtFVEhST1VHSF9URVhUJyxcbiAgICAnU01BTEwnOiAnU01BTExfVEVYVCcsXG4gICAgJ1NVQic6ICdTVUJTVFJJUFQnLFxuICAgICdTVVAnOiAnU1VQRVJTQ1JJUFQnLFxuICAgICdUQk9EWSc6ICdUQUJMRV9CT0RZJyxcbiAgICAnVEQnOiAnVEFCTEVfQ0VMTCcsXG4gICAgJ1RGT09UJzogJ1RBQkxFX0ZPT1RFUicsXG4gICAgJ1RIJzogJ1RBQkxFX0hFQURFUl9DRUxMJyxcbiAgICAnVEhFQUQnOiAnVEFCTEVfSEVBREVSJyxcbiAgICAnVFInOiAnVEFCTEVfUk9XJyxcbiAgICAnVFQnOiAnTU9OT1NQQUNFRF9URVhUJyxcbiAgICAnVSc6ICdVTkRFUkxJTkVEX1RFWFQnLFxuICAgICdVTCc6ICdVTk9SREVSRURfTElTVCcsXG59O1xuLyoqXG4gKiBDcmVhdGVzIHVuaXF1ZSBuYW1lcyBmb3IgcGxhY2Vob2xkZXIgd2l0aCBkaWZmZXJlbnQgY29udGVudC5cbiAqXG4gKiBSZXR1cm5zIHRoZSBzYW1lIHBsYWNlaG9sZGVyIG5hbWUgd2hlbiB0aGUgY29udGVudCBpcyBpZGVudGljYWwuXG4gKlxuICogXFxAaW50ZXJuYWxcbiAqL1xudmFyIFBsYWNlaG9sZGVyUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBsYWNlaG9sZGVyUmVnaXN0cnkoKSB7XG4gICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50cyA9IHt9O1xuICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWUgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdcbiAgICAgKiBAcGFyYW0gez99IGF0dHJzXG4gICAgICogQHBhcmFtIHs/fSBpc1ZvaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLmdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKHRhZywgYXR0cnMsIGlzVm9pZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaWduYXR1cmUgPSB0aGlzLl9oYXNoVGFnKHRhZywgYXR0cnMsIGlzVm9pZCk7XG4gICAgICAgIGlmICh0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwcGVyVGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VOYW1lID0gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBcIlRBR19cIiArIHVwcGVyVGFnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5fZ2VuZXJhdGVVbmlxdWVOYW1lKGlzVm9pZCA/IGJhc2VOYW1lIDogXCJTVEFSVF9cIiArIGJhc2VOYW1lKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2lnbmF0dXJlID0gdGhpcy5faGFzaENsb3NpbmdUYWcodGFnKTtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IFwiVEFHX1wiICsgdXBwZXJUYWc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoXCJDTE9TRV9cIiArIGJhc2VOYW1lKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUGxhY2Vob2xkZXJSZWdpc3RyeS5wcm90b3R5cGUuZ2V0UGxhY2Vob2xkZXJOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBwZXJOYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzaWduYXR1cmUgPSBcIlBIOiBcIiArIHVwcGVyTmFtZSArIFwiPVwiICsgY29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pcXVlTmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZSh1cHBlck5hbWUpO1xuICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSA9IHVuaXF1ZU5hbWU7XG4gICAgICAgIHJldHVybiB1bmlxdWVOYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRVbmlxdWVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUobmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHBhcmFtIHs/fSBhdHRyc1xuICAgICAqIEBwYXJhbSB7P30gaXNWb2lkXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5faGFzaFRhZyA9IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCBpc1ZvaWQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnQgPSBcIjxcIiArIHRhZztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykuc29ydCgpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gXCIgXCIgKyBuYW1lICsgXCI9XCIgKyBhdHRyc1tuYW1lXTsgfSkuam9pbignJyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVuZCA9IGlzVm9pZCA/ICcvPicgOiBcIj48L1wiICsgdGFnICsgXCI+XCI7XG4gICAgICAgIHJldHVybiBzdGFydCArIHN0ckF0dHJzICsgZW5kO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0YWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBsYWNlaG9sZGVyUmVnaXN0cnkucHJvdG90eXBlLl9oYXNoQ2xvc2luZ1RhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRoaXMuX2hhc2hUYWcoXCIvXCIgKyB0YWcsIHt9LCBmYWxzZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBiYXNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQbGFjZWhvbGRlclJlZ2lzdHJ5LnByb3RvdHlwZS5fZ2VuZXJhdGVVbmlxdWVOYW1lID0gZnVuY3Rpb24gKGJhc2UpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VlbiA9IHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50cy5oYXNPd25Qcm9wZXJ0eShiYXNlKTtcbiAgICAgICAgaWYgKCFzZWVuKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV07XG4gICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50c1tiYXNlXSA9IGlkICsgMTtcbiAgICAgICAgcmV0dXJuIGJhc2UgKyBcIl9cIiArIGlkO1xuICAgIH07XG4gICAgcmV0dXJuIFBsYWNlaG9sZGVyUmVnaXN0cnk7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9leHBQYXJzZXIgPSBuZXcgUGFyc2VyKG5ldyBMZXhlcigpKTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGNvbnZlcnRpbmcgaHRtbCBub2RlcyB0byBhbiBpMThuIE1lc3NhZ2UgZ2l2ZW4gYW4gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKF9leHBQYXJzZXIsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCkgeyByZXR1cm4gdmlzaXRvci50b0kxOG5NZXNzYWdlKG5vZGVzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpOyB9O1xufVxudmFyIF9JMThuVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZXhwcmVzc2lvblBhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX2ludGVycG9sYXRpb25Db25maWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfSTE4blZpc2l0b3IoX2V4cHJlc3Npb25QYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2V4cHJlc3Npb25QYXJzZXIgPSBfZXhwcmVzc2lvblBhcnNlcjtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSBtZWFuaW5nXG4gICAgICogQHBhcmFtIHs/fSBkZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudG9JMThuTWVzc2FnZSA9IGZ1bmN0aW9uIChub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkKSB7XG4gICAgICAgIHRoaXMuX2lzSWN1ID0gbm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZXNbMF0gaW5zdGFuY2VvZiBFeHBhbnNpb247XG4gICAgICAgIHRoaXMuX2ljdURlcHRoID0gMDtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeSA9IG5ldyBQbGFjZWhvbGRlclJlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50ID0ge307XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9NZXNzYWdlID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5vZGVzID0gdmlzaXRBbGwodGhpcywgbm9kZXMsIHt9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKGkxOG5vZGVzLCB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudCwgdGhpcy5fcGxhY2Vob2xkZXJUb01lc3NhZ2UsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfSTE4blZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0cnMgPSB7fTtcbiAgICAgICAgZWwuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgLy8gRG8gbm90IHZpc2l0IHRoZSBhdHRyaWJ1dGVzLCB0cmFuc2xhdGFibGUgb25lcyBhcmUgdG9wLWxldmVsIEFTVHNcbiAgICAgICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNWb2lkID0gZ2V0SHRtbFRhZ0RlZmluaXRpb24oZWwubmFtZSkuaXNWb2lkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFBoTmFtZSA9IHRoaXMuX3BsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0U3RhcnRUYWdQbGFjZWhvbGRlck5hbWUoZWwubmFtZSwgYXR0cnMsIGlzVm9pZCk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50W3N0YXJ0UGhOYW1lXSA9IGVsLnNvdXJjZVNwYW4udG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvc2VQaE5hbWUgPSAnJztcbiAgICAgICAgaWYgKCFpc1ZvaWQpIHtcbiAgICAgICAgICAgIGNsb3NlUGhOYW1lID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZShlbC5uYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyVG9Db250ZW50W2Nsb3NlUGhOYW1lXSA9IFwiPC9cIiArIGVsLm5hbWUgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRhZ1BsYWNlaG9sZGVyKGVsLm5hbWUsIGF0dHJzLCBzdGFydFBoTmFtZSwgY2xvc2VQaE5hbWUsIGNoaWxkcmVuLCBpc1ZvaWQsIGVsLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JMThuVmlzaXRvci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbihhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24odGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5faWN1RGVwdGgrKztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4bkljdUNhc2VzID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5JY3UgPSBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGkxOG5JY3VDYXNlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICBpY3UuY2FzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2F6ZSkge1xuICAgICAgICAgICAgaTE4bkljdUNhc2VzW2NhemUudmFsdWVdID0gbmV3IENvbnRhaW5lcihjYXplLmV4cHJlc3Npb24ubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzLCB7fSk7IH0pLCBjYXplLmV4cFNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faWN1RGVwdGgtLTtcbiAgICAgICAgaWYgKHRoaXMuX2lzSWN1IHx8IHRoaXMuX2ljdURlcHRoID4gMCkge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBhbiBJQ1Ugbm9kZSB3aGVuOlxuICAgICAgICAgICAgLy8gLSB0aGUgbWVzc2FnZSAodnMgYSBwYXJ0IG9mIHRoZSBtZXNzYWdlKSBpcyBhbiBJQ1UgbWVzc2FnZSwgb3JcbiAgICAgICAgICAgIC8vIC0gdGhlIElDVSBtZXNzYWdlIGlzIG5lc3RlZC5cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cFBoID0gdGhpcy5fcGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRVbmlxdWVQbGFjZWhvbGRlcihcIlZBUl9cIiArIGljdS50eXBlKTtcbiAgICAgICAgICAgIGkxOG5JY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyID0gZXhwUGg7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtleHBQaF0gPSBpY3Uuc3dpdGNoVmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gaTE4bkljdTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlIHJldHVybnMgYSBwbGFjZWhvbGRlclxuICAgICAgICAvLyBJQ1UgcGxhY2Vob2xkZXJzIHNob3VsZCBub3QgYmUgcmVwbGFjZWQgd2l0aCB0aGVpciBvcmlnaW5hbCBjb250ZW50IGJ1dCB3aXRoIHRoZSB0aGVpclxuICAgICAgICAvLyB0cmFuc2xhdGlvbnMuIFdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHZpc2l0b3IgKHRoZXkgYXJlIG5vdCByZS1lbnRyYW50KSB0byBjb21wdXRlIHRoZVxuICAgICAgICAvLyBtZXNzYWdlIGlkLlxuICAgICAgICAvLyBUT0RPKHZpY2IpOiBhZGQgYSBodG1sLk5vZGUgLT4gaTE4bi5NZXNzYWdlIGNhY2hlIHRvIGF2b2lkIGhhdmluZyB0byByZS1jcmVhdGUgdGhlIG1zZ1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaE5hbWUgPSB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFBsYWNlaG9sZGVyTmFtZSgnSUNVJywgaWN1LnNvdXJjZVNwYW4udG9TdHJpbmcoKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKHRoaXMuX2V4cHJlc3Npb25QYXJzZXIsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvTWVzc2FnZVtwaE5hbWVdID0gdmlzaXRvci50b0kxOG5NZXNzYWdlKFtpY3VdLCAnJywgJycsICcnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3VQbGFjZWhvbGRlcihpMThuSWN1LCBwaE5hbWUsIGljdS5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1Q2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0kxOG5WaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodGV4dCwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGxpdEludGVycG9sYXRpb24gPSB0aGlzLl9leHByZXNzaW9uUGFyc2VyLnNwbGl0SW50ZXJwb2xhdGlvbih0ZXh0LCBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCksIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBpZiAoIXNwbGl0SW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgLy8gTm8gZXhwcmVzc2lvbiwgcmV0dXJuIGEgc2luZ2xlIHRleHRcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dCQxKHRleHQsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBhIGdyb3VwIG9mIHRleHQgKyBleHByZXNzaW9uc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyKG5vZGVzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZywgc0RlbGltaXRlciA9IF9hLnN0YXJ0LCBlRGVsaW1pdGVyID0gX2EuZW5kO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9uID0gc3BsaXRJbnRlcnBvbGF0aW9uLmV4cHJlc3Npb25zW2ldO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZU5hbWUgPSBfZXh0cmFjdFBsYWNlaG9sZGVyTmFtZShleHByZXNzaW9uKSB8fCAnSU5URVJQT0xBVElPTic7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaE5hbWUgPSB0aGlzLl9wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFBsYWNlaG9sZGVyTmFtZShiYXNlTmFtZSwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICBpZiAoc3BsaXRJbnRlcnBvbGF0aW9uLnN0cmluZ3NbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBhZGQgZW1wdHkgc3RyaW5nc1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMShzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tpXSwgc291cmNlU3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgUGxhY2Vob2xkZXIoZXhwcmVzc2lvbiwgcGhOYW1lLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlclRvQ29udGVudFtwaE5hbWVdID0gc0RlbGltaXRlciArIGV4cHJlc3Npb24gKyBlRGVsaW1pdGVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBsYXN0IGluZGV4IGNvbnRhaW5zIG5vIGV4cHJlc3Npb25cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdFN0cmluZ0lkeCA9IHNwbGl0SW50ZXJwb2xhdGlvbi5zdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tsYXN0U3RyaW5nSWR4XS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMShzcGxpdEludGVycG9sYXRpb24uc3RyaW5nc1tsYXN0U3RyaW5nSWR4XSwgc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfTtcbiAgICByZXR1cm4gX0kxOG5WaXNpdG9yO1xufSgpKTtcbnZhciBfQ1VTVE9NX1BIX0VYUCA9IC9cXC9cXC9bXFxzXFxTXSppMThuW1xcc1xcU10qXFwoW1xcc1xcU10qcGhbXFxzXFxTXSo9W1xcc1xcU10qKFwifCcpKFtcXHNcXFNdKj8pXFwxW1xcc1xcU10qXFwpL2c7XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9leHRyYWN0UGxhY2Vob2xkZXJOYW1lKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnNwbGl0KF9DVVNUT01fUEhfRVhQKVsyXTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQW4gaTE4biBlcnJvci5cbiAqL1xudmFyIEkxOG5FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEkxOG5FcnJvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IG1zZ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEkxOG5FcnJvcihzcGFuLCBtc2cpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIG1zZykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEkxOG5FcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9JMThOX0FUVFIgPSAnaTE4bic7XG52YXIgX0kxOE5fQVRUUl9QUkVGSVggPSAnaTE4bi0nO1xudmFyIF9JMThOX0NPTU1FTlRfUFJFRklYX1JFR0VYUCA9IC9eaTE4bjo/LztcbnZhciBNRUFOSU5HX1NFUEFSQVRPUiA9ICd8JztcbnZhciBJRF9TRVBBUkFUT1IgPSAnQEAnO1xuLyoqXG4gKiBFeHRyYWN0IHRyYW5zbGF0YWJsZSBtZXNzYWdlcyBmcm9tIGFuIGh0bWwgQVNUXG4gKiBAcGFyYW0gez99IG5vZGVzXG4gKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAqIEBwYXJhbSB7P30gaW1wbGljaXRUYWdzXG4gKiBAcGFyYW0gez99IGltcGxpY2l0QXR0cnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RNZXNzYWdlcyhub2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZywgaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfVmlzaXRvcihpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpO1xuICAgIHJldHVybiB2aXNpdG9yLmV4dHJhY3Qobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5vZGVzXG4gKiBAcGFyYW0gez99IHRyYW5zbGF0aW9uc1xuICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gKiBAcGFyYW0gez99IGltcGxpY2l0VGFnc1xuICogQHBhcmFtIHs/fSBpbXBsaWNpdEF0dHJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtZXJnZVRyYW5zbGF0aW9ucyhub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCBpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IF9WaXNpdG9yKGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycyk7XG4gICAgcmV0dXJuIHZpc2l0b3IubWVyZ2Uobm9kZXMsIHRyYW5zbGF0aW9ucywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG59XG52YXIgRXh0cmFjdGlvblJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlc1xuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXh0cmFjdGlvblJlc3VsdChtZXNzYWdlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBFeHRyYWN0aW9uUmVzdWx0O1xufSgpKTtcbnZhciBfVmlzaXRvck1vZGUgPSB7fTtcbl9WaXNpdG9yTW9kZS5FeHRyYWN0ID0gMDtcbl9WaXNpdG9yTW9kZS5NZXJnZSA9IDE7XG5fVmlzaXRvck1vZGVbX1Zpc2l0b3JNb2RlLkV4dHJhY3RdID0gXCJFeHRyYWN0XCI7XG5fVmlzaXRvck1vZGVbX1Zpc2l0b3JNb2RlLk1lcmdlXSA9IFwiTWVyZ2VcIjtcbi8qKlxuICogVGhpcyBWaXNpdG9yIGlzIHVzZWQ6XG4gKiAxLiB0byBleHRyYWN0IGFsbCB0aGUgdHJhbnNsYXRhYmxlIHN0cmluZ3MgZnJvbSBhbiBodG1sIEFTVCAoc2VlIGBleHRyYWN0KClgKSxcbiAqIDIuIHRvIHJlcGxhY2UgdGhlIHRyYW5zbGF0YWJsZSBzdHJpbmdzIHdpdGggdGhlIGFjdHVhbCB0cmFuc2xhdGlvbnMgKHNlZSBgbWVyZ2UoKWApXG4gKlxuICogXFxAaW50ZXJuYWxcbiAqL1xudmFyIF9WaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9pbXBsaWNpdFRhZ3NcbiAgICAgKiBAcGFyYW0gez99IF9pbXBsaWNpdEF0dHJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gX1Zpc2l0b3IoX2ltcGxpY2l0VGFncywgX2ltcGxpY2l0QXR0cnMpIHtcbiAgICAgICAgdGhpcy5faW1wbGljaXRUYWdzID0gX2ltcGxpY2l0VGFncztcbiAgICAgICAgdGhpcy5faW1wbGljaXRBdHRycyA9IF9pbXBsaWNpdEF0dHJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgbWVzc2FnZXMgZnJvbSB0aGUgdHJlZVxuICAgICAqIEBwYXJhbSB7P30gbm9kZXNcbiAgICAgKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKG5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLkV4dHJhY3QsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzLCBudWxsKTsgfSk7XG4gICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0sICdVbmNsb3NlZCBibG9jaycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXh0cmFjdGlvblJlc3VsdCh0aGlzLl9tZXNzYWdlcywgdGhpcy5fZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0cmVlIHdoZXJlIGFsbCB0cmFuc2xhdGFibGUgbm9kZXMgYXJlIHRyYW5zbGF0ZWRcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSB0cmFuc2xhdGlvbnNcbiAgICAgKiBAcGFyYW0gez99IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLk1lcmdlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25zID0gdHJhbnNsYXRpb25zO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBzaW5nbGUgZmFrZSByb290IGVsZW1lbnRcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd3JhcHBlciA9IG5ldyBFbGVtZW50KCd3cmFwcGVyJywgW10sIG5vZGVzLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNsYXRlZE5vZGUgPSB3cmFwcGVyLnZpc2l0KHRoaXMsIG51bGwpO1xuICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLCAnVW5jbG9zZWQgYmxvY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdCh0cmFuc2xhdGVkTm9kZS5jaGlsZHJlbiwgdGhpcy5fZXJyb3JzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1Q2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIFBhcnNlIGNhc2VzIGZvciB0cmFuc2xhdGFibGUgaHRtbCBhdHRyaWJ1dGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb24gPSB2aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4cGFuc2lvbkNhc2UoaWN1Q2FzZS52YWx1ZSwgZXhwcmVzc2lvbiwgaWN1Q2FzZS5zb3VyY2VTcGFuLCBpY3VDYXNlLnZhbHVlU291cmNlU3BhbiwgaWN1Q2FzZS5leHBTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKGljdSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHdhc0luSWN1ID0gdGhpcy5faW5JY3U7XG4gICAgICAgIGlmICghdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgIC8vIG5lc3RlZCBJQ1UgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBleHRyYWN0ZWQgYnV0IHRvcC1sZXZlbCB0cmFuc2xhdGVkIGFzIGEgd2hvbGVcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoW2ljdV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5JY3UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0gdmlzaXRBbGwodGhpcywgaWN1LmNhc2VzLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgaWN1ID0gbmV3IEV4cGFuc2lvbihpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBjYXNlcywgaWN1LnNvdXJjZVNwYW4sIGljdS5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luSWN1ID0gd2FzSW5JY3U7XG4gICAgICAgIHJldHVybiBpY3U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc09wZW5pbmcgPSBfaXNPcGVuaW5nQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgaWYgKGlzT3BlbmluZyAmJiB0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0NvdWxkIG5vdCBzdGFydCBhIGJsb2NrIGluc2lkZSBhIHRyYW5zbGF0YWJsZSBzZWN0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNDbG9zaW5nID0gX2lzQ2xvc2luZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgIGlmIChpc0Nsb3NpbmcgJiYgIXRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21tZW50LCAnVHJ5aW5nIHRvIGNsb3NlIGFuIHVub3BlbmVkIGJsb2NrJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbkkxOG5Ob2RlICYmICF0aGlzLl9pbkljdSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgICAgIGlmIChpc09wZW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5JMThuQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0RGVwdGggPSB0aGlzLl9kZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja01lYW5pbmdBbmREZXNjID0gY29tbWVudC52YWx1ZS5yZXBsYWNlKF9JMThOX0NPTU1FTlRfUFJFRklYX1JFR0VYUCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2xvc2luZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGVwdGggPT0gdGhpcy5fYmxvY2tTdGFydERlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCwgdGhpcy5fYmxvY2tDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZSA9IHRoaXMuX2FkZE1lc3NhZ2UodGhpcy5fYmxvY2tDaGlsZHJlbiwgdGhpcy5fYmxvY2tNZWFuaW5nQW5kRGVzYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBhdHRyaWJ1dGVzIGluIHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IHRoaXMuX3RyYW5zbGF0ZU1lc3NhZ2UoY29tbWVudCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRBbGwodGhpcywgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0kxOE4gYmxvY2tzIHNob3VsZCBub3QgY3Jvc3MgZWxlbWVudCBib3VuZGFyaWVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4oZWwpO1xuICAgICAgICB0aGlzLl9kZXB0aCsrO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3YXNJbkkxOG5Ob2RlID0gdGhpcy5faW5JMThuTm9kZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd2FzSW5JbXBsaWNpdE5vZGUgPSB0aGlzLl9pbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2xhdGVkQ2hpbGROb2RlcztcbiAgICAgICAgLy8gRXh0cmFjdDpcbiAgICAgICAgLy8gLSB0b3AgbGV2ZWwgbm9kZXMgd2l0aCB0aGUgKGltcGxpY2l0KSBcImkxOG5cIiBhdHRyaWJ1dGUgaWYgbm90IGFscmVhZHkgaW4gYSBzZWN0aW9uXG4gICAgICAgIC8vIC0gSUNVIG1lc3NhZ2VzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5BdHRyID0gX2dldEkxOG5BdHRyKGVsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4bk1ldGEgPSBpMThuQXR0ciA/IGkxOG5BdHRyLnZhbHVlIDogJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzSW1wbGljaXQgPSB0aGlzLl9pbXBsaWNpdFRhZ3Muc29tZShmdW5jdGlvbiAodGFnKSB7IHJldHVybiBlbC5uYW1lID09PSB0YWc7IH0pICYmICF0aGlzLl9pbkljdSAmJlxuICAgICAgICAgICAgIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1RvcExldmVsSW1wbGljaXQgPSAhd2FzSW5JbXBsaWNpdE5vZGUgJiYgaXNJbXBsaWNpdDtcbiAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSB3YXNJbkltcGxpY2l0Tm9kZSB8fCBpc0ltcGxpY2l0O1xuICAgICAgICBpZiAoIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uICYmICF0aGlzLl9pbkljdSkge1xuICAgICAgICAgICAgaWYgKGkxOG5BdHRyIHx8IGlzVG9wTGV2ZWxJbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2UgPSB0aGlzLl9hZGRNZXNzYWdlKGVsLmNoaWxkcmVuLCBpMThuTWV0YSk7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZENoaWxkTm9kZXMgPSB0aGlzLl90cmFuc2xhdGVNZXNzYWdlKGVsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09IF9WaXNpdG9yTW9kZS5FeHRyYWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNUcmFuc2xhdGFibGUgPSBpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzVHJhbnNsYXRhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuVHJhbnNsYXRhYmxlU2VjdGlvbihlbCk7XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uKGVsLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaTE4bkF0dHIgfHwgaXNUb3BMZXZlbEltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZWwsICdDb3VsZCBub3QgbWFyayBhbiBlbGVtZW50IGFzIHRyYW5zbGF0YWJsZSBpbnNpZGUgYSB0cmFuc2xhdGFibGUgc2VjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLkV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBEZXNjZW5kIGludG8gY2hpbGQgbm9kZXMgZm9yIGV4dHJhY3Rpb25cbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXROb2RlcyA9IHRyYW5zbGF0ZWRDaGlsZE5vZGVzIHx8IGVsLmNoaWxkcmVuO1xuICAgICAgICAgICAgdmlzaXROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0ZWQgPSBjaGlsZC52aXNpdChfdGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWQgJiYgIV90aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIHRoZSBjaGlsZHJlbiBmcm9tIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAoPSBpMThuIGJsb2NrcyBoZXJlKVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgYmUgYWRkZWQgbGF0ZXIgaW4gdGhpcyBsb29wIHdoZW4gdGhlIGJsb2NrIGNsb3NlcyAoaS5lLiBvbiBgPCEtLSAvaTE4biAtLT5gKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaXRBdHRyaWJ1dGVzT2YoZWwpO1xuICAgICAgICB0aGlzLl9kZXB0aC0tO1xuICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gd2FzSW5JMThuTm9kZTtcbiAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSB3YXNJbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNsYXRlZEF0dHJzID0gdGhpcy5fdHJhbnNsYXRlQXR0cmlidXRlcyhlbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZWwubmFtZSwgdHJhbnNsYXRlZEF0dHJzLCBjaGlsZE5vZGVzLCBlbC5zb3VyY2VTcGFuLCBlbC5zdGFydFNvdXJjZVNwYW4sIGVsLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEBwYXJhbSB7P30gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG1vZGUsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVwdGggPSAwO1xuICAgICAgICB0aGlzLl9pbkljdSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UgPSBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0QXR0cmlidXRlc09mID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcGxpY2l0QXR0ck5hbWVzID0gdGhpcy5faW1wbGljaXRBdHRyc1tlbC5uYW1lXSB8fCBbXTtcbiAgICAgICAgZWwuYXR0cnMuZmlsdGVyKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCk7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gZXhwbGljaXRBdHRyTmFtZVRvVmFsdWVbYXR0ci5uYW1lLnNsaWNlKF9JMThOX0FUVFJfUFJFRklYLmxlbmd0aCldID1cbiAgICAgICAgICAgIGF0dHIudmFsdWU7IH0pO1xuICAgICAgICBlbC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lIGluIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2FkZE1lc3NhZ2UoW2F0dHJdLCBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZVthdHRyLm5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGltcGxpY2l0QXR0ck5hbWVzLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gbmFtZTsgfSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYWRkTWVzc2FnZShbYXR0cl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/PX0gbXNnTWV0YVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9hZGRNZXNzYWdlID0gZnVuY3Rpb24gKGFzdCwgbXNnTWV0YSkge1xuICAgICAgICBpZiAoYXN0Lmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICBhc3QubGVuZ3RoID09IDEgJiYgYXN0WzBdIGluc3RhbmNlb2YgQXR0cmlidXRlJDEgJiYgISgoYXN0WzBdKSkudmFsdWUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBjcmVhdGUgZW1wdHkgbWVzc2FnZXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBfcGFyc2VNZXNzYWdlTWV0YShtc2dNZXRhKSwgbWVhbmluZyA9IF9hLm1lYW5pbmcsIGRlc2NyaXB0aW9uID0gX2EuZGVzY3JpcHRpb24sIGlkID0gX2EuaWQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2UgPSB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZShhc3QsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl90cmFuc2xhdGVNZXNzYWdlID0gZnVuY3Rpb24gKGVsLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlICYmIHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSB0aGlzLl90cmFuc2xhdGlvbnMuZ2V0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZWwsIFwiVHJhbnNsYXRpb24gdW5hdmFpbGFibGUgZm9yIG1lc3NhZ2UgaWQ9XFxcIlwiICsgdGhpcy5fdHJhbnNsYXRpb25zLmRpZ2VzdChtZXNzYWdlKSArIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvci5wcm90b3R5cGUuX3RyYW5zbGF0ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0cmlidXRlcyA9IGVsLmF0dHJzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuUGFyc2VkTWVzc2FnZU1ldGEgPSB7fTtcbiAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgaTE4blBhcnNlZE1lc3NhZ2VNZXRhW2F0dHIubmFtZS5zbGljZShfSTE4Tl9BVFRSX1BSRUZJWC5sZW5ndGgpXSA9XG4gICAgICAgICAgICAgICAgICAgIF9wYXJzZU1lc3NhZ2VNZXRhKGF0dHIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNsYXRlZEF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBfSTE4Tl9BVFRSIHx8IGF0dHIubmFtZS5zdGFydHNXaXRoKF9JMThOX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGkxOG4gc3BlY2lmaWMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyLnZhbHVlICYmIGF0dHIudmFsdWUgIT0gJycgJiYgaTE4blBhcnNlZE1lc3NhZ2VNZXRhLmhhc093blByb3BlcnR5KGF0dHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBpMThuUGFyc2VkTWVzc2FnZU1ldGFbYXR0ci5uYW1lXSwgbWVhbmluZyA9IF9hLm1lYW5pbmcsIGRlc2NyaXB0aW9uID0gX2EuZGVzY3JpcHRpb24sIGlkID0gX2EuaWQ7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZSA9IF90aGlzLl9jcmVhdGVJMThuTWVzc2FnZShbYXR0cl0sIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBfdGhpcy5fdHJhbnNsYXRpb25zLmdldChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkQXR0cmlidXRlcy5wdXNoKG5ldyBBdHRyaWJ1dGUkMShhdHRyLm5hbWUsICcnLCBhdHRyLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2Rlc1swXSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gKChub2Rlc1swXSkpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChuZXcgQXR0cmlidXRlJDEoYXR0ci5uYW1lLCB2YWx1ZSwgYXR0ci5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0cmFuc2xhdGlvbiBmb3IgYXR0cmlidXRlIFxcXCJcIiArIGF0dHIubmFtZSArIFwiXFxcIiAoaWQ9XFxcIlwiICsgKGlkIHx8IF90aGlzLl90cmFuc2xhdGlvbnMuZGlnZXN0KG1lc3NhZ2UpKSArIFwiXFxcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihlbCwgXCJUcmFuc2xhdGlvbiB1bmF2YWlsYWJsZSBmb3IgYXR0cmlidXRlIFxcXCJcIiArIGF0dHIubmFtZSArIFwiXFxcIiAoaWQ9XFxcIlwiICsgKGlkIHx8IF90aGlzLl90cmFuc2xhdGlvbnMuZGlnZXN0KG1lc3NhZ2UpKSArIFwiXFxcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGVkQXR0cmlidXRlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgbm9kZSBhcyBhIGNoaWxkIG9mIHRoZSBibG9jayB3aGVuOlxuICAgICAqIC0gd2UgYXJlIGluIGEgYmxvY2ssXG4gICAgICogLSB3ZSBhcmUgbm90IGluc2lkZSBhIElDVSBtZXNzYWdlICh0aG9zZSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5KSxcbiAgICAgKiAtIHRoZSBub2RlIGlzIGEgXCJkaXJlY3QgY2hpbGRcIiBvZiB0aGUgYmxvY2tcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luSTE4bkJsb2NrICYmICF0aGlzLl9pbkljdSAmJiB0aGlzLl9kZXB0aCA9PSB0aGlzLl9ibG9ja1N0YXJ0RGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrQ2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIHN0YXJ0IG9mIGEgc2VjdGlvbiwgc2VlIGBfY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uYFxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9vcGVuVHJhbnNsYXRhYmxlU2VjdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZSwgJ1VuZXhwZWN0ZWQgc2VjdGlvbiBzdGFydCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHRoaXMuX21lc3NhZ2VzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9WaXNpdG9yLnByb3RvdHlwZSwgXCJfaXNJblRyYW5zbGF0YWJsZVNlY3Rpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB0cmFuc2xhdGFibGUgc2VjdGlvbiBjb3VsZCBiZTpcbiAgICAgICAgICogLSB0aGUgY29udGVudCBvZiB0cmFuc2xhdGFibGUgZWxlbWVudCxcbiAgICAgICAgICogLSBub2RlcyBiZXR3ZWVuIGA8IS0tIGkxOG4gLS0+YCBhbmQgYDwhLS0gL2kxOG4gLS0+YCBjb21tZW50c1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCAhPT0gdm9pZCAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGVzIGEgc2VjdGlvbi5cbiAgICAgKlxuICAgICAqIElmIGEgc2VjdGlvbiBoYXMgb25seSBvbmUgc2lnbmlmaWNhbnQgY2hpbGRyZW4gKGNvbW1lbnRzIG5vdCBzaWduaWZpY2FudCkgdGhlbiB3ZSBzaG91bGQgbm90XG4gICAgICoga2VlcCB0aGUgbWVzc2FnZSBmcm9tIHRoaXMgY2hpbGRyZW46XG4gICAgICpcbiAgICAgKiBgPHAgaTE4bj1cIm1lYW5pbmd8ZGVzY3JpcHRpb25cIj57SUNVIG1lc3NhZ2V9PC9wPmAgd291bGQgcHJvZHVjZSB0d28gbWVzc2FnZXM6XG4gICAgICogLSBvbmUgZm9yIHRoZSA8cD4gY29udGVudCB3aXRoIG1lYW5pbmcgYW5kIGRlc2NyaXB0aW9uLFxuICAgICAqIC0gYW5vdGhlciBvbmUgZm9yIHRoZSBJQ1UgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEluIHRoaXMgY2FzZSB0aGUgbGFzdCBtZXNzYWdlIGlzIGRpc2NhcmRlZCBhcyBpdCBjb250YWlucyBsZXNzIGluZm9ybWF0aW9uICh0aGUgQVNUIGlzXG4gICAgICogb3RoZXJ3aXNlIGlkZW50aWNhbCkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2Ugc2hvdWxkIHN0aWxsIGtlZXAgbWVzc2FnZXMgZXh0cmFjdGVkIGZyb20gYXR0cmlidXRlcyBpbnNpZGUgdGhlIHNlY3Rpb24gKGllIGluIHRoZVxuICAgICAqIElDVSBtZXNzYWdlIGhlcmUpXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RDaGlsZHJlblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IucHJvdG90eXBlLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24gPSBmdW5jdGlvbiAobm9kZSwgZGlyZWN0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZSwgJ1VuZXhwZWN0ZWQgc2VjdGlvbiBlbmQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydEluZGV4ID0gdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2lnbmlmaWNhbnRDaGlsZHJlbiA9IGRpcmVjdENoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIG5vZGUpIHsgcmV0dXJuIGNvdW50ICsgKG5vZGUgaW5zdGFuY2VvZiBDb21tZW50ID8gMCA6IDEpOyB9LCAwKTtcbiAgICAgICAgaWYgKHNpZ25pZmljYW50Q2hpbGRyZW4gPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gdGhpcy5fbWVzc2FnZXMubGVuZ3RoIC0gMTsgaSA+PSBzdGFydEluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB0aGlzLl9tZXNzYWdlc1tpXS5ub2RlcztcbiAgICAgICAgICAgICAgICBpZiAoIShhc3QubGVuZ3RoID09IDEgJiYgYXN0WzBdIGluc3RhbmNlb2YgVGV4dCQxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdm9pZCAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtc2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yLnByb3RvdHlwZS5fcmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbXNnKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtc2cpKTtcbiAgICB9O1xuICAgIHJldHVybiBfVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2lzT3BlbmluZ0NvbW1lbnQobikge1xuICAgIHJldHVybiBuIGluc3RhbmNlb2YgQ29tbWVudCAmJiBuLnZhbHVlICYmIG4udmFsdWUuc3RhcnRzV2l0aCgnaTE4bicpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9pc0Nsb3NpbmdDb21tZW50KG4pIHtcbiAgICByZXR1cm4gbiBpbnN0YW5jZW9mIENvbW1lbnQgJiYgbi52YWx1ZSAmJiBuLnZhbHVlID09PSAnL2kxOG4nO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHBcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9nZXRJMThuQXR0cihwKSB7XG4gICAgcmV0dXJuIHAuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSBfSTE4Tl9BVFRSOyB9KSB8fCBudWxsO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGkxOG5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9wYXJzZU1lc3NhZ2VNZXRhKGkxOG4pIHtcbiAgICBpZiAoIWkxOG4pXG4gICAgICAgIHJldHVybiB7IG1lYW5pbmc6ICcnLCBkZXNjcmlwdGlvbjogJycsIGlkOiAnJyB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkSW5kZXggPSBpMThuLmluZGV4T2YoSURfU0VQQVJBVE9SKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXNjSW5kZXggPSBpMThuLmluZGV4T2YoTUVBTklOR19TRVBBUkFUT1IpO1xuICAgIHZhciBfYSA9IChpZEluZGV4ID4gLTEpID8gW2kxOG4uc2xpY2UoMCwgaWRJbmRleCksIGkxOG4uc2xpY2UoaWRJbmRleCArIDIpXSA6IFtpMThuLCAnJ10sIG1lYW5pbmdBbmREZXNjID0gX2FbMF0sIGlkID0gX2FbMV07XG4gICAgdmFyIF9iID0gKGRlc2NJbmRleCA+IC0xKSA/XG4gICAgICAgIFttZWFuaW5nQW5kRGVzYy5zbGljZSgwLCBkZXNjSW5kZXgpLCBtZWFuaW5nQW5kRGVzYy5zbGljZShkZXNjSW5kZXggKyAxKV0gOlxuICAgICAgICBbJycsIG1lYW5pbmdBbmREZXNjXSwgbWVhbmluZyA9IF9iWzBdLCBkZXNjcmlwdGlvbiA9IF9iWzFdO1xuICAgIHJldHVybiB7IG1lYW5pbmc6IG1lYW5pbmcsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiwgaWQ6IGlkIH07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgWG1sVGFnRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWG1sVGFnRGVmaW5pdGlvbigpIHtcbiAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gVGFnQ29udGVudFR5cGUuUEFSU0FCTEVfREFUQTtcbiAgICAgICAgdGhpcy5pc1ZvaWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pZ25vcmVGaXJzdExmID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuU2VsZkNsb3NlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjdXJyZW50UGFyZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5yZXF1aXJlRXh0cmFQYXJlbnQgPSBmdW5jdGlvbiAoY3VycmVudFBhcmVudCkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUYWdEZWZpbml0aW9uLnByb3RvdHlwZS5pc0Nsb3NlZEJ5Q2hpbGQgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgcmV0dXJuIFhtbFRhZ0RlZmluaXRpb247XG59KCkpO1xudmFyIF9UQUdfREVGSU5JVElPTiA9IG5ldyBYbWxUYWdEZWZpbml0aW9uKCk7XG4vKipcbiAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0WG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKSB7XG4gICAgcmV0dXJuIF9UQUdfREVGSU5JVElPTjtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBYbWxQYXJzZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYbWxQYXJzZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWG1sUGFyc2VyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ2V0WG1sVGFnRGVmaW5pdGlvbikgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEBwYXJhbSB7Pz19IHBhcnNlRXhwYW5zaW9uRm9ybXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwsIHBhcnNlRXhwYW5zaW9uRm9ybXMpIHtcbiAgICAgICAgaWYgKHBhcnNlRXhwYW5zaW9uRm9ybXMgPT09IHZvaWQgMCkgeyBwYXJzZUV4cGFuc2lvbkZvcm1zID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgbnVsbCk7XG4gICAgfTtcbiAgICByZXR1cm4gWG1sUGFyc2VyO1xufShQYXJzZXIkMSkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGRpZ2VzdChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UuaWQgfHwgc2hhMShzZXJpYWxpemVOb2RlcyhtZXNzYWdlLm5vZGVzKS5qb2luKCcnKSArIChcIltcIiArIG1lc3NhZ2UubWVhbmluZyArIFwiXVwiKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZGVjaW1hbERpZ2VzdChtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuaWQpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuaWQ7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBtZXNzYWdlLm5vZGVzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS52aXNpdCh2aXNpdG9yLCBudWxsKTsgfSk7XG4gICAgcmV0dXJuIGNvbXB1dGVNc2dJZChwYXJ0cy5qb2luKCcnKSwgbWVzc2FnZS5tZWFuaW5nKTtcbn1cbi8qKlxuICogU2VyaWFsaXplIHRoZSBpMThuIGFzdCB0byBzb21ldGhpbmcgeG1sLWxpa2UgaW4gb3JkZXIgdG8gZ2VuZXJhdGUgYW4gVUlELlxuICpcbiAqIFRoZSB2aXNpdG9yIGlzIGFsc28gdXNlZCBpbiB0aGUgaTE4biBwYXJzZXIgdGVzdHNcbiAqXG4gKiBcXEBpbnRlcm5hbFxuICovXG52YXIgX1NlcmlhbGl6ZXJWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfU2VyaWFsaXplclZpc2l0b3IoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gdGV4dC52YWx1ZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgY29udGFpbmVyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnZpc2l0KF90aGlzKTsgfSkuam9pbignLCAnKSArIFwiXVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGsgKyBcIiB7XCIgKyBpY3UuY2FzZXNba10udmlzaXQoX3RoaXMpICsgXCJ9XCI7IH0pO1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBpY3UuZXhwcmVzc2lvbiArIFwiLCBcIiArIGljdS50eXBlICsgXCIsIFwiICsgc3RyQ2FzZXMuam9pbignLCAnKSArIFwifVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1NlcmlhbGl6ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRhZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBwaC5pc1ZvaWQgP1xuICAgICAgICAgICAgXCI8cGggdGFnIG5hbWU9XFxcIlwiICsgcGguc3RhcnROYW1lICsgXCJcXFwiLz5cIiA6XG4gICAgICAgICAgICBcIjxwaCB0YWcgbmFtZT1cXFwiXCIgKyBwaC5zdGFydE5hbWUgKyBcIlxcXCI+XCIgKyBwaC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC52aXNpdChfdGhpcyk7IH0pLmpvaW4oJywgJykgKyBcIjwvcGggbmFtZT1cXFwiXCIgKyBwaC5jbG9zZU5hbWUgKyBcIlxcXCI+XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2VyaWFsaXplclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHBoLnZhbHVlID8gXCI8cGggbmFtZT1cXFwiXCIgKyBwaC5uYW1lICsgXCJcXFwiPlwiICsgcGgudmFsdWUgKyBcIjwvcGg+XCIgOiBcIjxwaCBuYW1lPVxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCIvPlwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9TZXJpYWxpemVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gXCI8cGggaWN1IG5hbWU9XFxcIlwiICsgcGgubmFtZSArIFwiXFxcIj5cIiArIHBoLnZhbHVlLnZpc2l0KHRoaXMpICsgXCI8L3BoPlwiO1xuICAgIH07XG4gICAgcmV0dXJuIF9TZXJpYWxpemVyVmlzaXRvcjtcbn0oKSk7XG52YXIgc2VyaWFsaXplclZpc2l0b3IgPSBuZXcgX1NlcmlhbGl6ZXJWaXNpdG9yKCk7XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVzKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS52aXNpdChzZXJpYWxpemVyVmlzaXRvciwgbnVsbCk7IH0pO1xufVxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGkxOG4gYXN0IHRvIHNvbWV0aGluZyB4bWwtbGlrZSBpbiBvcmRlciB0byBnZW5lcmF0ZSBhbiBVSUQuXG4gKlxuICogSWdub3JlIHRoZSBJQ1UgZXhwcmVzc2lvbnMgc28gdGhhdCBtZXNzYWdlIElEcyBzdGF5cyBpZGVudGljYWwgaWYgb25seSB0aGUgZXhwcmVzc2lvbiBjaGFuZ2VzLlxuICpcbiAqIFxcQGludGVybmFsXG4gKi9cbnZhciBfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1ID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrICsgXCIge1wiICsgaWN1LmNhc2VzW2tdLnZpc2l0KF90aGlzKSArIFwifVwiOyB9KTtcbiAgICAgICAgLy8gRG8gbm90IHRha2UgdGhlIGV4cHJlc3Npb24gaW50byBhY2NvdW50XG4gICAgICAgIHJldHVybiBcIntcIiArIGljdS50eXBlICsgXCIsIFwiICsgc3RyQ2FzZXMuam9pbignLCAnKSArIFwifVwiO1xuICAgIH07XG4gICAgcmV0dXJuIF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvcjtcbn0oX1NlcmlhbGl6ZXJWaXNpdG9yKSk7XG4vKipcbiAqIENvbXB1dGUgdGhlIFNIQTEgb2YgdGhlIGdpdmVuIHN0cmluZ1xuICpcbiAqIHNlZSBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTQvZmlwcy0xODAtNC5wZGZcbiAqXG4gKiBXQVJOSU5HOiB0aGlzIGZ1bmN0aW9uIGhhcyBub3QgYmVlbiBkZXNpZ25lZCBub3QgdGVzdGVkIHdpdGggc2VjdXJpdHkgaW4gbWluZC5cbiAqICAgICAgICAgIERPIE5PVCBVU0UgSVQgSU4gQSBTRUNVUklUWSBTRU5TSVRJVkUgQ09OVEVYVC5cbiAqIEBwYXJhbSB7P30gc3RyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzaGExKHN0cikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHV0ZjggPSB1dGY4RW5jb2RlKHN0cik7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd29yZHMzMiA9IHN0cmluZ1RvV29yZHMzMih1dGY4LCBFbmRpYW4uQmlnKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZW4gPSB1dGY4Lmxlbmd0aCAqIDg7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdyA9IG5ldyBBcnJheSg4MCk7XG4gICAgdmFyIF9hID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdLCBhID0gX2FbMF0sIGIgPSBfYVsxXSwgYyA9IF9hWzJdLCBkID0gX2FbM10sIGUgPSBfYVs0XTtcbiAgICB3b3JkczMyW2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgICB3b3JkczMyWygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgIHZhciBfYiA9IFthLCBiLCBjLCBkLCBlXSwgaDAgPSBfYlswXSwgaDEgPSBfYlsxXSwgaDIgPSBfYlsyXSwgaDMgPSBfYlszXSwgaDQgPSBfYls0XTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChqIDwgMTYpIHtcbiAgICAgICAgICAgICAgICB3W2pdID0gd29yZHMzMltpICsgal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3W2pdID0gcm9sMzIod1tqIC0gM10gXiB3W2ogLSA4XSBeIHdbaiAtIDE0XSBeIHdbaiAtIDE2XSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2MgPSBmayhqLCBiLCBjLCBkKSwgZiA9IF9jWzBdLCBrID0gX2NbMV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wID0gW3JvbDMyKGEsIDUpLCBmLCBlLCBrLCB3W2pdXS5yZWR1Y2UoYWRkMzIpO1xuICAgICAgICAgICAgX2QgPSBbZCwgYywgcm9sMzIoYiwgMzApLCBhLCB0ZW1wXSwgZSA9IF9kWzBdLCBkID0gX2RbMV0sIGMgPSBfZFsyXSwgYiA9IF9kWzNdLCBhID0gX2RbNF07XG4gICAgICAgIH1cbiAgICAgICAgX2UgPSBbYWRkMzIoYSwgaDApLCBhZGQzMihiLCBoMSksIGFkZDMyKGMsIGgyKSwgYWRkMzIoZCwgaDMpLCBhZGQzMihlLCBoNCldLCBhID0gX2VbMF0sIGIgPSBfZVsxXSwgYyA9IF9lWzJdLCBkID0gX2VbM10sIGUgPSBfZVs0XTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVTdHJpbmdUb0hleFN0cmluZyh3b3JkczMyVG9CeXRlU3RyaW5nKFthLCBiLCBjLCBkLCBlXSkpO1xuICAgIHZhciBfZCwgX2U7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gYlxuICogQHBhcmFtIHs/fSBjXG4gKiBAcGFyYW0gez99IGRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZrKGluZGV4LCBiLCBjLCBkKSB7XG4gICAgaWYgKGluZGV4IDwgMjApIHtcbiAgICAgICAgcmV0dXJuIFsoYiAmIGMpIHwgKH5iICYgZCksIDB4NWE4Mjc5OTldO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCA0MCkge1xuICAgICAgICByZXR1cm4gW2IgXiBjIF4gZCwgMHg2ZWQ5ZWJhMV07XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDYwKSB7XG4gICAgICAgIHJldHVybiBbKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpLCAweDhmMWJiY2RjXTtcbiAgICB9XG4gICAgcmV0dXJuIFtiIF4gYyBeIGQsIDB4Y2E2MmMxZDZdO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBmaW5nZXJwcmludCBvZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKlxuICogVGhlIG91dHB1dCBpcyA2NCBiaXQgbnVtYmVyIGVuY29kZWQgYXMgYSBkZWNpbWFsIHN0cmluZ1xuICpcbiAqIGJhc2VkIG9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2Jsb2IvbWFzdGVyL3NyYy9jb20vZ29vZ2xlL2phdmFzY3JpcHQvanNjb21wL0dvb2dsZUpzTWVzc2FnZUlkR2VuZXJhdG9yLmphdmFcbiAqIEBwYXJhbSB7P30gc3RyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmaW5nZXJwcmludChzdHIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1dGY4ID0gdXRmOEVuY29kZShzdHIpO1xuICAgIHZhciBfYSA9IFtoYXNoMzIodXRmOCwgMCksIGhhc2gzMih1dGY4LCAxMDIwNzIpXSwgaGkgPSBfYVswXSwgbG8gPSBfYVsxXTtcbiAgICBpZiAoaGkgPT0gMCAmJiAobG8gPT0gMCB8fCBsbyA9PSAxKSkge1xuICAgICAgICBoaSA9IGhpIF4gMHgxMzBmOWJlZjtcbiAgICAgICAgbG8gPSBsbyBeIC0weDZiNWY1NmQ4O1xuICAgIH1cbiAgICByZXR1cm4gW2hpLCBsb107XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbXNnXG4gKiBAcGFyYW0gez99IG1lYW5pbmdcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVNc2dJZChtc2csIG1lYW5pbmcpIHtcbiAgICB2YXIgX2EgPSBmaW5nZXJwcmludChtc2cpLCBoaSA9IF9hWzBdLCBsbyA9IF9hWzFdO1xuICAgIGlmIChtZWFuaW5nKSB7XG4gICAgICAgIHZhciBfYiA9IGZpbmdlcnByaW50KG1lYW5pbmcpLCBoaW0gPSBfYlswXSwgbG9tID0gX2JbMV07XG4gICAgICAgIF9jID0gYWRkNjQocm9sNjQoW2hpLCBsb10sIDEpLCBbaGltLCBsb21dKSwgaGkgPSBfY1swXSwgbG8gPSBfY1sxXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVTdHJpbmdUb0RlY1N0cmluZyh3b3JkczMyVG9CeXRlU3RyaW5nKFtoaSAmIDB4N2ZmZmZmZmYsIGxvXSkpO1xuICAgIHZhciBfYztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEBwYXJhbSB7P30gY1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaGFzaDMyKHN0ciwgYykge1xuICAgIHZhciBfYSA9IFsweDllMzc3OWI5LCAweDllMzc3OWI5XSwgYSA9IF9hWzBdLCBiID0gX2FbMV07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgKyAxMiA8PSBsZW47IGkgKz0gMTIpIHtcbiAgICAgICAgYSA9IGFkZDMyKGEsIHdvcmRBdChzdHIsIGksIEVuZGlhbi5MaXR0bGUpKTtcbiAgICAgICAgYiA9IGFkZDMyKGIsIHdvcmRBdChzdHIsIGkgKyA0LCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgICAgIGMgPSBhZGQzMihjLCB3b3JkQXQoc3RyLCBpICsgOCwgRW5kaWFuLkxpdHRsZSkpO1xuICAgICAgICBfYiA9IG1peChbYSwgYiwgY10pLCBhID0gX2JbMF0sIGIgPSBfYlsxXSwgYyA9IF9iWzJdO1xuICAgIH1cbiAgICBhID0gYWRkMzIoYSwgd29yZEF0KHN0ciwgaSwgRW5kaWFuLkxpdHRsZSkpO1xuICAgIGIgPSBhZGQzMihiLCB3b3JkQXQoc3RyLCBpICsgNCwgRW5kaWFuLkxpdHRsZSkpO1xuICAgIC8vIHRoZSBmaXJzdCBieXRlIG9mIGMgaXMgcmVzZXJ2ZWQgZm9yIHRoZSBsZW5ndGhcbiAgICBjID0gYWRkMzIoYywgbGVuKTtcbiAgICBjID0gYWRkMzIoYywgd29yZEF0KHN0ciwgaSArIDgsIEVuZGlhbi5MaXR0bGUpIDw8IDgpO1xuICAgIHJldHVybiBtaXgoW2EsIGIsIGNdKVsyXTtcbiAgICB2YXIgX2I7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gX18wXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtaXgoX2EpIHtcbiAgICB2YXIgYSA9IF9hWzBdLCBiID0gX2FbMV0sIGMgPSBfYVsyXTtcbiAgICBhID0gc3ViMzIoYSwgYik7XG4gICAgYSA9IHN1YjMyKGEsIGMpO1xuICAgIGEgXj0gYyA+Pj4gMTM7XG4gICAgYiA9IHN1YjMyKGIsIGMpO1xuICAgIGIgPSBzdWIzMihiLCBhKTtcbiAgICBiIF49IGEgPDwgODtcbiAgICBjID0gc3ViMzIoYywgYSk7XG4gICAgYyA9IHN1YjMyKGMsIGIpO1xuICAgIGMgXj0gYiA+Pj4gMTM7XG4gICAgYSA9IHN1YjMyKGEsIGIpO1xuICAgIGEgPSBzdWIzMihhLCBjKTtcbiAgICBhIF49IGMgPj4+IDEyO1xuICAgIGIgPSBzdWIzMihiLCBjKTtcbiAgICBiID0gc3ViMzIoYiwgYSk7XG4gICAgYiBePSBhIDw8IDE2O1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiA1O1xuICAgIGEgPSBzdWIzMihhLCBiKTtcbiAgICBhID0gc3ViMzIoYSwgYyk7XG4gICAgYSBePSBjID4+PiAzO1xuICAgIGIgPSBzdWIzMihiLCBjKTtcbiAgICBiID0gc3ViMzIoYiwgYSk7XG4gICAgYiBePSBhIDw8IDEwO1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiAxNTtcbiAgICByZXR1cm4gW2EsIGIsIGNdO1xufVxudmFyIEVuZGlhbiA9IHt9O1xuRW5kaWFuLkxpdHRsZSA9IDA7XG5FbmRpYW4uQmlnID0gMTtcbkVuZGlhbltFbmRpYW4uTGl0dGxlXSA9IFwiTGl0dGxlXCI7XG5FbmRpYW5bRW5kaWFuLkJpZ10gPSBcIkJpZ1wiO1xuLyoqXG4gKiBAcGFyYW0gez99IGFcbiAqIEBwYXJhbSB7P30gYlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYWRkMzIoYSwgYikge1xuICAgIHJldHVybiBhZGQzMnRvNjQoYSwgYilbMV07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYVxuICogQHBhcmFtIHs/fSBiXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhZGQzMnRvNjQoYSwgYikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvdyA9IChhICYgMHhmZmZmKSArIChiICYgMHhmZmZmKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoaWdoID0gKGEgPj4+IDE2KSArIChiID4+PiAxNikgKyAobG93ID4+PiAxNik7XG4gICAgcmV0dXJuIFtoaWdoID4+PiAxNiwgKGhpZ2ggPDwgMTYpIHwgKGxvdyAmIDB4ZmZmZildO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IF9fMFxuICogQHBhcmFtIHs/fSBfXzFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFkZDY0KF9hLCBfYikge1xuICAgIHZhciBhaCA9IF9hWzBdLCBhbCA9IF9hWzFdO1xuICAgIHZhciBiaCA9IF9iWzBdLCBibCA9IF9iWzFdO1xuICAgIHZhciBfYyA9IGFkZDMydG82NChhbCwgYmwpLCBjYXJyeSA9IF9jWzBdLCBsID0gX2NbMV07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaCA9IGFkZDMyKGFkZDMyKGFoLCBiaCksIGNhcnJ5KTtcbiAgICByZXR1cm4gW2gsIGxdO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFcbiAqIEBwYXJhbSB7P30gYlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3ViMzIoYSwgYikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvdyA9IChhICYgMHhmZmZmKSAtIChiICYgMHhmZmZmKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoaWdoID0gKGEgPj4gMTYpIC0gKGIgPj4gMTYpICsgKGxvdyA+PiAxNik7XG4gICAgcmV0dXJuIChoaWdoIDw8IDE2KSB8IChsb3cgJiAweGZmZmYpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFcbiAqIEBwYXJhbSB7P30gY291bnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJvbDMyKGEsIGNvdW50KSB7XG4gICAgcmV0dXJuIChhIDw8IGNvdW50KSB8IChhID4+PiAoMzIgLSBjb3VudCkpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IF9fMFxuICogQHBhcmFtIHs/fSBjb3VudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcm9sNjQoX2EsIGNvdW50KSB7XG4gICAgdmFyIGhpID0gX2FbMF0sIGxvID0gX2FbMV07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaCA9IChoaSA8PCBjb3VudCkgfCAobG8gPj4+ICgzMiAtIGNvdW50KSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbCA9IChsbyA8PCBjb3VudCkgfCAoaGkgPj4+ICgzMiAtIGNvdW50KSk7XG4gICAgcmV0dXJuIFtoLCBsXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEBwYXJhbSB7P30gZW5kaWFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1dvcmRzMzIoc3RyLCBlbmRpYW4pIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB3b3JkczMyID0gQXJyYXkoKHN0ci5sZW5ndGggKyAzKSA+Pj4gMik7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHdvcmRzMzIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29yZHMzMltpXSA9IHdvcmRBdChzdHIsIGkgKiA0LCBlbmRpYW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29yZHMzMjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ5dGVBdChzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IHN0ci5sZW5ndGggPyAwIDogc3RyLmNoYXJDb2RlQXQoaW5kZXgpICYgMHhmZjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEBwYXJhbSB7P30gaW5kZXhcbiAqIEBwYXJhbSB7P30gZW5kaWFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB3b3JkQXQoc3RyLCBpbmRleCwgZW5kaWFuKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd29yZCA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gRW5kaWFuLkJpZykge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB3b3JkICs9IGJ5dGVBdChzdHIsIGluZGV4ICsgaSkgPDwgKDI0IC0gOCAqIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB3b3JkICs9IGJ5dGVBdChzdHIsIGluZGV4ICsgaSkgPDwgOCAqIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdvcmQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gd29yZHMzMlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gd29yZHMzMlRvQnl0ZVN0cmluZyh3b3JkczMyKSB7XG4gICAgcmV0dXJuIHdvcmRzMzIucmVkdWNlKGZ1bmN0aW9uIChzdHIsIHdvcmQpIHsgcmV0dXJuIHN0ciArIHdvcmQzMlRvQnl0ZVN0cmluZyh3b3JkKTsgfSwgJycpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHdvcmRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHdvcmQzMlRvQnl0ZVN0cmluZyh3b3JkKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RyID0gJyc7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgod29yZCA+Pj4gOCAqICgzIC0gaSkpICYgMHhmZik7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gc3RyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBieXRlU3RyaW5nVG9IZXhTdHJpbmcoc3RyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGV4ID0gJyc7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiID0gYnl0ZUF0KHN0ciwgaSk7XG4gICAgICAgIGhleCArPSAoYiA+Pj4gNCkudG9TdHJpbmcoMTYpICsgKGIgJiAweDBmKS50b1N0cmluZygxNik7XG4gICAgfVxuICAgIHJldHVybiBoZXgudG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGJ5dGVTdHJpbmdUb0RlY1N0cmluZyhzdHIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWNpbWFsID0gJyc7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9UaGVQb3dlciA9ICcxJztcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBzdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZGVjaW1hbCA9IGFkZEJpZ0ludChkZWNpbWFsLCBudW1iZXJUaW1lc0JpZ0ludChieXRlQXQoc3RyLCBpKSwgdG9UaGVQb3dlcikpO1xuICAgICAgICB0b1RoZVBvd2VyID0gbnVtYmVyVGltZXNCaWdJbnQoMjU2LCB0b1RoZVBvd2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY2ltYWwuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB4XG4gKiBAcGFyYW0gez99IHlcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFkZEJpZ0ludCh4LCB5KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtID0gJyc7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVuID0gTWF0aC5tYXgoeC5sZW5ndGgsIHkubGVuZ3RoKTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwLCAvKiogQHR5cGUgez99ICovIGNhcnJ5ID0gMDsgaSA8IGxlbiB8fCBjYXJyeTsgaSsrKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRtcFN1bSA9IGNhcnJ5ICsgKyh4W2ldIHx8IDApICsgKyh5W2ldIHx8IDApO1xuICAgICAgICBpZiAodG1wU3VtID49IDEwKSB7XG4gICAgICAgICAgICBjYXJyeSA9IDE7XG4gICAgICAgICAgICBzdW0gKz0gdG1wU3VtIC0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgICAgICBzdW0gKz0gdG1wU3VtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gbnVtXG4gKiBAcGFyYW0gez99IGJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIG51bWJlclRpbWVzQmlnSW50KG51bSwgYikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb2R1Y3QgPSAnJztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiVG9UaGVQb3dlciA9IGI7XG4gICAgZm9yICg7IG51bSAhPT0gMDsgbnVtID0gbnVtID4+PiAxKSB7XG4gICAgICAgIGlmIChudW0gJiAxKVxuICAgICAgICAgICAgcHJvZHVjdCA9IGFkZEJpZ0ludChwcm9kdWN0LCBiVG9UaGVQb3dlcik7XG4gICAgICAgIGJUb1RoZVBvd2VyID0gYWRkQmlnSW50KGJUb1RoZVBvd2VyLCBiVG9UaGVQb3dlcik7XG4gICAgfVxuICAgIHJldHVybiBwcm9kdWN0O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIFNlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcmlhbGl6ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VyaWFsaXplci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobWVzc2FnZXMsIGxvY2FsZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJpYWxpemVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2VyaWFsaXplci5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcmlhbGl6ZXIucHJvdG90eXBlLmNyZWF0ZU5hbWVNYXBwZXIgPSBmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICByZXR1cm4gU2VyaWFsaXplcjtcbn0oKSk7XG4vKipcbiAqIEEgc2ltcGxlIG1hcHBlciB0aGF0IHRha2UgYSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYW4gaW50ZXJuYWwgbmFtZSB0byBhIHB1YmxpYyBuYW1lXG4gKi9cbnZhciBTaW1wbGVQbGFjZWhvbGRlck1hcHBlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gbWFwTmFtZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyKG1lc3NhZ2UsIG1hcE5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWFwTmFtZSA9IG1hcE5hbWU7XG4gICAgICAgIF90aGlzLmludGVybmFsVG9QdWJsaWMgPSB7fTtcbiAgICAgICAgX3RoaXMucHVibGljVG9OZXh0SWQgPSB7fTtcbiAgICAgICAgX3RoaXMucHVibGljVG9JbnRlcm5hbCA9IHt9O1xuICAgICAgICBtZXNzYWdlLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGludGVybmFsTmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnRvUHVibGljTmFtZSA9IGZ1bmN0aW9uIChpbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxUb1B1YmxpYy5oYXNPd25Qcm9wZXJ0eShpbnRlcm5hbE5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxUb1B1YmxpY1tpbnRlcm5hbE5hbWVdIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHB1YmxpY05hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS50b0ludGVybmFsTmFtZSA9IGZ1bmN0aW9uIChwdWJsaWNOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY1RvSW50ZXJuYWwuaGFzT3duUHJvcGVydHkocHVibGljTmFtZSkgPyB0aGlzLnB1YmxpY1RvSW50ZXJuYWxbcHVibGljTmFtZV0gOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdFBsYWNlaG9sZGVyTmFtZShwaC5zdGFydE5hbWUpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIuY2FsbCh0aGlzLCBwaCwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRQbGFjZWhvbGRlck5hbWUocGguY2xvc2VOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVQbGFjZWhvbGRlck1hcHBlci5wcm90b3R5cGUudmlzaXRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkgeyB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLm5hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaW1wbGVQbGFjZWhvbGRlck1hcHBlci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLm5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcm5hbE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyTmFtZSA9IGZ1bmN0aW9uIChpbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgaWYgKCFpbnRlcm5hbE5hbWUgfHwgdGhpcy5pbnRlcm5hbFRvUHVibGljLmhhc093blByb3BlcnR5KGludGVybmFsTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwdWJsaWNOYW1lID0gdGhpcy5tYXBOYW1lKGludGVybmFsTmFtZSk7XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY1RvSW50ZXJuYWwuaGFzT3duUHJvcGVydHkocHVibGljTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBYTUIgd2hlbiBpdCBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHRJZCA9IHRoaXMucHVibGljVG9OZXh0SWRbcHVibGljTmFtZV07XG4gICAgICAgICAgICB0aGlzLnB1YmxpY1RvTmV4dElkW3B1YmxpY05hbWVdID0gbmV4dElkICsgMTtcbiAgICAgICAgICAgIHB1YmxpY05hbWUgPSBwdWJsaWNOYW1lICsgXCJfXCIgKyBuZXh0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1YmxpY1RvTmV4dElkW3B1YmxpY05hbWVdID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVybmFsVG9QdWJsaWNbaW50ZXJuYWxOYW1lXSA9IHB1YmxpY05hbWU7XG4gICAgICAgIHRoaXMucHVibGljVG9JbnRlcm5hbFtwdWJsaWNOYW1lXSA9IGludGVybmFsTmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBTaW1wbGVQbGFjZWhvbGRlck1hcHBlcjtcbn0oUmVjdXJzZVZpc2l0b3IpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfVmlzaXRvciQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfVmlzaXRvciQxKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRhZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ckF0dHJzID0gdGhpcy5fc2VyaWFsaXplQXR0cmlidXRlcyh0YWcuYXR0cnMpO1xuICAgICAgICBpZiAodGFnLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcubmFtZSArIHN0ckF0dHJzICsgXCIvPlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ckNoaWxkcmVuID0gdGFnLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pO1xuICAgICAgICByZXR1cm4gXCI8XCIgKyB0YWcubmFtZSArIHN0ckF0dHJzICsgXCI+XCIgKyBzdHJDaGlsZHJlbi5qb2luKCcnKSArIFwiPC9cIiArIHRhZy5uYW1lICsgXCI+XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGVjbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMS5wcm90b3R5cGUudmlzaXREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChkZWNsKSB7XG4gICAgICAgIHJldHVybiBcIjw/eG1sXCIgKyB0aGlzLl9zZXJpYWxpemVBdHRyaWJ1dGVzKGRlY2wuYXR0cnMpICsgXCIgPz5cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yJDEucHJvdG90eXBlLl9zZXJpYWxpemVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0ckF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbmFtZSArIFwiPVxcXCJcIiArIGF0dHJzW25hbWVdICsgXCJcXFwiXCI7IH0pLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIHN0ckF0dHJzLmxlbmd0aCA+IDAgPyAnICcgKyBzdHJBdHRycyA6ICcnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkb2N0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQxLnByb3RvdHlwZS52aXNpdERvY3R5cGUgPSBmdW5jdGlvbiAoZG9jdHlwZSkge1xuICAgICAgICByZXR1cm4gXCI8IURPQ1RZUEUgXCIgKyBkb2N0eXBlLnJvb3RUYWcgKyBcIiBbXFxuXCIgKyBkb2N0eXBlLmR0ZCArIFwiXFxuXT5cIjtcbiAgICB9O1xuICAgIHJldHVybiBfVmlzaXRvciQxO1xufSgpKTtcbnZhciBfdmlzaXRvciA9IG5ldyBfVmlzaXRvciQxKCk7XG4vKipcbiAqIEBwYXJhbSB7P30gbm9kZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZShub2Rlcykge1xuICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3Zpc2l0b3IpOyB9KS5qb2luKCcnKTtcbn1cbnZhciBEZWNsYXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1bmVzY2FwZWRBdHRyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlY2xhcmF0aW9uKHVuZXNjYXBlZEF0dHJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModW5lc2NhcGVkQXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIF90aGlzLmF0dHJzW2tdID0gX2VzY2FwZVhtbCh1bmVzY2FwZWRBdHRyc1trXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlY2xhcmF0aW9uLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyYXRpb24odGhpcyk7IH07XG4gICAgcmV0dXJuIERlY2xhcmF0aW9uO1xufSgpKTtcbnZhciBEb2N0eXBlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvb3RUYWdcbiAgICAgKiBAcGFyYW0gez99IGR0ZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERvY3R5cGUocm9vdFRhZywgZHRkKSB7XG4gICAgICAgIHRoaXMucm9vdFRhZyA9IHJvb3RUYWc7XG4gICAgICAgIHRoaXMuZHRkID0gZHRkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb2N0eXBlLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0RG9jdHlwZSh0aGlzKTsgfTtcbiAgICByZXR1cm4gRG9jdHlwZTtcbn0oKSk7XG52YXIgVGFnID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSB1bmVzY2FwZWRBdHRyc1xuICAgICAqIEBwYXJhbSB7Pz19IGNoaWxkcmVuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGFnKG5hbWUsIHVuZXNjYXBlZEF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgICBpZiAodW5lc2NhcGVkQXR0cnMgPT09IHZvaWQgMCkgeyB1bmVzY2FwZWRBdHRycyA9IHt9OyB9XG4gICAgICAgIGlmIChjaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGNoaWxkcmVuID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHVuZXNjYXBlZEF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBfdGhpcy5hdHRyc1trXSA9IF9lc2NhcGVYbWwodW5lc2NhcGVkQXR0cnNba10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUYWcucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24gKHZpc2l0b3IpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWcodGhpcyk7IH07XG4gICAgcmV0dXJuIFRhZztcbn0oKSk7XG52YXIgVGV4dCQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVuZXNjYXBlZFZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGV4dCQyKHVuZXNjYXBlZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBfZXNjYXBlWG1sKHVuZXNjYXBlZFZhbHVlKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGV4dCQyLnByb3RvdHlwZS52aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yKSB7IHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzKTsgfTtcbiAgICByZXR1cm4gVGV4dCQyO1xufSgpKTtcbnZhciBDUiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENSLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ1Iod3MpIHtcbiAgICAgICAgaWYgKHdzID09PSB2b2lkIDApIHsgd3MgPSAwOyB9XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcIlxcblwiICsgbmV3IEFycmF5KHdzICsgMSkuam9pbignICcpKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ1I7XG59KFRleHQkMikpO1xudmFyIF9FU0NBUEVEX0NIQVJTID0gW1xuICAgIFsvJi9nLCAnJmFtcDsnXSxcbiAgICBbL1wiL2csICcmcXVvdDsnXSxcbiAgICBbLycvZywgJyZhcG9zOyddLFxuICAgIFsvPC9nLCAnJmx0OyddLFxuICAgIFsvPi9nLCAnJmd0OyddLFxuXTtcbi8qKlxuICogQHBhcmFtIHs/fSB0ZXh0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZXNjYXBlWG1sKHRleHQpIHtcbiAgICByZXR1cm4gX0VTQ0FQRURfQ0hBUlMucmVkdWNlKGZ1bmN0aW9uICh0ZXh0LCBlbnRyeSkgeyByZXR1cm4gdGV4dC5yZXBsYWNlKGVudHJ5WzBdLCBlbnRyeVsxXSk7IH0sIHRleHQpO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9WRVJTSU9OID0gJzEuMic7XG52YXIgX1hNTE5TID0gJ3VybjpvYXNpczpuYW1lczp0Yzp4bGlmZjpkb2N1bWVudDoxLjInO1xuLy8gVE9ETyh2aWNiKTogbWFrZSB0aGlzIGEgcGFyYW0gKHMvXy8tLylcbnZhciBfREVGQVVMVF9TT1VSQ0VfTEFORyA9ICdlbic7XG52YXIgX1BMQUNFSE9MREVSX1RBRyA9ICd4JztcbnZhciBfRklMRV9UQUcgPSAnZmlsZSc7XG52YXIgX1NPVVJDRV9UQUcgPSAnc291cmNlJztcbnZhciBfVEFSR0VUX1RBRyA9ICd0YXJnZXQnO1xudmFyIF9VTklUX1RBRyA9ICd0cmFucy11bml0JztcbnZhciBYbGlmZiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhsaWZmLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhsaWZmKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfV3JpdGVWaXNpdG9yKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zVW5pdHMgPSBbXTtcbiAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNVbml0ID0gbmV3IFRhZyhfVU5JVF9UQUcsIHsgaWQ6IG1lc3NhZ2UuaWQsIGRhdGF0eXBlOiAnaHRtbCcgfSk7XG4gICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoX1NPVVJDRV9UQUcsIHt9LCB2aXNpdG9yLnNlcmlhbGl6ZShtZXNzYWdlLm5vZGVzKSksIG5ldyBDUig4KSwgbmV3IFRhZyhfVEFSR0VUX1RBRykpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IHByaW9yaXR5OiAnMScsIGZyb206ICdkZXNjcmlwdGlvbicgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5kZXNjcmlwdGlvbildKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBwcmlvcml0eTogJzEnLCBmcm9tOiAnbWVhbmluZycgfSwgW25ldyBUZXh0JDIobWVzc2FnZS5tZWFuaW5nKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSk7XG4gICAgICAgICAgICB0cmFuc1VuaXRzLnB1c2gobmV3IENSKDYpLCB0cmFuc1VuaXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9IG5ldyBUYWcoJ2JvZHknLCB7fSwgdHJhbnNVbml0cy5jb25jYXQoW25ldyBDUig0KV0pKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZSA9IG5ldyBUYWcoJ2ZpbGUnLCB7XG4gICAgICAgICAgICAnc291cmNlLWxhbmd1YWdlJzogbG9jYWxlIHx8IF9ERUZBVUxUX1NPVVJDRV9MQU5HLFxuICAgICAgICAgICAgZGF0YXR5cGU6ICdwbGFpbnRleHQnLFxuICAgICAgICAgICAgb3JpZ2luYWw6ICduZzIudGVtcGxhdGUnLFxuICAgICAgICB9LCBbbmV3IENSKDQpLCBib2R5LCBuZXcgQ1IoMildKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geGxpZmYgPSBuZXcgVGFnKCd4bGlmZicsIHsgdmVyc2lvbjogX1ZFUlNJT04sIHhtbG5zOiBfWE1MTlMgfSwgW25ldyBDUigyKSwgZmlsZSwgbmV3IENSKCldKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbXG4gICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksIG5ldyBDUigpLCB4bGlmZiwgbmV3IENSKClcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29udGVudCwgdXJsKSB7XG4gICAgICAgIC8vIHhsaWZmIHRvIHhtbCBub2Rlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bGlmZlBhcnNlciA9IG5ldyBYbGlmZlBhcnNlcigpO1xuICAgICAgICB2YXIgX2EgPSB4bGlmZlBhcnNlci5wYXJzZShjb250ZW50LCB1cmwpLCBsb2NhbGUgPSBfYS5sb2NhbGUsIG1sTm9kZXNCeU1zZ0lkID0gX2EubWxOb2Rlc0J5TXNnSWQsIGVycm9ycyA9IF9hLmVycm9ycztcbiAgICAgICAgLy8geG1sIG5vZGVzIHRvIGkxOG4gbm9kZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTE4bk5vZGVzQnlNc2dJZCA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZXIgPSBuZXcgWG1sVG9JMThuKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKG1sTm9kZXNCeU1zZ0lkKS5mb3JFYWNoKGZ1bmN0aW9uIChtc2dJZCkge1xuICAgICAgICAgICAgdmFyIF9hID0gY29udmVydGVyLmNvbnZlcnQobWxOb2Rlc0J5TXNnSWRbbXNnSWRdKSwgaTE4bk5vZGVzID0gX2EuaTE4bk5vZGVzLCBlID0gX2EuZXJyb3JzO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBlKTtcbiAgICAgICAgICAgIGkxOG5Ob2Rlc0J5TXNnSWRbbXNnSWRdID0gaTE4bk5vZGVzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInhsaWZmIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbG9jYWxlOiBsb2NhbGUsIGkxOG5Ob2Rlc0J5TXNnSWQ6IGkxOG5Ob2Rlc0J5TXNnSWQgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmYucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBkaWdlc3QobWVzc2FnZSk7IH07XG4gICAgcmV0dXJuIFhsaWZmO1xufShTZXJpYWxpemVyKSk7XG52YXIgX1dyaXRlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX1dyaXRlVmlzaXRvcigpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIFtuZXcgVGV4dCQyKHRleHQudmFsdWUpXTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlcyA9IFtdO1xuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZXMucHVzaC5hcHBseShub2Rlcywgbm9kZS52aXNpdChfdGhpcykpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfV3JpdGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEljdSA9IGZ1bmN0aW9uIChpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5JY3UpIHtcbiAgICAgICAgICAgIC8vIG5lc3RlZCBJQ1UgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4bGlmZiBkb2VzIG5vdCBzdXBwb3J0IG5lc3RlZCBJQ1UgbWVzc2FnZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0luSWN1ID0gdHJ1ZTtcbiAgICAgICAgLy8gVE9ETyh2aWNiKTogc3VwcG9ydCBJQ1UgbWVzc2FnZXNcbiAgICAgICAgLy8gaHR0cHM6Ly9saXN0cy5vYXNpcy1vcGVuLm9yZy9hcmNoaXZlcy94bGlmZi8yMDEyMDEvbXNnMDAwMjguaHRtbFxuICAgICAgICAvLyBodHRwOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy94bGlmZi92MS4yL3hsaWZmLXByb2ZpbGUtcG8veGxpZmYtcHJvZmlsZS1wby0xLjItY2QwMi5odG1sXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW107XG4gICAgICAgIHRoaXMuX2lzSW5JY3UgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R5cGUgPSBnZXRDdHlwZUZvclRhZyhwaC50YWcpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydFRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IGlkOiBwaC5zdGFydE5hbWUsIGN0eXBlOiBjdHlwZSB9KTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgLy8gdm9pZCB0YWdzIGhhdmUgbm8gY2hpbGRyZW4gbm9yIGNsb3NpbmcgdGFnc1xuICAgICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9zZVRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHLCB7IGlkOiBwaC5jbG9zZU5hbWUsIGN0eXBlOiBjdHlwZSB9KTtcbiAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXS5jb25jYXQodGhpcy5zZXJpYWxpemUocGguY2hpbGRyZW4pLCBbY2xvc2VUYWdQaF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgaWQ6IHBoLm5hbWUgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Xcml0ZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUcsIHsgaWQ6IHBoLm5hbWUgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1dyaXRlVmlzaXRvci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2lzSW5JY3UgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgbm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZpc2l0KF90aGlzKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIF9Xcml0ZVZpc2l0b3I7XG59KCkpO1xudmFyIFhsaWZmUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbGlmZlBhcnNlcigpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB4bGlmZlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoeGxpZmYsIHVybCkge1xuICAgICAgICB0aGlzLl91bml0TWxOb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLl9tbE5vZGVzQnlNc2dJZCA9IHt9O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bWwgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UoeGxpZmYsIHVybCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWwuZXJyb3JzO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB4bWwucm9vdE5vZGVzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1sTm9kZXNCeU1zZ0lkOiB0aGlzLl9tbE5vZGVzQnlNc2dJZCxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhsaWZmUGFyc2VyLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBfVU5JVF9UQUc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdE1sTm9kZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnaWQnOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9VTklUX1RBRyArIFwiPiBtaXNzZXMgdGhlIFxcXCJpZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSBpZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tbE5vZGVzQnlNc2dJZC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIFwiRHVwbGljYXRlZCB0cmFuc2xhdGlvbnMgZm9yIG1zZyBcIiArIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VuaXRNbE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWxOb2Rlc0J5TXNnSWRbaWRdID0gdGhpcy5fdW5pdE1sTm9kZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIk1lc3NhZ2UgXCIgKyBpZCArIFwiIG1pc3NlcyBhIHRyYW5zbGF0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfU09VUkNFX1RBRzpcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgc291cmNlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1RBUkdFVF9UQUc6XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdE1sTm9kZXMgPSBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfRklMRV9UQUc6XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9jYWxlQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAndGFyZ2V0LWxhbmd1YWdlJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZUF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFRPRE8odmljYik6IGFzc2VydCBmaWxlIHN0cnVjdHVyZSwgeGxpZmYgdmVyc2lvblxuICAgICAgICAgICAgICAgIC8vIEZvciBub3cgb25seSByZWN1cnNlIG9uIHVuaGFuZGxlZCBub2Rlc1xuICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvblxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGV4cGFuc2lvbiwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwYW5zaW9uQ2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWGxpZmZQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbGlmZlBhcnNlci5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbGlmZlBhcnNlcjtcbn0oKSk7XG52YXIgWG1sVG9JMThuID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxUb0kxOG4oKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlczogdmlzaXRBbGwodGhpcywgbm9kZXMpLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4bi5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIG5ldyBUZXh0JDEodGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbCwgY29udGV4dCkge1xuICAgICAgICBpZiAoZWwubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZUF0dHIgPSBlbC5hdHRycy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUgPT09ICdpZCc7IH0pO1xuICAgICAgICAgICAgaWYgKG5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcignJywgbmFtZUF0dHIudmFsdWUsIGVsLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiPFwiICsgX1BMQUNFSE9MREVSX1RBRyArIFwiPiBtaXNzZXMgdGhlIFxcXCJpZFxcXCIgYXR0cmlidXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiVW5leHBlY3RlZCB0YWdcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1Q2FzZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoaWN1Q2FzZSwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tbWVudFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4ucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuLnByb3RvdHlwZS5fYWRkRXJyb3IgPSBmdW5jdGlvbiAobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFhtbFRvSTE4bjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gdGFnXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBnZXRDdHlwZUZvclRhZyh0YWcpIHtcbiAgICBzd2l0Y2ggKHRhZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ2JyJzpcbiAgICAgICAgICAgIHJldHVybiAnbGInO1xuICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJ4LVwiICsgdGFnO1xuICAgIH1cbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfTUVTU0FHRVNfVEFHID0gJ21lc3NhZ2VidW5kbGUnO1xudmFyIF9NRVNTQUdFX1RBRyA9ICdtc2cnO1xudmFyIF9QTEFDRUhPTERFUl9UQUckMSA9ICdwaCc7XG52YXIgX0VYRU1QTEVfVEFHID0gJ2V4JztcbnZhciBfRE9DVFlQRSA9IFwiPCFFTEVNRU5UIG1lc3NhZ2VidW5kbGUgKG1zZykqPlxcbjwhQVRUTElTVCBtZXNzYWdlYnVuZGxlIGNsYXNzIENEQVRBICNJTVBMSUVEPlxcblxcbjwhRUxFTUVOVCBtc2cgKCNQQ0RBVEF8cGh8c291cmNlKSo+XFxuPCFBVFRMSVNUIG1zZyBpZCBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIHNlcSBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG5hbWUgQ0RBVEEgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyBkZXNjIENEQVRBICNJTVBMSUVEPlxcbjwhQVRUTElTVCBtc2cgbWVhbmluZyBDREFUQSAjSU1QTElFRD5cXG48IUFUVExJU1QgbXNnIG9ic29sZXRlIChvYnNvbGV0ZSkgI0lNUExJRUQ+XFxuPCFBVFRMSVNUIG1zZyB4bWw6c3BhY2UgKGRlZmF1bHR8cHJlc2VydmUpIFxcXCJkZWZhdWx0XFxcIj5cXG48IUFUVExJU1QgbXNnIGlzX2hpZGRlbiBDREFUQSAjSU1QTElFRD5cXG5cXG48IUVMRU1FTlQgc291cmNlICgjUENEQVRBKT5cXG5cXG48IUVMRU1FTlQgcGggKCNQQ0RBVEF8ZXgpKj5cXG48IUFUVExJU1QgcGggbmFtZSBDREFUQSAjUkVRVUlSRUQ+XFxuXFxuPCFFTEVNRU5UIGV4ICgjUENEQVRBKT5cIjtcbnZhciBYbWIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYbWIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWG1iKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1iLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4YW1wbGVWaXNpdG9yID0gbmV3IEV4YW1wbGVWaXNpdG9yKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IkMigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290Tm9kZSA9IG5ldyBUYWcoX01FU1NBR0VTX1RBRyk7XG4gICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJzID0geyBpZDogbWVzc2FnZS5pZCB9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBhdHRyc1snZGVzYyddID0gbWVzc2FnZS5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1snbWVhbmluZyddID0gbWVzc2FnZS5tZWFuaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW4ucHVzaChuZXcgQ1IoMiksIG5ldyBUYWcoX01FU1NBR0VfVEFHLCBhdHRycywgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb3ROb2RlLmNoaWxkcmVuLnB1c2gobmV3IENSKCkpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtcbiAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbih7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04JyB9KSxcbiAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgICAgbmV3IERvY3R5cGUoX01FU1NBR0VTX1RBRywgX0RPQ1RZUEUpLFxuICAgICAgICAgICAgbmV3IENSKCksXG4gICAgICAgICAgICBleGFtcGxlVmlzaXRvci5hZGREZWZhdWx0RXhhbXBsZXMocm9vdE5vZGUpLFxuICAgICAgICAgICAgbmV3IENSKCksXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50XG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtYi5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBkaWdlc3QkMShtZXNzYWdlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtYi5wcm90b3R5cGUuY3JlYXRlTmFtZU1hcHBlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIobWVzc2FnZSwgdG9QdWJsaWNOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWI7XG59KFNlcmlhbGl6ZXIpKTtcbnZhciBfVmlzaXRvciQyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfVmlzaXRvciQyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQyLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgY29udGV4dCkgeyByZXR1cm4gW25ldyBUZXh0JDIodGV4dC52YWx1ZSldOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQyLnByb3RvdHlwZS52aXNpdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXMgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGVzLnB1c2guYXBwbHkobm9kZXMsIG5vZGUudmlzaXQoX3RoaXMpKTsgfSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMi5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gW25ldyBUZXh0JDIoXCJ7XCIgKyBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyICsgXCIsIFwiICsgaWN1LnR5cGUgKyBcIiwgXCIpXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoLmFwcGx5KG5vZGVzLCBbbmV3IFRleHQkMihjICsgXCIge1wiKV0uY29uY2F0KGljdS5jYXNlc1tjXS52aXNpdChfdGhpcyksIFtuZXcgVGV4dCQyKFwifSBcIildKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDIoXCJ9XCIpKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9WaXNpdG9yJDIucHJvdG90eXBlLnZpc2l0VGFnUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRFeCA9IG5ldyBUYWcoX0VYRU1QTEVfVEFHLCB7fSwgW25ldyBUZXh0JDIoXCI8XCIgKyBwaC50YWcgKyBcIj5cIildKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IG5hbWU6IHBoLnN0YXJ0TmFtZSB9LCBbc3RhcnRFeF0pO1xuICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICAvLyB2b2lkIHRhZ3MgaGF2ZSBubyBjaGlsZHJlbiBub3IgY2xvc2luZyB0YWdzXG4gICAgICAgICAgICByZXR1cm4gW3N0YXJ0VGFnUGhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsb3NlRXggPSBuZXcgVGFnKF9FWEVNUExFX1RBRywge30sIFtuZXcgVGV4dCQyKFwiPC9cIiArIHBoLnRhZyArIFwiPlwiKV0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9zZVRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgbmFtZTogcGguY2xvc2VOYW1lIH0sIFtjbG9zZUV4XSk7XG4gICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF0uY29uY2F0KHRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgW2Nsb3NlVGFnUGhdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmlzaXRvciQyLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHsgbmFtZTogcGgubmFtZSB9KV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMi5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IG5hbWU6IHBoLm5hbWUgfSldO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1Zpc2l0b3IkMi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBfVmlzaXRvciQyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkaWdlc3QkMShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGRlY2ltYWxEaWdlc3QobWVzc2FnZSk7XG59XG52YXIgRXhhbXBsZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4YW1wbGVWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4YW1wbGVWaXNpdG9yLnByb3RvdHlwZS5hZGREZWZhdWx0RXhhbXBsZXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0YWcubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRyQxKSB7XG4gICAgICAgICAgICBpZiAoIXRhZy5jaGlsZHJlbiB8fCB0YWcuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleFRleHQgPSBuZXcgVGV4dCQyKHRhZy5hdHRyc1snbmFtZSddIHx8ICcuLi4nKTtcbiAgICAgICAgICAgICAgICB0YWcuY2hpbGRyZW4gPSBbbmV3IFRhZyhfRVhFTVBMRV9UQUcsIHt9LCBbZXhUZXh0XSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhZy5jaGlsZHJlbikge1xuICAgICAgICAgICAgdGFnLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUudmlzaXQoX3RoaXMpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeGFtcGxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlY2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4YW1wbGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmF0aW9uID0gZnVuY3Rpb24gKGRlY2wpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRvY3R5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4YW1wbGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdERvY3R5cGUgPSBmdW5jdGlvbiAoZG9jdHlwZSkgeyB9O1xuICAgIHJldHVybiBFeGFtcGxlVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gaW50ZXJuYWxOYW1lXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0b1B1YmxpY05hbWUoaW50ZXJuYWxOYW1lKSB7XG4gICAgcmV0dXJuIGludGVybmFsTmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1teQS1aMC05X10vZywgJ18nKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfVFJBTlNMQVRJT05TX1RBRyA9ICd0cmFuc2xhdGlvbmJ1bmRsZSc7XG52YXIgX1RSQU5TTEFUSU9OX1RBRyA9ICd0cmFuc2xhdGlvbic7XG52YXIgX1BMQUNFSE9MREVSX1RBRyQyID0gJ3BoJztcbnZhciBYdGIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhYdGIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWHRiKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gez99IGxvY2FsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWHRiLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgbG9jYWxlKSB7IHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWHRiLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAvLyB4dGIgdG8geG1sIG5vZGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHh0YlBhcnNlciA9IG5ldyBYdGJQYXJzZXIoKTtcbiAgICAgICAgdmFyIF9hID0geHRiUGFyc2VyLnBhcnNlKGNvbnRlbnQsIHVybCksIGxvY2FsZSA9IF9hLmxvY2FsZSwgbXNnSWRUb0h0bWwgPSBfYS5tc2dJZFRvSHRtbCwgZXJyb3JzID0gX2EuZXJyb3JzO1xuICAgICAgICAvLyB4bWwgbm9kZXMgdG8gaTE4biBub2Rlc1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuTm9kZXNCeU1zZ0lkID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnZlcnRlciA9IG5ldyBYbWxUb0kxOG4kMSgpO1xuICAgICAgICAvLyBCZWNhdXNlIHdlIHNob3VsZCBiZSBhYmxlIHRvIGxvYWQgeHRiIGZpbGVzIHRoYXQgcmVseSBvbiBmZWF0dXJlcyBub3Qgc3VwcG9ydGVkIGJ5IGFuZ3VsYXIsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsYXkgdGhlIGNvbnZlcnNpb24gb2YgaHRtbCB0byBpMThuIG5vZGVzIHNvIHRoYXQgbm9uIGFuZ3VsYXIgbWVzc2FnZXMgYXJlIG5vdFxuICAgICAgICAvLyBjb252ZXJ0ZWRcbiAgICAgICAgT2JqZWN0LmtleXMobXNnSWRUb0h0bWwpLmZvckVhY2goZnVuY3Rpb24gKG1zZ0lkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZUZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGNvbnZlcnRlci5jb252ZXJ0KG1zZ0lkVG9IdG1sW21zZ0lkXSwgdXJsKSwgaTE4bk5vZGVzID0gX2EuaTE4bk5vZGVzLCBlcnJvcnMgPSBfYS5lcnJvcnM7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHRiIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpMThuTm9kZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3JlYXRlTGF6eVByb3BlcnR5KGkxOG5Ob2Rlc0J5TXNnSWQsIG1zZ0lkLCB2YWx1ZUZuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4dGIgcGFyc2UgZXJyb3JzOlxcblwiICsgZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsb2NhbGU6IGxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZDogaTE4bk5vZGVzQnlNc2dJZCB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBkaWdlc3QkMShtZXNzYWdlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0Yi5wcm90b3R5cGUuY3JlYXRlTmFtZU1hcHBlciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIobWVzc2FnZSwgdG9QdWJsaWNOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBYdGI7XG59KFNlcmlhbGl6ZXIpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtZXNzYWdlc1xuICogQHBhcmFtIHs/fSBpZFxuICogQHBhcmFtIHs/fSB2YWx1ZUZuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVMYXp5UHJvcGVydHkobWVzc2FnZXMsIGlkLCB2YWx1ZUZuKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lc3NhZ2VzLCBpZCwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB2YWx1ZUZuKCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWVzc2FnZXMsIGlkLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoXykgeyB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBvdmVyd3JpdGUgYW4gWFRCIHRyYW5zbGF0aW9uJyk7IH0sXG4gICAgfSk7XG59XG52YXIgWHRiUGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYdGJQYXJzZXIoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30geHRiXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoeHRiLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGggPSAwO1xuICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbCA9IHt9O1xuICAgICAgICAvLyBXZSBjYW4gbm90IHBhcnNlIHRoZSBJQ1UgbWVzc2FnZXMgYXQgdGhpcyBwb2ludCBhcyBzb21lIG1lc3NhZ2VzIG1pZ2h0IG5vdCBvcmlnaW5hdGVcbiAgICAgICAgLy8gZnJvbSBBbmd1bGFyIHRoYXQgY291bGQgbm90IGJlIGxleCdkLlxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB4bWwgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UoeHRiLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sLmVycm9ycztcbiAgICAgICAgdmlzaXRBbGwodGhpcywgeG1sLnJvb3ROb2Rlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2dJZFRvSHRtbDogdGhpcy5fbXNnSWRUb0h0bWwsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9UUkFOU0xBVElPTlNfVEFHOlxuICAgICAgICAgICAgICAgIHRoaXMuX2J1bmRsZURlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2J1bmRsZURlcHRoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBcIjxcIiArIF9UUkFOU0xBVElPTlNfVEFHICsgXCI+IGVsZW1lbnRzIGNhbiBub3QgYmUgbmVzdGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYW5nQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnbGFuZyc7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChsYW5nQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBsYW5nQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGgtLTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1RSQU5TTEFUSU9OX1RBRzpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZEF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gJ2lkJzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZEF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCI8XCIgKyBfVFJBTlNMQVRJT05fVEFHICsgXCI+IG1pc3NlcyB0aGUgXFxcImlkXFxcIiBhdHRyaWJ1dGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IGlkQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21zZ0lkVG9IdG1sLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgXCJEdXBsaWNhdGVkIHRyYW5zbGF0aW9ucyBmb3IgbXNnIFwiICsgaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUZXh0U3RhcnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5uZXJUZXh0RW5kID0gZWxlbWVudC5lbmRTb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbm5lclRleHQgPSBjb250ZW50LnNsaWNlKGlubmVyVGV4dFN0YXJ0LCBpbm5lclRleHRFbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWxbaWRdID0gaW5uZXJUZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCAnVW5leHBlY3RlZCB0YWcnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25cbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFh0YlBhcnNlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoZXhwYW5zaW9uLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25DYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uQ2FzZSA9IGZ1bmN0aW9uIChleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYdGJQYXJzZXIucHJvdG90eXBlLl9hZGRFcnJvciA9IGZ1bmN0aW9uIChub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtZXNzYWdlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gWHRiUGFyc2VyO1xufSgpKTtcbnZhciBYbWxUb0kxOG4kMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWG1sVG9JMThuJDEoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChtZXNzYWdlLCB1cmwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8geG1sSWN1ID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKG1lc3NhZ2UsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbEljdS5lcnJvcnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgeG1sSWN1LnJvb3ROb2Rlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpMThuTm9kZXM6IGkxOG5Ob2RlcyxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIG5ldyBUZXh0JDEodGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgWG1sVG9JMThuJDEucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYXNlTWFwID0ge307XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgY2FzZU1hcFtjLnZhbHVlXSA9IG5ldyBDb250YWluZXIoYy5ub2RlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3UoaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgY2FzZU1hcCwgaWN1LnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VDYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IHZpc2l0QWxsKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbiksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChlbC5uYW1lID09PSBfUExBQ0VIT0xERVJfVEFHJDIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVBdHRyID0gZWwuYXR0cnMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci5uYW1lID09PSAnbmFtZSc7IH0pO1xuICAgICAgICAgICAgaWYgKG5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcignJywgbmFtZUF0dHIudmFsdWUsIGVsLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIFwiPFwiICsgX1BMQUNFSE9MREVSX1RBRyQyICsgXCI+IG1pc3NlcyB0aGUgXFxcIm5hbWVcXFwiIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBcIlVuZXhwZWN0ZWQgdGFnXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFhtbFRvSTE4biQxLnByb3RvdHlwZS52aXNpdENvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUudmlzaXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBYbWxUb0kxOG4kMS5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWxUb0kxOG4kMTtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSHRtbFBhcnNlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEh0bWxQYXJzZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHRtbFBhcnNlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGdldEh0bWxUYWdEZWZpbml0aW9uKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gcGFyc2VFeHBhbnNpb25Gb3Jtc1xuICAgICAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEh0bWxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucGFyc2UuY2FsbCh0aGlzLCBzb3VyY2UsIHVybCwgcGFyc2VFeHBhbnNpb25Gb3JtcywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbFBhcnNlcjtcbn0oUGFyc2VyJDEpKTtcbkh0bWxQYXJzZXIuZGVjb3JhdG9ycyA9IFtcbiAgICB7IHR5cGU6IENvbXBpbGVySW5qZWN0YWJsZSB9LFxuXTtcbi8qKlxuICogQG5vY29sbGFwc2VcbiAqL1xuSHRtbFBhcnNlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgdHJhbnNsYXRlZCBtZXNzYWdlc1xuICovXG52YXIgVHJhbnNsYXRpb25CdW5kbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9pMThuTm9kZXNCeU1zZ0lkXG4gICAgICogQHBhcmFtIHs/PX0gbG9jYWxlXG4gICAgICogQHBhcmFtIHs/PX0gZGlnZXN0XG4gICAgICogQHBhcmFtIHs/PX0gbWFwcGVyRmFjdG9yeVxuICAgICAqIEBwYXJhbSB7Pz19IG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5XG4gICAgICogQHBhcmFtIHs/PX0gY29uc29sZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYW5zbGF0aW9uQnVuZGxlKF9pMThuTm9kZXNCeU1zZ0lkLCBsb2NhbGUsIGRpZ2VzdCwgbWFwcGVyRmFjdG9yeSwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIGNvbnNvbGUpIHtcbiAgICAgICAgaWYgKF9pMThuTm9kZXNCeU1zZ0lkID09PSB2b2lkIDApIHsgX2kxOG5Ob2Rlc0J5TXNnSWQgPSB7fTsgfVxuICAgICAgICBpZiAobWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPT09IHZvaWQgMCkgeyBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmc7IH1cbiAgICAgICAgdGhpcy5faTE4bk5vZGVzQnlNc2dJZCA9IF9pMThuTm9kZXNCeU1zZ0lkO1xuICAgICAgICB0aGlzLmRpZ2VzdCA9IGRpZ2VzdDtcbiAgICAgICAgdGhpcy5tYXBwZXJGYWN0b3J5ID0gbWFwcGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5faTE4blRvSHRtbCA9IG5ldyBJMThuVG9IdG1sVmlzaXRvcihfaTE4bk5vZGVzQnlNc2dJZCwgbG9jYWxlLCBkaWdlc3QsIG1hcHBlckZhY3RvcnksIG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBjb25zb2xlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb250ZW50XG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez99IHNlcmlhbGl6ZXJcbiAgICAgKiBAcGFyYW0gez99IG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5XG4gICAgICogQHBhcmFtIHs/PX0gY29uc29sZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHJhbnNsYXRpb25CdW5kbGUubG9hZCA9IGZ1bmN0aW9uIChjb250ZW50LCB1cmwsIHNlcmlhbGl6ZXIsIG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBjb25zb2xlKSB7XG4gICAgICAgIHZhciBfYSA9IHNlcmlhbGl6ZXIubG9hZChjb250ZW50LCB1cmwpLCBsb2NhbGUgPSBfYS5sb2NhbGUsIGkxOG5Ob2Rlc0J5TXNnSWQgPSBfYS5pMThuTm9kZXNCeU1zZ0lkO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaWdlc3RGbiA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBzZXJpYWxpemVyLmRpZ2VzdChtKTsgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwcGVyRmFjdG9yeSA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBzZXJpYWxpemVyLmNyZWF0ZU5hbWVNYXBwZXIobSk7IH07XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNsYXRpb25CdW5kbGUoaTE4bk5vZGVzQnlNc2dJZCwgbG9jYWxlLCBkaWdlc3RGbiwgbWFwcGVyRmFjdG9yeSwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIGNvbnNvbGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNNc2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyYW5zbGF0aW9uQnVuZGxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoc3JjTXNnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGh0bWwgPSB0aGlzLl9pMThuVG9IdG1sLmNvbnZlcnQoc3JjTXNnKTtcbiAgICAgICAgaWYgKGh0bWwuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGh0bWwuZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbC5ub2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3JjTXNnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUcmFuc2xhdGlvbkJ1bmRsZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHNyY01zZykgeyByZXR1cm4gdGhpcy5kaWdlc3Qoc3JjTXNnKSBpbiB0aGlzLl9pMThuTm9kZXNCeU1zZ0lkOyB9O1xuICAgIHJldHVybiBUcmFuc2xhdGlvbkJ1bmRsZTtcbn0oKSk7XG52YXIgSTE4blRvSHRtbFZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9pMThuTm9kZXNCeU1zZ0lkXG4gICAgICogQHBhcmFtIHs/PX0gX2xvY2FsZVxuICAgICAqIEBwYXJhbSB7Pz19IF9kaWdlc3RcbiAgICAgKiBAcGFyYW0gez89fSBfbWFwcGVyRmFjdG9yeVxuICAgICAqIEBwYXJhbSB7Pz19IF9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVxuICAgICAqIEBwYXJhbSB7Pz19IF9jb25zb2xlXG4gICAgICovXG4gICAgZnVuY3Rpb24gSTE4blRvSHRtbFZpc2l0b3IoX2kxOG5Ob2Rlc0J5TXNnSWQsIF9sb2NhbGUsIF9kaWdlc3QsIF9tYXBwZXJGYWN0b3J5LCBfbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3ksIF9jb25zb2xlKSB7XG4gICAgICAgIGlmIChfaTE4bk5vZGVzQnlNc2dJZCA9PT0gdm9pZCAwKSB7IF9pMThuTm9kZXNCeU1zZ0lkID0ge307IH1cbiAgICAgICAgdGhpcy5faTE4bk5vZGVzQnlNc2dJZCA9IF9pMThuTm9kZXNCeU1zZ0lkO1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB0aGlzLl9kaWdlc3QgPSBfZGlnZXN0O1xuICAgICAgICB0aGlzLl9tYXBwZXJGYWN0b3J5ID0gX21hcHBlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID0gX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5O1xuICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgIHRoaXMuX2NvbnRleHRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNNc2dcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKHNyY01zZykge1xuICAgICAgICB0aGlzLl9jb250ZXh0U3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fZXJyb3JzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vIGkxOG4gdG8gdGV4dFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0ID0gdGhpcy5fY29udmVydFRvVGV4dChzcmNNc2cpO1xuICAgICAgICAvLyB0ZXh0IHRvIGh0bWxcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsID0gc3JjTXNnLm5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQuZmlsZS51cmw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGh0bWwgPSBuZXcgSHRtbFBhcnNlcigpLnBhcnNlKHRleHQsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlczogaHRtbC5yb290Tm9kZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycy5jb25jYXQoaHRtbC5lcnJvcnMpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uICh0ZXh0LCBjb250ZXh0KSB7IHJldHVybiB0ZXh0LnZhbHVlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmVyXG4gICAgICogQHBhcmFtIHs/PX0gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcyk7IH0pLmpvaW4oJycpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpY3VcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3UgPSBmdW5jdGlvbiAoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGsgKyBcIiB7XCIgKyBpY3UuY2FzZXNba10udmlzaXQoX3RoaXMpICsgXCJ9XCI7IH0pO1xuICAgICAgICAvLyBUT0RPKHZpY2IpOiBPbmNlIGFsbCBmb3JtYXQgc3dpdGNoIHRvIHVzaW5nIGV4cHJlc3Npb24gcGxhY2Vob2xkZXJzXG4gICAgICAgIC8vIHdlIHNob3VsZCB0aHJvdyB3aGVuIHRoZSBwbGFjZWhvbGRlciBpcyBub3QgaW4gdGhlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cCA9IHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnMuaGFzT3duUHJvcGVydHkoaWN1LmV4cHJlc3Npb24pID9cbiAgICAgICAgICAgIHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnNbaWN1LmV4cHJlc3Npb25dIDpcbiAgICAgICAgICAgIGljdS5leHByZXNzaW9uO1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBleHAgKyBcIiwgXCIgKyBpY3UudHlwZSArIFwiLCBcIiArIGNhc2VzLmpvaW4oJyAnKSArIFwifVwiO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEkxOG5Ub0h0bWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBoTmFtZSA9IHRoaXMuX21hcHBlcihwaC5uYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnMuaGFzT3duUHJvcGVydHkocGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnNbcGhOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyVG9NZXNzYWdlLmhhc093blByb3BlcnR5KHBoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9UZXh0KHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlclRvTWVzc2FnZVtwaE5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRFcnJvcihwaCwgXCJVbmtub3duIHBsYWNlaG9sZGVyIFxcXCJcIiArIHBoLm5hbWUgKyBcIlxcXCJcIik7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWcgPSBcIlwiICsgcGgudGFnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRycyA9IE9iamVjdC5rZXlzKHBoLmF0dHJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgKyBcIj1cXFwiXCIgKyBwaC5hdHRyc1tuYW1lXSArIFwiXFxcIlwiOyB9KS5qb2luKCcgJyk7XG4gICAgICAgIGlmIChwaC5pc1ZvaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxcIiArIHRhZyArIFwiIFwiICsgYXR0cnMgKyBcIi8+XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSBwaC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudmlzaXQoX3RoaXMpOyB9KS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIFwiPFwiICsgdGFnICsgXCIgXCIgKyBhdHRycyArIFwiPlwiICsgY2hpbGRyZW4gKyBcIjwvXCIgKyB0YWcgKyBcIj5cIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRJY3VQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgY29udGV4dCkge1xuICAgICAgICAvLyBBbiBJQ1UgcGxhY2Vob2xkZXIgcmVmZXJlbmNlcyB0aGUgc291cmNlIG1lc3NhZ2UgdG8gYmUgc2VyaWFsaXplZFxuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydFRvVGV4dCh0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJUb01lc3NhZ2VbcGgubmFtZV0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHNvdXJjZSBtZXNzYWdlIHRvIGEgdHJhbnNsYXRlZCB0ZXh0IHN0cmluZzpcbiAgICAgKiAtIHRleHQgbm9kZXMgYXJlIHJlcGxhY2VkIHdpdGggdGhlaXIgdHJhbnNsYXRpb24sXG4gICAgICogLSBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIHdpdGggdGhlaXIgY29udGVudCxcbiAgICAgKiAtIElDVSBub2RlcyBhcmUgY29udmVydGVkIHRvIElDVSBleHByZXNzaW9ucy5cbiAgICAgKiBAcGFyYW0gez99IHNyY01zZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4blRvSHRtbFZpc2l0b3IucHJvdG90eXBlLl9jb252ZXJ0VG9UZXh0ID0gZnVuY3Rpb24gKHNyY01zZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHRoaXMuX2RpZ2VzdChzcmNNc2cpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXBwZXIgPSB0aGlzLl9tYXBwZXJGYWN0b3J5ID8gdGhpcy5fbWFwcGVyRmFjdG9yeShzcmNNc2cpIDogbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZXM7XG4gICAgICAgIHRoaXMuX2NvbnRleHRTdGFjay5wdXNoKHsgbXNnOiB0aGlzLl9zcmNNc2csIG1hcHBlcjogdGhpcy5fbWFwcGVyIH0pO1xuICAgICAgICB0aGlzLl9zcmNNc2cgPSBzcmNNc2c7XG4gICAgICAgIGlmICh0aGlzLl9pMThuTm9kZXNCeU1zZ0lkLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBpcyBhIHRyYW5zbGF0aW9uIHVzZSBpdHMgbm9kZXMgYXMgdGhlIHNvdXJjZVxuICAgICAgICAgICAgLy8gQW5kIGNyZWF0ZSBhIG1hcHBlciB0byBjb252ZXJ0IHNlcmlhbGl6ZWQgcGxhY2Vob2xkZXIgbmFtZXMgdG8gaW50ZXJuYWwgbmFtZXNcbiAgICAgICAgICAgIG5vZGVzID0gdGhpcy5faTE4bk5vZGVzQnlNc2dJZFtpZF07XG4gICAgICAgICAgICB0aGlzLl9tYXBwZXIgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWFwcGVyID8gbWFwcGVyLnRvSW50ZXJuYWxOYW1lKG5hbWUpIDogbmFtZTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gbm8gdHJhbnNsYXRpb24gaGFzIGJlZW4gZm91bmRcbiAgICAgICAgICAgIC8vIC0gcmVwb3J0IGFuIGVycm9yIC8gYSB3YXJuaW5nIC8gbm90aGluZyxcbiAgICAgICAgICAgIC8vIC0gdXNlIHRoZSBub2RlcyBmcm9tIHRoZSBvcmlnaW5hbCBtZXNzYWdlXG4gICAgICAgICAgICAvLyAtIHBsYWNlaG9sZGVycyBhcmUgYWxyZWFkeSBpbnRlcm5hbCBhbmQgbmVlZCBubyBtYXBwZXJcbiAgICAgICAgICAgIGlmICh0aGlzLl9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9PT0gTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHggPSB0aGlzLl9sb2NhbGUgPyBcIiBmb3IgbG9jYWxlIFxcXCJcIiArIHRoaXMuX2xvY2FsZSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3Ioc3JjTXNnLm5vZGVzWzBdLCBcIk1pc3NpbmcgdHJhbnNsYXRpb24gZm9yIG1lc3NhZ2UgXFxcIlwiICsgaWQgKyBcIlxcXCJcIiArIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jb25zb2xlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPT09IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHggPSB0aGlzLl9sb2NhbGUgPyBcIiBmb3IgbG9jYWxlIFxcXCJcIiArIHRoaXMuX2xvY2FsZSArIFwiXFxcIlwiIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS53YXJuKFwiTWlzc2luZyB0cmFuc2xhdGlvbiBmb3IgbWVzc2FnZSBcXFwiXCIgKyBpZCArIFwiXFxcIlwiICsgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzID0gc3JjTXNnLm5vZGVzO1xuICAgICAgICAgICAgdGhpcy5fbWFwcGVyID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWU7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGV4dCA9IG5vZGVzLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS52aXNpdChfdGhpcyk7IH0pLmpvaW4oJycpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZXh0ID0gdGhpcy5fY29udGV4dFN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLl9zcmNNc2cgPSBjb250ZXh0Lm1zZztcbiAgICAgICAgdGhpcy5fbWFwcGVyID0gY29udGV4dC5tYXBwZXI7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbFxuICAgICAqIEBwYXJhbSB7P30gbXNnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJMThuVG9IdG1sVmlzaXRvci5wcm90b3R5cGUuX2FkZEVycm9yID0gZnVuY3Rpb24gKGVsLCBtc2cpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihlbC5zb3VyY2VTcGFuLCBtc2cpKTtcbiAgICB9O1xuICAgIHJldHVybiBJMThuVG9IdG1sVmlzaXRvcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgSTE4Tkh0bWxQYXJzZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2h0bWxQYXJzZXJcbiAgICAgKiBAcGFyYW0gez89fSB0cmFuc2xhdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSB0cmFuc2xhdGlvbnNGb3JtYXRcbiAgICAgKiBAcGFyYW0gez89fSBtaXNzaW5nVHJhbnNsYXRpb25cbiAgICAgKiBAcGFyYW0gez89fSBjb25zb2xlXG4gICAgICovXG4gICAgZnVuY3Rpb24gSTE4Tkh0bWxQYXJzZXIoX2h0bWxQYXJzZXIsIHRyYW5zbGF0aW9ucywgdHJhbnNsYXRpb25zRm9ybWF0LCBtaXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpIHtcbiAgICAgICAgaWYgKG1pc3NpbmdUcmFuc2xhdGlvbiA9PT0gdm9pZCAwKSB7IG1pc3NpbmdUcmFuc2xhdGlvbiA9IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmc7IH1cbiAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICBpZiAodHJhbnNsYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplciA9IGNyZWF0ZVNlcmlhbGl6ZXIodHJhbnNsYXRpb25zRm9ybWF0KTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uQnVuZGxlID1cbiAgICAgICAgICAgICAgICBUcmFuc2xhdGlvbkJ1bmRsZS5sb2FkKHRyYW5zbGF0aW9ucywgJ2kxOG4nLCBzZXJpYWxpemVyLCBtaXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcGFyYW0gez89fSBwYXJzZUV4cGFuc2lvbkZvcm1zXG4gICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSTE4Tkh0bWxQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIGlmIChwYXJzZUV4cGFuc2lvbkZvcm1zID09PSB2b2lkIDApIHsgcGFyc2VFeHBhbnNpb25Gb3JtcyA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uQ29uZmlnID09PSB2b2lkIDApIHsgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyc2VSZXN1bHQgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHNvdXJjZSwgdXJsLCBwYXJzZUV4cGFuc2lvbkZvcm1zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc2xhdGlvbkJ1bmRsZSkge1xuICAgICAgICAgICAgLy8gRG8gbm90IGVuYWJsZSBpMThuIHdoZW4gbm8gdHJhbnNsYXRpb24gYnVuZGxlIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHBhcnNlUmVzdWx0LnJvb3ROb2RlcywgcGFyc2VSZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VUcmFuc2xhdGlvbnMocGFyc2VSZXN1bHQucm9vdE5vZGVzLCB0aGlzLl90cmFuc2xhdGlvbkJ1bmRsZSwgaW50ZXJwb2xhdGlvbkNvbmZpZywgW10sIHt9KTtcbiAgICB9O1xuICAgIHJldHVybiBJMThOSHRtbFBhcnNlcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7Pz19IGZvcm1hdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihmb3JtYXQpIHtcbiAgICBmb3JtYXQgPSAoZm9ybWF0IHx8ICd4bGYnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ3htYic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhtYigpO1xuICAgICAgICBjYXNlICd4dGInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYdGIoKTtcbiAgICAgICAgY2FzZSAneGxpZmYnOlxuICAgICAgICBjYXNlICd4bGYnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYbGlmZigpO1xuICAgIH1cbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDT1JFID0gYXNzZXRVcmwoJ2NvcmUnKTtcbnZhciBJZGVudGlmaWVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSWRlbnRpZmllcnMoKSB7XG4gICAgfVxuICAgIHJldHVybiBJZGVudGlmaWVycztcbn0oKSk7XG5JZGVudGlmaWVycy5BTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTID0ge1xuICAgIG5hbWU6ICdBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTJyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgcnVudGltZTogQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UU1xufTtcbklkZW50aWZpZXJzLkVsZW1lbnRSZWYgPSB7IG5hbWU6ICdFbGVtZW50UmVmJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiBFbGVtZW50UmVmIH07XG5JZGVudGlmaWVycy5OZ01vZHVsZVJlZiA9IHsgbmFtZTogJ05nTW9kdWxlUmVmJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiBOZ01vZHVsZVJlZiB9O1xuSWRlbnRpZmllcnMuVmlld0NvbnRhaW5lclJlZiA9IHsgbmFtZTogJ1ZpZXdDb250YWluZXJSZWYnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IFZpZXdDb250YWluZXJSZWYgfTtcbklkZW50aWZpZXJzLkNoYW5nZURldGVjdG9yUmVmID0geyBuYW1lOiAnQ2hhbmdlRGV0ZWN0b3JSZWYnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IENoYW5nZURldGVjdG9yUmVmIH07XG5JZGVudGlmaWVycy5RdWVyeUxpc3QgPSB7IG5hbWU6ICdRdWVyeUxpc3QnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IFF1ZXJ5TGlzdCB9O1xuSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYgPSB7IG5hbWU6ICdUZW1wbGF0ZVJlZicsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogVGVtcGxhdGVSZWYgfTtcbklkZW50aWZpZXJzLkNvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSB7XG4gICAgbmFtZTogJ8m1Q29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcicsXG4gICAgbW9kdWxlVXJsOiBDT1JFLFxuICAgIHJ1bnRpbWU6IMm1Q29kZWdlbkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlclxufTtcbklkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IHtcbiAgICBuYW1lOiAnQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyJyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgcnVudGltZTogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG59O1xuSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeSA9IHsgbmFtZTogJ0NvbXBvbmVudEZhY3RvcnknLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IENvbXBvbmVudEZhY3RvcnkgfTtcbklkZW50aWZpZXJzLkNvbXBvbmVudFJlZiA9IHsgbmFtZTogJ0NvbXBvbmVudFJlZicsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogQ29tcG9uZW50UmVmIH07XG5JZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkgPSB7IG5hbWU6ICdOZ01vZHVsZUZhY3RvcnknLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IE5nTW9kdWxlRmFjdG9yeSB9O1xuSWRlbnRpZmllcnMuTmdNb2R1bGVJbmplY3RvciA9IHtcbiAgICBuYW1lOiAnybVOZ01vZHVsZUluamVjdG9yJyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgcnVudGltZTogybVOZ01vZHVsZUluamVjdG9yLFxufTtcbklkZW50aWZpZXJzLlJlZ2lzdGVyTW9kdWxlRmFjdG9yeUZuID0ge1xuICAgIG5hbWU6ICfJtXJlZ2lzdGVyTW9kdWxlRmFjdG9yeScsXG4gICAgbW9kdWxlVXJsOiBDT1JFLFxuICAgIHJ1bnRpbWU6IMm1cmVnaXN0ZXJNb2R1bGVGYWN0b3J5LFxufTtcbklkZW50aWZpZXJzLkluamVjdG9yID0geyBuYW1lOiAnSW5qZWN0b3InLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IEluamVjdG9yIH07XG5JZGVudGlmaWVycy5WaWV3RW5jYXBzdWxhdGlvbiA9IHsgbmFtZTogJ1ZpZXdFbmNhcHN1bGF0aW9uJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiBWaWV3RW5jYXBzdWxhdGlvbiB9O1xuSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSB7XG4gICAgbmFtZTogJ0NoYW5nZURldGVjdGlvblN0cmF0ZWd5JyxcbiAgICBtb2R1bGVVcmw6IENPUkUsXG4gICAgcnVudGltZTogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lcbn07XG5JZGVudGlmaWVycy5TZWN1cml0eUNvbnRleHQgPSB7XG4gICAgbmFtZTogJ1NlY3VyaXR5Q29udGV4dCcsXG4gICAgbW9kdWxlVXJsOiBDT1JFLFxuICAgIHJ1bnRpbWU6IFNlY3VyaXR5Q29udGV4dCxcbn07XG5JZGVudGlmaWVycy5MT0NBTEVfSUQgPSB7IG5hbWU6ICdMT0NBTEVfSUQnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IExPQ0FMRV9JRCB9O1xuSWRlbnRpZmllcnMuVFJBTlNMQVRJT05TX0ZPUk1BVCA9IHsgbmFtZTogJ1RSQU5TTEFUSU9OU19GT1JNQVQnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IFRSQU5TTEFUSU9OU19GT1JNQVQgfTtcbklkZW50aWZpZXJzLmlubGluZUludGVycG9sYXRlID0geyBuYW1lOiAnybVpbmxpbmVJbnRlcnBvbGF0ZScsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVpbmxpbmVJbnRlcnBvbGF0ZSB9O1xuSWRlbnRpZmllcnMuaW50ZXJwb2xhdGUgPSB7IG5hbWU6ICfJtWludGVycG9sYXRlJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtWludGVycG9sYXRlIH07XG5JZGVudGlmaWVycy5FTVBUWV9BUlJBWSA9IHsgbmFtZTogJ8m1RU1QVFlfQVJSQVknLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1RU1QVFlfQVJSQVkgfTtcbklkZW50aWZpZXJzLkVNUFRZX01BUCA9IHsgbmFtZTogJ8m1RU1QVFlfTUFQJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtUVNUFRZX01BUCB9O1xuSWRlbnRpZmllcnMuUmVuZGVyZXIgPSB7IG5hbWU6ICdSZW5kZXJlcicsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogUmVuZGVyZXIgfTtcbklkZW50aWZpZXJzLnZpZXdEZWYgPSB7IG5hbWU6ICfJtXZpZCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybV2aWQgfTtcbklkZW50aWZpZXJzLmVsZW1lbnREZWYgPSB7IG5hbWU6ICfJtWVsZCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVlbGQgfTtcbklkZW50aWZpZXJzLmFuY2hvckRlZiA9IHsgbmFtZTogJ8m1YW5kJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtWFuZCB9O1xuSWRlbnRpZmllcnMudGV4dERlZiA9IHsgbmFtZTogJ8m1dGVkJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXRlZCB9O1xuSWRlbnRpZmllcnMuZGlyZWN0aXZlRGVmID0geyBuYW1lOiAnybVkaWQnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1ZGlkIH07XG5JZGVudGlmaWVycy5wcm92aWRlckRlZiA9IHsgbmFtZTogJ8m1cHJkJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXByZCB9O1xuSWRlbnRpZmllcnMucXVlcnlEZWYgPSB7IG5hbWU6ICfJtXF1ZCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVxdWQgfTtcbklkZW50aWZpZXJzLnB1cmVBcnJheURlZiA9IHsgbmFtZTogJ8m1cGFkJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXBhZCB9O1xuSWRlbnRpZmllcnMucHVyZU9iamVjdERlZiA9IHsgbmFtZTogJ8m1cG9kJywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXBvZCB9O1xuSWRlbnRpZmllcnMucHVyZVBpcGVEZWYgPSB7IG5hbWU6ICfJtXBwZCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVwcGQgfTtcbklkZW50aWZpZXJzLnBpcGVEZWYgPSB7IG5hbWU6ICfJtXBpZCcsIG1vZHVsZVVybDogQ09SRSwgcnVudGltZTogybVwaWQgfTtcbklkZW50aWZpZXJzLm5vZGVWYWx1ZSA9IHsgbmFtZTogJ8m1bm92JywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtW5vdiB9O1xuSWRlbnRpZmllcnMubmdDb250ZW50RGVmID0geyBuYW1lOiAnybVuY2QnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1bmNkIH07XG5JZGVudGlmaWVycy51bndyYXBWYWx1ZSA9IHsgbmFtZTogJ8m1dW52JywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtXVudiB9O1xuSWRlbnRpZmllcnMuY3JlYXRlUmVuZGVyZXJUeXBlMiA9IHsgbmFtZTogJ8m1Y3J0JywgbW9kdWxlVXJsOiBDT1JFLCBydW50aW1lOiDJtWNydCB9O1xuSWRlbnRpZmllcnMuUmVuZGVyZXJUeXBlMiA9IHtcbiAgICBuYW1lOiAnUmVuZGVyZXJUeXBlMicsXG4gICAgbW9kdWxlVXJsOiBDT1JFLFxuICAgIC8vIHR5cGUgb25seVxuICAgIHJ1bnRpbWU6IG51bGxcbn07XG5JZGVudGlmaWVycy5WaWV3RGVmaW5pdGlvbiA9IHtcbiAgICBuYW1lOiAnybVWaWV3RGVmaW5pdGlvbicsXG4gICAgbW9kdWxlVXJsOiBDT1JFLFxuICAgIC8vIHR5cGUgb25seVxuICAgIHJ1bnRpbWU6IG51bGxcbn07XG5JZGVudGlmaWVycy5jcmVhdGVDb21wb25lbnRGYWN0b3J5ID0geyBuYW1lOiAnybVjY2YnLCBtb2R1bGVVcmw6IENPUkUsIHJ1bnRpbWU6IMm1Y2NmIH07XG4vKipcbiAqIEBwYXJhbSB7P30gcGtnXG4gKiBAcGFyYW0gez89fSBwYXRoXG4gKiBAcGFyYW0gez89fSB0eXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhc3NldFVybChwa2csIHBhdGgsIHR5cGUpIHtcbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBudWxsOyB9XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gJ3NyYyc7IH1cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIkBhbmd1bGFyL1wiICsgcGtnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiQGFuZ3VsYXIvXCIgKyBwa2cgKyBcIi9cIiArIHR5cGUgKyBcIi9cIiArIHBhdGg7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IGlkZW50aWZpZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gaWRlbnRpZmllci5uYW1lO1xuICAgIHJldHVybiDJtXJlZmxlY3Rvci5yZXNvbHZlSWRlbnRpZmllcihuYW1lLCBpZGVudGlmaWVyLm1vZHVsZVVybCwgbnVsbCwgaWRlbnRpZmllci5ydW50aW1lKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBpZGVudGlmaWVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4geyByZWZlcmVuY2U6IHJlc29sdmVJZGVudGlmaWVyKGlkZW50aWZpZXIpIH07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaWRlbnRpZmllclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaWRlbnRpZmllclRva2VuKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4geyBpZGVudGlmaWVyOiBpZGVudGlmaWVyIH07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaWRlbnRpZmllclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSWRlbnRpZmllclRva2VuKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllclRva2VuKGNyZWF0ZUlkZW50aWZpZXIoaWRlbnRpZmllcikpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGVudW1UeXBlXG4gKiBAcGFyYW0gez99IG5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL2luZGV4L2NsZHItc3BlYy9wbHVyYWwtcnVsZXNcbnZhciBQTFVSQUxfQ0FTRVMgPSBbJ3plcm8nLCAnb25lJywgJ3R3bycsICdmZXcnLCAnbWFueScsICdvdGhlciddO1xuLyoqXG4gKiBFeHBhbmRzIHNwZWNpYWwgZm9ybXMgaW50byBlbGVtZW50cy5cbiAqXG4gKiBGb3IgZXhhbXBsZSxcbiAqXG4gKiBgYGBcbiAqIHsgbWVzc2FnZXMubGVuZ3RoLCBwbHVyYWwsXG4gKiAgID0wIHt6ZXJvfVxuICogICA9MSB7b25lfVxuICogICBvdGhlciB7bW9yZSB0aGFuIG9uZX1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIHdpbGwgYmUgZXhwYW5kZWQgaW50b1xuICpcbiAqIGBgYFxuICogPG5nLWNvbnRhaW5lciBbbmdQbHVyYWxdPVwibWVzc2FnZXMubGVuZ3RoXCI+XG4gKiAgIDxuZy10ZW1wbGF0ZSBuZ1BsdXJhbENhc2U9XCI9MFwiPnplcm88L25nLXRlbXBsYXRlPlxuICogICA8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwiPTFcIj5vbmU8L25nLXRlbXBsYXRlPlxuICogICA8bmctdGVtcGxhdGUgbmdQbHVyYWxDYXNlPVwib3RoZXJcIj5tb3JlIHRoYW4gb25lPC9uZy10ZW1wbGF0ZT5cbiAqIDwvbmctY29udGFpbmVyPlxuICogYGBgXG4gKiBAcGFyYW0gez99IG5vZGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBleHBhbmROb2Rlcyhub2Rlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cGFuZGVyID0gbmV3IF9FeHBhbmRlcigpO1xuICAgIHJldHVybiBuZXcgRXhwYW5zaW9uUmVzdWx0KHZpc2l0QWxsKGV4cGFuZGVyLCBub2RlcyksIGV4cGFuZGVyLmlzRXhwYW5kZWQsIGV4cGFuZGVyLmVycm9ycyk7XG59XG52YXIgRXhwYW5zaW9uUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVzXG4gICAgICogQHBhcmFtIHs/fSBleHBhbmRlZFxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwYW5zaW9uUmVzdWx0KG5vZGVzLCBleHBhbmRlZCwgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGV4cGFuZGVkO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgcmV0dXJuIEV4cGFuc2lvblJlc3VsdDtcbn0oKSk7XG52YXIgRXhwYW5zaW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHBhbnNpb25FcnJvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGVycm9yTXNnXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwYW5zaW9uRXJyb3Ioc3BhbiwgZXJyb3JNc2cpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNwYW4sIGVycm9yTXNnKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRXhwYW5zaW9uRXJyb3I7XG59KFBhcnNlRXJyb3IpKTtcbi8qKlxuICogRXhwYW5kIGV4cGFuc2lvbiBmb3JtcyAocGx1cmFsLCBzZWxlY3QpIHRvIGRpcmVjdGl2ZXNcbiAqXG4gKiBcXEBpbnRlcm5hbFxuICovXG52YXIgX0V4cGFuZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBfRXhwYW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaXNFeHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGVsZW1lbnQubmFtZSwgZWxlbWVudC5hdHRycywgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiksIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0V4cGFuZGVyLnByb3RvdHlwZS52aXNpdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGNvbnRleHQpIHsgcmV0dXJuIGF0dHJpYnV0ZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGNvbnRleHQpIHsgcmV0dXJuIHRleHQ7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiBjb21tZW50OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaWN1XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfRXhwYW5kZXIucHJvdG90eXBlLnZpc2l0RXhwYW5zaW9uID0gZnVuY3Rpb24gKGljdSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmlzRXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gaWN1LnR5cGUgPT0gJ3BsdXJhbCcgPyBfZXhwYW5kUGx1cmFsRm9ybShpY3UsIHRoaXMuZXJyb3JzKSA6XG4gICAgICAgICAgICBfZXhwYW5kRGVmYXVsdEZvcm0oaWN1LCB0aGlzLmVycm9ycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGljdUNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9FeHBhbmRlci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGJlIHJlYWNoZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBfRXhwYW5kZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGFzdFxuICogQHBhcmFtIHs/fSBlcnJvcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9leHBhbmRQbHVyYWxGb3JtKGFzdCwgZXJyb3JzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRyZW4gPSBhc3QuY2FzZXMubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChQTFVSQUxfQ0FTRVMuaW5kZXhPZihjLnZhbHVlKSA9PSAtMSAmJiAhYy52YWx1ZS5tYXRjaCgvXj1cXGQrJC8pKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChuZXcgRXhwYW5zaW9uRXJyb3IoYy52YWx1ZVNvdXJjZVNwYW4sIFwiUGx1cmFsIGNhc2VzIHNob3VsZCBiZSBcXFwiPTxudW1iZXI+XFxcIiBvciBvbmUgb2YgXCIgKyBQTFVSQUxfQ0FTRVMuam9pbihcIiwgXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwYW5zaW9uUmVzdWx0ID0gZXhwYW5kTm9kZXMoYy5leHByZXNzaW9uKTtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBleHBhbnNpb25SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KFwibmctdGVtcGxhdGVcIiwgW25ldyBBdHRyaWJ1dGUkMSgnbmdQbHVyYWxDYXNlJywgXCJcIiArIGMudmFsdWUsIGMudmFsdWVTb3VyY2VTcGFuKV0sIGV4cGFuc2lvblJlc3VsdC5ub2RlcywgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4sIGMuc291cmNlU3Bhbik7XG4gICAgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3dpdGNoQXR0ciA9IG5ldyBBdHRyaWJ1dGUkMSgnW25nUGx1cmFsXScsIGFzdC5zd2l0Y2hWYWx1ZSwgYXN0LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50KCduZy1jb250YWluZXInLCBbc3dpdGNoQXR0cl0sIGNoaWxkcmVuLCBhc3Quc291cmNlU3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zb3VyY2VTcGFuKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEBwYXJhbSB7P30gZXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZXhwYW5kRGVmYXVsdEZvcm0oYXN0LCBlcnJvcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IGFzdC5jYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwYW5zaW9uUmVzdWx0ID0gZXhwYW5kTm9kZXMoYy5leHByZXNzaW9uKTtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBleHBhbnNpb25SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgaWYgKGMudmFsdWUgPT09ICdvdGhlcicpIHtcbiAgICAgICAgICAgIC8vIG90aGVyIGlzIHRoZSBkZWZhdWx0IGNhc2Ugd2hlbiBubyB2YWx1ZXMgbWF0Y2hcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudChcIm5nLXRlbXBsYXRlXCIsIFtuZXcgQXR0cmlidXRlJDEoJ25nU3dpdGNoRGVmYXVsdCcsICcnLCBjLnZhbHVlU291cmNlU3BhbildLCBleHBhbnNpb25SZXN1bHQubm9kZXMsIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWxlbWVudChcIm5nLXRlbXBsYXRlXCIsIFtuZXcgQXR0cmlidXRlJDEoJ25nU3dpdGNoQ2FzZScsIFwiXCIgKyBjLnZhbHVlLCBjLnZhbHVlU291cmNlU3BhbildLCBleHBhbnNpb25SZXN1bHQubm9kZXMsIGMuc291cmNlU3BhbiwgYy5zb3VyY2VTcGFuLCBjLnNvdXJjZVNwYW4pO1xuICAgIH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN3aXRjaEF0dHIgPSBuZXcgQXR0cmlidXRlJDEoJ1tuZ1N3aXRjaF0nLCBhc3Quc3dpdGNoVmFsdWUsIGFzdC5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pO1xuICAgIHJldHVybiBuZXcgRWxlbWVudCgnbmctY29udGFpbmVyJywgW3N3aXRjaEF0dHJdLCBjaGlsZHJlbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUHJvdmlkZXJFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3ZpZGVyRXJyb3IsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvdmlkZXJFcnJvcihtZXNzYWdlLCBzcGFuKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJFcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xudmFyIFByb3ZpZGVyVmlld0NvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJvdmlkZXJWaWV3Q29udGV4dChjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMudmlld1F1ZXJpZXMgPSBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KTtcbiAgICAgICAgdGhpcy52aWV3UHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb21wb25lbnQudmlld1Byb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgaWYgKF90aGlzLnZpZXdQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnZpZXdQcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvdmlkZXJWaWV3Q29udGV4dDtcbn0oKSk7XG52YXIgUHJvdmlkZXJFbGVtZW50Q29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aWV3Q29udGV4dFxuICAgICAqIEBwYXJhbSB7P30gX3BhcmVudFxuICAgICAqIEBwYXJhbSB7P30gX2lzVmlld1Jvb3RcbiAgICAgKiBAcGFyYW0gez99IF9kaXJlY3RpdmVBc3RzXG4gICAgICogQHBhcmFtIHs/fSBhdHRyc1xuICAgICAqIEBwYXJhbSB7P30gcmVmc1xuICAgICAqIEBwYXJhbSB7P30gaXNUZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFF1ZXJ5U3RhcnRJZFxuICAgICAqIEBwYXJhbSB7P30gX3NvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcm92aWRlckVsZW1lbnRDb250ZXh0KHZpZXdDb250ZXh0LCBfcGFyZW50LCBfaXNWaWV3Um9vdCwgX2RpcmVjdGl2ZUFzdHMsIGF0dHJzLCByZWZzLCBpc1RlbXBsYXRlLCBjb250ZW50UXVlcnlTdGFydElkLCBfc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnZpZXdDb250ZXh0ID0gdmlld0NvbnRleHQ7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgICAgIHRoaXMuX2lzVmlld1Jvb3QgPSBfaXNWaWV3Um9vdDtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlQXN0cyA9IF9kaXJlY3RpdmVBc3RzO1xuICAgICAgICB0aGlzLl9zb3VyY2VTcGFuID0gX3NvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3F1ZXJpZWRUb2tlbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dHJzID0ge307XG4gICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJBc3QpIHsgcmV0dXJuIF90aGlzLl9hdHRyc1thdHRyQXN0Lm5hbWVdID0gYXR0ckFzdC52YWx1ZTsgfSk7XG4gICAgICAgIHZhciBkaXJlY3RpdmVzTWV0YSA9IF9kaXJlY3RpdmVBc3RzLm1hcChmdW5jdGlvbiAoZGlyZWN0aXZlQXN0KSB7IHJldHVybiBkaXJlY3RpdmVBc3QuZGlyZWN0aXZlOyB9KTtcbiAgICAgICAgdGhpcy5fYWxsUHJvdmlkZXJzID1cbiAgICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzRnJvbURpcmVjdGl2ZXMoZGlyZWN0aXZlc01ldGEsIF9zb3VyY2VTcGFuLCB2aWV3Q29udGV4dC5lcnJvcnMpO1xuICAgICAgICB0aGlzLl9jb250ZW50UXVlcmllcyA9IF9nZXRDb250ZW50UXVlcmllcyhjb250ZW50UXVlcnlTdGFydElkLCBkaXJlY3RpdmVzTWV0YSk7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5fYWxsUHJvdmlkZXJzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgX3RoaXMuX2FkZFF1ZXJ5UmVhZHNUbyhwcm92aWRlci50b2tlbiwgcHJvdmlkZXIudG9rZW4sIF90aGlzLl9xdWVyaWVkVG9rZW5zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1RlbXBsYXRlKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVSZWZJZCA9IGNyZWF0ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZik7XG4gICAgICAgICAgICB0aGlzLl9hZGRRdWVyeVJlYWRzVG8odGVtcGxhdGVSZWZJZCwgdGVtcGxhdGVSZWZJZCwgdGhpcy5fcXVlcmllZFRva2Vucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWZBc3QpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0UXVlcnlWYWx1ZSA9IHJlZkFzdC52YWx1ZSB8fCBjcmVhdGVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuRWxlbWVudFJlZik7XG4gICAgICAgICAgICBfdGhpcy5fYWRkUXVlcnlSZWFkc1RvKHsgdmFsdWU6IHJlZkFzdC5uYW1lIH0sIGRlZmF1bHRRdWVyeVZhbHVlLCBfdGhpcy5fcXVlcmllZFRva2Vucyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fcXVlcmllZFRva2Vucy5nZXQocmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVmlld0NvbnRhaW5lclJlZikpKSB7XG4gICAgICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgdGhlIHByb3ZpZGVycyB0aGF0IHdlIGtub3cgYXJlIGVhZ2VyIGZpcnN0XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5fYWxsUHJvdmlkZXJzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIGVhZ2VyID0gcHJvdmlkZXIuZWFnZXIgfHwgX3RoaXMuX3F1ZXJpZWRUb2tlbnMuZ2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSk7XG4gICAgICAgICAgICBpZiAoZWFnZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyKHByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgcHJvdmlkZXIudG9rZW4sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5hZnRlckVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGNvbGxlY3QgbGF6eSBwcm92aWRlcnNcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9hbGxQcm92aWRlcnMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBfdGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyKHByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgcHJvdmlkZXIudG9rZW4sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwidHJhbnNmb3JtUHJvdmlkZXJzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLnZhbHVlcygpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLCBcInRyYW5zZm9ybWVkRGlyZWN0aXZlQXN0c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3J0ZWRQcm92aWRlclR5cGVzID0gdGhpcy50cmFuc2Zvcm1Qcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlcikgeyByZXR1cm4gcHJvdmlkZXIudG9rZW4uaWRlbnRpZmllcjsgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3J0ZWREaXJlY3RpdmVzID0gdGhpcy5fZGlyZWN0aXZlQXN0cy5zbGljZSgpO1xuICAgICAgICAgICAgc29ydGVkRGlyZWN0aXZlcy5zb3J0KGZ1bmN0aW9uIChkaXIxLCBkaXIyKSB7IHJldHVybiBzb3J0ZWRQcm92aWRlclR5cGVzLmluZGV4T2YoZGlyMS5kaXJlY3RpdmUudHlwZSkgLVxuICAgICAgICAgICAgICAgIHNvcnRlZFByb3ZpZGVyVHlwZXMuaW5kZXhPZihkaXIyLmRpcmVjdGl2ZS50eXBlKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gc29ydGVkRGlyZWN0aXZlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLCBcInRyYW5zZm9ybWVkSGFzVmlld0NvbnRhaW5lclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9oYXNWaWV3Q29udGFpbmVyOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUsIFwicXVlcnlNYXRjaGVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbE1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXJpZWRUb2tlbnMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2hlcykgeyBhbGxNYXRjaGVzLnB1c2guYXBwbHkoYWxsTWF0Y2hlcywgbWF0Y2hlcyk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFsbE1hdGNoZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcGFyYW0gez99IGRlZmF1bHRWYWx1ZVxuICAgICAqIEBwYXJhbSB7P30gcXVlcnlSZWFkVG9rZW5zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fYWRkUXVlcnlSZWFkc1RvID0gZnVuY3Rpb24gKHRva2VuLCBkZWZhdWx0VmFsdWUsIHF1ZXJ5UmVhZFRva2Vucykge1xuICAgICAgICB0aGlzLl9nZXRRdWVyaWVzRm9yKHRva2VuKS5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlWYWx1ZSA9IHF1ZXJ5Lm1ldGEucmVhZCB8fCBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlblJlZiA9IHRva2VuUmVmZXJlbmNlKHF1ZXJ5VmFsdWUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlNYXRjaGVzID0gcXVlcnlSZWFkVG9rZW5zLmdldCh0b2tlblJlZik7XG4gICAgICAgICAgICBpZiAoIXF1ZXJ5TWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHF1ZXJ5UmVhZFRva2Vucy5zZXQodG9rZW5SZWYsIHF1ZXJ5TWF0Y2hlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWVyeU1hdGNoZXMucHVzaCh7IHF1ZXJ5SWQ6IHF1ZXJ5LnF1ZXJ5SWQsIHZhbHVlOiBxdWVyeVZhbHVlIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9nZXRRdWVyaWVzRm9yID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50RWwgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXN0YW5jZSA9IDA7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZXM7XG4gICAgICAgIHdoaWxlIChjdXJyZW50RWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXJpZXMgPSBjdXJyZW50RWwuX2NvbnRlbnRRdWVyaWVzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICAgICAgaWYgKHF1ZXJpZXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHF1ZXJpZXMuZmlsdGVyKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gcXVlcnkubWV0YS5kZXNjZW5kYW50cyB8fCBkaXN0YW5jZSA8PSAxOyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudEVsLl9kaXJlY3RpdmVBc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEVsID0gY3VycmVudEVsLl9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcXVlcmllcyA9IHRoaXMudmlld0NvbnRleHQudmlld1F1ZXJpZXMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmIChxdWVyaWVzKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHF1ZXJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RpbmdQcm92aWRlclR5cGVcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHBhcmFtIHs/fSBlYWdlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUHJvdmlkZXJFbGVtZW50Q29udGV4dC5wcm90b3R5cGUuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlciA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCB0b2tlbiwgZWFnZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRQcm92aWRlciA9IHRoaXMuX2FsbFByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKTtcbiAgICAgICAgaWYgKCFyZXNvbHZlZFByb3ZpZGVyIHx8ICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UpICYmXG4gICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlKSB8fFxuICAgICAgICAgICAgKChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuUHJpdmF0ZVNlcnZpY2UgfHxcbiAgICAgICAgICAgICAgICByZXF1ZXN0aW5nUHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuUHVibGljU2VydmljZSkgJiZcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkJ1aWx0aW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID0gdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuZ2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2VlblByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5ISBcIiArIHRva2VuTmFtZSh0b2tlbiksIHRoaXMuX3NvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlZW5Qcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgdHJ1ZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkUHJvdmlkZXJzID0gcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRVc2VWYWx1ZSA9IHByb3ZpZGVyLnVzZVZhbHVlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IHByb3ZpZGVyLnVzZUV4aXN0aW5nO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWREZXBzO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLnVzZUV4aXN0aW5nICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleGlzdGluZ0RpRGVwID0gX3RoaXMuX2dldERlcGVuZGVuY3kocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUsIHsgdG9rZW46IHByb3ZpZGVyLnVzZUV4aXN0aW5nIH0sIGVhZ2VyKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdEaURlcC50b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBleGlzdGluZ0RpRGVwLnRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlVmFsdWUgPSBleGlzdGluZ0RpRGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERlcHMgPVxuICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShyZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VDbGFzcy5kaURlcHM7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWREZXBzID1cbiAgICAgICAgICAgICAgICAgICAgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gX3RoaXMuX2dldERlcGVuZGVuY3kocmVzb2x2ZWRQcm92aWRlci5wcm92aWRlclR5cGUsIGRlcCwgZWFnZXIpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdHJhbnNmb3JtUHJvdmlkZXIocHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogdHJhbnNmb3JtZWRVc2VFeGlzdGluZyxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogdHJhbnNmb3JtZWRVc2VWYWx1ZSxcbiAgICAgICAgICAgICAgICBkZXBzOiB0cmFuc2Zvcm1lZERlcHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNmb3JtZWRQcm92aWRlckFzdCA9XG4gICAgICAgICAgICBfdHJhbnNmb3JtUHJvdmlkZXJBc3QocmVzb2x2ZWRQcm92aWRlciwgeyBlYWdlcjogZWFnZXIsIHByb3ZpZGVyczogdHJhbnNmb3JtZWRQcm92aWRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzLnNldCh0b2tlblJlZmVyZW5jZSh0b2tlbiksIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QpO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRQcm92aWRlckFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdGluZ1Byb3ZpZGVyVHlwZVxuICAgICAqIEBwYXJhbSB7P30gZGVwXG4gICAgICogQHBhcmFtIHs/PX0gZWFnZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFByb3ZpZGVyRWxlbWVudENvbnRleHQucHJvdG90eXBlLl9nZXRMb2NhbERlcGVuZGVuY3kgPSBmdW5jdGlvbiAocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcikge1xuICAgICAgICBpZiAoZWFnZXIgPT09IHZvaWQgMCkgeyBlYWdlciA9IG51bGw7IH1cbiAgICAgICAgaWYgKGRlcC5pc0F0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0clZhbHVlID0gdGhpcy5fYXR0cnNbZGVwLnRva2VuLnZhbHVlXTtcbiAgICAgICAgICAgIHJldHVybiB7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBhdHRyVmFsdWUgPT0gbnVsbCA/IG51bGwgOiBhdHRyVmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGFjY2VzcyBidWlsdGludHNcbiAgICAgICAgICAgIGlmICgocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3RpbmdQcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLlJlbmRlcmVyKSB8fFxuICAgICAgICAgICAgICAgICAgICB0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5FbGVtZW50UmVmKSB8fFxuICAgICAgICAgICAgICAgICAgICB0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5DaGFuZ2VEZXRlY3RvclJlZikgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNWaWV3Q29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhY2Nlc3MgdGhlIGluamVjdG9yXG4gICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuSW5qZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFjY2VzcyBwcm92aWRlcnNcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRPckNyZWF0ZUxvY2FsUHJvdmlkZXIocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLnRva2VuLCBlYWdlcikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RpbmdQcm92aWRlclR5cGVcbiAgICAgKiBAcGFyYW0gez99IGRlcFxuICAgICAqIEBwYXJhbSB7Pz19IGVhZ2VyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQcm92aWRlckVsZW1lbnRDb250ZXh0LnByb3RvdHlwZS5fZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZXF1ZXN0aW5nUHJvdmlkZXJUeXBlLCBkZXAsIGVhZ2VyKSB7XG4gICAgICAgIGlmIChlYWdlciA9PT0gdm9pZCAwKSB7IGVhZ2VyID0gbnVsbDsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyRWxlbWVudCA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJFYWdlciA9IGVhZ2VyO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAoIWRlcC5pc1NraXBTZWxmKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRMb2NhbERlcGVuZGVuY3kocmVxdWVzdGluZ1Byb3ZpZGVyVHlwZSwgZGVwLCBlYWdlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcC5pc1NlbGYpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0ICYmIGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geyBpc1ZhbHVlOiB0cnVlLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gY2hlY2sgcGFyZW50IGVsZW1lbnRzXG4gICAgICAgICAgICB3aGlsZSAoIXJlc3VsdCAmJiBjdXJyRWxlbWVudC5fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldkVsZW1lbnQgPSBjdXJyRWxlbWVudDtcbiAgICAgICAgICAgICAgICBjdXJyRWxlbWVudCA9IGN1cnJFbGVtZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZFbGVtZW50Ll9pc1ZpZXdSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJFYWdlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjdXJyRWxlbWVudC5fZ2V0TG9jYWxEZXBlbmRlbmN5KFByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBkZXAsIGN1cnJFYWdlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBASG9zdCByZXN0cmljdGlvblxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlcC5pc0hvc3QgfHwgdGhpcy52aWV3Q29udGV4dC5jb21wb25lbnQuaXNIb3N0IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQuY29tcG9uZW50LnR5cGUucmVmZXJlbmNlID09PSB0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld0NvbnRleHQudmlld1Byb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZXAuaXNPcHRpb25hbCA/IHJlc3VsdCA9IHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IG51bGwgfSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDb250ZXh0LmVycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiTm8gcHJvdmlkZXIgZm9yIFwiICsgdG9rZW5OYW1lKGRlcC50b2tlbiksIHRoaXMuX3NvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFByb3ZpZGVyRWxlbWVudENvbnRleHQ7XG59KCkpO1xudmFyIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZVxuICAgICAqIEBwYXJhbSB7P30gZXh0cmFQcm92aWRlcnNcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXIobmdNb2R1bGUsIGV4dHJhUHJvdmlkZXJzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zZWVuUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fYWxsUHJvdmlkZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobmdNb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICB2YXIgbmdNb2R1bGVQcm92aWRlciA9IHsgdG9rZW46IHsgaWRlbnRpZmllcjogbmdNb2R1bGVUeXBlIH0sIHVzZUNsYXNzOiBuZ01vZHVsZVR5cGUgfTtcbiAgICAgICAgICAgIF9yZXNvbHZlUHJvdmlkZXJzKFtuZ01vZHVsZVByb3ZpZGVyXSwgUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIHRydWUsIHNvdXJjZVNwYW4sIF90aGlzLl9lcnJvcnMsIF90aGlzLl9hbGxQcm92aWRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMobmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5wcm92aWRlcnMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnkucHJvdmlkZXI7IH0pLmNvbmNhdChleHRyYVByb3ZpZGVycyksIFByb3ZpZGVyQXN0VHlwZS5QdWJsaWNTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGhpcy5fZXJyb3JzLCB0aGlzLl9hbGxQcm92aWRlcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5fYWxsUHJvdmlkZXJzLnZhbHVlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICAgICAgX3RoaXMuX2dldE9yQ3JlYXRlTG9jYWxQcm92aWRlcihwcm92aWRlci50b2tlbiwgcHJvdmlkZXIuZWFnZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvclN0cmluZyA9IHRoaXMuX2Vycm9ycy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIHBhcnNlIGVycm9yczpcXG5cIiArIGVycm9yU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy52YWx1ZXMoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRva2VuXG4gICAgICogQHBhcmFtIHs/fSBlYWdlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyID0gZnVuY3Rpb24gKHRva2VuLCBlYWdlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFByb3ZpZGVyID0gdGhpcy5fYWxsUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QgPSB0aGlzLl90cmFuc2Zvcm1lZFByb3ZpZGVycy5nZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkUHJvdmlkZXJBc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zZWVuUHJvdmlkZXJzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBQcm92aWRlckVycm9yKFwiQ2Fubm90IGluc3RhbnRpYXRlIGN5Y2xpYyBkZXBlbmRlbmN5ISBcIiArIHRva2VuTmFtZSh0b2tlbiksIHJlc29sdmVkUHJvdmlkZXIuc291cmNlU3BhbikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VlblByb3ZpZGVycy5zZXQodG9rZW5SZWZlcmVuY2UodG9rZW4pLCB0cnVlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHJhbnNmb3JtZWRQcm92aWRlcnMgPSByZXNvbHZlZFByb3ZpZGVyLnByb3ZpZGVycy5tYXAoZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZFVzZVZhbHVlID0gcHJvdmlkZXIudXNlVmFsdWU7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nID0gcHJvdmlkZXIudXNlRXhpc3Rpbmc7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZERlcHM7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXIudXNlRXhpc3RpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4aXN0aW5nRGlEZXAgPSBfdGhpcy5fZ2V0RGVwZW5kZW5jeSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9LCBlYWdlciwgcmVzb2x2ZWRQcm92aWRlci5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdEaURlcC50b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlRXhpc3RpbmcgPSBleGlzdGluZ0RpRGVwLnRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRVc2VFeGlzdGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkVXNlVmFsdWUgPSBleGlzdGluZ0RpRGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZERlcHMgPVxuICAgICAgICAgICAgICAgICAgICBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShkZXAsIGVhZ2VyLCByZXNvbHZlZFByb3ZpZGVyLnNvdXJjZVNwYW4pOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnVzZUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwcyA9IHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlQ2xhc3MuZGlEZXBzO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkRGVwcyA9XG4gICAgICAgICAgICAgICAgICAgIGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KGRlcCwgZWFnZXIsIHJlc29sdmVkUHJvdmlkZXIuc291cmNlU3Bhbik7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90cmFuc2Zvcm1Qcm92aWRlcihwcm92aWRlciwge1xuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiB0cmFuc2Zvcm1lZFVzZUV4aXN0aW5nLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0cmFuc2Zvcm1lZFVzZVZhbHVlLFxuICAgICAgICAgICAgICAgIGRlcHM6IHRyYW5zZm9ybWVkRGVwc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0ID1cbiAgICAgICAgICAgIF90cmFuc2Zvcm1Qcm92aWRlckFzdChyZXNvbHZlZFByb3ZpZGVyLCB7IGVhZ2VyOiBlYWdlciwgcHJvdmlkZXJzOiB0cmFuc2Zvcm1lZFByb3ZpZGVycyB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQcm92aWRlcnMuc2V0KHRva2VuUmVmZXJlbmNlKHRva2VuKSwgdHJhbnNmb3JtZWRQcm92aWRlckFzdCk7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFByb3ZpZGVyQXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZXBcbiAgICAgKiBAcGFyYW0gez89fSBlYWdlclxuICAgICAqIEBwYXJhbSB7Pz19IHJlcXVlc3RvclNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlUHJvdmlkZXJBbmFseXplci5wcm90b3R5cGUuX2dldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoZGVwLCBlYWdlciwgcmVxdWVzdG9yU291cmNlU3Bhbikge1xuICAgICAgICBpZiAoZWFnZXIgPT09IHZvaWQgMCkgeyBlYWdlciA9IG51bGw7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm91bmRMb2NhbCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWRlcC5pc1NraXBTZWxmICYmIGRlcC50b2tlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBhY2Nlc3MgdGhlIGluamVjdG9yXG4gICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuSW5qZWN0b3IpIHx8XG4gICAgICAgICAgICAgICAgdG9rZW5SZWZlcmVuY2UoZGVwLnRva2VuKSA9PT0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kTG9jYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZ2V0T3JDcmVhdGVMb2NhbFByb3ZpZGVyKGRlcC50b2tlbiwgZWFnZXIpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3VuZExvY2FsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBkZXA7XG4gICAgICAgIGlmIChkZXAuaXNTZWxmICYmICFmb3VuZExvY2FsKSB7XG4gICAgICAgICAgICBpZiAoZGVwLmlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7IGlzVmFsdWU6IHRydWUsIHZhbHVlOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIk5vIHByb3ZpZGVyIGZvciBcIiArIHRva2VuTmFtZShkZXAudG9rZW4pLCByZXF1ZXN0b3JTb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBOZ01vZHVsZVByb3ZpZGVyQW5hbHl6ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gKiBAcGFyYW0gez99IF9fMVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3RyYW5zZm9ybVByb3ZpZGVyKHByb3ZpZGVyLCBfYSkge1xuICAgIHZhciB1c2VFeGlzdGluZyA9IF9hLnVzZUV4aXN0aW5nLCB1c2VWYWx1ZSA9IF9hLnVzZVZhbHVlLCBkZXBzID0gX2EuZGVwcztcbiAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogcHJvdmlkZXIudG9rZW4sXG4gICAgICAgIHVzZUNsYXNzOiBwcm92aWRlci51c2VDbGFzcyxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IHVzZUV4aXN0aW5nLFxuICAgICAgICB1c2VGYWN0b3J5OiBwcm92aWRlci51c2VGYWN0b3J5LFxuICAgICAgICB1c2VWYWx1ZTogdXNlVmFsdWUsXG4gICAgICAgIGRlcHM6IGRlcHMsXG4gICAgICAgIG11bHRpOiBwcm92aWRlci5tdWx0aVxuICAgIH07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJcbiAqIEBwYXJhbSB7P30gX18xXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfdHJhbnNmb3JtUHJvdmlkZXJBc3QocHJvdmlkZXIsIF9hKSB7XG4gICAgdmFyIGVhZ2VyID0gX2EuZWFnZXIsIHByb3ZpZGVycyA9IF9hLnByb3ZpZGVycztcbiAgICByZXR1cm4gbmV3IFByb3ZpZGVyQXN0KHByb3ZpZGVyLnRva2VuLCBwcm92aWRlci5tdWx0aVByb3ZpZGVyLCBwcm92aWRlci5lYWdlciB8fCBlYWdlciwgcHJvdmlkZXJzLCBwcm92aWRlci5wcm92aWRlclR5cGUsIHByb3ZpZGVyLmxpZmVjeWNsZUhvb2tzLCBwcm92aWRlci5zb3VyY2VTcGFuKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAqIEBwYXJhbSB7P30gdGFyZ2V0RXJyb3JzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfcmVzb2x2ZVByb3ZpZGVyc0Zyb21EaXJlY3RpdmVzKGRpcmVjdGl2ZXMsIHNvdXJjZVNwYW4sIHRhcmdldEVycm9ycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyc0J5VG9rZW4gPSBuZXcgTWFwKCk7XG4gICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyUHJvdmlkZXIgPSB7IHRva2VuOiB7IGlkZW50aWZpZXI6IGRpcmVjdGl2ZS50eXBlIH0sIHVzZUNsYXNzOiBkaXJlY3RpdmUudHlwZSB9O1xuICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhbZGlyUHJvdmlkZXJdLCBkaXJlY3RpdmUuaXNDb21wb25lbnQgPyBQcm92aWRlckFzdFR5cGUuQ29tcG9uZW50IDogUHJvdmlkZXJBc3RUeXBlLkRpcmVjdGl2ZSwgdHJ1ZSwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCBwcm92aWRlcnNCeVRva2VuKTtcbiAgICB9KTtcbiAgICAvLyBOb3RlOiBkaXJlY3RpdmVzIG5lZWQgdG8gYmUgYWJsZSB0byBvdmVyd3JpdGUgcHJvdmlkZXJzIG9mIGEgY29tcG9uZW50IVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpcmVjdGl2ZXNXaXRoQ29tcG9uZW50Rmlyc3QgPSBkaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAoZGlyKSB7IHJldHVybiBkaXIuaXNDb21wb25lbnQ7IH0pLmNvbmNhdChkaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAhZGlyLmlzQ29tcG9uZW50OyB9KSk7XG4gICAgZGlyZWN0aXZlc1dpdGhDb21wb25lbnRGaXJzdC5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgX3Jlc29sdmVQcm92aWRlcnMoZGlyZWN0aXZlLnByb3ZpZGVycywgUHJvdmlkZXJBc3RUeXBlLlB1YmxpY1NlcnZpY2UsIGZhbHNlLCBzb3VyY2VTcGFuLCB0YXJnZXRFcnJvcnMsIHByb3ZpZGVyc0J5VG9rZW4pO1xuICAgICAgICBfcmVzb2x2ZVByb3ZpZGVycyhkaXJlY3RpdmUudmlld1Byb3ZpZGVycywgUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlLCBmYWxzZSwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCBwcm92aWRlcnNCeVRva2VuKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvdmlkZXJzQnlUb2tlbjtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwcm92aWRlcnNcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJUeXBlXG4gKiBAcGFyYW0gez99IGVhZ2VyXG4gKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAqIEBwYXJhbSB7P30gdGFyZ2V0RXJyb3JzXG4gKiBAcGFyYW0gez99IHRhcmdldFByb3ZpZGVyc0J5VG9rZW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9yZXNvbHZlUHJvdmlkZXJzKHByb3ZpZGVycywgcHJvdmlkZXJUeXBlLCBlYWdlciwgc291cmNlU3BhbiwgdGFyZ2V0RXJyb3JzLCB0YXJnZXRQcm92aWRlcnNCeVRva2VuKSB7XG4gICAgcHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkUHJvdmlkZXIgPSB0YXJnZXRQcm92aWRlcnNCeVRva2VuLmdldCh0b2tlblJlZmVyZW5jZShwcm92aWRlci50b2tlbikpO1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm92aWRlciAhPSBudWxsICYmICEhcmVzb2x2ZWRQcm92aWRlci5tdWx0aVByb3ZpZGVyICE9PSAhIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICB0YXJnZXRFcnJvcnMucHVzaChuZXcgUHJvdmlkZXJFcnJvcihcIk1peGluZyBtdWx0aSBhbmQgbm9uIG11bHRpIHByb3ZpZGVyIGlzIG5vdCBwb3NzaWJsZSBmb3IgdG9rZW4gXCIgKyB0b2tlbk5hbWUocmVzb2x2ZWRQcm92aWRlci50b2tlbiksIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc29sdmVkUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpZmVjeWNsZUhvb2tzID0gcHJvdmlkZXIudG9rZW4uaWRlbnRpZmllciAmJlxuICAgICAgICAgICAgICAgICgocHJvdmlkZXIudG9rZW4uaWRlbnRpZmllcikpLmxpZmVjeWNsZUhvb2tzID9cbiAgICAgICAgICAgICAgICAoKHByb3ZpZGVyLnRva2VuLmlkZW50aWZpZXIpKS5saWZlY3ljbGVIb29rcyA6XG4gICAgICAgICAgICAgICAgW107XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc1VzZVZhbHVlID0gIShwcm92aWRlci51c2VDbGFzcyB8fCBwcm92aWRlci51c2VFeGlzdGluZyB8fCBwcm92aWRlci51c2VGYWN0b3J5KTtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIgPSBuZXcgUHJvdmlkZXJBc3QocHJvdmlkZXIudG9rZW4sIHByb3ZpZGVyLm11bHRpLCBlYWdlciB8fCBpc1VzZVZhbHVlLCBbcHJvdmlkZXJdLCBwcm92aWRlclR5cGUsIGxpZmVjeWNsZUhvb2tzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRhcmdldFByb3ZpZGVyc0J5VG9rZW4uc2V0KHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyLnRva2VuKSwgcmVzb2x2ZWRQcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXByb3ZpZGVyLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlci5wcm92aWRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfZ2V0Vmlld1F1ZXJpZXMoY29tcG9uZW50KSB7XG4gICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdRdWVyeUlkID0gMTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICBpZiAoY29tcG9uZW50LnZpZXdRdWVyaWVzKSB7XG4gICAgICAgIGNvbXBvbmVudC52aWV3UXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gX2FkZFF1ZXJ5VG9Ub2tlbk1hcCh2aWV3UXVlcmllcywgeyBtZXRhOiBxdWVyeSwgcXVlcnlJZDogdmlld1F1ZXJ5SWQrKyB9KTsgfSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3UXVlcmllcztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb250ZW50UXVlcnlTdGFydElkXG4gKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9nZXRDb250ZW50UXVlcmllcyhjb250ZW50UXVlcnlTdGFydElkLCBkaXJlY3RpdmVzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGVudFF1ZXJ5SWQgPSBjb250ZW50UXVlcnlTdGFydElkO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnRRdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlLCBkaXJlY3RpdmVJbmRleCkge1xuICAgICAgICBpZiAoZGlyZWN0aXZlLnF1ZXJpZXMpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZS5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBfYWRkUXVlcnlUb1Rva2VuTWFwKGNvbnRlbnRRdWVyaWVzLCB7IG1ldGE6IHF1ZXJ5LCBxdWVyeUlkOiBjb250ZW50UXVlcnlJZCsrIH0pOyB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb250ZW50UXVlcmllcztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBtYXBcbiAqIEBwYXJhbSB7P30gcXVlcnlcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9hZGRRdWVyeVRvVG9rZW5NYXAobWFwLCBxdWVyeSkge1xuICAgIHF1ZXJ5Lm1ldGEuc2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5ID0gbWFwLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgICAgICBlbnRyeSA9IFtdO1xuICAgICAgICAgICAgbWFwLnNldCh0b2tlblJlZmVyZW5jZSh0b2tlbiksIGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5wdXNoKHF1ZXJ5KTtcbiAgICB9KTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBFbGVtZW50U2NoZW1hUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBwcm9wTmFtZVxuICAgICAqIEBwYXJhbSB7P30gc2NoZW1hTWV0YXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuaGFzUHJvcGVydHkgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcE5hbWUsIHNjaGVtYU1ldGFzKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSB0YWdOYW1lXG4gICAgICogQHBhcmFtIHs/fSBzY2hlbWFNZXRhc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5oYXNFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHNjaGVtYU1ldGFzKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcGFyYW0gez99IGlzQXR0cmlidXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnNlY3VyaXR5Q29udGV4dCA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSB7IH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmFsbEtub3duRWxlbWVudE5hbWVzID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0TWFwcGVkUHJvcE5hbWUgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0RGVmYXVsdENvbXBvbmVudEVsZW1lbnROYW1lID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS52YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUudmFsaWRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmFtZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUubm9ybWFsaXplQW5pbWF0aW9uU3R5bGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gY2FtZWxDYXNlUHJvcFxuICAgICAqIEBwYXJhbSB7P30gdXNlclByb3ZpZGVkUHJvcFxuICAgICAqIEBwYXJhbSB7P30gdmFsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLm5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlVmFsdWUgPSBmdW5jdGlvbiAoY2FtZWxDYXNlUHJvcCwgdXNlclByb3ZpZGVkUHJvcCwgdmFsKSB7IH07XG4gICAgcmV0dXJuIEVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU3R5bGVXaXRoSW1wb3J0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVVcmxzXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3R5bGVXaXRoSW1wb3J0cyhzdHlsZSQkMSwgc3R5bGVVcmxzKSB7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZSQkMTtcbiAgICAgICAgdGhpcy5zdHlsZVVybHMgPSBzdHlsZVVybHM7XG4gICAgfVxuICAgIHJldHVybiBTdHlsZVdpdGhJbXBvcnRzO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB1cmxcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzU3R5bGVVcmxSZXNvbHZhYmxlKHVybCkge1xuICAgIGlmICh1cmwgPT0gbnVsbCB8fCB1cmwubGVuZ3RoID09PSAwIHx8IHVybFswXSA9PSAnLycpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2hlbWVNYXRjaCA9IHVybC5tYXRjaChVUkxfV0lUSF9TQ0hFTUFfUkVHRVhQKTtcbiAgICByZXR1cm4gc2NoZW1lTWF0Y2ggPT09IG51bGwgfHwgc2NoZW1lTWF0Y2hbMV0gPT0gJ3BhY2thZ2UnIHx8IHNjaGVtZU1hdGNoWzFdID09ICdhc3NldCc7XG59XG4vKipcbiAqIFJld3JpdGVzIHN0eWxlc2hlZXRzIGJ5IHJlc29sdmluZyBhbmQgcmVtb3ZpbmcgdGhlIFxcQGltcG9ydCB1cmxzIHRoYXRcbiAqIGFyZSBlaXRoZXIgcmVsYXRpdmUgb3IgZG9uJ3QgaGF2ZSBhIGBwYWNrYWdlOmAgc2NoZW1lXG4gKiBAcGFyYW0gez99IHJlc29sdmVyXG4gKiBAcGFyYW0gez99IGJhc2VVcmxcbiAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFN0eWxlVXJscyhyZXNvbHZlciwgYmFzZVVybCwgY3NzVGV4dCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZvdW5kVXJscyA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZGlmaWVkQ3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShDU1NfQ09NTUVOVF9SRUdFWFAsICcnKS5yZXBsYWNlKENTU19JTVBPUlRfUkVHRVhQLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXJsID0gbVsxXSB8fCBtWzJdO1xuICAgICAgICBpZiAoIWlzU3R5bGVVcmxSZXNvbHZhYmxlKHVybCkpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBhdHRlbXB0IHRvIHJlc29sdmUgbm9uLXBhY2thZ2UgYWJzb2x1dGUgVVJMcyB3aXRoIFVSSSBzY2hlbWVcbiAgICAgICAgICAgIHJldHVybiBtWzBdO1xuICAgICAgICB9XG4gICAgICAgIGZvdW5kVXJscy5wdXNoKHJlc29sdmVyLnJlc29sdmUoYmFzZVVybCwgdXJsKSk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFN0eWxlV2l0aEltcG9ydHMobW9kaWZpZWRDc3NUZXh0LCBmb3VuZFVybHMpO1xufVxudmFyIENTU19JTVBPUlRfUkVHRVhQID0gL0BpbXBvcnRcXHMrKD86dXJsXFwoKT9cXHMqKD86KD86WydcIl0oW14nXCJdKikpfChbXjtcXClcXHNdKikpW147XSo7Py9nO1xudmFyIENTU19DT01NRU5UX1JFR0VYUCA9IC9cXC9cXCouKz9cXCpcXC8vZztcbnZhciBVUkxfV0lUSF9TQ0hFTUFfUkVHRVhQID0gL14oW146Lz8jXSspOi87XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SID0gJy4nO1xudmFyIEFUVFJJQlVURV9QUkVGSVggPSAnYXR0cic7XG52YXIgQ0xBU1NfUFJFRklYID0gJ2NsYXNzJztcbnZhciBTVFlMRV9QUkVGSVggPSAnc3R5bGUnO1xudmFyIEFOSU1BVEVfUFJPUF9QUkVGSVggPSAnYW5pbWF0ZS0nO1xudmFyIEJvdW5kUHJvcGVydHlUeXBlID0ge307XG5Cb3VuZFByb3BlcnR5VHlwZS5ERUZBVUxUID0gMDtcbkJvdW5kUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUiA9IDE7XG5Cb3VuZFByb3BlcnR5VHlwZS5BTklNQVRJT04gPSAyO1xuQm91bmRQcm9wZXJ0eVR5cGVbQm91bmRQcm9wZXJ0eVR5cGUuREVGQVVMVF0gPSBcIkRFRkFVTFRcIjtcbkJvdW5kUHJvcGVydHlUeXBlW0JvdW5kUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUl0gPSBcIkxJVEVSQUxfQVRUUlwiO1xuQm91bmRQcm9wZXJ0eVR5cGVbQm91bmRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OXSA9IFwiQU5JTUFUSU9OXCI7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBwYXJzZWQgcHJvcGVydHkuXG4gKi9cbnZhciBCb3VuZFByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCb3VuZFByb3BlcnR5KG5hbWUsIGV4cHJlc3Npb24sIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kUHJvcGVydHkucHJvdG90eXBlLCBcImlzTGl0ZXJhbFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnR5cGUgPT09IEJvdW5kUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJvdW5kUHJvcGVydHkucHJvdG90eXBlLCBcImlzQW5pbWF0aW9uXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudHlwZSA9PT0gQm91bmRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQm91bmRQcm9wZXJ0eTtcbn0oKSk7XG4vKipcbiAqIFBhcnNlcyBiaW5kaW5ncyBpbiB0ZW1wbGF0ZXMgYW5kIGluIHRoZSBkaXJlY3RpdmUgaG9zdCBhcmVhLlxuICovXG52YXIgQmluZGluZ1BhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZXhwclBhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX2ludGVycG9sYXRpb25Db25maWdcbiAgICAgKiBAcGFyYW0gez99IF9zY2hlbWFSZWdpc3RyeVxuICAgICAqIEBwYXJhbSB7P30gcGlwZXNcbiAgICAgKiBAcGFyYW0gez99IF90YXJnZXRFcnJvcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCaW5kaW5nUGFyc2VyKF9leHByUGFyc2VyLCBfaW50ZXJwb2xhdGlvbkNvbmZpZywgX3NjaGVtYVJlZ2lzdHJ5LCBwaXBlcywgX3RhcmdldEVycm9ycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9leHByUGFyc2VyID0gX2V4cHJQYXJzZXI7XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBfaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuX3RhcmdldEVycm9ycyA9IF90YXJnZXRFcnJvcnM7XG4gICAgICAgIHRoaXMucGlwZXNCeU5hbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3VzZWRQaXBlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgcGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gX3RoaXMucGlwZXNCeU5hbWUuc2V0KHBpcGUubmFtZSwgcGlwZSk7IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLmdldFVzZWRQaXBlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fdXNlZFBpcGVzLnZhbHVlcygpKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpck1ldGFcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuY3JlYXRlRGlyZWN0aXZlSG9zdFByb3BlcnR5QXN0cyA9IGZ1bmN0aW9uIChkaXJNZXRhLCBlbGVtZW50U2VsZWN0b3IsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRpck1ldGEuaG9zdFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvdW5kUHJvcHNfMSA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlyTWV0YS5ob3N0UHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByZXNzaW9uID0gZGlyTWV0YS5ob3N0UHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZVByb3BlcnR5QmluZGluZyhwcm9wTmFtZSwgZXhwcmVzc2lvbiwgdHJ1ZSwgc291cmNlU3BhbiwgW10sIGJvdW5kUHJvcHNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJWYWx1ZSBvZiB0aGUgaG9zdCBwcm9wZXJ0eSBiaW5kaW5nIFxcXCJcIiArIHByb3BOYW1lICsgXCJcXFwiIG5lZWRzIHRvIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBleHByZXNzaW9uIGJ1dCBnb3QgXFxcIlwiICsgZXhwcmVzc2lvbiArIFwiXFxcIiAoXCIgKyB0eXBlb2YgZXhwcmVzc2lvbiArIFwiKVwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBib3VuZFByb3BzXzEubWFwKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBfdGhpcy5jcmVhdGVFbGVtZW50UHJvcGVydHlBc3QoZWxlbWVudFNlbGVjdG9yLCBwcm9wKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyTWV0YVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyA9IGZ1bmN0aW9uIChkaXJNZXRhLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChkaXJNZXRhLmhvc3RMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRhcmdldEV2ZW50QXN0c18xID0gW107XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJNZXRhLmhvc3RMaXN0ZW5lcnMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcmVzc2lvbiA9IGRpck1ldGEuaG9zdExpc3RlbmVyc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZUV2ZW50KHByb3BOYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBbXSwgdGFyZ2V0RXZlbnRBc3RzXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiVmFsdWUgb2YgdGhlIGhvc3QgbGlzdGVuZXIgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgbmVlZHMgdG8gYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV4cHJlc3Npb24gYnV0IGdvdCBcXFwiXCIgKyBleHByZXNzaW9uICsgXCJcXFwiIChcIiArIHR5cGVvZiBleHByZXNzaW9uICsgXCIpXCIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldEV2ZW50QXN0c18xO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZUludGVycG9sYXRpb24gPSBmdW5jdGlvbiAodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlSW5mbyA9IHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VJbmZvLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChhc3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByZWZpeFRva2VuXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRWYXJzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyA9IGZ1bmN0aW9uIChwcmVmaXhUb2tlbiwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywgdGFyZ2V0VmFycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5ncyA9IHRoaXMuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyhwcmVmaXhUb2tlbiwgdmFsdWUsIHNvdXJjZVNwYW4pO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLmtleUlzVmFyKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VmFycy5wdXNoKG5ldyBWYXJpYWJsZUFzdChiaW5kaW5nLmtleSwgYmluZGluZy5uYW1lLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kaW5nLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KGJpbmRpbmcua2V5LCBiaW5kaW5nLmV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtiaW5kaW5nLmtleSwgJyddKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTGl0ZXJhbEF0dHIoYmluZGluZy5rZXksIG51bGwsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJlZml4VG9rZW5cbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VUZW1wbGF0ZUJpbmRpbmdzID0gZnVuY3Rpb24gKHByZWZpeFRva2VuLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmluZGluZ3NSZXN1bHQgPSB0aGlzLl9leHByUGFyc2VyLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyhwcmVmaXhUb2tlbiwgdmFsdWUsIHNvdXJjZUluZm8pO1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhiaW5kaW5nc1Jlc3VsdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hlY2tQaXBlcyhiaW5kaW5nLmV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQud2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAod2FybmluZykgeyBfdGhpcy5fcmVwb3J0RXJyb3Iod2FybmluZywgc291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLldBUk5JTkcpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5nc1Jlc3VsdC50ZW1wbGF0ZUJpbmRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldE1hdGNoYWJsZUF0dHJzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRQcm9wc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUucGFyc2VMaXRlcmFsQXR0ciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIGlmIChfaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJBc3NpZ25pbmcgYW5pbWF0aW9uIHRyaWdnZXJzIHZpYSBAcHJvcD1cXFwiZXhwXFxcIiBhdHRyaWJ1dGVzIHdpdGggYW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgVXNlIHByb3BlcnR5IGJpbmRpbmdzIChlLmcuIFtAcHJvcF09XFxcImV4cFxcXCIpIG9yIHVzZSBhbiBhdHRyaWJ1dGUgd2l0aG91dCBhIHZhbHVlIChlLmcuIEBwcm9wKSBpbnN0ZWFkLlwiLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb24obmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBCb3VuZFByb3BlcnR5KG5hbWUsIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUodmFsdWUsICcnKSwgQm91bmRQcm9wZXJ0eVR5cGUuTElURVJBTF9BVFRSLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gaXNIb3N0XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRNYXRjaGFibGVBdHRyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UHJvcHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlUHJvcGVydHlCaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIGlzSG9zdCwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzQW5pbWF0aW9uUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKEFOSU1BVEVfUFJPUF9QUkVGSVgpKSB7XG4gICAgICAgICAgICBpc0FuaW1hdGlvblByb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKEFOSU1BVEVfUFJPUF9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgaXNBbmltYXRpb25Qcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBbmltYXRpb25Qcm9wKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUFuaW1hdGlvbihuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChuYW1lLCB0aGlzLl9wYXJzZUJpbmRpbmcoZXhwcmVzc2lvbiwgaXNIb3N0LCBzb3VyY2VTcGFuKSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHIgPSB0aGlzLnBhcnNlSW50ZXJwb2xhdGlvbih2YWx1ZSwgc291cmNlU3Bhbik7XG4gICAgICAgIGlmIChleHByKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KG5hbWUsIGV4cHIsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFByb3BzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VQcm9wZXJ0eUFzdCA9IGZ1bmN0aW9uIChuYW1lLCBhc3QsIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IEJvdW5kUHJvcGVydHkobmFtZSwgYXN0LCBCb3VuZFByb3BlcnR5VHlwZS5ERUZBVUxULCBzb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldE1hdGNoYWJsZUF0dHJzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRQcm9wc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlQW5pbWF0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICAvLyBUaGlzIHdpbGwgb2NjdXIgd2hlbiBhIEB0cmlnZ2VyIGlzIG5vdCBwYWlyZWQgd2l0aCBhbiBleHByZXNzaW9uLlxuICAgICAgICAvLyBGb3IgYW5pbWF0aW9ucyBpdCBpcyB2YWxpZCB0byBub3QgaGF2ZSBhbiBleHByZXNzaW9uIHNpbmNlICovdm9pZFxuICAgICAgICAvLyBzdGF0ZXMgd2lsbCBiZSBhcHBsaWVkIGJ5IGFuZ3VsYXIgd2hlbiB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZC9kZXRhY2hlZFxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB0aGlzLl9wYXJzZUJpbmRpbmcoZXhwcmVzc2lvbiB8fCAnbnVsbCcsIGZhbHNlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgYXN0LnNvdXJjZV0pO1xuICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBCb3VuZFByb3BlcnR5KG5hbWUsIGFzdCwgQm91bmRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OLCBzb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBpc0hvc3RCaW5kaW5nXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VCaW5kaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBpc0hvc3RCaW5kaW5nLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSBpc0hvc3RCaW5kaW5nID9cbiAgICAgICAgICAgICAgICB0aGlzLl9leHByUGFyc2VyLnBhcnNlU2ltcGxlQmluZGluZyh2YWx1ZSwgc291cmNlSW5mbywgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykgOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V4cHJQYXJzZXIucGFyc2VCaW5kaW5nKHZhbHVlLCBzb3VyY2VJbmZvLCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChhc3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGlwZXMoYXN0LCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXCIgKyBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnRTZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gYm91bmRQcm9wXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50UHJvcGVydHlBc3QgPSBmdW5jdGlvbiAoZWxlbWVudFNlbGVjdG9yLCBib3VuZFByb3ApIHtcbiAgICAgICAgaWYgKGJvdW5kUHJvcC5pc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChib3VuZFByb3AubmFtZSwgUHJvcGVydHlCaW5kaW5nVHlwZS5BbmltYXRpb24sIFNlY3VyaXR5Q29udGV4dC5OT05FLCBib3VuZFByb3AuZXhwcmVzc2lvbiwgbnVsbCwgYm91bmRQcm9wLnNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXQgPSBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nVHlwZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm91bmRQcm9wZXJ0eU5hbWUgPSBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IGJvdW5kUHJvcC5uYW1lLnNwbGl0KFBST1BFUlRZX1BBUlRTX1NFUEFSQVRPUik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlY3VyaXR5Q29udGV4dHM7XG4gICAgICAgIC8vIENoZWNrIGNoZWNrIGZvciBzcGVjaWFsIGNhc2VzIChwcmVmaXggc3R5bGUsIGF0dHIsIGNsYXNzKVxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09IEFUVFJJQlVURV9QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUHJvcGVydHlPckF0dHJpYnV0ZU5hbWUoYm91bmRQcm9wZXJ0eU5hbWUsIGJvdW5kUHJvcC5zb3VyY2VTcGFuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyh0aGlzLl9zY2hlbWFSZWdpc3RyeSwgZWxlbWVudFNlbGVjdG9yLCBib3VuZFByb3BlcnR5TmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnNTZXBhcmF0b3JJZHggPSBib3VuZFByb3BlcnR5TmFtZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKG5zU2VwYXJhdG9ySWR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbnMgPSBib3VuZFByb3BlcnR5TmFtZS5zdWJzdHJpbmcoMCwgbnNTZXBhcmF0b3JJZHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gYm91bmRQcm9wZXJ0eU5hbWUuc3Vic3RyaW5nKG5zU2VwYXJhdG9ySWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gbWVyZ2VOc0FuZE5hbWUobnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IFByb3BlcnR5QmluZGluZ1R5cGUuQXR0cmlidXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydHNbMF0gPT0gQ0xBU1NfUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IFByb3BlcnR5QmluZGluZ1R5cGUuQ2xhc3M7XG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IFtTZWN1cml0eUNvbnRleHQuTk9ORV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBTVFlMRV9QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gcGFydHMubGVuZ3RoID4gMiA/IHBhcnRzWzJdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gUHJvcGVydHlCaW5kaW5nVHlwZS5TdHlsZTtcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gW1NlY3VyaXR5Q29udGV4dC5TVFlMRV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm90IGEgc3BlY2lhbCBjYXNlLCB1c2UgdGhlIGZ1bGwgcHJvcGVydHkgbmFtZVxuICAgICAgICBpZiAoYm91bmRQcm9wZXJ0eU5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuZ2V0TWFwcGVkUHJvcE5hbWUoYm91bmRQcm9wLm5hbWUpO1xuICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHModGhpcy5fc2NoZW1hUmVnaXN0cnksIGVsZW1lbnRTZWxlY3RvciwgYm91bmRQcm9wZXJ0eU5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gUHJvcGVydHlCaW5kaW5nVHlwZS5Qcm9wZXJ0eTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUHJvcGVydHlPckF0dHJpYnV0ZU5hbWUoYm91bmRQcm9wZXJ0eU5hbWUsIGJvdW5kUHJvcC5zb3VyY2VTcGFuLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZEVsZW1lbnRQcm9wZXJ0eUFzdChib3VuZFByb3BlcnR5TmFtZSwgYmluZGluZ1R5cGUsIHNlY3VyaXR5Q29udGV4dHNbMF0sIGJvdW5kUHJvcC5leHByZXNzaW9uLCB1bml0LCBib3VuZFByb3Auc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldE1hdGNoYWJsZUF0dHJzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRFdmVudHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLnBhcnNlRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xuICAgICAgICBpZiAoX2lzQW5pbWF0aW9uTGFiZWwobmFtZSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQW5pbWF0aW9uRXZlbnQobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlRXZlbnQobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0RXZlbnRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VBbmltYXRpb25FdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRFdmVudHMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlcyA9IHNwbGl0QXRQZXJpb2QobmFtZSwgW25hbWUsICcnXSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV2ZW50TmFtZSA9IG1hdGNoZXNbMF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBoYXNlID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAocGhhc2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGhhc2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX3BhcnNlQWN0aW9uKGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFdmVudHMucHVzaChuZXcgQm91bmRFdmVudEFzdChldmVudE5hbWUsIG51bGwsIHBoYXNlLCBhc3QsIHNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGUgcHJvdmlkZWQgYW5pbWF0aW9uIG91dHB1dCBwaGFzZSB2YWx1ZSBcXFwiXCIgKyBwaGFzZSArIFwiXFxcIiBmb3IgXFxcIkBcIiArIGV2ZW50TmFtZSArIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkICh1c2Ugc3RhcnQgb3IgZG9uZSlcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGUgYW5pbWF0aW9uIHRyaWdnZXIgb3V0cHV0IGV2ZW50IChAXCIgKyBldmVudE5hbWUgKyBcIikgaXMgbWlzc2luZyBpdHMgcGhhc2UgdmFsdWUgbmFtZSAoc3RhcnQgb3IgZG9uZSBhcmUgY3VycmVudGx5IHN1cHBvcnRlZClcIiwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldEV2ZW50c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1BhcnNlci5wcm90b3R5cGUuX3BhcnNlRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cykge1xuICAgICAgICAvLyBsb25nIGZvcm1hdDogJ3RhcmdldDogZXZlbnROYW1lJ1xuICAgICAgICB2YXIgX2EgPSBzcGxpdEF0Q29sb24obmFtZSwgW251bGwsIG5hbWVdKSwgdGFyZ2V0ID0gX2FbMF0sIGV2ZW50TmFtZSA9IF9hWzFdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3QgPSB0aGlzLl9wYXJzZUFjdGlvbihleHByZXNzaW9uLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgYXN0LnNvdXJjZV0pO1xuICAgICAgICB0YXJnZXRFdmVudHMucHVzaChuZXcgQm91bmRFdmVudEFzdChldmVudE5hbWUsIHRhcmdldCwgbnVsbCwgYXN0LCBzb3VyY2VTcGFuKSk7XG4gICAgICAgIC8vIERvbid0IGRldGVjdCBkaXJlY3RpdmVzIGZvciBldmVudCBuYW1lcyBmb3Igbm93LFxuICAgICAgICAvLyBzbyBkb24ndCBhZGQgdGhlIGV2ZW50IG5hbWUgdG8gdGhlIG1hdGNoYWJsZUF0dHJzXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fcGFyc2VBY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlSW5mbyA9IHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFzdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VBY3Rpb24odmFsdWUsIHNvdXJjZUluZm8sIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgaWYgKGFzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYXN0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFzdCB8fCBhc3QuYXN0IGluc3RhbmNlb2YgRW1wdHlFeHByKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJFbXB0eSBleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWRcIiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGVja1BpcGVzKGFzdCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlwiICsgZSwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/PX0gbGV2ZWxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBzb3VyY2VTcGFuLCBsZXZlbCkge1xuICAgICAgICBpZiAobGV2ZWwgPT09IHZvaWQgMCkgeyBsZXZlbCA9IFBhcnNlRXJyb3JMZXZlbC5FUlJPUjsgfVxuICAgICAgICB0aGlzLl90YXJnZXRFcnJvcnMucHVzaChuZXcgUGFyc2VFcnJvcihzb3VyY2VTcGFuLCBtZXNzYWdlLCBsZXZlbCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvcnNcbiAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJpbmRpbmdQYXJzZXIucHJvdG90eXBlLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzID0gZnVuY3Rpb24gKGVycm9ycywgc291cmNlU3Bhbikge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGVycm9yc18xID0gZXJyb3JzOyBfaSA8IGVycm9yc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gZXJyb3JzXzFbX2ldO1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZXJyb3IubWVzc2FnZSwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fY2hlY2tQaXBlcyA9IGZ1bmN0aW9uIChhc3QsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFzdCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29sbGVjdG9yID0gbmV3IFBpcGVDb2xsZWN0b3IoKTtcbiAgICAgICAgICAgIGFzdC52aXNpdChjb2xsZWN0b3IpO1xuICAgICAgICAgICAgY29sbGVjdG9yLnBpcGVzLmZvckVhY2goZnVuY3Rpb24gKGFzdCwgcGlwZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlTWV0YSA9IF90aGlzLnBpcGVzQnlOYW1lLmdldChwaXBlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwaXBlTWV0YSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGUgcGlwZSAnXCIgKyBwaXBlTmFtZSArIFwiJyBjb3VsZCBub3QgYmUgZm91bmRcIiwgbmV3IFBhcnNlU291cmNlU3Bhbihzb3VyY2VTcGFuLnN0YXJ0Lm1vdmVCeShhc3Quc3Bhbi5zdGFydCksIHNvdXJjZVNwYW4uc3RhcnQubW92ZUJ5KGFzdC5zcGFuLmVuZCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl91c2VkUGlwZXMuc2V0KHBpcGVOYW1lLCBwaXBlTWV0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWUgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IC8gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSBpc0F0dHIgdHJ1ZSB3aGVuIGJpbmRpbmcgdG8gYW4gYXR0cmlidXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nUGFyc2VyLnByb3RvdHlwZS5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc291cmNlU3BhbiwgaXNBdHRyKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcG9ydCA9IGlzQXR0ciA/IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LnZhbGlkYXRlQXR0cmlidXRlKHByb3BOYW1lKSA6XG4gICAgICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeS52YWxpZGF0ZVByb3BlcnR5KHByb3BOYW1lKTtcbiAgICAgICAgaWYgKHJlcG9ydC5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IocmVwb3J0Lm1zZywgc291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLkVSUk9SKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJpbmRpbmdQYXJzZXI7XG59KCkpO1xudmFyIFBpcGVDb2xsZWN0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQaXBlQ29sbGVjdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBpcGVDb2xsZWN0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBpcGVzID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBQaXBlQ29sbGVjdG9yLnByb3RvdHlwZS52aXNpdFBpcGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMucGlwZXMuc2V0KGFzdC5uYW1lLCBhc3QpO1xuICAgICAgICBhc3QuZXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gUGlwZUNvbGxlY3Rvcjtcbn0oUmVjdXJzaXZlQXN0VmlzaXRvcikpO1xuLyoqXG4gKiBAcGFyYW0gez99IG5hbWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9pc0FuaW1hdGlvbkxhYmVsKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZVswXSA9PSAnQCc7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcmVnaXN0cnlcbiAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAqIEBwYXJhbSB7P30gaXNBdHRyaWJ1dGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHMocmVnaXN0cnksIHNlbGVjdG9yLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdHhzID0gW107XG4gICAgQ3NzU2VsZWN0b3IucGFyc2Uoc2VsZWN0b3IpLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnROYW1lcyA9IHNlbGVjdG9yLmVsZW1lbnQgPyBbc2VsZWN0b3IuZWxlbWVudF0gOiByZWdpc3RyeS5hbGxLbm93bkVsZW1lbnROYW1lcygpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3RFbGVtZW50TmFtZXMgPSBuZXcgU2V0KHNlbGVjdG9yLm5vdFNlbGVjdG9ycy5maWx0ZXIoZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBzZWxlY3Rvci5pc0VsZW1lbnRTZWxlY3RvcigpOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIHNlbGVjdG9yLmVsZW1lbnQ7IH0pKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcG9zc2libGVFbGVtZW50TmFtZXMgPSBlbGVtZW50TmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50TmFtZSkgeyByZXR1cm4gIW5vdEVsZW1lbnROYW1lcy5oYXMoZWxlbWVudE5hbWUpOyB9KTtcbiAgICAgICAgY3R4cy5wdXNoLmFwcGx5KGN0eHMsIHBvc3NpYmxlRWxlbWVudE5hbWVzLm1hcChmdW5jdGlvbiAoZWxlbWVudE5hbWUpIHsgcmV0dXJuIHJlZ2lzdHJ5LnNlY3VyaXR5Q29udGV4dChlbGVtZW50TmFtZSwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKTsgfSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBjdHhzLmxlbmd0aCA9PT0gMCA/IFtTZWN1cml0eUNvbnRleHQuTk9ORV0gOiBBcnJheS5mcm9tKG5ldyBTZXQoY3R4cykpLnNvcnQoKTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBOR19DT05URU5UX1NFTEVDVF9BVFRSID0gJ3NlbGVjdCc7XG52YXIgTkdfQ09OVEVOVF9FTEVNRU5UID0gJ25nLWNvbnRlbnQnO1xudmFyIExJTktfRUxFTUVOVCA9ICdsaW5rJztcbnZhciBMSU5LX1NUWUxFX1JFTF9BVFRSID0gJ3JlbCc7XG52YXIgTElOS19TVFlMRV9IUkVGX0FUVFIgPSAnaHJlZic7XG52YXIgTElOS19TVFlMRV9SRUxfVkFMVUUgPSAnc3R5bGVzaGVldCc7XG52YXIgU1RZTEVfRUxFTUVOVCA9ICdzdHlsZSc7XG52YXIgU0NSSVBUX0VMRU1FTlQgPSAnc2NyaXB0JztcbnZhciBOR19OT05fQklOREFCTEVfQVRUUiA9ICduZ05vbkJpbmRhYmxlJztcbnZhciBOR19QUk9KRUNUX0FTID0gJ25nUHJvamVjdEFzJztcbi8qKlxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHByZXBhcnNlRWxlbWVudChhc3QpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RBdHRyID0gbnVsbDtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBocmVmQXR0ciA9IG51bGw7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVsQXR0ciA9IG51bGw7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9uQmluZGFibGUgPSBmYWxzZTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9qZWN0QXMgPSBudWxsO1xuICAgIGFzdC5hdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxjQXR0ck5hbWUgPSBhdHRyLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxjQXR0ck5hbWUgPT0gTkdfQ09OVEVOVF9TRUxFQ1RfQVRUUikge1xuICAgICAgICAgICAgc2VsZWN0QXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGNBdHRyTmFtZSA9PSBMSU5LX1NUWUxFX0hSRUZfQVRUUikge1xuICAgICAgICAgICAgaHJlZkF0dHIgPSBhdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxjQXR0ck5hbWUgPT0gTElOS19TVFlMRV9SRUxfQVRUUikge1xuICAgICAgICAgICAgcmVsQXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lID09IE5HX05PTl9CSU5EQUJMRV9BVFRSKSB7XG4gICAgICAgICAgICBub25CaW5kYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lID09IE5HX1BST0pFQ1RfQVMpIHtcbiAgICAgICAgICAgIGlmIChhdHRyLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0QXMgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgc2VsZWN0QXR0ciA9IG5vcm1hbGl6ZU5nQ29udGVudFNlbGVjdChzZWxlY3RBdHRyKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlTmFtZSA9IGFzdC5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk9USEVSO1xuICAgIGlmIChzcGxpdE5zTmFtZShub2RlTmFtZSlbMV0gPT0gTkdfQ09OVEVOVF9FTEVNRU5UKSB7XG4gICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBTVFlMRV9FTEVNRU5UKSB7XG4gICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gU0NSSVBUX0VMRU1FTlQpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVDtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gTElOS19FTEVNRU5UICYmIHJlbEF0dHIgPT0gTElOS19TVFlMRV9SRUxfVkFMVUUpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJlcGFyc2VkRWxlbWVudCh0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUsIHByb2plY3RBcyk7XG59XG52YXIgUHJlcGFyc2VkRWxlbWVudFR5cGUgPSB7fTtcblByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQgPSAwO1xuUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUgPSAxO1xuUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVCA9IDI7XG5QcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQgPSAzO1xuUHJlcGFyc2VkRWxlbWVudFR5cGUuT1RIRVIgPSA0O1xuUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVF0gPSBcIk5HX0NPTlRFTlRcIjtcblByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFXSA9IFwiU1RZTEVcIjtcblByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVRdID0gXCJTVFlMRVNIRUVUXCI7XG5QcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFRdID0gXCJTQ1JJUFRcIjtcblByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlLk9USEVSXSA9IFwiT1RIRVJcIjtcbnZhciBQcmVwYXJzZWRFbGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdEF0dHJcbiAgICAgKiBAcGFyYW0gez99IGhyZWZBdHRyXG4gICAgICogQHBhcmFtIHs/fSBub25CaW5kYWJsZVxuICAgICAqIEBwYXJhbSB7P30gcHJvamVjdEFzXG4gICAgICovXG4gICAgZnVuY3Rpb24gUHJlcGFyc2VkRWxlbWVudCh0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUsIHByb2plY3RBcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNlbGVjdEF0dHIgPSBzZWxlY3RBdHRyO1xuICAgICAgICB0aGlzLmhyZWZBdHRyID0gaHJlZkF0dHI7XG4gICAgICAgIHRoaXMubm9uQmluZGFibGUgPSBub25CaW5kYWJsZTtcbiAgICAgICAgdGhpcy5wcm9qZWN0QXMgPSBwcm9qZWN0QXM7XG4gICAgfVxuICAgIHJldHVybiBQcmVwYXJzZWRFbGVtZW50O1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBzZWxlY3RBdHRyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVOZ0NvbnRlbnRTZWxlY3Qoc2VsZWN0QXR0cikge1xuICAgIGlmIChzZWxlY3RBdHRyID09PSBudWxsIHx8IHNlbGVjdEF0dHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnKic7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RBdHRyO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEJJTkRfTkFNRV9SRUdFWFAgPSAvXig/Oig/Oig/OihiaW5kLSl8KGxldC0pfChyZWYtfCMpfChvbi0pfChiaW5kb24tKXwoQCkpKC4rKSl8XFxbXFwoKFteXFwpXSspXFwpXFxdfFxcWyhbXlxcXV0rKVxcXXxcXCgoW15cXCldKylcXCkpJC87XG4vLyBHcm91cCAxID0gXCJiaW5kLVwiXG52YXIgS1dfQklORF9JRFggPSAxO1xuLy8gR3JvdXAgMiA9IFwibGV0LVwiXG52YXIgS1dfTEVUX0lEWCA9IDI7XG4vLyBHcm91cCAzID0gXCJyZWYtLyNcIlxudmFyIEtXX1JFRl9JRFggPSAzO1xuLy8gR3JvdXAgNCA9IFwib24tXCJcbnZhciBLV19PTl9JRFggPSA0O1xuLy8gR3JvdXAgNSA9IFwiYmluZG9uLVwiXG52YXIgS1dfQklORE9OX0lEWCA9IDU7XG4vLyBHcm91cCA2ID0gXCJAXCJcbnZhciBLV19BVF9JRFggPSA2O1xuLy8gR3JvdXAgNyA9IHRoZSBpZGVudGlmaWVyIGFmdGVyIFwiYmluZC1cIiwgXCJsZXQtXCIsIFwicmVmLS8jXCIsIFwib24tXCIsIFwiYmluZG9uLVwiIG9yIFwiQFwiXG52YXIgSURFTlRfS1dfSURYID0gNztcbi8vIEdyb3VwIDggPSBpZGVudGlmaWVyIGluc2lkZSBbKCldXG52YXIgSURFTlRfQkFOQU5BX0JPWF9JRFggPSA4O1xuLy8gR3JvdXAgOSA9IGlkZW50aWZpZXIgaW5zaWRlIFtdXG52YXIgSURFTlRfUFJPUEVSVFlfSURYID0gOTtcbi8vIEdyb3VwIDEwID0gaWRlbnRpZmllciBpbnNpZGUgKClcbnZhciBJREVOVF9FVkVOVF9JRFggPSAxMDtcbnZhciBOR19URU1QTEFURV9FTEVNRU5UID0gJ25nLXRlbXBsYXRlJztcbi8vIGRlcHJlY2F0ZWQgaW4gNC54XG52YXIgVEVNUExBVEVfRUxFTUVOVCA9ICd0ZW1wbGF0ZSc7XG4vLyBkZXByZWNhdGVkIGluIDQueFxudmFyIFRFTVBMQVRFX0FUVFIgPSAndGVtcGxhdGUnO1xudmFyIFRFTVBMQVRFX0FUVFJfUFJFRklYID0gJyonO1xudmFyIENMQVNTX0FUVFIgPSAnY2xhc3MnO1xudmFyIFRFWFRfQ1NTX1NFTEVDVE9SID0gQ3NzU2VsZWN0b3IucGFyc2UoJyonKVswXTtcbnZhciBURU1QTEFURV9FTEVNRU5UX0RFUFJFQ0FUSU9OX1dBUk5JTkcgPSAnVGhlIDx0ZW1wbGF0ZT4gZWxlbWVudCBpcyBkZXByZWNhdGVkLiBVc2UgPG5nLXRlbXBsYXRlPiBpbnN0ZWFkJztcbnZhciBURU1QTEFURV9BVFRSX0RFUFJFQ0FUSU9OX1dBUk5JTkcgPSAnVGhlIHRlbXBsYXRlIGF0dHJpYnV0ZSBpcyBkZXByZWNhdGVkLiBVc2UgYW4gbmctdGVtcGxhdGUgZWxlbWVudCBpbnN0ZWFkLic7XG52YXIgd2FybmluZ0NvdW50cyA9IHt9O1xuLyoqXG4gKiBAcGFyYW0gez99IHdhcm5pbmdzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB3YXJuT25seU9uY2Uod2FybmluZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh3YXJuaW5ncy5pbmRleE9mKGVycm9yLm1zZykgIT09IC0xKSB7XG4gICAgICAgICAgICB3YXJuaW5nQ291bnRzW2Vycm9yLm1zZ10gPSAod2FybmluZ0NvdW50c1tlcnJvci5tc2ddIHx8IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiB3YXJuaW5nQ291bnRzW2Vycm9yLm1zZ10gPD0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG4gKiBQcm92aWRlcyBhbiBhcnJheSBvZiB7QGxpbmsgVGVtcGxhdGVBc3RWaXNpdG9yfXMgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHRyYW5zZm9ybVxuICogcGFyc2VkIHRlbXBsYXRlcyBiZWZvcmUgY29tcGlsYXRpb24gaXMgaW52b2tlZCwgYWxsb3dpbmcgY3VzdG9tIGV4cHJlc3Npb24gc3ludGF4XG4gKiBhbmQgb3RoZXIgYWR2YW5jZWQgdHJhbnNmb3JtYXRpb25zLlxuICpcbiAqIFRoaXMgaXMgY3VycmVudGx5IGFuIGludGVybmFsLW9ubHkgZmVhdHVyZSBhbmQgbm90IG1lYW50IGZvciBnZW5lcmFsIHVzZS5cbiAqL1xudmFyIFRFTVBMQVRFX1RSQU5TRk9STVMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ1RlbXBsYXRlVHJhbnNmb3JtcycpO1xudmFyIFRlbXBsYXRlUGFyc2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRlbXBsYXRlUGFyc2VFcnJvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gez99IHNwYW5cbiAgICAgKiBAcGFyYW0gez99IGxldmVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZUVycm9yKG1lc3NhZ2UsIHNwYW4sIGxldmVsKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBtZXNzYWdlLCBsZXZlbCkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VFcnJvcjtcbn0oUGFyc2VFcnJvcikpO1xudmFyIFRlbXBsYXRlUGFyc2VSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHRlbXBsYXRlQXN0XG4gICAgICogQHBhcmFtIHs/PX0gdXNlZFBpcGVzXG4gICAgICogQHBhcmFtIHs/PX0gZXJyb3JzXG4gICAgICovXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQYXJzZVJlc3VsdCh0ZW1wbGF0ZUFzdCwgdXNlZFBpcGVzLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUFzdCA9IHRlbXBsYXRlQXN0O1xuICAgICAgICB0aGlzLnVzZWRQaXBlcyA9IHVzZWRQaXBlcztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBUZW1wbGF0ZVBhcnNlUmVzdWx0O1xufSgpKTtcbnZhciBUZW1wbGF0ZVBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfY29uZmlnXG4gICAgICogQHBhcmFtIHs/fSBfZXhwclBhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX3NjaGVtYVJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIHs/fSBfaHRtbFBhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX2NvbnNvbGVcbiAgICAgKiBAcGFyYW0gez99IHRyYW5zZm9ybXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUZW1wbGF0ZVBhcnNlcihfY29uZmlnLCBfZXhwclBhcnNlciwgX3NjaGVtYVJlZ2lzdHJ5LCBfaHRtbFBhcnNlciwgX2NvbnNvbGUsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgdGhpcy5fZXhwclBhcnNlciA9IF9leHByUGFyc2VyO1xuICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtcyA9IHRyYW5zZm9ybXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gcGlwZXNcbiAgICAgKiBAcGFyYW0gez99IHNjaGVtYXNcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlVXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoY29tcG9uZW50LCB0ZW1wbGF0ZSwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMsIHRlbXBsYXRlVXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMudHJ5UGFyc2UoY29tcG9uZW50LCB0ZW1wbGF0ZSwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMsIHRlbXBsYXRlVXJsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd2FybmluZ3MgPSByZXN1bHQuZXJyb3JzLmZpbHRlcihmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGVycm9yLmxldmVsID09PSBQYXJzZUVycm9yTGV2ZWwuV0FSTklORzsgfSkuZmlsdGVyKHdhcm5Pbmx5T25jZShbXG4gICAgICAgICAgICBURU1QTEFURV9BVFRSX0RFUFJFQ0FUSU9OX1dBUk5JTkcsIFRFTVBMQVRFX0VMRU1FTlRfREVQUkVDQVRJT05fV0FSTklOR1xuICAgICAgICBdKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IHJlc3VsdC5lcnJvcnMuZmlsdGVyKGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZXJyb3IubGV2ZWwgPT09IFBhcnNlRXJyb3JMZXZlbC5FUlJPUjsgfSk7XG4gICAgICAgIGlmICh3YXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zb2xlLndhcm4oXCJUZW1wbGF0ZSBwYXJzZSB3YXJuaW5nczpcXG5cIiArIHdhcm5pbmdzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yU3RyaW5nID0gZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJUZW1wbGF0ZSBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvclN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdGVtcGxhdGU6IHJlc3VsdC50ZW1wbGF0ZUFzdCwgcGlwZXM6IHJlc3VsdC51c2VkUGlwZXMgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gcGlwZXNcbiAgICAgKiBAcGFyYW0gez99IHNjaGVtYXNcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlVXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlci5wcm90b3R5cGUudHJ5UGFyc2UgPSBmdW5jdGlvbiAoY29tcG9uZW50LCB0ZW1wbGF0ZSwgZGlyZWN0aXZlcywgcGlwZXMsIHNjaGVtYXMsIHRlbXBsYXRlVXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyeVBhcnNlSHRtbCh0aGlzLmV4cGFuZEh0bWwodGhpcy5faHRtbFBhcnNlci5wYXJzZSh0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIHRydWUsIHRoaXMuZ2V0SW50ZXJwb2xhdGlvbkNvbmZpZyhjb21wb25lbnQpKSksIGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGh0bWxBc3RXaXRoRXJyb3JzXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBwaXBlc1xuICAgICAqIEBwYXJhbSB7P30gc2NoZW1hc1xuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVVcmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VyLnByb3RvdHlwZS50cnlQYXJzZUh0bWwgPSBmdW5jdGlvbiAoaHRtbEFzdFdpdGhFcnJvcnMsIGNvbXBvbmVudCwgdGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBzY2hlbWFzLCB0ZW1wbGF0ZVVybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9ycyA9IGh0bWxBc3RXaXRoRXJyb3JzLmVycm9ycztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXNlZFBpcGVzID0gW107XG4gICAgICAgIGlmIChodG1sQXN0V2l0aEVycm9ycy5yb290Tm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdW5pcURpcmVjdGl2ZXMgPSByZW1vdmVTdW1tYXJ5RHVwbGljYXRlcyhkaXJlY3RpdmVzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVuaXFQaXBlcyA9IHJlbW92ZVN1bW1hcnlEdXBsaWNhdGVzKHBpcGVzKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyVmlld0NvbnRleHQgPSBuZXcgUHJvdmlkZXJWaWV3Q29udGV4dChjb21wb25lbnQpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW50ZXJwb2xhdGlvbkNvbmZpZyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQudGVtcGxhdGUgJiYgY29tcG9uZW50LnRlbXBsYXRlLmludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogY29tcG9uZW50LnRlbXBsYXRlLmludGVycG9sYXRpb25bMF0sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogY29tcG9uZW50LnRlbXBsYXRlLmludGVycG9sYXRpb25bMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmluZGluZ1BhcnNlciA9IG5ldyBCaW5kaW5nUGFyc2VyKHRoaXMuX2V4cHJQYXJzZXIsIGludGVycG9sYXRpb25Db25maWcsIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LCB1bmlxUGlwZXMsIGVycm9ycyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJzZVZpc2l0b3IgPSBuZXcgVGVtcGxhdGVQYXJzZVZpc2l0b3IodGhpcy5fY29uZmlnLCBwcm92aWRlclZpZXdDb250ZXh0LCB1bmlxRGlyZWN0aXZlcywgYmluZGluZ1BhcnNlciwgdGhpcy5fc2NoZW1hUmVnaXN0cnksIHNjaGVtYXMsIGVycm9ycyk7XG4gICAgICAgICAgICByZXN1bHQgPSB2aXNpdEFsbChwYXJzZVZpc2l0b3IsIGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2RlcywgRU1QVFlfRUxFTUVOVF9DT05URVhUKTtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgcHJvdmlkZXJWaWV3Q29udGV4dC5lcnJvcnMpO1xuICAgICAgICAgICAgdXNlZFBpcGVzLnB1c2guYXBwbHkodXNlZFBpcGVzLCBiaW5kaW5nUGFyc2VyLmdldFVzZWRQaXBlcygpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Fzc2VydE5vUmVmZXJlbmNlRHVwbGljYXRpb25PblRlbXBsYXRlKHJlc3VsdCwgZXJyb3JzKTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlUGFyc2VSZXN1bHQocmVzdWx0LCB1c2VkUGlwZXMsIGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3Jtcykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1zLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zZm9ybSkgeyByZXN1bHQgPSB0ZW1wbGF0ZVZpc2l0QWxsKHRyYW5zZm9ybSwgcmVzdWx0KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZVBhcnNlUmVzdWx0KHJlc3VsdCwgdXNlZFBpcGVzLCBlcnJvcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBodG1sQXN0V2l0aEVycm9yc1xuICAgICAqIEBwYXJhbSB7Pz19IGZvcmNlZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLmV4cGFuZEh0bWwgPSBmdW5jdGlvbiAoaHRtbEFzdFdpdGhFcnJvcnMsIGZvcmNlZCkge1xuICAgICAgICBpZiAoZm9yY2VkID09PSB2b2lkIDApIHsgZm9yY2VkID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gaHRtbEFzdFdpdGhFcnJvcnMuZXJyb3JzO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PSAwIHx8IGZvcmNlZCkge1xuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElDVSBtZXNzYWdlcyB0byBhbmd1bGFyIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cGFuZGVkSHRtbEFzdCA9IGV4cGFuZE5vZGVzKGh0bWxBc3RXaXRoRXJyb3JzLnJvb3ROb2Rlcyk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIGV4cGFuZGVkSHRtbEFzdC5lcnJvcnMpO1xuICAgICAgICAgICAgaHRtbEFzdFdpdGhFcnJvcnMgPSBuZXcgUGFyc2VUcmVlUmVzdWx0KGV4cGFuZGVkSHRtbEFzdC5ub2RlcywgZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbEFzdFdpdGhFcnJvcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLmdldEludGVycG9sYXRpb25Db25maWcgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjb21wb25lbnQudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnBvbGF0aW9uQ29uZmlnLmZyb21BcnJheShjb21wb25lbnQudGVtcGxhdGUuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFxcQGludGVybmFsXG4gICAgICogQHBhcmFtIHs/fSByZXN1bHRcbiAgICAgKiBAcGFyYW0gez99IGVycm9yc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZXIucHJvdG90eXBlLl9hc3NlcnROb1JlZmVyZW5jZUR1cGxpY2F0aW9uT25UZW1wbGF0ZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGVycm9ycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleGlzdGluZ1JlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgcmVzdWx0LmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gISEoKGVsZW1lbnQpKS5yZWZlcmVuY2VzOyB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHsgcmV0dXJuICgoZWxlbWVudCkpLnJlZmVyZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAocmVmZXJlbmNlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gcmVmZXJlbmNlLm5hbWU7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdSZWZlcmVuY2VzLmluZGV4T2YobmFtZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdSZWZlcmVuY2VzLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvciA9IG5ldyBUZW1wbGF0ZVBhcnNlRXJyb3IoXCJSZWZlcmVuY2UgXFxcIiNcIiArIG5hbWUgKyBcIlxcXCIgaXMgZGVmaW5lZCBzZXZlcmFsIHRpbWVzXCIsIHJlZmVyZW5jZS5zb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuRVJST1IpO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbXBsYXRlUGFyc2VyO1xufSgpKTtcblRlbXBsYXRlUGFyc2VyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblRlbXBsYXRlUGFyc2VyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgeyB0eXBlOiBQYXJzZXIsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50U2NoZW1hUmVnaXN0cnksIH0sXG4gICAgeyB0eXBlOiBJMThOSHRtbFBhcnNlciwgfSxcbiAgICB7IHR5cGU6IMm1Q29uc29sZSwgfSxcbiAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBPcHRpb25hbCB9LCB7IHR5cGU6IEluamVjdCwgYXJnczogW1RFTVBMQVRFX1RSQU5TRk9STVMsXSB9LF0gfSxcbl07IH07XG52YXIgVGVtcGxhdGVQYXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29uZmlnXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclZpZXdDb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBfYmluZGluZ1BhcnNlclxuICAgICAqIEBwYXJhbSB7P30gX3NjaGVtYVJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIHs/fSBfc2NoZW1hc1xuICAgICAqIEBwYXJhbSB7P30gX3RhcmdldEVycm9yc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUGFyc2VWaXNpdG9yKGNvbmZpZywgcHJvdmlkZXJWaWV3Q29udGV4dCwgZGlyZWN0aXZlcywgX2JpbmRpbmdQYXJzZXIsIF9zY2hlbWFSZWdpc3RyeSwgX3NjaGVtYXMsIF90YXJnZXRFcnJvcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCA9IHByb3ZpZGVyVmlld0NvbnRleHQ7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIgPSBfYmluZGluZ1BhcnNlcjtcbiAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkgPSBfc2NoZW1hUmVnaXN0cnk7XG4gICAgICAgIHRoaXMuX3NjaGVtYXMgPSBfc2NoZW1hcztcbiAgICAgICAgdGhpcy5fdGFyZ2V0RXJyb3JzID0gX3RhcmdldEVycm9ycztcbiAgICAgICAgdGhpcy5zZWxlY3Rvck1hdGNoZXIgPSBuZXcgU2VsZWN0b3JNYXRjaGVyKCk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5nQ29udGVudENvdW50ID0gMDtcbiAgICAgICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgICAgICB0aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQgPSBwcm92aWRlclZpZXdDb250ZXh0LmNvbXBvbmVudC52aWV3UXVlcmllcy5sZW5ndGggKyAxO1xuICAgICAgICBkaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IENzc1NlbGVjdG9yLnBhcnNlKGRpcmVjdGl2ZS5zZWxlY3Rvcik7XG4gICAgICAgICAgICBfdGhpcy5zZWxlY3Rvck1hdGNoZXIuYWRkU2VsZWN0YWJsZXMoc2VsZWN0b3IsIGRpcmVjdGl2ZSk7XG4gICAgICAgICAgICBfdGhpcy5kaXJlY3RpdmVzSW5kZXguc2V0KGRpcmVjdGl2ZSwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25cbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBhbnNpb25DYXNlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHQgPSBmdW5jdGlvbiAodGV4dCwgcGFyZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nQ29udGVudEluZGV4ID0gcGFyZW50LmZpbmROZ0NvbnRlbnRJbmRleChURVhUX0NTU19TRUxFQ1RPUik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHIgPSB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlSW50ZXJwb2xhdGlvbih0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgICAgICByZXR1cm4gZXhwciA/IG5ldyBCb3VuZFRleHRBc3QoZXhwciwgbmdDb250ZW50SW5kZXgsIHRleHQuc291cmNlU3BhbikgOlxuICAgICAgICAgICAgbmV3IFRleHRBc3QodGV4dC52YWx1ZSwgbmdDb250ZW50SW5kZXgsIHRleHQuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJBc3QoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSwgYXR0cmlidXRlLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGNvbW1lbnQsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgcGFyZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5U3RhcnRJbmRleCA9IHRoaXMuY29udGVudFF1ZXJ5U3RhcnRJZDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZU5hbWUgPSBlbGVtZW50Lm5hbWU7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXBhcnNlZEVsZW1lbnQgPSBwcmVwYXJzZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSkge1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHNjcmlwdD4gZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzdHlsZT4gYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQgJiZcbiAgICAgICAgICAgIGlzU3R5bGVVcmxSZXNvbHZhYmxlKHByZXBhcnNlZEVsZW1lbnQuaHJlZkF0dHIpKSB7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyBzdHlsZXNoZWV0cyB3aXRoIGVpdGhlciByZWxhdGl2ZSB1cmxzIG9yIHBhY2thZ2Ugc2NoZW1lIGFzIHdlIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAvLyB0aGVtIGluIHRoZSBTdHlsZUNvbXBpbGVyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaGFibGVBdHRycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50T3JEaXJlY3RpdmVSZWZzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRWYXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV2ZW50cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlTWF0Y2hhYmxlQXR0cnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVFbGVtZW50VmFycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNJbmxpbmVUZW1wbGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0cnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNUZW1wbGF0ZUVsZW1lbnQgPSBpc1RlbXBsYXRlKGVsZW1lbnQsIHRoaXMuY29uZmlnLmVuYWJsZUxlZ2FjeVRlbXBsYXRlLCBmdW5jdGlvbiAobSwgc3BhbikgeyByZXR1cm4gX3RoaXMuX3JlcG9ydEVycm9yKG0sIHNwYW4sIFBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HKTsgfSk7XG4gICAgICAgIGVsZW1lbnQuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFzQmluZGluZyA9IF90aGlzLl9wYXJzZUF0dHIoaXNUZW1wbGF0ZUVsZW1lbnQsIGF0dHIsIG1hdGNoYWJsZUF0dHJzLCBlbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgZXZlbnRzLCBlbGVtZW50T3JEaXJlY3RpdmVSZWZzLCBlbGVtZW50VmFycyk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZUJpbmRpbmdzU291cmNlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4VG9rZW47XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3JtYWxpemVkTmFtZSA9IF90aGlzLl9ub3JtYWxpemVBdHRyaWJ1dGVOYW1lKGF0dHIubmFtZSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlnLmVuYWJsZUxlZ2FjeVRlbXBsYXRlICYmIG5vcm1hbGl6ZWROYW1lID09IFRFTVBMQVRFX0FUVFIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoVEVNUExBVEVfQVRUUl9ERVBSRUNBVElPTl9XQVJOSU5HLCBhdHRyLnNvdXJjZVNwYW4sIFBhcnNlRXJyb3JMZXZlbC5XQVJOSU5HKTtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZUJpbmRpbmdzU291cmNlID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vcm1hbGl6ZWROYW1lLnN0YXJ0c1dpdGgoVEVNUExBVEVfQVRUUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVCaW5kaW5nc1NvdXJjZSA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgcHJlZml4VG9rZW4gPSBub3JtYWxpemVkTmFtZS5zdWJzdHJpbmcoVEVNUExBVEVfQVRUUl9QUkVGSVgubGVuZ3RoKSArICc6JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhc1RlbXBsYXRlQmluZGluZyA9IHRlbXBsYXRlQmluZGluZ3NTb3VyY2UgIT0gbnVsbDtcbiAgICAgICAgICAgIGlmIChoYXNUZW1wbGF0ZUJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzSW5saW5lVGVtcGxhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIkNhbid0IGhhdmUgbXVsdGlwbGUgdGVtcGxhdGUgYmluZGluZ3Mgb24gb25lIGVsZW1lbnQuIFVzZSBvbmx5IG9uZSBhdHRyaWJ1dGUgbmFtZWQgJ3RlbXBsYXRlJyBvciBwcmVmaXhlZCB3aXRoICpcIiwgYXR0ci5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFzSW5saW5lVGVtcGxhdGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyhwcmVmaXhUb2tlbiwgdGVtcGxhdGVCaW5kaW5nc1NvdXJjZSwgYXR0ci5zb3VyY2VTcGFuLCB0ZW1wbGF0ZU1hdGNoYWJsZUF0dHJzLCB0ZW1wbGF0ZUVsZW1lbnRPckRpcmVjdGl2ZVByb3BzLCB0ZW1wbGF0ZUVsZW1lbnRWYXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzQmluZGluZyAmJiAhaGFzVGVtcGxhdGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgaW5jbHVkZSB0aGUgYmluZGluZ3MgYXMgYXR0cmlidXRlcyBhcyB3ZWxsIGluIHRoZSBBU1RcbiAgICAgICAgICAgICAgICBhdHRycy5wdXNoKF90aGlzLnZpc2l0QXR0cmlidXRlKGF0dHIsIG51bGwpKTtcbiAgICAgICAgICAgICAgICBtYXRjaGFibGVBdHRycy5wdXNoKFthdHRyLm5hbWUsIGF0dHIudmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRDc3NTZWxlY3RvciA9IGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3Rvcihub2RlTmFtZSwgbWF0Y2hhYmxlQXR0cnMpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9wYXJzZURpcmVjdGl2ZXModGhpcy5zZWxlY3Rvck1hdGNoZXIsIGVsZW1lbnRDc3NTZWxlY3RvciksIGRpcmVjdGl2ZU1ldGFzID0gX2EuZGlyZWN0aXZlcywgbWF0Y2hFbGVtZW50ID0gX2EubWF0Y2hFbGVtZW50O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWZlcmVuY2VzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJlY3RpdmVBc3RzID0gdGhpcy5fY3JlYXRlRGlyZWN0aXZlQXN0cyhpc1RlbXBsYXRlRWxlbWVudCwgZWxlbWVudC5uYW1lLCBkaXJlY3RpdmVNZXRhcywgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMsIGVsZW1lbnQuc291cmNlU3BhbiwgcmVmZXJlbmNlcywgYm91bmREaXJlY3RpdmVQcm9wTmFtZXMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50UHJvcHMgPSB0aGlzLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3RzKGVsZW1lbnQubmFtZSwgZWxlbWVudE9yRGlyZWN0aXZlUHJvcHMsIGJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNWaWV3Um9vdCA9IHBhcmVudC5pc1RlbXBsYXRlRWxlbWVudCB8fCBoYXNJbmxpbmVUZW1wbGF0ZXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyQ29udGV4dCA9IG5ldyBQcm92aWRlckVsZW1lbnRDb250ZXh0KHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCwgcGFyZW50LnByb3ZpZGVyQ29udGV4dCwgaXNWaWV3Um9vdCwgZGlyZWN0aXZlQXN0cywgYXR0cnMsIHJlZmVyZW5jZXMsIGlzVGVtcGxhdGVFbGVtZW50LCBxdWVyeVN0YXJ0SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkcmVuID0gdmlzaXRBbGwocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSA/IE5PTl9CSU5EQUJMRV9WSVNJVE9SIDogdGhpcywgZWxlbWVudC5jaGlsZHJlbiwgRWxlbWVudENvbnRleHQuY3JlYXRlKGlzVGVtcGxhdGVFbGVtZW50LCBkaXJlY3RpdmVBc3RzLCBpc1RlbXBsYXRlRWxlbWVudCA/IHBhcmVudC5wcm92aWRlckNvbnRleHQgOiBwcm92aWRlckNvbnRleHQpKTtcbiAgICAgICAgcHJvdmlkZXJDb250ZXh0LmFmdGVyRWxlbWVudCgpO1xuICAgICAgICAvLyBPdmVycmlkZSB0aGUgYWN0dWFsIHNlbGVjdG9yIHdoZW4gdGhlIGBuZ1Byb2plY3RBc2AgYXR0cmlidXRlIGlzIHByb3ZpZGVkXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb2plY3Rpb25TZWxlY3RvciA9IHByZXBhcnNlZEVsZW1lbnQucHJvamVjdEFzICE9IG51bGwgP1xuICAgICAgICAgICAgQ3NzU2VsZWN0b3IucGFyc2UocHJlcGFyc2VkRWxlbWVudC5wcm9qZWN0QXMpWzBdIDpcbiAgICAgICAgICAgIGVsZW1lbnRDc3NTZWxlY3RvcjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdDb250ZW50SW5kZXggPSBwYXJlbnQuZmluZE5nQ29udGVudEluZGV4KHByb2plY3Rpb25TZWxlY3Rvcik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnNlZEVsZW1lbnQ7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNoaWxkcmVuICYmICFlbGVtZW50LmNoaWxkcmVuLmV2ZXJ5KF9pc0VtcHR5VGV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCI8bmctY29udGVudD4gZWxlbWVudCBjYW5ub3QgaGF2ZSBjb250ZW50LlwiLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBOZ0NvbnRlbnRBc3QodGhpcy5uZ0NvbnRlbnRDb3VudCsrLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VydEFsbEV2ZW50c1B1Ymxpc2hlZEJ5RGlyZWN0aXZlcyhkaXJlY3RpdmVBc3RzLCBldmVudHMpO1xuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0Tm9Db21wb25lbnRzTm9yRWxlbWVudEJpbmRpbmdzT25UZW1wbGF0ZShkaXJlY3RpdmVBc3RzLCBlbGVtZW50UHJvcHMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IEVtYmVkZGVkVGVtcGxhdGVBc3QoYXR0cnMsIGV2ZW50cywgcmVmZXJlbmNlcywgZWxlbWVudFZhcnMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1Qcm92aWRlcnMsIHByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZEhhc1ZpZXdDb250YWluZXIsIHByb3ZpZGVyQ29udGV4dC5xdWVyeU1hdGNoZXMsIGNoaWxkcmVuLCBoYXNJbmxpbmVUZW1wbGF0ZXMgPyBudWxsIDogbmdDb250ZW50SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hc3NlcnRFbGVtZW50RXhpc3RzKG1hdGNoRWxlbWVudCwgZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9hc3NlcnRPbmx5T25lQ29tcG9uZW50KGRpcmVjdGl2ZUFzdHMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0NvbnRlbnRJbmRleF8xID0gaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgocHJvamVjdGlvblNlbGVjdG9yKTtcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgRWxlbWVudEFzdChub2RlTmFtZSwgYXR0cnMsIGVsZW1lbnRQcm9wcywgZXZlbnRzLCByZWZlcmVuY2VzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWREaXJlY3RpdmVBc3RzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtUHJvdmlkZXJzLCBwcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCBwcm92aWRlckNvbnRleHQucXVlcnlNYXRjaGVzLCBjaGlsZHJlbiwgaGFzSW5saW5lVGVtcGxhdGVzID8gbnVsbCA6IG5nQ29udGVudEluZGV4XzEsIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5lbmRTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzSW5saW5lVGVtcGxhdGVzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZVF1ZXJ5U3RhcnRJbmRleCA9IHRoaXMuY29udGVudFF1ZXJ5U3RhcnRJZDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlU2VsZWN0b3IgPSBjcmVhdGVFbGVtZW50Q3NzU2VsZWN0b3IoVEVNUExBVEVfRUxFTUVOVCwgdGVtcGxhdGVNYXRjaGFibGVBdHRycyk7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVEaXJlY3RpdmVNZXRhcyA9IHRoaXMuX3BhcnNlRGlyZWN0aXZlcyh0aGlzLnNlbGVjdG9yTWF0Y2hlciwgdGVtcGxhdGVTZWxlY3RvcikuZGlyZWN0aXZlcztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlQm91bmREaXJlY3RpdmVQcm9wTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZURpcmVjdGl2ZUFzdHMgPSB0aGlzLl9jcmVhdGVEaXJlY3RpdmVBc3RzKHRydWUsIGVsZW1lbnQubmFtZSwgdGVtcGxhdGVEaXJlY3RpdmVNZXRhcywgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgW10sIGVsZW1lbnQuc291cmNlU3BhbiwgW10sIHRlbXBsYXRlQm91bmREaXJlY3RpdmVQcm9wTmFtZXMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVFbGVtZW50UHJvcHMgPSB0aGlzLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3RzKGVsZW1lbnQubmFtZSwgdGVtcGxhdGVFbGVtZW50T3JEaXJlY3RpdmVQcm9wcywgdGVtcGxhdGVCb3VuZERpcmVjdGl2ZVByb3BOYW1lcyk7XG4gICAgICAgICAgICB0aGlzLl9hc3NlcnROb0NvbXBvbmVudHNOb3JFbGVtZW50QmluZGluZ3NPblRlbXBsYXRlKHRlbXBsYXRlRGlyZWN0aXZlQXN0cywgdGVtcGxhdGVFbGVtZW50UHJvcHMsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dCA9IG5ldyBQcm92aWRlckVsZW1lbnRDb250ZXh0KHRoaXMucHJvdmlkZXJWaWV3Q29udGV4dCwgcGFyZW50LnByb3ZpZGVyQ29udGV4dCwgcGFyZW50LmlzVGVtcGxhdGVFbGVtZW50LCB0ZW1wbGF0ZURpcmVjdGl2ZUFzdHMsIFtdLCBbXSwgdHJ1ZSwgdGVtcGxhdGVRdWVyeVN0YXJ0SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC5hZnRlckVsZW1lbnQoKTtcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgRW1iZWRkZWRUZW1wbGF0ZUFzdChbXSwgW10sIFtdLCB0ZW1wbGF0ZUVsZW1lbnRWYXJzLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC50cmFuc2Zvcm1lZERpcmVjdGl2ZUFzdHMsIHRlbXBsYXRlUHJvdmlkZXJDb250ZXh0LnRyYW5zZm9ybVByb3ZpZGVycywgdGVtcGxhdGVQcm92aWRlckNvbnRleHQudHJhbnNmb3JtZWRIYXNWaWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVByb3ZpZGVyQ29udGV4dC5xdWVyeU1hdGNoZXMsIFtwYXJzZWRFbGVtZW50XSwgbmdDb250ZW50SW5kZXgsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZEVsZW1lbnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlzVGVtcGxhdGVFbGVtZW50XG4gICAgICogQHBhcmFtIHs/fSBhdHRyXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRNYXRjaGFibGVBdHRyc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UHJvcHNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldEV2ZW50c1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0UmVmc1xuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0VmFyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUF0dHIgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGF0dHIsIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywgdGFyZ2V0RXZlbnRzLCB0YXJnZXRSZWZzLCB0YXJnZXRWYXJzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSB0aGlzLl9ub3JtYWxpemVBdHRyaWJ1dGVOYW1lKGF0dHIubmFtZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3JjU3BhbiA9IGF0dHIuc291cmNlU3BhbjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmluZFBhcnRzID0gbmFtZS5tYXRjaChCSU5EX05BTUVfUkVHRVhQKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFzQmluZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoYmluZFBhcnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBoYXNCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChiaW5kUGFydHNbS1dfQklORF9JRFhdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfTEVUX0lEWF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVZhcmlhYmxlKGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRWYXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKFwiXFxcImxldC1cXFwiIGlzIG9ubHkgc3VwcG9ydGVkIG9uIHRlbXBsYXRlIGVsZW1lbnRzLlwiLCBzcmNTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfUkVGX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWF07XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VSZWZlcmVuY2UoaWRlbnRpZmllciwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldFJlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX09OX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQoYmluZFBhcnRzW0lERU5UX0tXX0lEWF0sIHZhbHVlLCBzcmNTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19CSU5ET05fSURYXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoYmluZFBhcnRzW0lERU5UX0tXX0lEWF0sIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFzc2lnbm1lbnRFdmVudChiaW5kUGFydHNbSURFTlRfS1dfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0FUX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlTGl0ZXJhbEF0dHIobmFtZSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbSURFTlRfQkFOQU5BX0JPWF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhiaW5kUGFydHNbSURFTlRfQkFOQU5BX0JPWF9JRFhdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBc3NpZ25tZW50RXZlbnQoYmluZFBhcnRzW0lERU5UX0JBTkFOQV9CT1hfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0lERU5UX1BST1BFUlRZX0lEWF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGJpbmRQYXJ0c1tJREVOVF9QUk9QRVJUWV9JRFhdLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbSURFTlRfRVZFTlRfSURYXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VFdmVudChiaW5kUGFydHNbSURFTlRfRVZFTlRfSURYXSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFzQmluZGluZyA9IHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUludGVycG9sYXRpb24obmFtZSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNCaW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5nUGFyc2VyLnBhcnNlTGl0ZXJhbEF0dHIobmFtZSwgdmFsdWUsIHNyY1NwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc0JpbmRpbmc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGF0dHJOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX25vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAoYXR0ck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIC9eZGF0YS0vaS50ZXN0KGF0dHJOYW1lKSA/IGF0dHJOYW1lLnN1YnN0cmluZyg1KSA6IGF0dHJOYW1lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0VmFyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZVZhcmlhYmxlID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRWYXJzKSB7XG4gICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlxcXCItXFxcIiBpcyBub3QgYWxsb3dlZCBpbiB2YXJpYWJsZSBuYW1lc1wiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRWYXJzLnB1c2gobmV3IFZhcmlhYmxlQXN0KGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRSZWZzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3BhcnNlUmVmZXJlbmNlID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuLCB0YXJnZXRSZWZzKSB7XG4gICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIlxcXCItXFxcIiBpcyBub3QgYWxsb3dlZCBpbiByZWZlcmVuY2UgbmFtZXNcIiwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0UmVmcy5wdXNoKG5ldyBFbGVtZW50T3JEaXJlY3RpdmVSZWYoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0TWF0Y2hhYmxlQXR0cnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldEV2ZW50c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9wYXJzZUFzc2lnbm1lbnRFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKSB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdQYXJzZXIucGFyc2VFdmVudChuYW1lICsgXCJDaGFuZ2VcIiwgZXhwcmVzc2lvbiArIFwiPSRldmVudFwiLCBzb3VyY2VTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JNYXRjaGVyXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50Q3NzU2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fcGFyc2VEaXJlY3RpdmVzID0gZnVuY3Rpb24gKHNlbGVjdG9yTWF0Y2hlciwgZWxlbWVudENzc1NlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIE5lZWQgdG8gc29ydCB0aGUgZGlyZWN0aXZlcyBzbyB0aGF0IHdlIGdldCBjb25zaXN0ZW50IHJlc3VsdHMgdGhyb3VnaG91dCxcbiAgICAgICAgLy8gYXMgc2VsZWN0b3JNYXRjaGVyIHVzZXMgTWFwcyBpbnNpZGUuXG4gICAgICAgIC8vIEFsc28gZGVkdXBsaWNhdGUgZGlyZWN0aXZlcyBhcyB0aGV5IG1pZ2h0IG1hdGNoIG1vcmUgdGhhbiBvbmUgdGltZSFcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyZWN0aXZlcyA9IG5ldyBBcnJheSh0aGlzLmRpcmVjdGl2ZXNJbmRleC5zaXplKTtcbiAgICAgICAgLy8gV2hldGhlciBhbnkgZGlyZWN0aXZlIHNlbGVjdG9yIG1hdGNoZXMgb24gdGhlIGVsZW1lbnQgbmFtZVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaEVsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgc2VsZWN0b3JNYXRjaGVyLm1hdGNoKGVsZW1lbnRDc3NTZWxlY3RvciwgZnVuY3Rpb24gKHNlbGVjdG9yLCBkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXNbX3RoaXMuZGlyZWN0aXZlc0luZGV4LmdldChkaXJlY3RpdmUpXSA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgIG1hdGNoRWxlbWVudCA9IG1hdGNoRWxlbWVudCB8fCBzZWxlY3Rvci5oYXNFbGVtZW50U2VsZWN0b3IoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzLmZpbHRlcihmdW5jdGlvbiAoZGlyKSB7IHJldHVybiAhIWRpcjsgfSksXG4gICAgICAgICAgICBtYXRjaEVsZW1lbnQ6IG1hdGNoRWxlbWVudCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaXNUZW1wbGF0ZUVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnROYW1lXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBwcm9wc1xuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE9yRGlyZWN0aXZlUmVmc1xuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFNvdXJjZVNwYW5cbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFJlZmVyZW5jZXNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2NyZWF0ZURpcmVjdGl2ZUFzdHMgPSBmdW5jdGlvbiAoaXNUZW1wbGF0ZUVsZW1lbnQsIGVsZW1lbnROYW1lLCBkaXJlY3RpdmVzLCBwcm9wcywgZWxlbWVudE9yRGlyZWN0aXZlUmVmcywgZWxlbWVudFNvdXJjZVNwYW4sIHRhcmdldFJlZmVyZW5jZXMsIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hdGNoZWRSZWZlcmVuY2VzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnQgPSBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJlY3RpdmVBc3RzID0gZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oZWxlbWVudFNvdXJjZVNwYW4uc3RhcnQsIGVsZW1lbnRTb3VyY2VTcGFuLmVuZCwgXCJEaXJlY3RpdmUgXCIgKyBpZGVudGlmaWVyTmFtZShkaXJlY3RpdmUudHlwZSkpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudCA9IGRpcmVjdGl2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpcmVjdGl2ZVByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RQcm9wZXJ0aWVzID0gX3RoaXMuX2JpbmRpbmdQYXJzZXIuY3JlYXRlRGlyZWN0aXZlSG9zdFByb3BlcnR5QXN0cyhkaXJlY3RpdmUsIGVsZW1lbnROYW1lLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgdG8gY2hlY2sgdGhlIGhvc3QgcHJvcGVydGllcyBoZXJlIGFzIHdlbGwsXG4gICAgICAgICAgICAvLyBhcyB3ZSBkb24ndCBrbm93IHRoZSBlbGVtZW50IG5hbWUgaW4gdGhlIERpcmVjdGl2ZVdyYXBwZXJDb21waWxlciB5ZXQuXG4gICAgICAgICAgICBob3N0UHJvcGVydGllcyA9IF90aGlzLl9jaGVja1Byb3BlcnRpZXNJblNjaGVtYShlbGVtZW50TmFtZSwgaG9zdFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdEV2ZW50cyA9IF90aGlzLl9iaW5kaW5nUGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoZGlyZWN0aXZlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIF90aGlzLl9jcmVhdGVEaXJlY3RpdmVQcm9wZXJ0eUFzdHMoZGlyZWN0aXZlLmlucHV0cywgcHJvcHMsIGRpcmVjdGl2ZVByb3BlcnRpZXMsIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzKTtcbiAgICAgICAgICAgIGVsZW1lbnRPckRpcmVjdGl2ZVJlZnMuZm9yRWFjaChmdW5jdGlvbiAoZWxPckRpclJlZikge1xuICAgICAgICAgICAgICAgIGlmICgoZWxPckRpclJlZi52YWx1ZS5sZW5ndGggPT09IDAgJiYgZGlyZWN0aXZlLmlzQ29tcG9uZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoZGlyZWN0aXZlLmV4cG9ydEFzID09IGVsT3JEaXJSZWYudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFJlZmVyZW5jZXMucHVzaChuZXcgUmVmZXJlbmNlQXN0KGVsT3JEaXJSZWYubmFtZSwgaWRlbnRpZmllclRva2VuKGRpcmVjdGl2ZS50eXBlKSwgZWxPckRpclJlZi5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRSZWZlcmVuY2VzLmFkZChlbE9yRGlyUmVmLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGVudFF1ZXJ5U3RhcnRJZCA9IF90aGlzLmNvbnRlbnRRdWVyeVN0YXJ0SWQ7XG4gICAgICAgICAgICBfdGhpcy5jb250ZW50UXVlcnlTdGFydElkICs9IGRpcmVjdGl2ZS5xdWVyaWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGlyZWN0aXZlQXN0KGRpcmVjdGl2ZSwgZGlyZWN0aXZlUHJvcGVydGllcywgaG9zdFByb3BlcnRpZXMsIGhvc3RFdmVudHMsIGNvbnRlbnRRdWVyeVN0YXJ0SWQsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudE9yRGlyZWN0aXZlUmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChlbE9yRGlyUmVmKSB7XG4gICAgICAgICAgICBpZiAoZWxPckRpclJlZi52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkUmVmZXJlbmNlcy5oYXMoZWxPckRpclJlZi5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3IoXCJUaGVyZSBpcyBubyBkaXJlY3RpdmUgd2l0aCBcXFwiZXhwb3J0QXNcXFwiIHNldCB0byBcXFwiXCIgKyBlbE9yRGlyUmVmLnZhbHVlICsgXCJcXFwiXCIsIGVsT3JEaXJSZWYuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZlRva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmVG9rZW4gPSBjcmVhdGVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRSZWZlcmVuY2VzLnB1c2gobmV3IFJlZmVyZW5jZUFzdChlbE9yRGlyUmVmLm5hbWUsIHJlZlRva2VuLCBlbE9yRGlyUmVmLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmVBc3RzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVQcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHs/fSBib3VuZFByb3BzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BOYW1lc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVEaXJlY3RpdmVQcm9wZXJ0eUFzdHMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlUHJvcGVydGllcywgYm91bmRQcm9wcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wcywgdGFyZ2V0Qm91bmREaXJlY3RpdmVQcm9wTmFtZXMpIHtcbiAgICAgICAgaWYgKGRpcmVjdGl2ZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvdW5kUHJvcHNCeU5hbWVfMSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGJvdW5kUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldlZhbHVlID0gYm91bmRQcm9wc0J5TmFtZV8xLmdldChib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2VmFsdWUgfHwgcHJldlZhbHVlLmlzTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIFthXT1cImJcIiBhIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gYT1cImJcIiBvbiB0aGUgc2FtZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcHNCeU5hbWVfMS5zZXQoYm91bmRQcm9wLm5hbWUsIGJvdW5kUHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmVQcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChkaXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxQcm9wID0gZGlyZWN0aXZlUHJvcGVydGllc1tkaXJQcm9wXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBib3VuZFByb3AgPSBib3VuZFByb3BzQnlOYW1lXzEuZ2V0KGVsUHJvcCk7XG4gICAgICAgICAgICAgICAgLy8gQmluZGluZ3MgYXJlIG9wdGlvbmFsLCBzbyB0aGlzIGJpbmRpbmcgb25seSBuZWVkcyB0byBiZSBzZXQgdXAgaWYgYW4gZXhwcmVzc2lvbiBpcyBnaXZlbi5cbiAgICAgICAgICAgICAgICBpZiAoYm91bmRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEJvdW5kRGlyZWN0aXZlUHJvcE5hbWVzLmFkZChib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eUV4cHJlc3Npb24oYm91bmRQcm9wLmV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRCb3VuZERpcmVjdGl2ZVByb3BzLnB1c2gobmV3IEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QoZGlyUHJvcCwgYm91bmRQcm9wLm5hbWUsIGJvdW5kUHJvcC5leHByZXNzaW9uLCBib3VuZFByb3Auc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHByb3BzXG4gICAgICogQHBhcmFtIHs/fSBib3VuZERpcmVjdGl2ZVByb3BOYW1lc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jcmVhdGVFbGVtZW50UHJvcGVydHlBc3RzID0gZnVuY3Rpb24gKGVsZW1lbnROYW1lLCBwcm9wcywgYm91bmREaXJlY3RpdmVQcm9wTmFtZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm91bmRFbGVtZW50UHJvcHMgPSBbXTtcbiAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgaWYgKCFwcm9wLmlzTGl0ZXJhbCAmJiAhYm91bmREaXJlY3RpdmVQcm9wTmFtZXMuaGFzKHByb3AubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBib3VuZEVsZW1lbnRQcm9wcy5wdXNoKF90aGlzLl9iaW5kaW5nUGFyc2VyLmNyZWF0ZUVsZW1lbnRQcm9wZXJ0eUFzdChlbGVtZW50TmFtZSwgcHJvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrUHJvcGVydGllc0luU2NoZW1hKGVsZW1lbnROYW1lLCBib3VuZEVsZW1lbnRQcm9wcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fZmluZENvbXBvbmVudERpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcykge1xuICAgICAgICByZXR1cm4gZGlyZWN0aXZlcy5maWx0ZXIoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLmRpcmVjdGl2ZS5pc0NvbXBvbmVudDsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUGFyc2VWaXNpdG9yLnByb3RvdHlwZS5fZmluZENvbXBvbmVudERpcmVjdGl2ZU5hbWVzID0gZnVuY3Rpb24gKGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVzKGRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHsgcmV0dXJuIGlkZW50aWZpZXJOYW1lKGRpcmVjdGl2ZS5kaXJlY3RpdmUudHlwZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydE9ubHlPbmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRUeXBlTmFtZXMgPSB0aGlzLl9maW5kQ29tcG9uZW50RGlyZWN0aXZlTmFtZXMoZGlyZWN0aXZlcyk7XG4gICAgICAgIGlmIChjb21wb25lbnRUeXBlTmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoXCJNb3JlIHRoYW4gb25lIGNvbXBvbmVudCBtYXRjaGVkIG9uIHRoaXMgZWxlbWVudC5cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJNYWtlIHN1cmUgdGhhdCBvbmx5IG9uZSBjb21wb25lbnQncyBzZWxlY3RvciBjYW4gbWF0Y2ggYSBnaXZlbiBlbGVtZW50LlxcblwiICtcbiAgICAgICAgICAgICAgICAoXCJDb25mbGljdGluZyBjb21wb25lbnRzOiBcIiArIGNvbXBvbmVudFR5cGVOYW1lcy5qb2luKCcsJykpLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHRoYXQgbm9uLWFuZ3VsYXIgdGFncyBjb25mb3JtIHRvIHRoZSBzY2hlbWFzLlxuICAgICAqXG4gICAgICogTm90ZTogQW4gZWxlbWVudCBpcyBjb25zaWRlcmVkIGFuIGFuZ3VsYXIgdGFnIHdoZW4gYXQgbGVhc3Qgb25lIGRpcmVjdGl2ZSBzZWxlY3RvciBtYXRjaGVzIHRoZVxuICAgICAqIHRhZyBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBtYXRjaEVsZW1lbnQgV2hldGhlciBhbnkgZGlyZWN0aXZlIGhhcyBtYXRjaGVkIG9uIHRoZSB0YWcgbmFtZVxuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudCB0aGUgaHRtbCBlbGVtZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydEVsZW1lbnRFeGlzdHMgPSBmdW5jdGlvbiAobWF0Y2hFbGVtZW50LCBlbGVtZW50KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsTmFtZSA9IGVsZW1lbnQubmFtZS5yZXBsYWNlKC9eOnhodG1sOi8sICcnKTtcbiAgICAgICAgaWYgKCFtYXRjaEVsZW1lbnQgJiYgIXRoaXMuX3NjaGVtYVJlZ2lzdHJ5Lmhhc0VsZW1lbnQoZWxOYW1lLCB0aGlzLl9zY2hlbWFzKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JNc2cgPSBcIidcIiArIGVsTmFtZSArIFwiJyBpcyBub3QgYSBrbm93biBlbGVtZW50OlxcblwiO1xuICAgICAgICAgICAgZXJyb3JNc2cgKz1cbiAgICAgICAgICAgICAgICBcIjEuIElmICdcIiArIGVsTmFtZSArIFwiJyBpcyBhbiBBbmd1bGFyIGNvbXBvbmVudCwgdGhlbiB2ZXJpZnkgdGhhdCBpdCBpcyBwYXJ0IG9mIHRoaXMgbW9kdWxlLlxcblwiO1xuICAgICAgICAgICAgaWYgKGVsTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgICAgIFwiMi4gSWYgJ1wiICsgZWxOYW1lICsgXCInIGlzIGEgV2ViIENvbXBvbmVudCB0aGVuIGFkZCAnQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQScgdG8gdGhlICdATmdNb2R1bGUuc2NoZW1hcycgb2YgdGhpcyBjb21wb25lbnQgdG8gc3VwcHJlc3MgdGhpcyBtZXNzYWdlLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNc2cgKz1cbiAgICAgICAgICAgICAgICAgICAgXCIyLiBUbyBhbGxvdyBhbnkgZWxlbWVudCBhZGQgJ05PX0VSUk9SU19TQ0hFTUEnIHRvIHRoZSAnQE5nTW9kdWxlLnNjaGVtYXMnIG9mIHRoaXMgY29tcG9uZW50LlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZXJyb3JNc2csIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gZWxlbWVudFByb3BzXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX2Fzc2VydE5vQ29tcG9uZW50c05vckVsZW1lbnRCaW5kaW5nc09uVGVtcGxhdGUgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgZWxlbWVudFByb3BzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudFR5cGVOYW1lcyA9IHRoaXMuX2ZpbmRDb21wb25lbnREaXJlY3RpdmVOYW1lcyhkaXJlY3RpdmVzKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFR5cGVOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihcIkNvbXBvbmVudHMgb24gYW4gZW1iZWRkZWQgdGVtcGxhdGU6IFwiICsgY29tcG9uZW50VHlwZU5hbWVzLmpvaW4oJywnKSwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihcIlByb3BlcnR5IGJpbmRpbmcgXCIgKyBwcm9wLm5hbWUgKyBcIiBub3QgdXNlZCBieSBhbnkgZGlyZWN0aXZlIG9uIGFuIGVtYmVkZGVkIHRlbXBsYXRlLiBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvcGVydHkgbmFtZSBpcyBzcGVsbGVkIGNvcnJlY3RseSBhbmQgYWxsIGRpcmVjdGl2ZXMgYXJlIGxpc3RlZCBpbiB0aGUgXFxcIkBOZ01vZHVsZS5kZWNsYXJhdGlvbnNcXFwiLlwiLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IGV2ZW50c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9hc3NlcnRBbGxFdmVudHNQdWJsaXNoZWRCeURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoZGlyZWN0aXZlcywgZXZlbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbERpcmVjdGl2ZUV2ZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRpcmVjdGl2ZS5kaXJlY3RpdmUub3V0cHV0cykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV2ZW50TmFtZSA9IGRpcmVjdGl2ZS5kaXJlY3RpdmUub3V0cHV0c1trXTtcbiAgICAgICAgICAgICAgICBhbGxEaXJlY3RpdmVFdmVudHMuYWRkKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPSBudWxsIHx8ICFhbGxEaXJlY3RpdmVFdmVudHMuaGFzKGV2ZW50Lm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKFwiRXZlbnQgYmluZGluZyBcIiArIGV2ZW50LmZ1bGxOYW1lICsgXCIgbm90IGVtaXR0ZWQgYnkgYW55IGRpcmVjdGl2ZSBvbiBhbiBlbWJlZGRlZCB0ZW1wbGF0ZS4gTWFrZSBzdXJlIHRoYXQgdGhlIGV2ZW50IG5hbWUgaXMgc3BlbGxlZCBjb3JyZWN0bHkgYW5kIGFsbCBkaXJlY3RpdmVzIGFyZSBsaXN0ZWQgaW4gdGhlIFxcXCJATmdNb2R1bGUuZGVjbGFyYXRpb25zXFxcIi5cIiwgZXZlbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbGVtZW50TmFtZVxuICAgICAqIEBwYXJhbSB7P30gYm91bmRQcm9wc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQYXJzZVZpc2l0b3IucHJvdG90eXBlLl9jaGVja1Byb3BlcnRpZXNJblNjaGVtYSA9IGZ1bmN0aW9uIChlbGVtZW50TmFtZSwgYm91bmRQcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBOb3RlOiBXZSBjYW4ndCBmaWx0ZXIgb3V0IGVtcHR5IGV4cHJlc3Npb25zIGJlZm9yZSB0aGlzIG1ldGhvZCxcbiAgICAgICAgLy8gYXMgd2Ugc3RpbGwgd2FudCB0byB2YWxpZGF0ZSB0aGVtIVxuICAgICAgICByZXR1cm4gYm91bmRQcm9wcy5maWx0ZXIoZnVuY3Rpb24gKGJvdW5kUHJvcCkge1xuICAgICAgICAgICAgaWYgKGJvdW5kUHJvcC50eXBlID09PSBQcm9wZXJ0eUJpbmRpbmdUeXBlLlByb3BlcnR5ICYmXG4gICAgICAgICAgICAgICAgIV90aGlzLl9zY2hlbWFSZWdpc3RyeS5oYXNQcm9wZXJ0eShlbGVtZW50TmFtZSwgYm91bmRQcm9wLm5hbWUsIF90aGlzLl9zY2hlbWFzKSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVycm9yTXNnID0gXCJDYW4ndCBiaW5kIHRvICdcIiArIGJvdW5kUHJvcC5uYW1lICsgXCInIHNpbmNlIGl0IGlzbid0IGEga25vd24gcHJvcGVydHkgb2YgJ1wiICsgZWxlbWVudE5hbWUgKyBcIicuXCI7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnROYW1lLnN0YXJ0c1dpdGgoJ25nLScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTXNnICs9XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbjEuIElmICdcIiArIGJvdW5kUHJvcC5uYW1lICsgXCInIGlzIGFuIEFuZ3VsYXIgZGlyZWN0aXZlLCB0aGVuIGFkZCAnQ29tbW9uTW9kdWxlJyB0byB0aGUgJ0BOZ01vZHVsZS5pbXBvcnRzJyBvZiB0aGlzIGNvbXBvbmVudC5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4yLiBUbyBhbGxvdyBhbnkgcHJvcGVydHkgYWRkICdOT19FUlJPUlNfU0NIRU1BJyB0byB0aGUgJ0BOZ01vZHVsZS5zY2hlbWFzJyBvZiB0aGlzIGNvbXBvbmVudC5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudE5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNc2cgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuMS4gSWYgJ1wiICsgZWxlbWVudE5hbWUgKyBcIicgaXMgYW4gQW5ndWxhciBjb21wb25lbnQgYW5kIGl0IGhhcyAnXCIgKyBib3VuZFByb3AubmFtZSArIFwiJyBpbnB1dCwgdGhlbiB2ZXJpZnkgdGhhdCBpdCBpcyBwYXJ0IG9mIHRoaXMgbW9kdWxlLlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJcXG4yLiBJZiAnXCIgKyBlbGVtZW50TmFtZSArIFwiJyBpcyBhIFdlYiBDb21wb25lbnQgdGhlbiBhZGQgJ0NVU1RPTV9FTEVNRU5UU19TQ0hFTUEnIHRvIHRoZSAnQE5nTW9kdWxlLnNjaGVtYXMnIG9mIHRoaXMgY29tcG9uZW50IHRvIHN1cHByZXNzIHRoaXMgbWVzc2FnZS5cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuMy4gVG8gYWxsb3cgYW55IHByb3BlcnR5IGFkZCAnTk9fRVJST1JTX1NDSEVNQScgdG8gdGhlICdATmdNb2R1bGUuc2NoZW1hcycgb2YgdGhpcyBjb21wb25lbnQuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihlcnJvck1zZywgYm91bmRQcm9wLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFpc0VtcHR5RXhwcmVzc2lvbihib3VuZFByb3AudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7Pz19IGxldmVsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVBhcnNlVmlzaXRvci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7IGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SOyB9XG4gICAgICAgIHRoaXMuX3RhcmdldEVycm9ycy5wdXNoKG5ldyBQYXJzZUVycm9yKHNvdXJjZVNwYW4sIG1lc3NhZ2UsIGxldmVsKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGVtcGxhdGVQYXJzZVZpc2l0b3I7XG59KCkpO1xudmFyIE5vbkJpbmRhYmxlVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9uQmluZGFibGVWaXNpdG9yKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIHBhcmVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGFzdCk7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUKSB7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c2NyaXB0PiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHN0eWxlPiBhbmQgc3R5bGVzaGVldHMgYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJOYW1lQW5kVmFsdWVzID0gYXN0LmF0dHJzLm1hcChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gW2F0dHIubmFtZSwgYXR0ci52YWx1ZV07IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RvciA9IGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3Rvcihhc3QubmFtZSwgYXR0ck5hbWVBbmRWYWx1ZXMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgoc2VsZWN0b3IpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbiwgRU1QVFlfRUxFTUVOVF9DT05URVhUKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50QXN0KGFzdC5uYW1lLCB2aXNpdEFsbCh0aGlzLCBhc3QuYXR0cnMpLCBbXSwgW10sIFtdLCBbXSwgW10sIGZhbHNlLCBbXSwgY2hpbGRyZW4sIG5nQ29udGVudEluZGV4LCBhc3Quc291cmNlU3BhbiwgYXN0LmVuZFNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21tZW50XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0Q29tbWVudCA9IGZ1bmN0aW9uIChjb21tZW50LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXR0cmlidXRlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBOb25CaW5kYWJsZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJBc3QoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSwgYXR0cmlidXRlLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZXh0XG4gICAgICogQHBhcmFtIHs/fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIHBhcmVudCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0NvbnRlbnRJbmRleCA9IHBhcmVudC5maW5kTmdDb250ZW50SW5kZXgoVEVYVF9DU1NfU0VMRUNUT1IpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRBc3QodGV4dC52YWx1ZSwgbmdDb250ZW50SW5kZXgsIHRleHQuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvblxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm9uQmluZGFibGVWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbiA9IGZ1bmN0aW9uIChleHBhbnNpb24sIGNvbnRleHQpIHsgcmV0dXJuIGV4cGFuc2lvbjsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cGFuc2lvbkNhc2VcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5vbkJpbmRhYmxlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb25DYXNlID0gZnVuY3Rpb24gKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHsgcmV0dXJuIGV4cGFuc2lvbkNhc2U7IH07XG4gICAgcmV0dXJuIE5vbkJpbmRhYmxlVmlzaXRvcjtcbn0oKSk7XG52YXIgRWxlbWVudE9yRGlyZWN0aXZlUmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRWxlbWVudE9yRGlyZWN0aXZlUmVmKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgcmV0dXJuIEVsZW1lbnRPckRpcmVjdGl2ZVJlZjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gY2xhc3NBdHRyVmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHNwbGl0Q2xhc3NlcyhjbGFzc0F0dHJWYWx1ZSkge1xuICAgIHJldHVybiBjbGFzc0F0dHJWYWx1ZS50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG52YXIgRWxlbWVudENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaXNUZW1wbGF0ZUVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IF9uZ0NvbnRlbnRJbmRleE1hdGNoZXJcbiAgICAgKiBAcGFyYW0gez99IF93aWxkY2FyZE5nQ29udGVudEluZGV4XG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlckNvbnRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbGVtZW50Q29udGV4dChpc1RlbXBsYXRlRWxlbWVudCwgX25nQ29udGVudEluZGV4TWF0Y2hlciwgX3dpbGRjYXJkTmdDb250ZW50SW5kZXgsIHByb3ZpZGVyQ29udGV4dCkge1xuICAgICAgICB0aGlzLmlzVGVtcGxhdGVFbGVtZW50ID0gaXNUZW1wbGF0ZUVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX25nQ29udGVudEluZGV4TWF0Y2hlciA9IF9uZ0NvbnRlbnRJbmRleE1hdGNoZXI7XG4gICAgICAgIHRoaXMuX3dpbGRjYXJkTmdDb250ZW50SW5kZXggPSBfd2lsZGNhcmROZ0NvbnRlbnRJbmRleDtcbiAgICAgICAgdGhpcy5wcm92aWRlckNvbnRleHQgPSBwcm92aWRlckNvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaXNUZW1wbGF0ZUVsZW1lbnRcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyQ29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudENvbnRleHQuY3JlYXRlID0gZnVuY3Rpb24gKGlzVGVtcGxhdGVFbGVtZW50LCBkaXJlY3RpdmVzLCBwcm92aWRlckNvbnRleHQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gd2lsZGNhcmROZ0NvbnRlbnRJbmRleCA9IG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudCA9IGRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUuZGlyZWN0aXZlLmlzQ29tcG9uZW50OyB9KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdDb250ZW50U2VsZWN0b3JzID0gY29tcG9uZW50LmRpcmVjdGl2ZS50ZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnM7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgbmdDb250ZW50U2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0b3IgPSBuZ0NvbnRlbnRTZWxlY3RvcnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lsZGNhcmROZ0NvbnRlbnRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVyLmFkZFNlbGVjdGFibGVzKENzc1NlbGVjdG9yLnBhcnNlKG5nQ29udGVudFNlbGVjdG9yc1tpXSksIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRDb250ZXh0KGlzVGVtcGxhdGVFbGVtZW50LCBtYXRjaGVyLCB3aWxkY2FyZE5nQ29udGVudEluZGV4LCBwcm92aWRlckNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRWxlbWVudENvbnRleHQucHJvdG90eXBlLmZpbmROZ0NvbnRlbnRJbmRleCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0NvbnRlbnRJbmRpY2VzID0gW107XG4gICAgICAgIHRoaXMuX25nQ29udGVudEluZGV4TWF0Y2hlci5tYXRjaChzZWxlY3RvciwgZnVuY3Rpb24gKHNlbGVjdG9yLCBuZ0NvbnRlbnRJbmRleCkgeyBuZ0NvbnRlbnRJbmRpY2VzLnB1c2gobmdDb250ZW50SW5kZXgpOyB9KTtcbiAgICAgICAgbmdDb250ZW50SW5kaWNlcy5zb3J0KCk7XG4gICAgICAgIGlmICh0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5nQ29udGVudEluZGljZXMucHVzaCh0aGlzLl93aWxkY2FyZE5nQ29udGVudEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmdDb250ZW50SW5kaWNlcy5sZW5ndGggPiAwID8gbmdDb250ZW50SW5kaWNlc1swXSA6IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudENvbnRleHQ7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnROYW1lXG4gKiBAcGFyYW0gez99IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRDc3NTZWxlY3RvcihlbGVtZW50TmFtZSwgYXR0cmlidXRlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNzc1NlbGVjdG9yID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxOYW1lTm9OcyA9IHNwbGl0TnNOYW1lKGVsZW1lbnROYW1lKVsxXTtcbiAgICBjc3NTZWxlY3Rvci5zZXRFbGVtZW50KGVsTmFtZU5vTnMpO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGF0dHJOYW1lID0gYXR0cmlidXRlc1tpXVswXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0ck5hbWVOb05zID0gc3BsaXROc05hbWUoYXR0ck5hbWUpWzFdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhdHRyVmFsdWUgPSBhdHRyaWJ1dGVzW2ldWzFdO1xuICAgICAgICBjc3NTZWxlY3Rvci5hZGRBdHRyaWJ1dGUoYXR0ck5hbWVOb05zLCBhdHRyVmFsdWUpO1xuICAgICAgICBpZiAoYXR0ck5hbWUudG9Mb3dlckNhc2UoKSA9PSBDTEFTU19BVFRSKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc2VzID0gc3BsaXRDbGFzc2VzKGF0dHJWYWx1ZSk7XG4gICAgICAgICAgICBjbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gY3NzU2VsZWN0b3IuYWRkQ2xhc3NOYW1lKGNsYXNzTmFtZSk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjc3NTZWxlY3Rvcjtcbn1cbnZhciBFTVBUWV9FTEVNRU5UX0NPTlRFWFQgPSBuZXcgRWxlbWVudENvbnRleHQodHJ1ZSwgbmV3IFNlbGVjdG9yTWF0Y2hlcigpLCBudWxsLCBudWxsKTtcbnZhciBOT05fQklOREFCTEVfVklTSVRPUiA9IG5ldyBOb25CaW5kYWJsZVZpc2l0b3IoKTtcbi8qKlxuICogQHBhcmFtIHs/fSBub2RlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfaXNFbXB0eVRleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRleHQgJiYgbm9kZS52YWx1ZS50cmltKCkubGVuZ3RoID09IDA7XG59XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0gez99IGl0ZW1zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiByZW1vdmVTdW1tYXJ5RHVwbGljYXRlcyhpdGVtcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcCA9IG5ldyBNYXAoKTtcbiAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmICghbWFwLmdldChpdGVtLnR5cGUucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgbWFwLnNldChpdGVtLnR5cGUucmVmZXJlbmNlLCBpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBBcnJheS5mcm9tKG1hcC52YWx1ZXMoKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc0VtcHR5RXhwcmVzc2lvbihhc3QpIHtcbiAgICBpZiAoYXN0IGluc3RhbmNlb2YgQVNUV2l0aFNvdXJjZSkge1xuICAgICAgICBhc3QgPSBhc3QuYXN0O1xuICAgIH1cbiAgICByZXR1cm4gYXN0IGluc3RhbmNlb2YgRW1wdHlFeHByO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGVsXG4gKiBAcGFyYW0gez99IGVuYWJsZUxlZ2FjeVRlbXBsYXRlXG4gKiBAcGFyYW0gez99IHJlcG9ydERlcHJlY2F0aW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1RlbXBsYXRlKGVsLCBlbmFibGVMZWdhY3lUZW1wbGF0ZSwgcmVwb3J0RGVwcmVjYXRpb24pIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YWdOb05zID0gc3BsaXROc05hbWUoZWwubmFtZSlbMV07XG4gICAgLy8gYDxuZy10ZW1wbGF0ZT5gIGlzIGFuIGFuZ3VsYXIgY29uc3RydWN0IGFuZCBpcyBsb3dlciBjYXNlXG4gICAgaWYgKHRhZ05vTnMgPT09IE5HX1RFTVBMQVRFX0VMRU1FTlQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIGA8dGVtcGxhdGU+YCBpcyBIVE1MIGFuZCBjYXNlIGluc2Vuc2l0aXZlXG4gICAgaWYgKHRhZ05vTnMudG9Mb3dlckNhc2UoKSA9PT0gVEVNUExBVEVfRUxFTUVOVCkge1xuICAgICAgICBpZiAoZW5hYmxlTGVnYWN5VGVtcGxhdGUgJiYgdGFnTm9Ocy50b0xvd2VyQ2FzZSgpID09PSBURU1QTEFURV9FTEVNRU5UKSB7XG4gICAgICAgICAgICByZXBvcnREZXByZWNhdGlvbihURU1QTEFURV9FTEVNRU5UX0RFUFJFQ0FUSU9OX1dBUk5JTkcsIGVsLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQW4gaW50ZXJmYWNlIGZvciByZXRyaWV2aW5nIGRvY3VtZW50cyBieSBVUkwgdGhhdCB0aGUgY29tcGlsZXIgdXNlc1xuICogdG8gbG9hZCB0ZW1wbGF0ZXMuXG4gKi9cbnZhciBSZXNvdXJjZUxvYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzb3VyY2VMb2FkZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZXNvdXJjZUxvYWRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICByZXR1cm4gUmVzb3VyY2VMb2FkZXI7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDcmVhdGUgYSB7XFxAbGluayBVcmxSZXNvbHZlcn0gd2l0aCBubyBwYWNrYWdlIHByZWZpeC5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVVybFJlc29sdmVyV2l0aG91dFBhY2thZ2VQcmVmaXgoKSB7XG4gICAgcmV0dXJuIG5ldyBVcmxSZXNvbHZlcigpO1xufVxuLyoqXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVPZmZsaW5lQ29tcGlsZVVybFJlc29sdmVyKCkge1xuICAgIHJldHVybiBuZXcgVXJsUmVzb2x2ZXIoJy4nKTtcbn1cbi8qKlxuICogQSBkZWZhdWx0IHByb3ZpZGVyIGZvciB7QGxpbmsgUEFDS0FHRV9ST09UX1VSTH0gdGhhdCBtYXBzIHRvICcvJy5cbiAqL1xudmFyIERFRkFVTFRfUEFDS0FHRV9VUkxfUFJPVklERVIgPSB7XG4gICAgcHJvdmlkZTogUEFDS0FHRV9ST09UX1VSTCxcbiAgICB1c2VWYWx1ZTogJy8nXG59O1xuLyoqXG4gKiBVc2VkIGJ5IHRoZSB7XFxAbGluayBDb21waWxlcn0gd2hlbiByZXNvbHZpbmcgSFRNTCBhbmQgQ1NTIHRlbXBsYXRlIFVSTHMuXG4gKlxuICogVGhpcyBjbGFzcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIHRvIGNyZWF0ZSBjdXN0b20gYmVoYXZpb3IuXG4gKlxuICogU2VlIHtcXEBsaW5rIENvbXBpbGVyfVxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKiB7XFxAZXhhbXBsZSBjb21waWxlci90cy91cmxfcmVzb2x2ZXIvdXJsX3Jlc29sdmVyLnRzIHJlZ2lvbj0ndXJsX3Jlc29sdmVyJ31cbiAqXG4gKiBcXEBzZWN1cml0eSBXaGVuIGNvbXBpbGluZyB0ZW1wbGF0ZXMgYXQgcnVudGltZSwgeW91IG11c3RcbiAqIGVuc3VyZSB0aGF0IHRoZSBlbnRpcmUgdGVtcGxhdGUgY29tZXMgZnJvbSBhIHRydXN0ZWQgc291cmNlLlxuICogQXR0YWNrZXItY29udHJvbGxlZCBkYXRhIGludHJvZHVjZWQgYnkgYSB0ZW1wbGF0ZSBjb3VsZCBleHBvc2UgeW91clxuICogYXBwbGljYXRpb24gdG8gWFNTIHJpc2tzLiBGb3IgbW9yZSBkZXRhaWwsIHNlZSB0aGUgW1NlY3VyaXR5IEd1aWRlXShodHRwOi8vZy5jby9uZy9zZWN1cml0eSkuXG4gKi9cbnZhciBVcmxSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX3BhY2thZ2VQcmVmaXhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVcmxSZXNvbHZlcihfcGFja2FnZVByZWZpeCkge1xuICAgICAgICBpZiAoX3BhY2thZ2VQcmVmaXggPT09IHZvaWQgMCkgeyBfcGFja2FnZVByZWZpeCA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fcGFja2FnZVByZWZpeCA9IF9wYWNrYWdlUHJlZml4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgYHVybGAgZ2l2ZW4gdGhlIGBiYXNlVXJsYDpcbiAgICAgKiAtIHdoZW4gdGhlIGB1cmxgIGlzIG51bGwsIHRoZSBgYmFzZVVybGAgaXMgcmV0dXJuZWQsXG4gICAgICogLSBpZiBgdXJsYCBpcyByZWxhdGl2ZSAoJ3BhdGgvdG8vaGVyZScsICcuL3BhdGgvdG8vaGVyZScpLCB0aGUgcmVzb2x2ZWQgdXJsIGlzIGEgY29tYmluYXRpb24gb2ZcbiAgICAgKiBgYmFzZVVybGAgYW5kIGB1cmxgLFxuICAgICAqIC0gaWYgYHVybGAgaXMgYWJzb2x1dGUgKGl0IGhhcyBhIHNjaGVtZTogJ2h0dHA6Ly8nLCAnaHR0cHM6Ly8nIG9yIHN0YXJ0IHdpdGggJy8nKSwgdGhlIGB1cmxgIGlzXG4gICAgICogcmV0dXJuZWQgYXMgaXMgKGlnbm9yaW5nIHRoZSBgYmFzZVVybGApXG4gICAgICogQHBhcmFtIHs/fSBiYXNlVXJsXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFVybFJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gKGJhc2VVcmwsIHVybCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFVybCA9IHVybDtcbiAgICAgICAgaWYgKGJhc2VVcmwgIT0gbnVsbCAmJiBiYXNlVXJsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc29sdmVkVXJsID0gX3Jlc29sdmVVcmwoYmFzZVVybCwgcmVzb2x2ZWRVcmwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkUGFydHMgPSBfc3BsaXQocmVzb2x2ZWRVcmwpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVmaXggPSB0aGlzLl9wYWNrYWdlUHJlZml4O1xuICAgICAgICBpZiAocHJlZml4ICE9IG51bGwgJiYgcmVzb2x2ZWRQYXJ0cyAhPSBudWxsICYmXG4gICAgICAgICAgICByZXNvbHZlZFBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdID09ICdwYWNrYWdlJykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGF0aCA9IHJlc29sdmVkUGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xuICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UoL1xcLyskLywgJycpO1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLysvLCAnJyk7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgXCIvXCIgKyBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZFVybDtcbiAgICB9O1xuICAgIHJldHVybiBVcmxSZXNvbHZlcjtcbn0oKSk7XG5VcmxSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5VcmxSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbUEFDS0FHRV9ST09UX1VSTCxdIH0sXSB9LFxuXTsgfTtcbi8qKlxuICogRXh0cmFjdCB0aGUgc2NoZW1lIG9mIGEgVVJMLlxuICogQHBhcmFtIHs/fSB1cmxcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldFVybFNjaGVtZSh1cmwpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXRjaCA9IF9zcGxpdCh1cmwpO1xuICAgIHJldHVybiAobWF0Y2ggJiYgbWF0Y2hbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0pIHx8ICcnO1xufVxuLyoqXG4gKiBCdWlsZHMgYSBVUkkgc3RyaW5nIGZyb20gYWxyZWFkeS1lbmNvZGVkIHBhcnRzLlxuICpcbiAqIE5vIGVuY29kaW5nIGlzIHBlcmZvcm1lZC4gIEFueSBjb21wb25lbnQgbWF5IGJlIG9taXR0ZWQgYXMgZWl0aGVyIG51bGwgb3JcbiAqIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez89fSBvcHRfc2NoZW1lIFRoZSBzY2hlbWUgc3VjaCBhcyAnaHR0cCcuXG4gKiBAcGFyYW0gez89fSBvcHRfdXNlckluZm8gVGhlIHVzZXIgbmFtZSBiZWZvcmUgdGhlICdcXEAnLlxuICogQHBhcmFtIHs/PX0gb3B0X2RvbWFpbiBUaGUgZG9tYWluIHN1Y2ggYXMgJ3d3dy5nb29nbGUuY29tJywgYWxyZWFkeVxuICogICAgIFVSSS1lbmNvZGVkLlxuICogQHBhcmFtIHs/PX0gb3B0X3BvcnQgVGhlIHBvcnQgbnVtYmVyLlxuICogQHBhcmFtIHs/PX0gb3B0X3BhdGggVGhlIHBhdGgsIGFscmVhZHkgVVJJLWVuY29kZWQuICBJZiBpdCBpcyBub3RcbiAqICAgICBlbXB0eSwgaXQgbXVzdCBiZWdpbiB3aXRoIGEgc2xhc2guXG4gKiBAcGFyYW0gez89fSBvcHRfcXVlcnlEYXRhIFRoZSBVUkktZW5jb2RlZCBxdWVyeSBkYXRhLlxuICogQHBhcmFtIHs/PX0gb3B0X2ZyYWdtZW50IFRoZSBVUkktZW5jb2RlZCBmcmFnbWVudCBpZGVudGlmaWVyLlxuICogQHJldHVybiB7P30gVGhlIGZ1bGx5IGNvbWJpbmVkIFVSSS5cbiAqL1xuZnVuY3Rpb24gX2J1aWxkRnJvbUVuY29kZWRQYXJ0cyhvcHRfc2NoZW1lLCBvcHRfdXNlckluZm8sIG9wdF9kb21haW4sIG9wdF9wb3J0LCBvcHRfcGF0aCwgb3B0X3F1ZXJ5RGF0YSwgb3B0X2ZyYWdtZW50KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0ID0gW107XG4gICAgaWYgKG9wdF9zY2hlbWUgIT0gbnVsbCkge1xuICAgICAgICBvdXQucHVzaChvcHRfc2NoZW1lICsgJzonKTtcbiAgICB9XG4gICAgaWYgKG9wdF9kb21haW4gIT0gbnVsbCkge1xuICAgICAgICBvdXQucHVzaCgnLy8nKTtcbiAgICAgICAgaWYgKG9wdF91c2VySW5mbyAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXQucHVzaChvcHRfdXNlckluZm8gKyAnQCcpO1xuICAgICAgICB9XG4gICAgICAgIG91dC5wdXNoKG9wdF9kb21haW4pO1xuICAgICAgICBpZiAob3B0X3BvcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0LnB1c2goJzonICsgb3B0X3BvcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRfcGF0aCAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKG9wdF9wYXRoKTtcbiAgICB9XG4gICAgaWYgKG9wdF9xdWVyeURhdGEgIT0gbnVsbCkge1xuICAgICAgICBvdXQucHVzaCgnPycgKyBvcHRfcXVlcnlEYXRhKTtcbiAgICB9XG4gICAgaWYgKG9wdF9mcmFnbWVudCAhPSBudWxsKSB7XG4gICAgICAgIG91dC5wdXNoKCcjJyArIG9wdF9mcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvdXQuam9pbignJyk7XG59XG4vKipcbiAqIEEgcmVndWxhciBleHByZXNzaW9uIGZvciBicmVha2luZyBhIFVSSSBpbnRvIGl0cyBjb21wb25lbnQgcGFydHMuXG4gKlxuICoge1xcQGxpbmsgaHR0cDovL3d3dy5nYml2LmNvbS9wcm90b2NvbHMvdXJpL3JmYy9yZmMzOTg2Lmh0bWwjUkZDMjIzNH0gc2F5c1xuICogQXMgdGhlIFwiZmlyc3QtbWF0Y2gtd2luc1wiIGFsZ29yaXRobSBpcyBpZGVudGljYWwgdG8gdGhlIFwiZ3JlZWR5XCJcbiAqIGRpc2FtYmlndWF0aW9uIG1ldGhvZCB1c2VkIGJ5IFBPU0lYIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGl0IGlzIG5hdHVyYWwgYW5kXG4gKiBjb21tb25wbGFjZSB0byB1c2UgYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIHBhcnNpbmcgdGhlIHBvdGVudGlhbCBmaXZlXG4gKiBjb21wb25lbnRzIG9mIGEgVVJJIHJlZmVyZW5jZS5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGxpbmUgaXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgYnJlYWtpbmctZG93biBhXG4gKiB3ZWxsLWZvcm1lZCBVUkkgcmVmZXJlbmNlIGludG8gaXRzIGNvbXBvbmVudHMuXG4gKlxuICogPHByZT5cbiAqIF4oKFteOi8/I10rKTopPygvLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT9cbiAqICAxMiAgICAgICAgICAgIDMgIDQgICAgICAgICAgNSAgICAgICA2ICA3ICAgICAgICA4IDlcbiAqIDwvcHJlPlxuICpcbiAqIFRoZSBudW1iZXJzIGluIHRoZSBzZWNvbmQgbGluZSBhYm92ZSBhcmUgb25seSB0byBhc3Npc3QgcmVhZGFiaWxpdHk7IHRoZXlcbiAqIGluZGljYXRlIHRoZSByZWZlcmVuY2UgcG9pbnRzIGZvciBlYWNoIHN1YmV4cHJlc3Npb24gKGkuZS4sIGVhY2ggcGFpcmVkXG4gKiBwYXJlbnRoZXNpcykuIFdlIHJlZmVyIHRvIHRoZSB2YWx1ZSBtYXRjaGVkIGZvciBzdWJleHByZXNzaW9uIDxuPiBhcyAkPG4+LlxuICogRm9yIGV4YW1wbGUsIG1hdGNoaW5nIHRoZSBhYm92ZSBleHByZXNzaW9uIHRvXG4gKiA8cHJlPlxuICogICAgIGh0dHA6Ly93d3cuaWNzLnVjaS5lZHUvcHViL2lldGYvdXJpLyNSZWxhdGVkXG4gKiA8L3ByZT5cbiAqIHJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZyBzdWJleHByZXNzaW9uIG1hdGNoZXM6XG4gKiA8cHJlPlxuICogICAgJDEgPSBodHRwOlxuICogICAgJDIgPSBodHRwXG4gKiAgICAkMyA9IC8vd3d3Lmljcy51Y2kuZWR1XG4gKiAgICAkNCA9IHd3dy5pY3MudWNpLmVkdVxuICogICAgJDUgPSAvcHViL2lldGYvdXJpL1xuICogICAgJDYgPSA8dW5kZWZpbmVkPlxuICogICAgJDcgPSA8dW5kZWZpbmVkPlxuICogICAgJDggPSAjUmVsYXRlZFxuICogICAgJDkgPSBSZWxhdGVkXG4gKiA8L3ByZT5cbiAqIHdoZXJlIDx1bmRlZmluZWQ+IGluZGljYXRlcyB0aGF0IHRoZSBjb21wb25lbnQgaXMgbm90IHByZXNlbnQsIGFzIGlzIHRoZVxuICogY2FzZSBmb3IgdGhlIHF1ZXJ5IGNvbXBvbmVudCBpbiB0aGUgYWJvdmUgZXhhbXBsZS4gVGhlcmVmb3JlLCB3ZSBjYW5cbiAqIGRldGVybWluZSB0aGUgdmFsdWUgb2YgdGhlIGZpdmUgY29tcG9uZW50cyBhc1xuICogPHByZT5cbiAqICAgIHNjaGVtZSAgICA9ICQyXG4gKiAgICBhdXRob3JpdHkgPSAkNFxuICogICAgcGF0aCAgICAgID0gJDVcbiAqICAgIHF1ZXJ5ICAgICA9ICQ3XG4gKiAgICBmcmFnbWVudCAgPSAkOVxuICogPC9wcmU+XG4gKlxuICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBoYXMgYmVlbiBtb2RpZmllZCBzbGlnaHRseSB0byBleHBvc2UgdGhlXG4gKiB1c2VySW5mbywgZG9tYWluLCBhbmQgcG9ydCBzZXBhcmF0ZWx5IGZyb20gdGhlIGF1dGhvcml0eS5cbiAqIFRoZSBtb2RpZmllZCB2ZXJzaW9uIHlpZWxkc1xuICogPHByZT5cbiAqICAgICQxID0gaHR0cCAgICAgICAgICAgICAgc2NoZW1lXG4gKiAgICAkMiA9IDx1bmRlZmluZWQ+ICAgICAgIHVzZXJJbmZvIC1cXFxuICogICAgJDMgPSB3d3cuaWNzLnVjaS5lZHUgICBkb21haW4gICAgIHwgYXV0aG9yaXR5XG4gKiAgICAkNCA9IDx1bmRlZmluZWQ+ICAgICAgIHBvcnQgICAgIC0vXG4gKiAgICAkNSA9IC9wdWIvaWV0Zi91cmkvICAgIHBhdGhcbiAqICAgICQ2ID0gPHVuZGVmaW5lZD4gICAgICAgcXVlcnkgd2l0aG91dCA/XG4gKiAgICAkNyA9IFJlbGF0ZWQgICAgICAgICAgIGZyYWdtZW50IHdpdGhvdXQgI1xuICogPC9wcmU+XG4gKiBcXEBpbnRlcm5hbFxuICovXG52YXIgX3NwbGl0UmUgPSBuZXcgUmVnRXhwKCdeJyArXG4gICAgJyg/OicgK1xuICAgICcoW146Lz8jLl0rKScgK1xuICAgIC8vIHVzZWQgYnkgb3RoZXIgVVJMIHBhcnRzIHN1Y2ggYXMgOixcbiAgICAvLyA/LCAvLCAjLCBhbmQgLlxuICAgICc6KT8nICtcbiAgICAnKD86Ly8nICtcbiAgICAnKD86KFteLz8jXSopQCk/JyArXG4gICAgJyhbXFxcXHdcXFxcZFxcXFwtXFxcXHUwMTAwLVxcXFx1ZmZmZi4lXSopJyArXG4gICAgLy8gZGlnaXRzLCBkYXNoZXMsIGRvdHMsIHBlcmNlbnRcbiAgICAvLyBlc2NhcGVzLCBhbmQgdW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgICcoPzo6KFswLTldKykpPycgK1xuICAgICcpPycgK1xuICAgICcoW14/I10rKT8nICtcbiAgICAnKD86XFxcXD8oW14jXSopKT8nICtcbiAgICAnKD86IyguKikpPycgK1xuICAgICckJyk7XG52YXIgX0NvbXBvbmVudEluZGV4ID0ge307XG5fQ29tcG9uZW50SW5kZXguU2NoZW1lID0gMTtcbl9Db21wb25lbnRJbmRleC5Vc2VySW5mbyA9IDI7XG5fQ29tcG9uZW50SW5kZXguRG9tYWluID0gMztcbl9Db21wb25lbnRJbmRleC5Qb3J0ID0gNDtcbl9Db21wb25lbnRJbmRleC5QYXRoID0gNTtcbl9Db21wb25lbnRJbmRleC5RdWVyeURhdGEgPSA2O1xuX0NvbXBvbmVudEluZGV4LkZyYWdtZW50ID0gNztcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguU2NoZW1lXSA9IFwiU2NoZW1lXCI7XG5fQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4LlVzZXJJbmZvXSA9IFwiVXNlckluZm9cIjtcbl9Db21wb25lbnRJbmRleFtfQ29tcG9uZW50SW5kZXguRG9tYWluXSA9IFwiRG9tYWluXCI7XG5fQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4LlBvcnRdID0gXCJQb3J0XCI7XG5fQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4LlBhdGhdID0gXCJQYXRoXCI7XG5fQ29tcG9uZW50SW5kZXhbX0NvbXBvbmVudEluZGV4LlF1ZXJ5RGF0YV0gPSBcIlF1ZXJ5RGF0YVwiO1xuX0NvbXBvbmVudEluZGV4W19Db21wb25lbnRJbmRleC5GcmFnbWVudF0gPSBcIkZyYWdtZW50XCI7XG4vKipcbiAqIFNwbGl0cyBhIFVSSSBpbnRvIGl0cyBjb21wb25lbnQgcGFydHMuXG4gKlxuICogRWFjaCBjb21wb25lbnQgY2FuIGJlIGFjY2Vzc2VkIHZpYSB0aGUgY29tcG9uZW50IGluZGljZXM7IGZvciBleGFtcGxlOlxuICogPHByZT5cbiAqIGdvb2cudXJpLnV0aWxzLnNwbGl0KHNvbWVTdHIpW2dvb2cudXJpLnV0aWxzLkNvbXBvbnRlbnRJbmRleC5RVUVSWV9EQVRBXTtcbiAqIDwvcHJlPlxuICpcbiAqIEBwYXJhbSB7P30gdXJpIFRoZSBVUkkgc3RyaW5nIHRvIGV4YW1pbmUuXG4gKiBAcmV0dXJuIHs/fSBFYWNoIGNvbXBvbmVudCBzdGlsbCBVUkktZW5jb2RlZC5cbiAqICAgICBFYWNoIGNvbXBvbmVudCB0aGF0IGlzIHByZXNlbnQgd2lsbCBjb250YWluIHRoZSBlbmNvZGVkIHZhbHVlLCB3aGVyZWFzXG4gKiAgICAgY29tcG9uZW50cyB0aGF0IGFyZSBub3QgcHJlc2VudCB3aWxsIGJlIHVuZGVmaW5lZCBvciBlbXB0eSwgZGVwZW5kaW5nXG4gKiAgICAgb24gdGhlIGJyb3dzZXIncyByZWd1bGFyIGV4cHJlc3Npb24gaW1wbGVtZW50YXRpb24uICBOZXZlciBudWxsLCBzaW5jZVxuICogICAgIGFyYml0cmFyeSBzdHJpbmdzIG1heSBzdGlsbCBsb29rIGxpa2UgcGF0aCBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gX3NwbGl0KHVyaSkge1xuICAgIHJldHVybiB1cmkubWF0Y2goX3NwbGl0UmUpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGRvdCBzZWdtZW50cyBpbiBnaXZlbiBwYXRoIGNvbXBvbmVudCwgYXMgZGVzY3JpYmVkIGluXG4gKiBSRkMgMzk4Niwgc2VjdGlvbiA1LjIuNC5cbiAqXG4gKiBAcGFyYW0gez99IHBhdGggQSBub24tZW1wdHkgcGF0aCBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHs/fSBQYXRoIGNvbXBvbmVudCB3aXRoIHJlbW92ZWQgZG90IHNlZ21lbnRzLlxuICovXG5mdW5jdGlvbiBfcmVtb3ZlRG90U2VnbWVudHMocGF0aCkge1xuICAgIGlmIChwYXRoID09ICcvJylcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZWFkaW5nU2xhc2ggPSBwYXRoWzBdID09ICcvJyA/ICcvJyA6ICcnO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYWlsaW5nU2xhc2ggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJyA/ICcvJyA6ICcnO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG91dCA9IFtdO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwID0gMDtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHBvcyA9IDA7IHBvcyA8IHNlZ21lbnRzLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VnbWVudCA9IHNlZ21lbnRzW3Bvc107XG4gICAgICAgIHN3aXRjaCAoc2VnbWVudCkge1xuICAgICAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLi4nOlxuICAgICAgICAgICAgICAgIGlmIChvdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1cCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goc2VnbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlYWRpbmdTbGFzaCA9PSAnJykge1xuICAgICAgICB3aGlsZSAodXAtLSA+IDApIHtcbiAgICAgICAgICAgIG91dC51bnNoaWZ0KCcuLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgb3V0LnB1c2goJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlYWRpbmdTbGFzaCArIG91dC5qb2luKCcvJykgKyB0cmFpbGluZ1NsYXNoO1xufVxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiB0aGUgcGFydHMgZnJvbSBzcGxpdCBhbmQgY2Fub25pY2FsaXplcyB0aGUgcGF0aCBwYXJ0XG4gKiBhbmQgdGhlbiBqb2lucyBhbGwgdGhlIHBhcnRzLlxuICogQHBhcmFtIHs/fSBwYXJ0c1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGF0aCA9IHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICBwYXRoID0gcGF0aCA9PSBudWxsID8gJycgOiBfcmVtb3ZlRG90U2VnbWVudHMocGF0aCk7XG4gICAgcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdID0gcGF0aDtcbiAgICByZXR1cm4gX2J1aWxkRnJvbUVuY29kZWRQYXJ0cyhwYXJ0c1tfQ29tcG9uZW50SW5kZXguU2NoZW1lXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LlVzZXJJbmZvXSwgcGFydHNbX0NvbXBvbmVudEluZGV4LkRvbWFpbl0sIHBhcnRzW19Db21wb25lbnRJbmRleC5Qb3J0XSwgcGF0aCwgcGFydHNbX0NvbXBvbmVudEluZGV4LlF1ZXJ5RGF0YV0sIHBhcnRzW19Db21wb25lbnRJbmRleC5GcmFnbWVudF0pO1xufVxuLyoqXG4gKiBSZXNvbHZlcyBhIFVSTC5cbiAqIEBwYXJhbSB7P30gYmFzZSBUaGUgVVJMIGFjdGluZyBhcyB0aGUgYmFzZSBVUkwuXG4gKiBAcGFyYW0gez99IHVybFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmVVcmwoYmFzZSwgdXJsKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydHMgPSBfc3BsaXQoZW5jb2RlVVJJKHVybCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VQYXJ0cyA9IF9zcGxpdChiYXNlKTtcbiAgICBpZiAocGFydHNbX0NvbXBvbmVudEluZGV4LlNjaGVtZV0gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gX2pvaW5BbmRDYW5vbmljYWxpemVQYXRoKHBhcnRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5TY2hlbWVdO1xuICAgIH1cbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSBfQ29tcG9uZW50SW5kZXguU2NoZW1lOyBpIDw9IF9Db21wb25lbnRJbmRleC5Qb3J0OyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnRzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcnRzW2ldID0gYmFzZVBhcnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0c1tfQ29tcG9uZW50SW5kZXguUGF0aF1bMF0gPT0gJy8nKSB7XG4gICAgICAgIHJldHVybiBfam9pbkFuZENhbm9uaWNhbGl6ZVBhdGgocGFydHMpO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXRoID0gYmFzZVBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXTtcbiAgICBpZiAocGF0aCA9PSBudWxsKVxuICAgICAgICBwYXRoID0gJy8nO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBpbmRleCArIDEpICsgcGFydHNbX0NvbXBvbmVudEluZGV4LlBhdGhdO1xuICAgIHBhcnRzW19Db21wb25lbnRJbmRleC5QYXRoXSA9IHBhdGg7XG4gICAgcmV0dXJuIF9qb2luQW5kQ2Fub25pY2FsaXplUGF0aChwYXJ0cyk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgRGlyZWN0aXZlTm9ybWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfcmVzb3VyY2VMb2FkZXJcbiAgICAgKiBAcGFyYW0gez99IF91cmxSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX2h0bWxQYXJzZXJcbiAgICAgKiBAcGFyYW0gez99IF9jb25maWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaXJlY3RpdmVOb3JtYWxpemVyKF9yZXNvdXJjZUxvYWRlciwgX3VybFJlc29sdmVyLCBfaHRtbFBhcnNlciwgX2NvbmZpZykge1xuICAgICAgICB0aGlzLl9yZXNvdXJjZUxvYWRlciA9IF9yZXNvdXJjZUxvYWRlcjtcbiAgICAgICAgdGhpcy5fdXJsUmVzb2x2ZXIgPSBfdXJsUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmNsZWFyKCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub3JtYWxpemVkRGlyZWN0aXZlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5jbGVhckNhY2hlRm9yID0gZnVuY3Rpb24gKG5vcm1hbGl6ZWREaXJlY3RpdmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFub3JtYWxpemVkRGlyZWN0aXZlLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5kZWxldGUobm9ybWFsaXplZERpcmVjdGl2ZS50ZW1wbGF0ZS50ZW1wbGF0ZVVybCk7XG4gICAgICAgIG5vcm1hbGl6ZWREaXJlY3RpdmUudGVtcGxhdGUuZXh0ZXJuYWxTdHlsZXNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZXNoZWV0KSB7IF90aGlzLl9yZXNvdXJjZUxvYWRlckNhY2hlLmRlbGV0ZShzdHlsZXNoZWV0Lm1vZHVsZVVybCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLl9mZXRjaCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5nZXQodXJsKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX3Jlc291cmNlTG9hZGVyLmdldCh1cmwpO1xuICAgICAgICAgICAgdGhpcy5fcmVzb3VyY2VMb2FkZXJDYWNoZS5zZXQodXJsLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByZW5vcm1EYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVUZW1wbGF0ZSA9IGZ1bmN0aW9uIChwcmVub3JtRGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3JtYWxpemVkVGVtcGxhdGVTeW5jID0gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9ybWFsaXplZFRlbXBsYXRlQXN5bmM7XG4gICAgICAgIGlmIChwcmVub3JtRGF0YS50ZW1wbGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocHJlbm9ybURhdGEudGVtcGxhdGVVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiJ1wiICsgybVzdHJpbmdpZnkocHJlbm9ybURhdGEuY29tcG9uZW50VHlwZSkgKyBcIicgY29tcG9uZW50IGNhbm5vdCBkZWZpbmUgYm90aCB0ZW1wbGF0ZSBhbmQgdGVtcGxhdGVVcmxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZW5vcm1EYXRhLnRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiVGhlIHRlbXBsYXRlIHNwZWNpZmllZCBmb3IgY29tcG9uZW50IFwiICsgybVzdHJpbmdpZnkocHJlbm9ybURhdGEuY29tcG9uZW50VHlwZSkgKyBcIiBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtYWxpemVkVGVtcGxhdGVTeW5jID0gdGhpcy5ub3JtYWxpemVUZW1wbGF0ZVN5bmMocHJlbm9ybURhdGEpO1xuICAgICAgICAgICAgbm9ybWFsaXplZFRlbXBsYXRlQXN5bmMgPSBQcm9taXNlLnJlc29sdmUobm9ybWFsaXplZFRlbXBsYXRlU3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlbm9ybURhdGEudGVtcGxhdGVVcmwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlbm9ybURhdGEudGVtcGxhdGVVcmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJUaGUgdGVtcGxhdGVVcmwgc3BlY2lmaWVkIGZvciBjb21wb25lbnQgXCIgKyDJtXN0cmluZ2lmeShwcmVub3JtRGF0YS5jb21wb25lbnRUeXBlKSArIFwiIGlzIG5vdCBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vcm1hbGl6ZWRUZW1wbGF0ZUFzeW5jID0gdGhpcy5ub3JtYWxpemVUZW1wbGF0ZUFzeW5jKHByZW5vcm1EYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKFwiTm8gdGVtcGxhdGUgc3BlY2lmaWVkIGZvciBjb21wb25lbnQgXCIgKyDJtXN0cmluZ2lmeShwcmVub3JtRGF0YS5jb21wb25lbnRUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMgJiYgbm9ybWFsaXplZFRlbXBsYXRlU3luYy5zdHlsZVVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBzeW5jIGNhc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3luY0FzeW5jUmVzdWx0KG5vcm1hbGl6ZWRUZW1wbGF0ZVN5bmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYXN5bmMgY2FzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW5jQXN5bmNSZXN1bHQobnVsbCwgbm9ybWFsaXplZFRlbXBsYXRlQXN5bmMudGhlbihmdW5jdGlvbiAobm9ybWFsaXplZFRlbXBsYXRlKSB7IHJldHVybiBfdGhpcy5ub3JtYWxpemVFeHRlcm5hbFN0eWxlc2hlZXRzKG5vcm1hbGl6ZWRUZW1wbGF0ZSk7IH0pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcmVub21EYXRhXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVUZW1wbGF0ZVN5bmMgPSBmdW5jdGlvbiAocHJlbm9tRGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVMb2FkZWRUZW1wbGF0ZShwcmVub21EYXRhLCBwcmVub21EYXRhLnRlbXBsYXRlLCBwcmVub21EYXRhLm1vZHVsZVVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByZW5vbURhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZVRlbXBsYXRlQXN5bmMgPSBmdW5jdGlvbiAocHJlbm9tRGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZVVybCA9IHRoaXMuX3VybFJlc29sdmVyLnJlc29sdmUocHJlbm9tRGF0YS5tb2R1bGVVcmwsIHByZW5vbURhdGEudGVtcGxhdGVVcmwpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2godGVtcGxhdGVVcmwpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLm5vcm1hbGl6ZUxvYWRlZFRlbXBsYXRlKHByZW5vbURhdGEsIHZhbHVlLCB0ZW1wbGF0ZVVybCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcmVub3JtRGF0YVxuICAgICAqIEBwYXJhbSB7P30gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlQWJzVXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVOb3JtYWxpemVyLnByb3RvdHlwZS5ub3JtYWxpemVMb2FkZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChwcmVub3JtRGF0YSwgdGVtcGxhdGUsIHRlbXBsYXRlQWJzVXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzSW5saW5lID0gISFwcmVub3JtRGF0YS50ZW1wbGF0ZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW50ZXJwb2xhdGlvbkNvbmZpZyA9IEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5KHByZW5vcm1EYXRhLmludGVycG9sYXRpb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByb290Tm9kZXNBbmRFcnJvcnMgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZVNvdXJjZVVybCh7IHJlZmVyZW5jZTogcHJlbm9ybURhdGEubmdNb2R1bGVUeXBlIH0sIHsgdHlwZTogeyByZWZlcmVuY2U6IHByZW5vcm1EYXRhLmNvbXBvbmVudFR5cGUgfSB9LCB7IGlzSW5saW5lOiBpc0lubGluZSwgdGVtcGxhdGVVcmw6IHRlbXBsYXRlQWJzVXJsIH0pLCB0cnVlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKHJvb3ROb2Rlc0FuZEVycm9ycy5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JTdHJpbmcgPSByb290Tm9kZXNBbmRFcnJvcnMuZXJyb3JzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IoXCJUZW1wbGF0ZSBwYXJzZSBlcnJvcnM6XFxuXCIgKyBlcnJvclN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVNZXRhZGF0YVN0eWxlcyA9IHRoaXMubm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7XG4gICAgICAgICAgICBzdHlsZXM6IHByZW5vcm1EYXRhLnN0eWxlcyxcbiAgICAgICAgICAgIHN0eWxlVXJsczogcHJlbm9ybURhdGEuc3R5bGVVcmxzLFxuICAgICAgICAgICAgbW9kdWxlVXJsOiBwcmVub3JtRGF0YS5tb2R1bGVVcmxcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdG9yID0gbmV3IFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yKCk7XG4gICAgICAgIHZpc2l0QWxsKHZpc2l0b3IsIHJvb3ROb2Rlc0FuZEVycm9ycy5yb290Tm9kZXMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZVN0eWxlcyA9IHRoaXMubm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7IHN0eWxlczogdmlzaXRvci5zdHlsZXMsIHN0eWxlVXJsczogdmlzaXRvci5zdHlsZVVybHMsIG1vZHVsZVVybDogdGVtcGxhdGVBYnNVcmwgfSkpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbmNhcHN1bGF0aW9uID0gcHJlbm9ybURhdGEuZW5jYXBzdWxhdGlvbjtcbiAgICAgICAgaWYgKGVuY2Fwc3VsYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbiA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXMgPSB0ZW1wbGF0ZU1ldGFkYXRhU3R5bGVzLnN0eWxlcy5jb25jYXQodGVtcGxhdGVTdHlsZXMuc3R5bGVzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3R5bGVVcmxzID0gdGVtcGxhdGVNZXRhZGF0YVN0eWxlcy5zdHlsZVVybHMuY29uY2F0KHRlbXBsYXRlU3R5bGVzLnN0eWxlVXJscyk7XG4gICAgICAgIGlmIChlbmNhcHN1bGF0aW9uID09PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCAmJiBzdHlsZXMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICBzdHlsZVVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uID0gVmlld0VuY2Fwc3VsYXRpb24uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogdGVtcGxhdGVBYnNVcmwsIHN0eWxlczogc3R5bGVzLCBzdHlsZVVybHM6IHN0eWxlVXJscyxcbiAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogdmlzaXRvci5uZ0NvbnRlbnRTZWxlY3RvcnMsXG4gICAgICAgICAgICBhbmltYXRpb25zOiBwcmVub3JtRGF0YS5hbmltYXRpb25zLFxuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogcHJlbm9ybURhdGEuaW50ZXJwb2xhdGlvbiwgaXNJbmxpbmU6IGlzSW5saW5lXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZU1ldGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZU5vcm1hbGl6ZXIucHJvdG90eXBlLm5vcm1hbGl6ZUV4dGVybmFsU3R5bGVzaGVldHMgPSBmdW5jdGlvbiAodGVtcGxhdGVNZXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkTWlzc2luZ0V4dGVybmFsU3R5bGVzaGVldHModGVtcGxhdGVNZXRhLnN0eWxlVXJscylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChleHRlcm5hbFN0eWxlc2hlZXRzKSB7IHJldHVybiBuZXcgQ29tcGlsZVRlbXBsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogdGVtcGxhdGVNZXRhLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGVNZXRhLnRlbXBsYXRlLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6IHRlbXBsYXRlTWV0YS50ZW1wbGF0ZVVybCxcbiAgICAgICAgICAgIHN0eWxlczogdGVtcGxhdGVNZXRhLnN0eWxlcyxcbiAgICAgICAgICAgIHN0eWxlVXJsczogdGVtcGxhdGVNZXRhLnN0eWxlVXJscyxcbiAgICAgICAgICAgIGV4dGVybmFsU3R5bGVzaGVldHM6IGV4dGVybmFsU3R5bGVzaGVldHMsXG4gICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IHRlbXBsYXRlTWV0YS5uZ0NvbnRlbnRTZWxlY3RvcnMsXG4gICAgICAgICAgICBhbmltYXRpb25zOiB0ZW1wbGF0ZU1ldGEuYW5pbWF0aW9ucyxcbiAgICAgICAgICAgIGludGVycG9sYXRpb246IHRlbXBsYXRlTWV0YS5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAgICAgaXNJbmxpbmU6IHRlbXBsYXRlTWV0YS5pc0lubGluZSxcbiAgICAgICAgfSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZVVybHNcbiAgICAgKiBAcGFyYW0gez89fSBsb2FkZWRTdHlsZXNoZWV0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUuX2xvYWRNaXNzaW5nRXh0ZXJuYWxTdHlsZXNoZWV0cyA9IGZ1bmN0aW9uIChzdHlsZVVybHMsIGxvYWRlZFN0eWxlc2hlZXRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChsb2FkZWRTdHlsZXNoZWV0cyA9PT0gdm9pZCAwKSB7IGxvYWRlZFN0eWxlc2hlZXRzID0gbmV3IE1hcCgpOyB9XG4gICAgICAgIHJldHVybiBQcm9taXNlXG4gICAgICAgICAgICAuYWxsKHN0eWxlVXJscy5maWx0ZXIoZnVuY3Rpb24gKHN0eWxlVXJsKSB7IHJldHVybiAhbG9hZGVkU3R5bGVzaGVldHMuaGFzKHN0eWxlVXJsKTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN0eWxlVXJsKSB7IHJldHVybiBfdGhpcy5fZmV0Y2goc3R5bGVVcmwpLnRoZW4oZnVuY3Rpb24gKGxvYWRlZFN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXNoZWV0ID0gX3RoaXMubm9ybWFsaXplU3R5bGVzaGVldChuZXcgQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YSh7IHN0eWxlczogW2xvYWRlZFN0eWxlXSwgbW9kdWxlVXJsOiBzdHlsZVVybCB9KSk7XG4gICAgICAgICAgICBsb2FkZWRTdHlsZXNoZWV0cy5zZXQoc3R5bGVVcmwsIHN0eWxlc2hlZXQpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9sb2FkTWlzc2luZ0V4dGVybmFsU3R5bGVzaGVldHMoc3R5bGVzaGVldC5zdHlsZVVybHMsIGxvYWRlZFN0eWxlc2hlZXRzKTtcbiAgICAgICAgfSk7IH0pKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKF8pIHsgcmV0dXJuIEFycmF5LmZyb20obG9hZGVkU3R5bGVzaGVldHMudmFsdWVzKCkpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzaGVldFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplci5wcm90b3R5cGUubm9ybWFsaXplU3R5bGVzaGVldCA9IGZ1bmN0aW9uIChzdHlsZXNoZWV0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFsbFN0eWxlVXJscyA9IHN0eWxlc2hlZXQuc3R5bGVVcmxzLmZpbHRlcihpc1N0eWxlVXJsUmVzb2x2YWJsZSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gX3RoaXMuX3VybFJlc29sdmVyLnJlc29sdmUoc3R5bGVzaGVldC5tb2R1bGVVcmwsIHVybCk7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxTdHlsZXMgPSBzdHlsZXNoZWV0LnN0eWxlcy5tYXAoZnVuY3Rpb24gKHN0eWxlJCQxKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZVdpdGhJbXBvcnRzID0gZXh0cmFjdFN0eWxlVXJscyhfdGhpcy5fdXJsUmVzb2x2ZXIsIHN0eWxlc2hlZXQubW9kdWxlVXJsLCBzdHlsZSQkMSk7XG4gICAgICAgICAgICBhbGxTdHlsZVVybHMucHVzaC5hcHBseShhbGxTdHlsZVVybHMsIHN0eWxlV2l0aEltcG9ydHMuc3R5bGVVcmxzKTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZVdpdGhJbXBvcnRzLnN0eWxlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHsgc3R5bGVzOiBhbGxTdHlsZXMsIHN0eWxlVXJsczogYWxsU3R5bGVVcmxzLCBtb2R1bGVVcmw6IHN0eWxlc2hlZXQubW9kdWxlVXJsIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERpcmVjdGl2ZU5vcm1hbGl6ZXI7XG59KCkpO1xuRGlyZWN0aXZlTm9ybWFsaXplci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5EaXJlY3RpdmVOb3JtYWxpemVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogUmVzb3VyY2VMb2FkZXIsIH0sXG4gICAgeyB0eXBlOiBVcmxSZXNvbHZlciwgfSxcbiAgICB7IHR5cGU6IEh0bWxQYXJzZXIsIH0sXG4gICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbl07IH07XG52YXIgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yKCkge1xuICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IFtdO1xuICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEVsZW1lbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXBhcnNlZEVsZW1lbnQgPSBwcmVwYXJzZUVsZW1lbnQoYXN0KTtcbiAgICAgICAgc3dpdGNoIChwcmVwYXJzZWRFbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZ05vbkJpbmRhYmxlU3RhY2tDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuc2VsZWN0QXR0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRTpcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZXh0Q29udGVudF8xID0gJyc7XG4gICAgICAgICAgICAgICAgYXN0LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50XzEgKz0gY2hpbGQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKHRleHRDb250ZW50XzEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUOlxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVVcmxzLnB1c2gocHJlcGFyc2VkRWxlbWVudC5ocmVmQXR0cik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50Lm5vbkJpbmRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLm5nTm9uQmluZGFibGVTdGFja0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQubm9uQmluZGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMubmdOb25CaW5kYWJsZVN0YWNrQ291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHBhbnNpb24gPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHZpc2l0QWxsKHRoaXMsIGFzdC5jYXNlcyk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cGFuc2lvbkNhc2UgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGFzdC5leHByZXNzaW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUZW1wbGF0ZVByZXBhcnNlVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0QXR0cmlidXRlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGVtcGxhdGVQcmVwYXJzZVZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgcmV0dXJuIFRlbXBsYXRlUHJlcGFyc2VWaXNpdG9yO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfX2Fzc2lnbiA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduKSB8fCBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGZvciAodmFyIHAgaW4gcylcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBEaXJlY3RpdmVSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gX3JlZmxlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERpcmVjdGl2ZVJlc29sdmVyKF9yZWZsZWN0b3IpIHtcbiAgICAgICAgaWYgKF9yZWZsZWN0b3IgPT09IHZvaWQgMCkgeyBfcmVmbGVjdG9yID0gybVyZWZsZWN0b3I7IH1cbiAgICAgICAgdGhpcy5fcmVmbGVjdG9yID0gX3JlZmxlY3RvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuaXNEaXJlY3RpdmUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlTWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMocmVzb2x2ZUZvcndhcmRSZWYodHlwZSkpO1xuICAgICAgICByZXR1cm4gdHlwZU1ldGFkYXRhICYmIHR5cGVNZXRhZGF0YS5zb21lKGlzRGlyZWN0aXZlTWV0YWRhdGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHtcXEBsaW5rIERpcmVjdGl2ZX0gZm9yIGEgZ2l2ZW4gYFR5cGVgLlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHRocm93SWZOb3RGb3VuZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodHlwZSwgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVNZXRhZGF0YSA9IHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyhyZXNvbHZlRm9yd2FyZFJlZih0eXBlKSk7XG4gICAgICAgIGlmICh0eXBlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGFkYXRhID0gZmluZExhc3QodHlwZU1ldGFkYXRhLCBpc0RpcmVjdGl2ZU1ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3BlcnR5TWV0YWRhdGEgPSB0aGlzLl9yZWZsZWN0b3IucHJvcE1ldGFkYXRhKHR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXJnZVdpdGhQcm9wZXJ0eU1ldGFkYXRhKG1ldGFkYXRhLCBwcm9wZXJ0eU1ldGFkYXRhLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBEaXJlY3RpdmUgYW5ub3RhdGlvbiBmb3VuZCBvbiBcIiArIMm1c3RyaW5naWZ5KHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZG1cbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5TWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERpcmVjdGl2ZVJlc29sdmVyLnByb3RvdHlwZS5fbWVyZ2VXaXRoUHJvcGVydHlNZXRhZGF0YSA9IGZ1bmN0aW9uIChkbSwgcHJvcGVydHlNZXRhZGF0YSwgZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0ID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJpZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcGVydHlNZXRhZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlucHV0ID0gZmluZExhc3QocHJvcGVydHlNZXRhZGF0YVtwcm9wTmFtZV0sIGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIGluc3RhbmNlb2YgSW5wdXQ7IH0pO1xuICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmJpbmRpbmdQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnB1c2gocHJvcE5hbWUgKyBcIjogXCIgKyBpbnB1dC5iaW5kaW5nUHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0cy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXQgPSBmaW5kTGFzdChwcm9wZXJ0eU1ldGFkYXRhW3Byb3BOYW1lXSwgZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgaW5zdGFuY2VvZiBPdXRwdXQ7IH0pO1xuICAgICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuYmluZGluZ1Byb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocHJvcE5hbWUgKyBcIjogXCIgKyBvdXRwdXQuYmluZGluZ1Byb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RCaW5kaW5ncyA9IHByb3BlcnR5TWV0YWRhdGFbcHJvcE5hbWVdLmZpbHRlcihmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSAmJiBhIGluc3RhbmNlb2YgSG9zdEJpbmRpbmc7IH0pO1xuICAgICAgICAgICAgaG9zdEJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RCaW5kaW5nLmhvc3RQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhcnRXaXRoID0gaG9zdEJpbmRpbmcuaG9zdFByb3BlcnR5TmFtZVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0V2l0aCA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJASG9zdEJpbmRpbmcgY2FuIG5vdCBiaW5kIHRvIGV2ZW50cy4gVXNlIEBIb3N0TGlzdGVuZXIgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRXaXRoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkBIb3N0QmluZGluZyBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgcHJvcGVydHkgbmFtZSwgJ2NsYXNzLjxuYW1lPicsIG9yICdhdHRyLjxuYW1lPicuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhvc3RbXCJbXCIgKyBob3N0QmluZGluZy5ob3N0UHJvcGVydHlOYW1lICsgXCJdXCJdID0gcHJvcE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBob3N0W1wiW1wiICsgcHJvcE5hbWUgKyBcIl1cIl0gPSBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RMaXN0ZW5lcnMgPSBwcm9wZXJ0eU1ldGFkYXRhW3Byb3BOYW1lXS5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEgJiYgYSBpbnN0YW5jZW9mIEhvc3RMaXN0ZW5lcjsgfSk7XG4gICAgICAgICAgICBob3N0TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSBob3N0TGlzdGVuZXIuYXJncyB8fCBbXTtcbiAgICAgICAgICAgICAgICBob3N0W1wiKFwiICsgaG9zdExpc3RlbmVyLmV2ZW50TmFtZSArIFwiKVwiXSA9IHByb3BOYW1lICsgXCIoXCIgKyBhcmdzLmpvaW4oJywnKSArIFwiKVwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeSA9IGZpbmRMYXN0KHByb3BlcnR5TWV0YWRhdGFbcHJvcE5hbWVdLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSBpbnN0YW5jZW9mIFF1ZXJ5OyB9KTtcbiAgICAgICAgICAgIGlmIChxdWVyeSkge1xuICAgICAgICAgICAgICAgIHF1ZXJpZXNbcHJvcE5hbWVdID0gcXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVyZ2UoZG0sIGlucHV0cywgb3V0cHV0cywgaG9zdCwgcXVlcmllcywgZGlyZWN0aXZlVHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlZlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLl9leHRyYWN0UHVibGljTmFtZSA9IGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuIHNwbGl0QXRDb2xvbihkZWYsIFtudWxsLCBkZWZdKVsxXS50cmltKCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBiaW5kaW5nc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIucHJvdG90eXBlLl9kZWR1cGVCaW5kaW5ncyA9IGZ1bmN0aW9uIChiaW5kaW5ncykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmV2ZXJzZWRSZXN1bHQgPSBbXTtcbiAgICAgICAgLy8gZ28gbGFzdCB0byBmaXJzdCB0byBhbGxvdyBsYXRlciBlbnRyaWVzIHRvIG92ZXJ3cml0ZSBwcmV2aW91cyBlbnRyaWVzXG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IGJpbmRpbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gdGhpcy5fZXh0cmFjdFB1YmxpY05hbWUoYmluZGluZyk7XG4gICAgICAgICAgICBpZiAoIW5hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIG5hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICByZXZlcnNlZFJlc3VsdC5wdXNoKGJpbmRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXZlcnNlZFJlc3VsdC5yZXZlcnNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZVxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRzXG4gICAgICogQHBhcmFtIHs/fSBvdXRwdXRzXG4gICAgICogQHBhcmFtIHs/fSBob3N0XG4gICAgICogQHBhcmFtIHs/fSBxdWVyaWVzXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEaXJlY3RpdmVSZXNvbHZlci5wcm90b3R5cGUuX21lcmdlID0gZnVuY3Rpb24gKGRpcmVjdGl2ZSwgaW5wdXRzLCBvdXRwdXRzLCBob3N0LCBxdWVyaWVzLCBkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lcmdlZElucHV0cyA9IHRoaXMuX2RlZHVwZUJpbmRpbmdzKGRpcmVjdGl2ZS5pbnB1dHMgPyBkaXJlY3RpdmUuaW5wdXRzLmNvbmNhdChpbnB1dHMpIDogaW5wdXRzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVyZ2VkT3V0cHV0cyA9IHRoaXMuX2RlZHVwZUJpbmRpbmdzKGRpcmVjdGl2ZS5vdXRwdXRzID8gZGlyZWN0aXZlLm91dHB1dHMuY29uY2F0KG91dHB1dHMpIDogb3V0cHV0cyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lcmdlZEhvc3QgPSBkaXJlY3RpdmUuaG9zdCA/IF9fYXNzaWduKHt9LCBkaXJlY3RpdmUuaG9zdCwgaG9zdCkgOiBob3N0O1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXJnZWRRdWVyaWVzID0gZGlyZWN0aXZlLnF1ZXJpZXMgPyBfX2Fzc2lnbih7fSwgZGlyZWN0aXZlLnF1ZXJpZXMsIHF1ZXJpZXMpIDogcXVlcmllcztcbiAgICAgICAgaWYgKGRpcmVjdGl2ZSBpbnN0YW5jZW9mIENvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnQoe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBkaXJlY3RpdmUuc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBtZXJnZWRJbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogbWVyZ2VkT3V0cHV0cyxcbiAgICAgICAgICAgICAgICBob3N0OiBtZXJnZWRIb3N0LFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBkaXJlY3RpdmUuZXhwb3J0QXMsXG4gICAgICAgICAgICAgICAgbW9kdWxlSWQ6IGRpcmVjdGl2ZS5tb2R1bGVJZCxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiBtZXJnZWRRdWVyaWVzLFxuICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogZGlyZWN0aXZlLmNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IGRpcmVjdGl2ZS5wcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgdmlld1Byb3ZpZGVyczogZGlyZWN0aXZlLnZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBkaXJlY3RpdmUuZW50cnlDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBkaXJlY3RpdmUudGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IGRpcmVjdGl2ZS50ZW1wbGF0ZVVybCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IGRpcmVjdGl2ZS5zdHlsZXMsXG4gICAgICAgICAgICAgICAgc3R5bGVVcmxzOiBkaXJlY3RpdmUuc3R5bGVVcmxzLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGRpcmVjdGl2ZS5lbmNhcHN1bGF0aW9uLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IGRpcmVjdGl2ZS5hbmltYXRpb25zLFxuICAgICAgICAgICAgICAgIGludGVycG9sYXRpb246IGRpcmVjdGl2ZS5pbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGlyZWN0aXZlKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogZGlyZWN0aXZlLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGlucHV0czogbWVyZ2VkSW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dHB1dHM6IG1lcmdlZE91dHB1dHMsXG4gICAgICAgICAgICAgICAgaG9zdDogbWVyZ2VkSG9zdCxcbiAgICAgICAgICAgICAgICBleHBvcnRBczogZGlyZWN0aXZlLmV4cG9ydEFzLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IG1lcmdlZFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBkaXJlY3RpdmUucHJvdmlkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERpcmVjdGl2ZVJlc29sdmVyO1xufSgpKTtcbkRpcmVjdGl2ZVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkRpcmVjdGl2ZVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogybVSZWZsZWN0b3JSZWFkZXIsIH0sXG5dOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IHR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzRGlyZWN0aXZlTWV0YWRhdGEodHlwZSkge1xuICAgIHJldHVybiB0eXBlIGluc3RhbmNlb2YgRGlyZWN0aXZlO1xufVxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHs/fSBhcnJcbiAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmaW5kTGFzdChhcnIsIGNvbmRpdGlvbikge1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY29uZGl0aW9uKGFycltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU1RSSVBfU1JDX0ZJTEVfU1VGRklYRVMgPSAvKFxcLnRzfFxcLmRcXC50c3xcXC5qc3xcXC5qc3h8XFwudHN4KSQvO1xudmFyIE5HX0ZBQ1RPUlkgPSAvXFwubmdmYWN0b3J5XFwuLztcbi8qKlxuICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbmdmYWN0b3J5RmlsZVBhdGgoZmlsZVBhdGgpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmxXaXRoU3VmZml4ID0gc3BsaXRUeXBlc2NyaXB0U3VmZml4KGZpbGVQYXRoKTtcbiAgICByZXR1cm4gdXJsV2l0aFN1ZmZpeFswXSArIFwiLm5nZmFjdG9yeVwiICsgdXJsV2l0aFN1ZmZpeFsxXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3RyaXBOZ0ZhY3RvcnkoZmlsZVBhdGgpIHtcbiAgICByZXR1cm4gZmlsZVBhdGgucmVwbGFjZShOR19GQUNUT1JZLCAnLicpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc05nRmFjdG9yeUZpbGUoZmlsZVBhdGgpIHtcbiAgICByZXR1cm4gTkdfRkFDVE9SWS50ZXN0KGZpbGVQYXRoKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwYXRoXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzcGxpdFR5cGVzY3JpcHRTdWZmaXgocGF0aCkge1xuICAgIGlmIChwYXRoLmVuZHNXaXRoKCcuZC50cycpKSB7XG4gICAgICAgIHJldHVybiBbcGF0aC5zbGljZSgwLCAtNSksICcudHMnXTtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdERvdCA9IHBhdGgubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAobGFzdERvdCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtwYXRoLnN1YnN0cmluZygwLCBsYXN0RG90KSwgcGF0aC5zdWJzdHJpbmcobGFzdERvdCldO1xuICAgIH1cbiAgICByZXR1cm4gW3BhdGgsICcnXTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBmaWxlTmFtZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gc3VtbWFyeUZpbGVOYW1lKGZpbGVOYW1lKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZU5hbWVXaXRob3V0U3VmZml4ID0gZmlsZU5hbWUucmVwbGFjZShTVFJJUF9TUkNfRklMRV9TVUZGSVhFUywgJycpO1xuICAgIHJldHVybiBmaWxlTmFtZVdpdGhvdXRTdWZmaXggKyBcIi5uZ3N1bW1hcnkuanNvblwiO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IGhvb2tcbiAqIEBwYXJhbSB7P30gdG9rZW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGhhc0xpZmVjeWNsZUhvb2soaG9vaywgdG9rZW4pIHtcbiAgICByZXR1cm4gybVyZWZsZWN0b3IuaGFzTGlmZWN5Y2xlSG9vayh0b2tlbiwgZ2V0SG9va05hbWUoaG9vaykpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGhvb2tcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tOYW1lKGhvb2spIHtcbiAgICBzd2l0Y2ggKGhvb2spIHtcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLk9uSW5pdDpcbiAgICAgICAgICAgIHJldHVybiAnbmdPbkluaXQnO1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuT25EZXN0cm95OlxuICAgICAgICAgICAgcmV0dXJuICduZ09uRGVzdHJveSc7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5Eb0NoZWNrOlxuICAgICAgICAgICAgcmV0dXJuICduZ0RvQ2hlY2snO1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuT25DaGFuZ2VzOlxuICAgICAgICAgICAgcmV0dXJuICduZ09uQ2hhbmdlcyc7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0OlxuICAgICAgICAgICAgcmV0dXJuICduZ0FmdGVyQ29udGVudEluaXQnO1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50Q2hlY2tlZDpcbiAgICAgICAgICAgIHJldHVybiAnbmdBZnRlckNvbnRlbnRDaGVja2VkJztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLkFmdGVyVmlld0luaXQ6XG4gICAgICAgICAgICByZXR1cm4gJ25nQWZ0ZXJWaWV3SW5pdCc7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdDaGVja2VkOlxuICAgICAgICAgICAgcmV0dXJuICduZ0FmdGVyVmlld0NoZWNrZWQnO1xuICAgIH1cbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSBvYmpcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9pc05nTW9kdWxlTWV0YWRhdGEob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE5nTW9kdWxlO1xufVxuLyoqXG4gKiBSZXNvbHZlcyB0eXBlcyB0byB7XFxAbGluayBOZ01vZHVsZX0uXG4gKi9cbnZhciBOZ01vZHVsZVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBfcmVmbGVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gTmdNb2R1bGVSZXNvbHZlcihfcmVmbGVjdG9yKSB7XG4gICAgICAgIGlmIChfcmVmbGVjdG9yID09PSB2b2lkIDApIHsgX3JlZmxlY3RvciA9IMm1cmVmbGVjdG9yOyB9XG4gICAgICAgIHRoaXMuX3JlZmxlY3RvciA9IF9yZWZsZWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTmdNb2R1bGVSZXNvbHZlci5wcm90b3R5cGUuaXNOZ01vZHVsZSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnModHlwZSkuc29tZShfaXNOZ01vZHVsZU1ldGFkYXRhKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSB0aHJvd0lmTm90Rm91bmRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAodHlwZSwgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlTWV0YSA9IGZpbmRMYXN0KHRoaXMuX3JlZmxlY3Rvci5hbm5vdGF0aW9ucyh0eXBlKSwgX2lzTmdNb2R1bGVNZXRhZGF0YSk7XG4gICAgICAgIGlmIChuZ01vZHVsZU1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZ01vZHVsZU1ldGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTmdNb2R1bGUgbWV0YWRhdGEgZm91bmQgZm9yICdcIiArIMm1c3RyaW5naWZ5KHR5cGUpICsgXCInLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTmdNb2R1bGVSZXNvbHZlcjtcbn0oKSk7XG5OZ01vZHVsZVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbk5nTW9kdWxlUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiDJtVJlZmxlY3RvclJlYWRlciwgfSxcbl07IH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEBwYXJhbSB7P30gdHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2lzUGlwZU1ldGFkYXRhKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSBpbnN0YW5jZW9mIFBpcGU7XG59XG4vKipcbiAqIFJlc29sdmUgYSBgVHlwZWAgZm9yIHtcXEBsaW5rIFBpcGV9LlxuICpcbiAqIFRoaXMgaW50ZXJmYWNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gY3JlYXRlIGN1c3RvbSBiZWhhdmlvci5cbiAqXG4gKiBTZWUge1xcQGxpbmsgQ29tcGlsZXJ9XG4gKi9cbnZhciBQaXBlUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IF9yZWZsZWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQaXBlUmVzb2x2ZXIoX3JlZmxlY3Rvcikge1xuICAgICAgICBpZiAoX3JlZmxlY3RvciA9PT0gdm9pZCAwKSB7IF9yZWZsZWN0b3IgPSDJtXJlZmxlY3RvcjsgfVxuICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBpcGVSZXNvbHZlci5wcm90b3R5cGUuaXNQaXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdHlwZU1ldGFkYXRhID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpKTtcbiAgICAgICAgcmV0dXJuIHR5cGVNZXRhZGF0YSAmJiB0eXBlTWV0YWRhdGEuc29tZShfaXNQaXBlTWV0YWRhdGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHtcXEBsaW5rIFBpcGV9IGZvciBhIGdpdmVuIGBUeXBlYC5cbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSB0aHJvd0lmTm90Rm91bmRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFBpcGVSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWV0YXMgPSB0aGlzLl9yZWZsZWN0b3IuYW5ub3RhdGlvbnMocmVzb2x2ZUZvcndhcmRSZWYodHlwZSkpO1xuICAgICAgICBpZiAobWV0YXMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFubm90YXRpb24gPSBmaW5kTGFzdChtZXRhcywgX2lzUGlwZU1ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFubm90YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUGlwZSBkZWNvcmF0b3IgZm91bmQgb24gXCIgKyDJtXN0cmluZ2lmeSh0eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gUGlwZVJlc29sdmVyO1xufSgpKTtcblBpcGVSZXNvbHZlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5QaXBlUmVzb2x2ZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiDJtVJlZmxlY3RvclJlYWRlciwgfSxcbl07IH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgU3VtbWFyeVJlc29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdW1tYXJ5UmVzb2x2ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZU5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuaXNMaWJyYXJ5RmlsZSA9IGZ1bmN0aW9uIChmaWxlTmFtZSkgeyByZXR1cm4gZmFsc2U7IH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZU5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuZ2V0TGlicmFyeUZpbGVOYW1lID0gZnVuY3Rpb24gKGZpbGVOYW1lKSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVmZXJlbmNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVTdW1tYXJ5ID0gZnVuY3Rpb24gKHJlZmVyZW5jZSkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRTeW1ib2xzT2YgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHsgcmV0dXJuIFtdOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVmZXJlbmNlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdW1tYXJ5UmVzb2x2ZXIucHJvdG90eXBlLmdldEltcG9ydEFzID0gZnVuY3Rpb24gKHJlZmVyZW5jZSkgeyByZXR1cm4gcmVmZXJlbmNlOyB9O1xuICAgIHJldHVybiBTdW1tYXJ5UmVzb2x2ZXI7XG59KCkpO1xuU3VtbWFyeVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cblN1bW1hcnlSZXNvbHZlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEVSUk9SX0NPTExFQ1RPUl9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbignRXJyb3JDb2xsZWN0b3InKTtcbnZhciBDb21waWxlTWV0YWRhdGFSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfY29uZmlnXG4gICAgICogQHBhcmFtIHs/fSBfbmdNb2R1bGVSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX2RpcmVjdGl2ZVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfcGlwZVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfc3VtbWFyeVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfc2NoZW1hUmVnaXN0cnlcbiAgICAgKiBAcGFyYW0gez99IF9kaXJlY3RpdmVOb3JtYWxpemVyXG4gICAgICogQHBhcmFtIHs/fSBfY29uc29sZVxuICAgICAqIEBwYXJhbSB7P30gX3N0YXRpY1N5bWJvbENhY2hlXG4gICAgICogQHBhcmFtIHs/PX0gX3JlZmxlY3RvclxuICAgICAqIEBwYXJhbSB7Pz19IF9lcnJvckNvbGxlY3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyKF9jb25maWcsIF9uZ01vZHVsZVJlc29sdmVyLCBfZGlyZWN0aXZlUmVzb2x2ZXIsIF9waXBlUmVzb2x2ZXIsIF9zdW1tYXJ5UmVzb2x2ZXIsIF9zY2hlbWFSZWdpc3RyeSwgX2RpcmVjdGl2ZU5vcm1hbGl6ZXIsIF9jb25zb2xlLCBfc3RhdGljU3ltYm9sQ2FjaGUsIF9yZWZsZWN0b3IsIF9lcnJvckNvbGxlY3Rvcikge1xuICAgICAgICBpZiAoX3JlZmxlY3RvciA9PT0gdm9pZCAwKSB7IF9yZWZsZWN0b3IgPSDJtXJlZmxlY3RvcjsgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZVJlc29sdmVyID0gX25nTW9kdWxlUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyID0gX2RpcmVjdGl2ZVJlc29sdmVyO1xuICAgICAgICB0aGlzLl9waXBlUmVzb2x2ZXIgPSBfcGlwZVJlc29sdmVyO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5UmVzb2x2ZXIgPSBfc3VtbWFyeVJlc29sdmVyO1xuICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlTm9ybWFsaXplciA9IF9kaXJlY3RpdmVOb3JtYWxpemVyO1xuICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgIHRoaXMuX3N0YXRpY1N5bWJvbENhY2hlID0gX3N0YXRpY1N5bWJvbENhY2hlO1xuICAgICAgICB0aGlzLl9yZWZsZWN0b3IgPSBfcmVmbGVjdG9yO1xuICAgICAgICB0aGlzLl9lcnJvckNvbGxlY3RvciA9IF9lcnJvckNvbGxlY3RvcjtcbiAgICAgICAgdGhpcy5fbm9uTm9ybWFsaXplZERpcmVjdGl2ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc3VtbWFyeUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9waXBlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSB0aGlzLl9kaXJlY3RpdmVDYWNoZS5nZXQodHlwZSk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdGhpcy5fbm9uTm9ybWFsaXplZERpcmVjdGl2ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdGhpcy5fc3VtbWFyeUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdGhpcy5fcGlwZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVPZlR5cGVzLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgLy8gQ2xlYXIgYWxsIG9mIHRoZSBOZ01vZHVsZSBhcyB0aGV5IGNvbnRhaW4gdHJhbnNpdGl2ZSBpbmZvcm1hdGlvbiFcbiAgICAgICAgdGhpcy5fbmdNb2R1bGVDYWNoZS5jbGVhcigpO1xuICAgICAgICBpZiAoZGlyTWV0YSkge1xuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aXZlTm9ybWFsaXplci5jbGVhckNhY2hlRm9yKGRpck1ldGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9ub25Ob3JtYWxpemVkRGlyZWN0aXZlQ2FjaGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fc3VtbWFyeUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3BpcGVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlT2ZUeXBlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVOb3JtYWxpemVyLmNsZWFyQ2FjaGUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYmFzZVR5cGVcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fY3JlYXRlUHJveHlDbGFzcyA9IGZ1bmN0aW9uIChiYXNlVHlwZSwgbmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3h5Q2xhc3MgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IENsYXNzIFwiICsgbmFtZSArIFwiIGZvciB0eXBlIFwiICsgybVzdHJpbmdpZnkoYmFzZVR5cGUpICsgXCIgaXMgbm90IGNvbXBpbGVkIHlldCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb3h5Q2xhc3Muc2V0RGVsZWdhdGUgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgZGVsZWdhdGUgPSBkO1xuICAgICAgICAgICAgKChwcm94eUNsYXNzKSkucHJvdG90eXBlID0gZC5wcm90b3R5cGU7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE1ha2Ugc3RyaW5naWZ5IHdvcmsgY29ycmVjdGx5XG4gICAgICAgICgocHJveHlDbGFzcykpLm92ZXJyaWRkZW5OYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIHByb3h5Q2xhc3M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpclR5cGVcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRHZW5lcmF0ZWRDbGFzcyA9IGZ1bmN0aW9uIChkaXJUeXBlLCBuYW1lKSB7XG4gICAgICAgIGlmIChkaXJUeXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGljU3ltYm9sQ2FjaGUuZ2V0KG5nZmFjdG9yeUZpbGVQYXRoKGRpclR5cGUuZmlsZVBhdGgpLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQcm94eUNsYXNzKGRpclR5cGUsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpclR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRDb21wb25lbnRWaWV3Q2xhc3MgPSBmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHZW5lcmF0ZWRDbGFzcyhkaXJUeXBlLCB2aWV3Q2xhc3NOYW1lKGRpclR5cGUsIDApKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldEhvc3RDb21wb25lbnRWaWV3Q2xhc3MgPSBmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHZW5lcmF0ZWRDbGFzcyhkaXJUeXBlLCBob3N0Vmlld0NsYXNzTmFtZShkaXJUeXBlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpclR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRIb3N0Q29tcG9uZW50VHlwZSA9IGZ1bmN0aW9uIChkaXJUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBpZGVudGlmaWVyTmFtZSh7IHJlZmVyZW5jZTogZGlyVHlwZSB9KSArIFwiX0hvc3RcIjtcbiAgICAgICAgaWYgKGRpclR5cGUgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0aWNTeW1ib2xDYWNoZS5nZXQoZGlyVHlwZS5maWxlUGF0aCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBIb3N0Q2xhc3MgPSAoZnVuY3Rpb24gSG9zdENsYXNzKCkgeyB9KTtcbiAgICAgICAgICAgIEhvc3RDbGFzcy5vdmVycmlkZGVuTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gSG9zdENsYXNzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpclR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRSZW5kZXJlclR5cGUgPSBmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICBpZiAoZGlyVHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRpY1N5bWJvbENhY2hlLmdldChuZ2ZhY3RvcnlGaWxlUGF0aChkaXJUeXBlLmZpbGVQYXRoKSwgcmVuZGVyZXJUeXBlTmFtZShkaXJUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgYW4gb2JqZWN0IGFzIHByb3h5LFxuICAgICAgICAgICAgLy8gdGhhdCB3ZSBmaWxsIGxhdGVyIGR1cmluZyBydW50aW1lIGNvbXBpbGF0aW9uLlxuICAgICAgICAgICAgcmV0dXJuICh7fSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGRpclR5cGVcbiAgICAgKiBAcGFyYW0gez99IGlucHV0c1xuICAgICAqIEBwYXJhbSB7P30gb3V0cHV0c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldENvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGRpclR5cGUsIGlucHV0cywgb3V0cHV0cykge1xuICAgICAgICBpZiAoZGlyVHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRpY1N5bWJvbENhY2hlLmdldChuZ2ZhY3RvcnlGaWxlUGF0aChkaXJUeXBlLmZpbGVQYXRoKSwgY29tcG9uZW50RmFjdG9yeU5hbWUoZGlyVHlwZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdFZpZXcgPSB0aGlzLmdldEhvc3RDb21wb25lbnRWaWV3Q2xhc3MoZGlyVHlwZSk7XG4gICAgICAgICAgICAvLyBOb3RlOiBuZ0NvbnRlbnRTZWxlY3RvcnMgd2lsbCBiZSBmaWxsZWQgbGF0ZXIgb25jZSB0aGUgdGVtcGxhdGUgaXNcbiAgICAgICAgICAgIC8vIGxvYWRlZC5cbiAgICAgICAgICAgIHJldHVybiDJtWNjZihzZWxlY3RvciwgZGlyVHlwZSwgLyoqIEB0eXBlIHs/fSAqLyAoaG9zdFZpZXcpLCBpbnB1dHMsIG91dHB1dHMsIFtdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmYWN0b3J5XG4gICAgICogQHBhcmFtIHs/fSBuZ0NvbnRlbnRTZWxlY3RvcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5pbml0Q29tcG9uZW50RmFjdG9yeSA9IGZ1bmN0aW9uIChmYWN0b3J5LCBuZ0NvbnRlbnRTZWxlY3RvcnMpIHtcbiAgICAgICAgaWYgKCEoZmFjdG9yeSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkpIHtcbiAgICAgICAgICAgIChfYSA9IGZhY3RvcnkubmdDb250ZW50U2VsZWN0b3JzKS5wdXNoLmFwcGx5KF9hLCBuZ0NvbnRlbnRTZWxlY3RvcnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30ga2luZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9sb2FkU3VtbWFyeSA9IGZ1bmN0aW9uICh0eXBlLCBraW5kKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVTdW1tYXJ5ID0gdGhpcy5fc3VtbWFyeUNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCF0eXBlU3VtbWFyeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeSA9IHRoaXMuX3N1bW1hcnlSZXNvbHZlci5yZXNvbHZlU3VtbWFyeSh0eXBlKTtcbiAgICAgICAgICAgIHR5cGVTdW1tYXJ5ID0gc3VtbWFyeSA/IHN1bW1hcnkudHlwZSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuc2V0KHR5cGUsIHR5cGVTdW1tYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZVN1bW1hcnkgJiYgdHlwZVN1bW1hcnkuc3VtbWFyeUtpbmQgPT09IGtpbmQgPyB0eXBlU3VtbWFyeSA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gaXNTeW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2xvYWREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUsIGRpcmVjdGl2ZVR5cGUsIGlzU3luYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aXZlQ2FjaGUuaGFzKGRpcmVjdGl2ZVR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGlyZWN0aXZlVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldE5vbk5vcm1hbGl6ZWREaXJlY3RpdmVNZXRhZGF0YShkaXJlY3RpdmVUeXBlKSwgYW5ub3RhdGlvbiA9IF9hLmFubm90YXRpb24sIG1ldGFkYXRhID0gX2EubWV0YWRhdGE7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNyZWF0ZURpcmVjdGl2ZU1ldGFkYXRhID0gZnVuY3Rpb24gKHRlbXBsYXRlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZWREaXJNZXRhID0gbmV3IENvbXBpbGVEaXJlY3RpdmVNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgdHlwZTogbWV0YWRhdGEudHlwZSxcbiAgICAgICAgICAgICAgICBpc0NvbXBvbmVudDogbWV0YWRhdGEuaXNDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IG1ldGFkYXRhLnNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGV4cG9ydEFzOiBtZXRhZGF0YS5leHBvcnRBcyxcbiAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IG1ldGFkYXRhLmNoYW5nZURldGVjdGlvbixcbiAgICAgICAgICAgICAgICBpbnB1dHM6IG1ldGFkYXRhLmlucHV0cyxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBtZXRhZGF0YS5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIGhvc3RMaXN0ZW5lcnM6IG1ldGFkYXRhLmhvc3RMaXN0ZW5lcnMsXG4gICAgICAgICAgICAgICAgaG9zdFByb3BlcnRpZXM6IG1ldGFkYXRhLmhvc3RQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIGhvc3RBdHRyaWJ1dGVzOiBtZXRhZGF0YS5ob3N0QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBwcm92aWRlcnM6IG1ldGFkYXRhLnByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzOiBtZXRhZGF0YS52aWV3UHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IG1ldGFkYXRhLnF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgdmlld1F1ZXJpZXM6IG1ldGFkYXRhLnZpZXdRdWVyaWVzLFxuICAgICAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50czogbWV0YWRhdGEuZW50cnlDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFZpZXdUeXBlOiBtZXRhZGF0YS5jb21wb25lbnRWaWV3VHlwZSxcbiAgICAgICAgICAgICAgICByZW5kZXJlclR5cGU6IG1ldGFkYXRhLnJlbmRlcmVyVHlwZSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRGYWN0b3J5OiBtZXRhZGF0YS5jb21wb25lbnRGYWN0b3J5LFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZU1ldGFkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5pdENvbXBvbmVudEZhY3RvcnkobWV0YWRhdGEuY29tcG9uZW50RmFjdG9yeSwgdGVtcGxhdGVNZXRhZGF0YS5uZ0NvbnRlbnRTZWxlY3RvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX2RpcmVjdGl2ZUNhY2hlLnNldChkaXJlY3RpdmVUeXBlLCBub3JtYWxpemVkRGlyTWV0YSk7XG4gICAgICAgICAgICBfdGhpcy5fc3VtbWFyeUNhY2hlLnNldChkaXJlY3RpdmVUeXBlLCBub3JtYWxpemVkRGlyTWV0YS50b1N1bW1hcnkoKSk7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZERpck1ldGE7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChtZXRhZGF0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVNZXRhID0gdGhpcy5fZGlyZWN0aXZlTm9ybWFsaXplci5ub3JtYWxpemVUZW1wbGF0ZSh7XG4gICAgICAgICAgICAgICAgbmdNb2R1bGVUeXBlOiBuZ01vZHVsZVR5cGUsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50VHlwZTogZGlyZWN0aXZlVHlwZSxcbiAgICAgICAgICAgICAgICBtb2R1bGVVcmw6IGNvbXBvbmVudE1vZHVsZVVybCh0aGlzLl9yZWZsZWN0b3IsIGRpcmVjdGl2ZVR5cGUsIGFubm90YXRpb24pLFxuICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IG1ldGFkYXRhLnRlbXBsYXRlLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IG1ldGFkYXRhLnRlbXBsYXRlLnRlbXBsYXRlLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiBtZXRhZGF0YS50ZW1wbGF0ZS50ZW1wbGF0ZVVybCxcbiAgICAgICAgICAgICAgICBzdHlsZXM6IG1ldGFkYXRhLnRlbXBsYXRlLnN0eWxlcyxcbiAgICAgICAgICAgICAgICBzdHlsZVVybHM6IG1ldGFkYXRhLnRlbXBsYXRlLnN0eWxlVXJscyxcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zOiBtZXRhZGF0YS50ZW1wbGF0ZS5hbmltYXRpb25zLFxuICAgICAgICAgICAgICAgIGludGVycG9sYXRpb246IG1ldGFkYXRhLnRlbXBsYXRlLmludGVycG9sYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlTWV0YS5zeW5jUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlRGlyZWN0aXZlTWV0YWRhdGEodGVtcGxhdGVNZXRhLnN5bmNSZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21wb25lbnRTdGlsbExvYWRpbmdFcnJvcihkaXJlY3RpdmVUeXBlKSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVNZXRhLmFzeW5jUmVzdWx0LnRoZW4oY3JlYXRlRGlyZWN0aXZlTWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZGlyZWN0aXZlXG4gICAgICAgICAgICBjcmVhdGVEaXJlY3RpdmVNZXRhZGF0YShudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXROb25Ob3JtYWxpemVkRGlyZWN0aXZlTWV0YWRhdGEgPSBmdW5jdGlvbiAoZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBkaXJlY3RpdmVUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWYoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIGlmICghZGlyZWN0aXZlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FjaGVFbnRyeSA9IHRoaXMuX25vbk5vcm1hbGl6ZWREaXJlY3RpdmVDYWNoZS5nZXQoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIGlmIChjYWNoZUVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVFbnRyeTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJNZXRhID0gdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIucmVzb2x2ZShkaXJlY3RpdmVUeXBlLCBmYWxzZSk7XG4gICAgICAgIGlmICghZGlyTWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGE7XG4gICAgICAgIGlmIChkaXJNZXRhIGluc3RhbmNlb2YgQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgIGFzc2VydEFycmF5T2ZTdHJpbmdzKCdzdHlsZXMnLCBkaXJNZXRhLnN0eWxlcyk7XG4gICAgICAgICAgICBhc3NlcnRBcnJheU9mU3RyaW5ncygnc3R5bGVVcmxzJywgZGlyTWV0YS5zdHlsZVVybHMpO1xuICAgICAgICAgICAgYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoJ2ludGVycG9sYXRpb24nLCBkaXJNZXRhLmludGVycG9sYXRpb24pO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYW5pbWF0aW9ucyA9IGRpck1ldGEuYW5pbWF0aW9ucztcbiAgICAgICAgICAgIG5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhID0gbmV3IENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBkaXJNZXRhLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IGRpck1ldGEudGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVVcmw6IGRpck1ldGEudGVtcGxhdGVVcmwsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBkaXJNZXRhLnN0eWxlcyxcbiAgICAgICAgICAgICAgICBzdHlsZVVybHM6IGRpck1ldGEuc3R5bGVVcmxzLFxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IGFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbjogZGlyTWV0YS5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAgICAgICAgIGlzSW5saW5lOiAhIWRpck1ldGEudGVtcGxhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gbnVsbDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld1Byb3ZpZGVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeUNvbXBvbmVudE1ldGFkYXRhID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdG9yID0gZGlyTWV0YS5zZWxlY3RvcjtcbiAgICAgICAgaWYgKGRpck1ldGEgaW5zdGFuY2VvZiBDb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIENvbXBvbmVudFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSBkaXJNZXRhLmNoYW5nZURldGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChkaXJNZXRhLnZpZXdQcm92aWRlcnMpIHtcbiAgICAgICAgICAgICAgICB2aWV3UHJvdmlkZXJzID0gdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEoZGlyTWV0YS52aWV3UHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudE1ldGFkYXRhLCBcInZpZXdQcm92aWRlcnMgZm9yIFxcXCJcIiArIHN0cmluZ2lmeVR5cGUoZGlyZWN0aXZlVHlwZSkgKyBcIlxcXCJcIiwgW10sIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpck1ldGEuZW50cnlDb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgZW50cnlDb21wb25lbnRNZXRhZGF0YSA9IGZsYXR0ZW5BbmREZWR1cGVBcnJheShkaXJNZXRhLmVudHJ5Q29tcG9uZW50cylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50TWV0YWRhdGEodHlwZSk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoZW50cnlDb21wb25lbnRNZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXREZWZhdWx0Q29tcG9uZW50RWxlbWVudE5hbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIERpcmVjdGl2ZVxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiRGlyZWN0aXZlIFwiICsgc3RyaW5naWZ5VHlwZShkaXJlY3RpdmVUeXBlKSArIFwiIGhhcyBubyBzZWxlY3RvciwgcGxlYXNlIGFkZCBpdCFcIiksIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJ2Vycm9yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKGRpck1ldGEucHJvdmlkZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHByb3ZpZGVycyA9IHRoaXMuX2dldFByb3ZpZGVyc01ldGFkYXRhKGRpck1ldGEucHJvdmlkZXJzLCBlbnRyeUNvbXBvbmVudE1ldGFkYXRhLCBcInByb3ZpZGVycyBmb3IgXFxcIlwiICsgc3RyaW5naWZ5VHlwZShkaXJlY3RpdmVUeXBlKSArIFwiXFxcIlwiLCBbXSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcmllcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UXVlcmllcyA9IFtdO1xuICAgICAgICBpZiAoZGlyTWV0YS5xdWVyaWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXJpZXMgPSB0aGlzLl9nZXRRdWVyaWVzTWV0YWRhdGEoZGlyTWV0YS5xdWVyaWVzLCBmYWxzZSwgZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICB2aWV3UXVlcmllcyA9IHRoaXMuX2dldFF1ZXJpZXNNZXRhZGF0YShkaXJNZXRhLnF1ZXJpZXMsIHRydWUsIGRpcmVjdGl2ZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGFkYXRhID0gQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhLmNyZWF0ZSh7XG4gICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICBleHBvcnRBczogZGlyTWV0YS5leHBvcnRBcyxcbiAgICAgICAgICAgIGlzQ29tcG9uZW50OiAhIW5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhLFxuICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZU1ldGFkYXRhKGRpcmVjdGl2ZVR5cGUpLFxuICAgICAgICAgICAgdGVtcGxhdGU6IG5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBjaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICAgICAgICAgIGlucHV0czogZGlyTWV0YS5pbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXRzOiBkaXJNZXRhLm91dHB1dHMsXG4gICAgICAgICAgICBob3N0OiBkaXJNZXRhLmhvc3QsXG4gICAgICAgICAgICBwcm92aWRlcnM6IHByb3ZpZGVycyxcbiAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IHZpZXdQcm92aWRlcnMsXG4gICAgICAgICAgICBxdWVyaWVzOiBxdWVyaWVzLFxuICAgICAgICAgICAgdmlld1F1ZXJpZXM6IHZpZXdRdWVyaWVzLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBlbnRyeUNvbXBvbmVudE1ldGFkYXRhLFxuICAgICAgICAgICAgY29tcG9uZW50Vmlld1R5cGU6IG5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhID8gdGhpcy5nZXRDb21wb25lbnRWaWV3Q2xhc3MoZGlyZWN0aXZlVHlwZSkgOlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZTogbm9uTm9ybWFsaXplZFRlbXBsYXRlTWV0YWRhdGEgPyB0aGlzLmdldFJlbmRlcmVyVHlwZShkaXJlY3RpdmVUeXBlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbXBvbmVudEZhY3Rvcnk6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5vbk5vcm1hbGl6ZWRUZW1wbGF0ZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICBtZXRhZGF0YS5jb21wb25lbnRGYWN0b3J5ID1cbiAgICAgICAgICAgICAgICB0aGlzLmdldENvbXBvbmVudEZhY3Rvcnkoc2VsZWN0b3IsIGRpcmVjdGl2ZVR5cGUsIG1ldGFkYXRhLmlucHV0cywgbWV0YWRhdGEub3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVFbnRyeSA9IHsgbWV0YWRhdGE6IG1ldGFkYXRhLCBhbm5vdGF0aW9uOiBkaXJNZXRhIH07XG4gICAgICAgIHRoaXMuX25vbk5vcm1hbGl6ZWREaXJlY3RpdmVDYWNoZS5zZXQoZGlyZWN0aXZlVHlwZSwgY2FjaGVFbnRyeSk7XG4gICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWV0YWRhdGEgZm9yIHRoZSBnaXZlbiBkaXJlY3RpdmUuXG4gICAgICogVGhpcyBhc3N1bWVzIGBsb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGFgIGhhcyBiZWVuIGNhbGxlZCBmaXJzdC5cbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXREaXJlY3RpdmVNZXRhZGF0YSA9IGZ1bmN0aW9uIChkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSB0aGlzLl9kaXJlY3RpdmVDYWNoZS5nZXQoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgIGlmICghZGlyTWV0YSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBnZXREaXJlY3RpdmVNZXRhZGF0YSBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgbG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhIGZvciBhIG1vZHVsZSB0aGF0IGRlY2xhcmVzIGl0LiBEaXJlY3RpdmUgXCIgKyBzdHJpbmdpZnlUeXBlKGRpcmVjdGl2ZVR5cGUpICsgXCIuXCIpLCBkaXJlY3RpdmVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlyTWV0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldERpcmVjdGl2ZVN1bW1hcnkgPSBmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJTdW1tYXJ5ID0gKHRoaXMuX2xvYWRTdW1tYXJ5KGRpclR5cGUsIENvbXBpbGVTdW1tYXJ5S2luZC5EaXJlY3RpdmUpKTtcbiAgICAgICAgaWYgKCFkaXJTdW1tYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIklsbGVnYWwgc3RhdGU6IENvdWxkIG5vdCBsb2FkIHRoZSBzdW1tYXJ5IGZvciBkaXJlY3RpdmUgXCIgKyBzdHJpbmdpZnlUeXBlKGRpclR5cGUpICsgXCIuXCIpLCBkaXJUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlyU3VtbWFyeTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmlzRGlyZWN0aXZlID0gZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHRoaXMuX2RpcmVjdGl2ZVJlc29sdmVyLmlzRGlyZWN0aXZlKHR5cGUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmlzUGlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLl9waXBlUmVzb2x2ZXIuaXNQaXBlKHR5cGUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldE5nTW9kdWxlU3VtbWFyeSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZVN1bW1hcnkgPSAodGhpcy5fbG9hZFN1bW1hcnkobW9kdWxlVHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLk5nTW9kdWxlKSk7XG4gICAgICAgIGlmICghbW9kdWxlU3VtbWFyeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YSA9IHRoaXMuZ2V0TmdNb2R1bGVNZXRhZGF0YShtb2R1bGVUeXBlLCBmYWxzZSk7XG4gICAgICAgICAgICBtb2R1bGVTdW1tYXJ5ID0gbW9kdWxlTWV0YSA/IG1vZHVsZU1ldGEudG9TdW1tYXJ5KCkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKG1vZHVsZVN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdW1tYXJ5Q2FjaGUuc2V0KG1vZHVsZVR5cGUsIG1vZHVsZVN1bW1hcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVTdW1tYXJ5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIGRlY2xhcmVkIGRpcmVjdGl2ZXMgYW5kIHBpcGVzIG9mIGFuIE5nTW9kdWxlLlxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gaXNTeW5jXG4gICAgICogQHBhcmFtIHs/PX0gdGhyb3dJZk5vdEZvdW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUubG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYywgdGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aHJvd0lmTm90Rm91bmQgPT09IHZvaWQgMCkgeyB0aHJvd0lmTm90Rm91bmQgPSB0cnVlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlID0gdGhpcy5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUsIHRocm93SWZOb3RGb3VuZCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvYWRpbmcgPSBbXTtcbiAgICAgICAgaWYgKG5nTW9kdWxlKSB7XG4gICAgICAgICAgICBuZ01vZHVsZS5kZWNsYXJlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9taXNlID0gX3RoaXMuX2xvYWREaXJlY3RpdmVNZXRhZGF0YShtb2R1bGVUeXBlLCBpZC5yZWZlcmVuY2UsIGlzU3luYyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmdNb2R1bGUuZGVjbGFyZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gX3RoaXMuX2xvYWRQaXBlTWV0YWRhdGEoaWQucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGxvYWRpbmcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHBhcmFtIHs/PX0gdGhyb3dJZk5vdEZvdW5kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0TmdNb2R1bGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCA9PT0gdm9pZCAwKSB7IHRocm93SWZOb3RGb3VuZCA9IHRydWU7IH1cbiAgICAgICAgbW9kdWxlVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKG1vZHVsZVR5cGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlTWV0YSA9IHRoaXMuX25nTW9kdWxlQ2FjaGUuZ2V0KG1vZHVsZVR5cGUpO1xuICAgICAgICBpZiAoY29tcGlsZU1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21waWxlTWV0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRhID0gdGhpcy5fbmdNb2R1bGVSZXNvbHZlci5yZXNvbHZlKG1vZHVsZVR5cGUsIHRocm93SWZOb3RGb3VuZCk7XG4gICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjbGFyZWREaXJlY3RpdmVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cG9ydGVkTm9uTW9kdWxlSWRlbnRpZmllcnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjbGFyZWRQaXBlcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbXBvcnRlZE1vZHVsZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0ZWRNb2R1bGVzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVycyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeUNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9vdHN0cmFwQ29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY2hlbWFzID0gW107XG4gICAgICAgIGlmIChtZXRhLmltcG9ydHMpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLmltcG9ydHMpLmZvckVhY2goZnVuY3Rpb24gKGltcG9ydGVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydGVkTW9kdWxlVHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFR5cGUoaW1wb3J0ZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZE1vZHVsZVR5cGUgPSBpbXBvcnRlZFR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGltcG9ydGVkVHlwZSAmJiBpbXBvcnRlZFR5cGUubmdNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlV2l0aFByb3ZpZGVycyA9IGltcG9ydGVkVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVUeXBlID0gbW9kdWxlV2l0aFByb3ZpZGVycy5uZ01vZHVsZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZVdpdGhQcm92aWRlcnMucHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnMucHVzaC5hcHBseShwcm92aWRlcnMsIF90aGlzLl9nZXRQcm92aWRlcnNNZXRhZGF0YShtb2R1bGVXaXRoUHJvdmlkZXJzLnByb3ZpZGVycywgZW50cnlDb21wb25lbnRzLCBcInByb3ZpZGVyIGZvciB0aGUgTmdNb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShpbXBvcnRlZE1vZHVsZVR5cGUpICsgXCInXCIsIFtdLCBpbXBvcnRlZFR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW1wb3J0ZWRNb2R1bGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fY2hlY2tTZWxmSW1wb3J0KG1vZHVsZVR5cGUsIGltcG9ydGVkTW9kdWxlVHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydGVkTW9kdWxlU3VtbWFyeSA9IF90aGlzLmdldE5nTW9kdWxlU3VtbWFyeShpbXBvcnRlZE1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWltcG9ydGVkTW9kdWxlU3VtbWFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVW5leHBlY3RlZCBcIiArIF90aGlzLl9nZXRUeXBlRGVzY3JpcHRvcihpbXBvcnRlZFR5cGUpICsgXCIgJ1wiICsgc3RyaW5naWZ5VHlwZShpbXBvcnRlZFR5cGUpICsgXCInIGltcG9ydGVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJy4gUGxlYXNlIGFkZCBhIEBOZ01vZHVsZSBhbm5vdGF0aW9uLlwiKSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRNb2R1bGVzLnB1c2goaW1wb3J0ZWRNb2R1bGVTdW1tYXJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5VHlwZShpbXBvcnRlZFR5cGUpICsgXCInIGltcG9ydGVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJ1wiKSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5leHBvcnRzKSB7XG4gICAgICAgICAgICBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5leHBvcnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChleHBvcnRlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKGV4cG9ydGVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSAnXCIgKyBzdHJpbmdpZnlUeXBlKGV4cG9ydGVkVHlwZSkgKyBcIicgZXhwb3J0ZWQgYnkgdGhlIG1vZHVsZSAnXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBvcnRlZE1vZHVsZVN1bW1hcnkgPSBfdGhpcy5nZXROZ01vZHVsZVN1bW1hcnkoZXhwb3J0ZWRUeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3J0ZWRNb2R1bGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkTW9kdWxlcy5wdXNoKGV4cG9ydGVkTW9kdWxlU3VtbWFyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZE5vbk1vZHVsZUlkZW50aWZpZXJzLnB1c2goX3RoaXMuX2dldElkZW50aWZpZXJNZXRhZGF0YShleHBvcnRlZFR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBUaGlzIHdpbGwgYmUgbW9kaWZpZWQgbGF0ZXIsIHNvIHdlIHJlbHkgb25cbiAgICAgICAgLy8gZ2V0dGluZyBhIG5ldyBpbnN0YW5jZSBldmVyeSB0aW1lIVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2l0aXZlTW9kdWxlID0gdGhpcy5fZ2V0VHJhbnNpdGl2ZU5nTW9kdWxlTWV0YWRhdGEoaW1wb3J0ZWRNb2R1bGVzLCBleHBvcnRlZE1vZHVsZXMpO1xuICAgICAgICBpZiAobWV0YS5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5BbmREZWR1cGVBcnJheShtZXRhLmRlY2xhcmF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoZGVjbGFyZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkVHlwZShkZWNsYXJlZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5VHlwZShkZWNsYXJlZFR5cGUpICsgXCInIGRlY2xhcmVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJ1wiKSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjbGFyZWRJZGVudGlmaWVyID0gX3RoaXMuX2dldElkZW50aWZpZXJNZXRhZGF0YShkZWNsYXJlZFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fZGlyZWN0aXZlUmVzb2x2ZXIuaXNEaXJlY3RpdmUoZGVjbGFyZWRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlLmFkZERpcmVjdGl2ZShkZWNsYXJlZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBkZWNsYXJlZERpcmVjdGl2ZXMucHVzaChkZWNsYXJlZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkVHlwZVRvTW9kdWxlKGRlY2xhcmVkVHlwZSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLl9waXBlUmVzb2x2ZXIuaXNQaXBlKGRlY2xhcmVkVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5hZGRQaXBlKGRlY2xhcmVkSWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUucGlwZXMucHVzaChkZWNsYXJlZElkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBkZWNsYXJlZFBpcGVzLnB1c2goZGVjbGFyZWRJZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZFR5cGVUb01vZHVsZShkZWNsYXJlZFR5cGUsIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVW5leHBlY3RlZCBcIiArIF90aGlzLl9nZXRUeXBlRGVzY3JpcHRvcihkZWNsYXJlZFR5cGUpICsgXCIgJ1wiICsgc3RyaW5naWZ5VHlwZShkZWNsYXJlZFR5cGUpICsgXCInIGRlY2xhcmVkIGJ5IHRoZSBtb2R1bGUgJ1wiICsgc3RyaW5naWZ5VHlwZShtb2R1bGVUeXBlKSArIFwiJy4gUGxlYXNlIGFkZCBhIEBQaXBlL0BEaXJlY3RpdmUvQENvbXBvbmVudCBhbm5vdGF0aW9uLlwiKSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBvcnRlZERpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0ZWRQaXBlcyA9IFtdO1xuICAgICAgICBleHBvcnRlZE5vbk1vZHVsZUlkZW50aWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKGV4cG9ydGVkSWQpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXNTZXQuaGFzKGV4cG9ydGVkSWQucmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICAgIGV4cG9ydGVkRGlyZWN0aXZlcy5wdXNoKGV4cG9ydGVkSWQpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpdmVNb2R1bGUuYWRkRXhwb3J0ZWREaXJlY3RpdmUoZXhwb3J0ZWRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0cmFuc2l0aXZlTW9kdWxlLnBpcGVzU2V0LmhhcyhleHBvcnRlZElkLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICBleHBvcnRlZFBpcGVzLnB1c2goZXhwb3J0ZWRJZCk7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGl2ZU1vZHVsZS5hZGRFeHBvcnRlZFBpcGUoZXhwb3J0ZWRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJDYW4ndCBleHBvcnQgXCIgKyBfdGhpcy5fZ2V0VHlwZURlc2NyaXB0b3IoZXhwb3J0ZWRJZC5yZWZlcmVuY2UpICsgXCIgXCIgKyBzdHJpbmdpZnlUeXBlKGV4cG9ydGVkSWQucmVmZXJlbmNlKSArIFwiIGZyb20gXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCIgYXMgaXQgd2FzIG5laXRoZXIgZGVjbGFyZWQgbm9yIGltcG9ydGVkIVwiKSwgbW9kdWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIHByb3ZpZGVycyBvZiB0aGUgbW9kdWxlIGhhdmUgdG8gZ28gbGFzdFxuICAgICAgICAvLyBzbyB0aGF0IHRoZXkgb3ZlcndyaXRlIGFueSBvdGhlciBwcm92aWRlciB3ZSBhbHJlYWR5IGFkZGVkLlxuICAgICAgICBpZiAobWV0YS5wcm92aWRlcnMpIHtcbiAgICAgICAgICAgIHByb3ZpZGVycy5wdXNoLmFwcGx5KHByb3ZpZGVycywgdGhpcy5fZ2V0UHJvdmlkZXJzTWV0YWRhdGEobWV0YS5wcm92aWRlcnMsIGVudHJ5Q29tcG9uZW50cywgXCJwcm92aWRlciBmb3IgdGhlIE5nTW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiwgW10sIG1vZHVsZVR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5lbnRyeUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGVudHJ5Q29tcG9uZW50cy5wdXNoLmFwcGx5KGVudHJ5Q29tcG9uZW50cywgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuZW50cnlDb21wb25lbnRzKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLl9nZXRFbnRyeUNvbXBvbmVudE1ldGFkYXRhKHR5cGUpOyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuYm9vdHN0cmFwKSB7XG4gICAgICAgICAgICBmbGF0dGVuQW5kRGVkdXBlQXJyYXkobWV0YS5ib290c3RyYXApLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgJ1wiICsgc3RyaW5naWZ5VHlwZSh0eXBlKSArIFwiJyB1c2VkIGluIHRoZSBib290c3RyYXAgcHJvcGVydHkgb2YgbW9kdWxlICdcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIidcIiksIG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvb3RzdHJhcENvbXBvbmVudHMucHVzaChfdGhpcy5fZ2V0SWRlbnRpZmllck1ldGFkYXRhKHR5cGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5Q29tcG9uZW50cy5wdXNoLmFwcGx5KGVudHJ5Q29tcG9uZW50cywgYm9vdHN0cmFwQ29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLl9nZXRFbnRyeUNvbXBvbmVudE1ldGFkYXRhKHR5cGUucmVmZXJlbmNlKTsgfSkpO1xuICAgICAgICBpZiAobWV0YS5zY2hlbWFzKSB7XG4gICAgICAgICAgICBzY2hlbWFzLnB1c2guYXBwbHkoc2NoZW1hcywgZmxhdHRlbkFuZERlZHVwZUFycmF5KG1ldGEuc2NoZW1hcykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBpbGVNZXRhID0gbmV3IENvbXBpbGVOZ01vZHVsZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2dldFR5cGVNZXRhZGF0YShtb2R1bGVUeXBlKSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogcHJvdmlkZXJzLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBlbnRyeUNvbXBvbmVudHMsXG4gICAgICAgICAgICBib290c3RyYXBDb21wb25lbnRzOiBib290c3RyYXBDb21wb25lbnRzLFxuICAgICAgICAgICAgc2NoZW1hczogc2NoZW1hcyxcbiAgICAgICAgICAgIGRlY2xhcmVkRGlyZWN0aXZlczogZGVjbGFyZWREaXJlY3RpdmVzLFxuICAgICAgICAgICAgZXhwb3J0ZWREaXJlY3RpdmVzOiBleHBvcnRlZERpcmVjdGl2ZXMsXG4gICAgICAgICAgICBkZWNsYXJlZFBpcGVzOiBkZWNsYXJlZFBpcGVzLFxuICAgICAgICAgICAgZXhwb3J0ZWRQaXBlczogZXhwb3J0ZWRQaXBlcyxcbiAgICAgICAgICAgIGltcG9ydGVkTW9kdWxlczogaW1wb3J0ZWRNb2R1bGVzLFxuICAgICAgICAgICAgZXhwb3J0ZWRNb2R1bGVzOiBleHBvcnRlZE1vZHVsZXMsXG4gICAgICAgICAgICB0cmFuc2l0aXZlTW9kdWxlOiB0cmFuc2l0aXZlTW9kdWxlLFxuICAgICAgICAgICAgaWQ6IG1ldGEuaWQsXG4gICAgICAgIH0pO1xuICAgICAgICBlbnRyeUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHRyYW5zaXRpdmVNb2R1bGUuYWRkRW50cnlDb21wb25lbnQoaWQpOyB9KTtcbiAgICAgICAgcHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiB0cmFuc2l0aXZlTW9kdWxlLmFkZFByb3ZpZGVyKHByb3ZpZGVyLCBjb21waWxlTWV0YS50eXBlKTsgfSk7XG4gICAgICAgIHRyYW5zaXRpdmVNb2R1bGUuYWRkTW9kdWxlKGNvbXBpbGVNZXRhLnR5cGUpO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZUNhY2hlLnNldChtb2R1bGVUeXBlLCBjb21waWxlTWV0YSk7XG4gICAgICAgIHJldHVybiBjb21waWxlTWV0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gaW1wb3J0ZWRNb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2NoZWNrU2VsZkltcG9ydCA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBpbXBvcnRlZE1vZHVsZVR5cGUpIHtcbiAgICAgICAgaWYgKG1vZHVsZVR5cGUgPT09IGltcG9ydGVkTW9kdWxlVHlwZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCInXCIgKyBzdHJpbmdpZnlUeXBlKG1vZHVsZVR5cGUpICsgXCInIG1vZHVsZSBjYW4ndCBpbXBvcnQgaXRzZWxmXCIpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRUeXBlRGVzY3JpcHRvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3RpdmVSZXNvbHZlci5pc0RpcmVjdGl2ZSh0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdkaXJlY3RpdmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9waXBlUmVzb2x2ZXIuaXNQaXBlKHR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3BpcGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9uZ01vZHVsZVJlc29sdmVyLmlzTmdNb2R1bGUodHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW9kdWxlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCh0eXBlKSkucHJvdmlkZSkge1xuICAgICAgICAgICAgcmV0dXJuICdwcm92aWRlcic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICd2YWx1ZSc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fYWRkVHlwZVRvTW9kdWxlID0gZnVuY3Rpb24gKHR5cGUsIG1vZHVsZVR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb2xkTW9kdWxlID0gdGhpcy5fbmdNb2R1bGVPZlR5cGVzLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKG9sZE1vZHVsZSAmJiBvbGRNb2R1bGUgIT09IG1vZHVsZVR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiVHlwZSBcIiArIHN0cmluZ2lmeVR5cGUodHlwZSkgKyBcIiBpcyBwYXJ0IG9mIHRoZSBkZWNsYXJhdGlvbnMgb2YgMiBtb2R1bGVzOiBcIiArIHN0cmluZ2lmeVR5cGUob2xkTW9kdWxlKSArIFwiIGFuZCBcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIiEgXCIgK1xuICAgICAgICAgICAgICAgIChcIlBsZWFzZSBjb25zaWRlciBtb3ZpbmcgXCIgKyBzdHJpbmdpZnlUeXBlKHR5cGUpICsgXCIgdG8gYSBoaWdoZXIgbW9kdWxlIHRoYXQgaW1wb3J0cyBcIiArIHN0cmluZ2lmeVR5cGUob2xkTW9kdWxlKSArIFwiIGFuZCBcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIi4gXCIpICtcbiAgICAgICAgICAgICAgICAoXCJZb3UgY2FuIGFsc28gY3JlYXRlIGEgbmV3IE5nTW9kdWxlIHRoYXQgZXhwb3J0cyBhbmQgaW5jbHVkZXMgXCIgKyBzdHJpbmdpZnlUeXBlKHR5cGUpICsgXCIgdGhlbiBpbXBvcnQgdGhhdCBOZ01vZHVsZSBpbiBcIiArIHN0cmluZ2lmeVR5cGUob2xkTW9kdWxlKSArIFwiIGFuZCBcIiArIHN0cmluZ2lmeVR5cGUobW9kdWxlVHlwZSkgKyBcIi5cIikpLCBtb2R1bGVUeXBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZ01vZHVsZU9mVHlwZXMuc2V0KHR5cGUsIG1vZHVsZVR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbXBvcnRlZE1vZHVsZXNcbiAgICAgKiBAcGFyYW0gez99IGV4cG9ydGVkTW9kdWxlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRUcmFuc2l0aXZlTmdNb2R1bGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChpbXBvcnRlZE1vZHVsZXMsIGV4cG9ydGVkTW9kdWxlcykge1xuICAgICAgICAvLyBjb2xsZWN0IGBwcm92aWRlcnNgIC8gYGVudHJ5Q29tcG9uZW50c2AgZnJvbSBhbGwgaW1wb3J0ZWQgYW5kIGFsbCBleHBvcnRlZCBtb2R1bGVzXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IG5ldyBUcmFuc2l0aXZlQ29tcGlsZU5nTW9kdWxlTWV0YWRhdGEoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlc0J5VG9rZW4gPSBuZXcgTWFwKCk7XG4gICAgICAgIGltcG9ydGVkTW9kdWxlcy5jb25jYXQoZXhwb3J0ZWRNb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2RTdW1tYXJ5KSB7XG4gICAgICAgICAgICBtb2RTdW1tYXJ5Lm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kKSB7IHJldHVybiByZXN1bHQuYWRkTW9kdWxlKG1vZCk7IH0pO1xuICAgICAgICAgICAgbW9kU3VtbWFyeS5lbnRyeUNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcCkgeyByZXR1cm4gcmVzdWx0LmFkZEVudHJ5Q29tcG9uZW50KGNvbXApOyB9KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFkZGVkVG9rZW5zID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbW9kU3VtbWFyeS5wcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlblJlZiA9IHRva2VuUmVmZXJlbmNlKGVudHJ5LnByb3ZpZGVyLnRva2VuKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmV2TW9kdWxlcyA9IG1vZHVsZXNCeVRva2VuLmdldCh0b2tlblJlZik7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2TW9kdWxlcykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2TW9kdWxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlc0J5VG9rZW4uc2V0KHRva2VuUmVmLCBwcmV2TW9kdWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZVJlZiA9IGVudHJ5Lm1vZHVsZS5yZWZlcmVuY2U7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogdGhlIHByb3ZpZGVycyBvZiBvbmUgbW9kdWxlIG1heSBzdGlsbCBjb250YWluIG11bHRpcGxlIHByb3ZpZGVyc1xuICAgICAgICAgICAgICAgIC8vIHBlciB0b2tlbiAoZS5nLiBmb3IgbXVsdGkgcHJvdmlkZXJzKSwgYW5kIHdlIG5lZWQgdG8gcHJlc2VydmUgdGhlc2UuXG4gICAgICAgICAgICAgICAgaWYgKGFkZGVkVG9rZW5zLmhhcyh0b2tlblJlZikgfHwgIXByZXZNb2R1bGVzLmhhcyhtb2R1bGVSZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZNb2R1bGVzLmFkZChtb2R1bGVSZWYpO1xuICAgICAgICAgICAgICAgICAgICBhZGRlZFRva2Vucy5hZGQodG9rZW5SZWYpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkUHJvdmlkZXIoZW50cnkucHJvdmlkZXIsIGVudHJ5Lm1vZHVsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBleHBvcnRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kU3VtbWFyeSkge1xuICAgICAgICAgICAgbW9kU3VtbWFyeS5leHBvcnRlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHJlc3VsdC5hZGRFeHBvcnRlZERpcmVjdGl2ZShpZCk7IH0pO1xuICAgICAgICAgICAgbW9kU3VtbWFyeS5leHBvcnRlZFBpcGVzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiByZXN1bHQuYWRkRXhwb3J0ZWRQaXBlKGlkKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbXBvcnRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kU3VtbWFyeSkge1xuICAgICAgICAgICAgbW9kU3VtbWFyeS5leHBvcnRlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIHJlc3VsdC5hZGREaXJlY3RpdmUoaWQpOyB9KTtcbiAgICAgICAgICAgIG1vZFN1bW1hcnkuZXhwb3J0ZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gcmVzdWx0LmFkZFBpcGUoaWQpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0SWRlbnRpZmllck1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmKHR5cGUpO1xuICAgICAgICByZXR1cm4geyByZWZlcmVuY2U6IHR5cGUgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmlzSW5qZWN0YWJsZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFubm90YXRpb25zID0gdGhpcy5fcmVmbGVjdG9yLmFubm90YXRpb25zKHR5cGUpO1xuICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIGFuIGV4YWN0IGNoZWNrIGhlcmUgYXMgQENvbXBvbmVudCAvIEBEaXJlY3RpdmUgLyAuLi4gaW5oZXJpdFxuICAgICAgICAvLyBmcm9tIEBDb21waWxlckluamVjdGFibGUhXG4gICAgICAgIHJldHVybiBhbm5vdGF0aW9ucy5zb21lKGZ1bmN0aW9uIChhbm4pIHsgcmV0dXJuIGFubi5jb25zdHJ1Y3RvciA9PT0gSW5qZWN0YWJsZTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRJbmplY3RhYmxlU3VtbWFyeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdW1tYXJ5S2luZDogQ29tcGlsZVN1bW1hcnlLaW5kLkluamVjdGFibGUsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEodHlwZSwgbnVsbCwgZmFsc2UpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBkZXBlbmRlbmNpZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0SW5qZWN0YWJsZU1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUsIGRlcGVuZGVuY2llcykge1xuICAgICAgICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHsgZGVwZW5kZW5jaWVzID0gbnVsbDsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlU3VtbWFyeSA9IHRoaXMuX2xvYWRTdW1tYXJ5KHR5cGUsIENvbXBpbGVTdW1tYXJ5S2luZC5JbmplY3RhYmxlKTtcbiAgICAgICAgaWYgKHR5cGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZVN1bW1hcnkudHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VHlwZU1ldGFkYXRhKHR5cGUsIGRlcGVuZGVuY2llcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBkZXBlbmRlbmNpZXNcbiAgICAgKiBAcGFyYW0gez89fSB0aHJvd09uVW5rbm93bkRlcHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0VHlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUsIGRlcGVuZGVuY2llcywgdGhyb3dPblVua25vd25EZXBzKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkgeyBkZXBlbmRlbmNpZXMgPSBudWxsOyB9XG4gICAgICAgIGlmICh0aHJvd09uVW5rbm93bkRlcHMgPT09IHZvaWQgMCkgeyB0aHJvd09uVW5rbm93bkRlcHMgPSB0cnVlOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlkZW50aWZpZXIgPSB0aGlzLl9nZXRJZGVudGlmaWVyTWV0YWRhdGEodHlwZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWZlcmVuY2U6IGlkZW50aWZpZXIucmVmZXJlbmNlLFxuICAgICAgICAgICAgZGlEZXBzOiB0aGlzLl9nZXREZXBlbmRlbmNpZXNNZXRhZGF0YShpZGVudGlmaWVyLnJlZmVyZW5jZSwgZGVwZW5kZW5jaWVzLCB0aHJvd09uVW5rbm93bkRlcHMpLFxuICAgICAgICAgICAgbGlmZWN5Y2xlSG9va3M6IMm1TElGRUNZQ0xFX0hPT0tTX1ZBTFVFUy5maWx0ZXIoZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGhhc0xpZmVjeWNsZUhvb2soaG9vaywgaWRlbnRpZmllci5yZWZlcmVuY2UpOyB9KSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmFjdG9yeVxuICAgICAqIEBwYXJhbSB7Pz19IGRlcGVuZGVuY2llc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRGYWN0b3J5TWV0YWRhdGEgPSBmdW5jdGlvbiAoZmFjdG9yeSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCkgeyBkZXBlbmRlbmNpZXMgPSBudWxsOyB9XG4gICAgICAgIGZhY3RvcnkgPSByZXNvbHZlRm9yd2FyZFJlZihmYWN0b3J5KTtcbiAgICAgICAgcmV0dXJuIHsgcmVmZXJlbmNlOiBmYWN0b3J5LCBkaURlcHM6IHRoaXMuX2dldERlcGVuZGVuY2llc01ldGFkYXRhKGZhY3RvcnksIGRlcGVuZGVuY2llcykgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1ldGFkYXRhIGZvciB0aGUgZ2l2ZW4gcGlwZS5cbiAgICAgKiBUaGlzIGFzc3VtZXMgYGxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YWAgaGFzIGJlZW4gY2FsbGVkIGZpcnN0LlxuICAgICAqIEBwYXJhbSB7P30gcGlwZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5nZXRQaXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAocGlwZVR5cGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZU1ldGEgPSB0aGlzLl9waXBlQ2FjaGUuZ2V0KHBpcGVUeXBlKTtcbiAgICAgICAgaWYgKCFwaXBlTWV0YSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBnZXRQaXBlTWV0YWRhdGEgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YSBmb3IgYSBtb2R1bGUgdGhhdCBkZWNsYXJlcyBpdC4gUGlwZSBcIiArIHN0cmluZ2lmeVR5cGUocGlwZVR5cGUpICsgXCIuXCIpLCBwaXBlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGVNZXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaXBlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLmdldFBpcGVTdW1tYXJ5ID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVTdW1tYXJ5ID0gKHRoaXMuX2xvYWRTdW1tYXJ5KHBpcGVUeXBlLCBDb21waWxlU3VtbWFyeUtpbmQuUGlwZSkpO1xuICAgICAgICBpZiAoIXBpcGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIklsbGVnYWwgc3RhdGU6IENvdWxkIG5vdCBsb2FkIHRoZSBzdW1tYXJ5IGZvciBwaXBlIFwiICsgc3RyaW5naWZ5VHlwZShwaXBlVHlwZSkgKyBcIi5cIiksIHBpcGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZVN1bW1hcnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBpcGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0T3JMb2FkUGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVNZXRhID0gdGhpcy5fcGlwZUNhY2hlLmdldChwaXBlVHlwZSk7XG4gICAgICAgIGlmICghcGlwZU1ldGEpIHtcbiAgICAgICAgICAgIHBpcGVNZXRhID0gdGhpcy5fbG9hZFBpcGVNZXRhZGF0YShwaXBlVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGVNZXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaXBlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9sb2FkUGlwZU1ldGFkYXRhID0gZnVuY3Rpb24gKHBpcGVUeXBlKSB7XG4gICAgICAgIHBpcGVUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWYocGlwZVR5cGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlQW5ub3RhdGlvbiA9IHRoaXMuX3BpcGVSZXNvbHZlci5yZXNvbHZlKHBpcGVUeXBlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZU1ldGEgPSBuZXcgQ29tcGlsZVBpcGVNZXRhZGF0YSh7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9nZXRUeXBlTWV0YWRhdGEocGlwZVR5cGUpLFxuICAgICAgICAgICAgbmFtZTogcGlwZUFubm90YXRpb24ubmFtZSxcbiAgICAgICAgICAgIHB1cmU6IHBpcGVBbm5vdGF0aW9uLnB1cmVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BpcGVDYWNoZS5zZXQocGlwZVR5cGUsIHBpcGVNZXRhKTtcbiAgICAgICAgdGhpcy5fc3VtbWFyeUNhY2hlLnNldChwaXBlVHlwZSwgcGlwZU1ldGEudG9TdW1tYXJ5KCkpO1xuICAgICAgICByZXR1cm4gcGlwZU1ldGE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgKiBAcGFyYW0gez99IGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSB7Pz19IHRocm93T25Vbmtub3duRGVwc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXREZXBlbmRlbmNpZXNNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jLCBkZXBlbmRlbmNpZXMsIHRocm93T25Vbmtub3duRGVwcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhyb3dPblVua25vd25EZXBzID09PSB2b2lkIDApIHsgdGhyb3dPblVua25vd25EZXBzID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoYXNVbmtub3duRGVwcyA9IGZhbHNlO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbXMgPSBkZXBlbmRlbmNpZXMgfHwgdGhpcy5fcmVmbGVjdG9yLnBhcmFtZXRlcnModHlwZU9yRnVuYykgfHwgW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcGVuZGVuY2llc01ldGFkYXRhID0gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzQXR0cmlidXRlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpc0hvc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzU2VsZiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNTa2lwU2VsZiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNPcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgcGFyYW0uZm9yRWFjaChmdW5jdGlvbiAocGFyYW1FbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIEhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSG9zdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIFNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VsZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1FbnRyeSBpbnN0YW5jZW9mIFNraXBTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NraXBTZWxmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXR0cmlidXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeS5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtRW50cnkgaW5zdGFuY2VvZiBJbmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeS50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbUVudHJ5IGluc3RhbmNlb2YgSW5qZWN0aW9uVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW1FbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbGlkVHlwZShwYXJhbUVudHJ5KSAmJiB0b2tlbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRva2VuID0gcGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhhc1Vua25vd25EZXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXNBdHRyaWJ1dGU6IGlzQXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIGlzSG9zdDogaXNIb3N0LFxuICAgICAgICAgICAgICAgIGlzU2VsZjogaXNTZWxmLFxuICAgICAgICAgICAgICAgIGlzU2tpcFNlbGY6IGlzU2tpcFNlbGYsXG4gICAgICAgICAgICAgICAgaXNPcHRpb25hbDogaXNPcHRpb25hbCxcbiAgICAgICAgICAgICAgICB0b2tlbjogX3RoaXMuX2dldFRva2VuTWV0YWRhdGEodG9rZW4pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc1Vua25vd25EZXBzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzVG9rZW5zID0gZGVwZW5kZW5jaWVzTWV0YWRhdGEubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIGRlcCA/IHN0cmluZ2lmeVR5cGUoZGVwLnRva2VuKSA6ICc/JzsgfSkuam9pbignLCAnKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2UgPSBcIkNhbid0IHJlc29sdmUgYWxsIHBhcmFtZXRlcnMgZm9yIFwiICsgc3RyaW5naWZ5VHlwZSh0eXBlT3JGdW5jKSArIFwiOiAoXCIgKyBkZXBzVG9rZW5zICsgXCIpLlwiO1xuICAgICAgICAgICAgaWYgKHRocm93T25Vbmtub3duRGVwcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKG1lc3NhZ2UpLCB0eXBlT3JGdW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUud2FybihcIldhcm5pbmc6IFwiICsgbWVzc2FnZSArIFwiIFRoaXMgd2lsbCBiZWNvbWUgYW4gZXJyb3IgaW4gQW5ndWxhciB2NS54XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXBlbmRlbmNpZXNNZXRhZGF0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdG9rZW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0VG9rZW5NZXRhZGF0YSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB0b2tlbiA9IHJlc29sdmVGb3J3YXJkUmVmKHRva2VuKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZVRva2VuO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29tcGlsZVRva2VuID0geyB2YWx1ZTogdG9rZW4gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBpbGVUb2tlbiA9IHsgaWRlbnRpZmllcjogeyByZWZlcmVuY2U6IHRva2VuIH0gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGlsZVRva2VuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlcnNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldEVudHJ5Q29tcG9uZW50c1xuICAgICAqIEBwYXJhbSB7Pz19IGRlYnVnSW5mb1xuICAgICAqIEBwYXJhbSB7Pz19IGNvbXBpbGVQcm92aWRlcnNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX2dldFByb3ZpZGVyc01ldGFkYXRhID0gZnVuY3Rpb24gKHByb3ZpZGVycywgdGFyZ2V0RW50cnlDb21wb25lbnRzLCBkZWJ1Z0luZm8sIGNvbXBpbGVQcm92aWRlcnMsIHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNvbXBpbGVQcm92aWRlcnMgPT09IHZvaWQgMCkgeyBjb21waWxlUHJvdmlkZXJzID0gW107IH1cbiAgICAgICAgcHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyLCBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2dldFByb3ZpZGVyc01ldGFkYXRhKHByb3ZpZGVyLCB0YXJnZXRFbnRyeUNvbXBvbmVudHMsIGRlYnVnSW5mbywgY29tcGlsZVByb3ZpZGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IHJlc29sdmVGb3J3YXJkUmVmKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlck1ldGEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyICYmIHR5cGVvZiBwcm92aWRlciA9PT0gJ29iamVjdCcgJiYgcHJvdmlkZXIuaGFzT3duUHJvcGVydHkoJ3Byb3ZpZGUnKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdmFsaWRhdGVQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YSA9IG5ldyBQcm92aWRlck1ldGEocHJvdmlkZXIucHJvdmlkZSwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbGlkVHlwZShwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhID0gbmV3IFByb3ZpZGVyTWV0YShwcm92aWRlciwgeyB1c2VDbGFzczogcHJvdmlkZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiRW5jb3VudGVyZWQgdW5kZWZpbmVkIHByb3ZpZGVyISBVc3VhbGx5IHRoaXMgbWVhbnMgeW91IGhhdmUgYSBjaXJjdWxhciBkZXBlbmRlbmNpZXMgKG1pZ2h0IGJlIGNhdXNlZCBieSB1c2luZyAnYmFycmVsJyBpbmRleC50cyBmaWxlcy5cIikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlcnNJbmZvID0gKChwcm92aWRlcnMucmVkdWNlKGZ1bmN0aW9uIChzb0Zhciwgc2VlblByb3ZpZGVyLCBzZWVuUHJvdmlkZXJJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWVuUHJvdmlkZXJJZHggPCBwcm92aWRlcklkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyLnB1c2goXCJcIiArIHN0cmluZ2lmeVR5cGUoc2VlblByb3ZpZGVyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWVuUHJvdmlkZXJJZHggPT0gcHJvdmlkZXJJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb0Zhci5wdXNoKFwiP1wiICsgc3RyaW5naWZ5VHlwZShzZWVuUHJvdmlkZXIpICsgXCI/XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VlblByb3ZpZGVySWR4ID09IHByb3ZpZGVySWR4ICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyLnB1c2goJy4uLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvRmFyO1xuICAgICAgICAgICAgICAgICAgICB9LCBbXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIkludmFsaWQgXCIgKyAoZGVidWdJbmZvID8gZGVidWdJbmZvIDogJ3Byb3ZpZGVyJykgKyBcIiAtIG9ubHkgaW5zdGFuY2VzIG9mIFByb3ZpZGVyIGFuZCBUeXBlIGFyZSBhbGxvd2VkLCBnb3Q6IFtcIiArIHByb3ZpZGVyc0luZm8gKyBcIl1cIiksIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlck1ldGEudG9rZW4gPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkFOQUxZWkVfRk9SX0VOVFJZX0NPTVBPTkVOVFMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVudHJ5Q29tcG9uZW50cy5wdXNoLmFwcGx5KHRhcmdldEVudHJ5Q29tcG9uZW50cywgX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50c0Zyb21Qcm92aWRlcihwcm92aWRlck1ldGEsIHR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVQcm92aWRlcnMucHVzaChfdGhpcy5nZXRQcm92aWRlck1ldGFkYXRhKHByb3ZpZGVyTWV0YSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21waWxlUHJvdmlkZXJzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl92YWxpZGF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG4gICAgICAgIGlmIChwcm92aWRlci5oYXNPd25Qcm9wZXJ0eSgndXNlQ2xhc3MnKSAmJiBwcm92aWRlci51c2VDbGFzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihzeW50YXhFcnJvcihcIkludmFsaWQgcHJvdmlkZXIgZm9yIFwiICsgc3RyaW5naWZ5VHlwZShwcm92aWRlci5wcm92aWRlKSArIFwiLiB1c2VDbGFzcyBjYW5ub3QgYmUgXCIgKyBwcm92aWRlci51c2VDbGFzcyArIFwiLlxcbiAgICAgICAgICAgVXN1YWxseSBpdCBoYXBwZW5zIHdoZW46XFxuICAgICAgICAgICAxLiBUaGVyZSdzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSAobWlnaHQgYmUgY2F1c2VkIGJ5IHVzaW5nIGluZGV4LnRzIChiYXJyZWwpIGZpbGVzKS5cXG4gICAgICAgICAgIDIuIENsYXNzIHdhcyB1c2VkIGJlZm9yZSBpdCB3YXMgZGVjbGFyZWQuIFVzZSBmb3J3YXJkUmVmIGluIHRoaXMgY2FzZS5cIikpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRFbnRyeUNvbXBvbmVudHNGcm9tUHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2xsZWN0ZWRJZGVudGlmaWVycyA9IFtdO1xuICAgICAgICBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSB8fCBwcm92aWRlci51c2VFeGlzdGluZyB8fCBwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJUaGUgQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUyB0b2tlbiBvbmx5IHN1cHBvcnRzIHVzZVZhbHVlIVwiKSwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm92aWRlci5tdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Ioc3ludGF4RXJyb3IoXCJUaGUgQU5BTFlaRV9GT1JfRU5UUllfQ09NUE9ORU5UUyB0b2tlbiBvbmx5IHN1cHBvcnRzICdtdWx0aSA9IHRydWUnIVwiKSwgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZXh0cmFjdElkZW50aWZpZXJzKHByb3ZpZGVyLnVzZVZhbHVlLCBjb2xsZWN0ZWRJZGVudGlmaWVycyk7XG4gICAgICAgIGNvbGxlY3RlZElkZW50aWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJ5ID0gX3RoaXMuX2dldEVudHJ5Q29tcG9uZW50TWV0YWRhdGEoaWRlbnRpZmllci5yZWZlcmVuY2UsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZGlyVHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHRocm93SWZOb3RGb3VuZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRFbnRyeUNvbXBvbmVudE1ldGFkYXRhID0gZnVuY3Rpb24gKGRpclR5cGUsIHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kID09PSB2b2lkIDApIHsgdGhyb3dJZk5vdEZvdW5kID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJNZXRhID0gdGhpcy5nZXROb25Ob3JtYWxpemVkRGlyZWN0aXZlTWV0YWRhdGEoZGlyVHlwZSk7XG4gICAgICAgIGlmIChkaXJNZXRhICYmIGRpck1ldGEubWV0YWRhdGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbXBvbmVudFR5cGU6IGRpclR5cGUsIGNvbXBvbmVudEZhY3Rvcnk6IGRpck1ldGEubWV0YWRhdGEuY29tcG9uZW50RmFjdG9yeSB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpclN1bW1hcnkgPSAodGhpcy5fbG9hZFN1bW1hcnkoZGlyVHlwZSwgQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSkpO1xuICAgICAgICBpZiAoZGlyU3VtbWFyeSAmJiBkaXJTdW1tYXJ5LmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb21wb25lbnRUeXBlOiBkaXJUeXBlLCBjb21wb25lbnRGYWN0b3J5OiBkaXJTdW1tYXJ5LmNvbXBvbmVudEZhY3RvcnkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhyb3dJZk5vdEZvdW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihkaXJUeXBlLm5hbWUgKyBcIiBjYW5ub3QgYmUgdXNlZCBhcyBhbiBlbnRyeSBjb21wb25lbnQuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuZ2V0UHJvdmlkZXJNZXRhZGF0YSA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlRGVwcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZVR5cGVNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVGYWN0b3J5TWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0b2tlbiA9IHRoaXMuX2dldFRva2VuTWV0YWRhdGEocHJvdmlkZXIudG9rZW4pO1xuICAgICAgICBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvbXBpbGVUeXBlTWV0YWRhdGEgPSB0aGlzLl9nZXRJbmplY3RhYmxlTWV0YWRhdGEocHJvdmlkZXIudXNlQ2xhc3MsIHByb3ZpZGVyLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICBjb21waWxlRGVwcyA9IGNvbXBpbGVUeXBlTWV0YWRhdGEuZGlEZXBzO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVyLnRva2VuID09PSBwcm92aWRlci51c2VDbGFzcykge1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgY29tcGlsZVR5cGVNZXRhZGF0YSBhcyBpdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBsaWZlY3ljbGVIb29rcy4uLlxuICAgICAgICAgICAgICAgIHRva2VuID0geyBpZGVudGlmaWVyOiBjb21waWxlVHlwZU1ldGFkYXRhIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgY29tcGlsZUZhY3RvcnlNZXRhZGF0YSA9IHRoaXMuX2dldEZhY3RvcnlNZXRhZGF0YShwcm92aWRlci51c2VGYWN0b3J5LCBwcm92aWRlci5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgY29tcGlsZURlcHMgPSBjb21waWxlRmFjdG9yeU1ldGFkYXRhLmRpRGVwcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgdXNlQ2xhc3M6IGNvbXBpbGVUeXBlTWV0YWRhdGEsXG4gICAgICAgICAgICB1c2VWYWx1ZTogcHJvdmlkZXIudXNlVmFsdWUsXG4gICAgICAgICAgICB1c2VGYWN0b3J5OiBjb21waWxlRmFjdG9yeU1ldGFkYXRhLFxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IHByb3ZpZGVyLnVzZUV4aXN0aW5nID8gdGhpcy5fZ2V0VG9rZW5NZXRhZGF0YShwcm92aWRlci51c2VFeGlzdGluZykgOiBudWxsLFxuICAgICAgICAgICAgZGVwczogY29tcGlsZURlcHMsXG4gICAgICAgICAgICBtdWx0aTogcHJvdmlkZXIubXVsdGlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcXVlcmllc1xuICAgICAqIEBwYXJhbSB7P30gaXNWaWV3UXVlcnlcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLnByb3RvdHlwZS5fZ2V0UXVlcmllc01ldGFkYXRhID0gZnVuY3Rpb24gKHF1ZXJpZXMsIGlzVmlld1F1ZXJ5LCBkaXJlY3RpdmVUeXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhxdWVyaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5ID0gcXVlcmllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmlzVmlld1F1ZXJ5ID09PSBpc1ZpZXdRdWVyeSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKF90aGlzLl9nZXRRdWVyeU1ldGFkYXRhKHF1ZXJ5LCBwcm9wZXJ0eU5hbWUsIGRpcmVjdGl2ZVR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX3F1ZXJ5VmFyQmluZGluZ3MgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIHNlbGVjdG9yLnNwbGl0KC9cXHMqLFxccyovKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHFcbiAgICAgKiBAcGFyYW0gez99IHByb3BlcnR5TmFtZVxuICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIucHJvdG90eXBlLl9nZXRRdWVyeU1ldGFkYXRhID0gZnVuY3Rpb24gKHEsIHByb3BlcnR5TmFtZSwgdHlwZU9yRnVuYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RvcnM7XG4gICAgICAgIGlmICh0eXBlb2YgcS5zZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlbGVjdG9ycyA9XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcnlWYXJCaW5kaW5ncyhxLnNlbGVjdG9yKS5tYXAoZnVuY3Rpb24gKHZhck5hbWUpIHsgcmV0dXJuIF90aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHZhck5hbWUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcS5zZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiQ2FuJ3QgY29uc3RydWN0IGEgcXVlcnkgZm9yIHRoZSBwcm9wZXJ0eSBcXFwiXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIlxcXCIgb2YgXFxcIlwiICsgc3RyaW5naWZ5VHlwZSh0eXBlT3JGdW5jKSArIFwiXFxcIiBzaW5jZSB0aGUgcXVlcnkgc2VsZWN0b3Igd2Fzbid0IGRlZmluZWQuXCIpLCB0eXBlT3JGdW5jKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IFt0aGlzLl9nZXRUb2tlbk1ldGFkYXRhKHEuc2VsZWN0b3IpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnMsXG4gICAgICAgICAgICBmaXJzdDogcS5maXJzdCxcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzOiBxLmRlc2NlbmRhbnRzLCBwcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgIHJlYWQ6IHEucmVhZCA/IHRoaXMuX2dldFRva2VuTWV0YWRhdGEocS5yZWFkKSA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXJyb3JcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gb3RoZXJUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlci5wcm90b3R5cGUuX3JlcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycm9yLCB0eXBlLCBvdGhlclR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Vycm9yQ29sbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvckNvbGxlY3RvcihlcnJvciwgdHlwZSk7XG4gICAgICAgICAgICBpZiAob3RoZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JDb2xsZWN0b3IoZXJyb3IsIG90aGVyVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyO1xufSgpKTtcbkNvbXBpbGVNZXRhZGF0YVJlc29sdmVyLmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkNvbXBpbGVNZXRhZGF0YVJlc29sdmVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgeyB0eXBlOiBOZ01vZHVsZVJlc29sdmVyLCB9LFxuICAgIHsgdHlwZTogRGlyZWN0aXZlUmVzb2x2ZXIsIH0sXG4gICAgeyB0eXBlOiBQaXBlUmVzb2x2ZXIsIH0sXG4gICAgeyB0eXBlOiBTdW1tYXJ5UmVzb2x2ZXIsIH0sXG4gICAgeyB0eXBlOiBFbGVtZW50U2NoZW1hUmVnaXN0cnksIH0sXG4gICAgeyB0eXBlOiBEaXJlY3RpdmVOb3JtYWxpemVyLCB9LFxuICAgIHsgdHlwZTogybVDb25zb2xlLCB9LFxuICAgIHsgdHlwZTogU3RhdGljU3ltYm9sQ2FjaGUsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sXSB9LFxuICAgIHsgdHlwZTogybVSZWZsZWN0b3JSZWFkZXIsIH0sXG4gICAgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7IHR5cGU6IE9wdGlvbmFsIH0sIHsgdHlwZTogSW5qZWN0LCBhcmdzOiBbRVJST1JfQ09MTEVDVE9SX1RPS0VOLF0gfSxdIH0sXG5dOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IHRyZWVcbiAqIEBwYXJhbSB7Pz19IG91dFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkFycmF5KHRyZWUsIG91dCkge1xuICAgIGlmIChvdXQgPT09IHZvaWQgMCkgeyBvdXQgPSBbXTsgfVxuICAgIGlmICh0cmVlKSB7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpdGVtID0gcmVzb2x2ZUZvcndhcmRSZWYodHJlZVtpXSk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGZsYXR0ZW5BcnJheShpdGVtLCBvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBhcnJheVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZGVkdXBlQXJyYXkoYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhcnJheSkpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdHJlZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkFuZERlZHVwZUFycmF5KHRyZWUpIHtcbiAgICByZXR1cm4gZGVkdXBlQXJyYXkoZmxhdHRlbkFycmF5KHRyZWUpKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB8fCAodmFsdWUgaW5zdGFuY2VvZiBUeXBlKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSByZWZsZWN0b3JcbiAqIEBwYXJhbSB7P30gdHlwZVxuICogQHBhcmFtIHs/fSBjbXBNZXRhZGF0YVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29tcG9uZW50TW9kdWxlVXJsKHJlZmxlY3RvciwgdHlwZSwgY21wTWV0YWRhdGEpIHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICByZXR1cm4gcmVmbGVjdG9yLnJlc291cmNlVXJpKHR5cGUpO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtb2R1bGVJZCA9IGNtcE1ldGFkYXRhLm1vZHVsZUlkO1xuICAgIGlmICh0eXBlb2YgbW9kdWxlSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNjaGVtZSA9IGdldFVybFNjaGVtZShtb2R1bGVJZCk7XG4gICAgICAgIHJldHVybiBzY2hlbWUgPyBtb2R1bGVJZCA6IFwicGFja2FnZTpcIiArIG1vZHVsZUlkICsgTU9EVUxFX1NVRkZJWDtcbiAgICB9XG4gICAgZWxzZSBpZiAobW9kdWxlSWQgIT09IG51bGwgJiYgbW9kdWxlSWQgIT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBzeW50YXhFcnJvcihcIm1vZHVsZUlkIHNob3VsZCBiZSBhIHN0cmluZyBpbiBcXFwiXCIgKyBzdHJpbmdpZnlUeXBlKHR5cGUpICsgXCJcXFwiLiBTZWUgaHR0cHM6Ly9nb28uZ2wvd0lERGlMIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcblwiICtcbiAgICAgICAgICAgIFwiSWYgeW91J3JlIHVzaW5nIFdlYnBhY2sgeW91IHNob3VsZCBpbmxpbmUgdGhlIHRlbXBsYXRlIGFuZCB0aGUgc3R5bGVzLCBzZWUgaHR0cHM6Ly9nb28uZ2wvWDJKOHpjLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZmxlY3Rvci5pbXBvcnRVcmkodHlwZSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEBwYXJhbSB7P30gdGFyZ2V0SWRlbnRpZmllcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RJZGVudGlmaWVycyh2YWx1ZSwgdGFyZ2V0SWRlbnRpZmllcnMpIHtcbiAgICB2aXNpdFZhbHVlKHZhbHVlLCBuZXcgX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcigpLCB0YXJnZXRJZGVudGlmaWVycyk7XG59XG52YXIgX0NvbXBpbGVWYWx1ZUNvbnZlcnRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9Db21waWxlVmFsdWVDb252ZXJ0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRJZGVudGlmaWVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0NvbXBpbGVWYWx1ZUNvbnZlcnRlci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgdGFyZ2V0SWRlbnRpZmllcnMpIHtcbiAgICAgICAgdGFyZ2V0SWRlbnRpZmllcnMucHVzaCh7IHJlZmVyZW5jZTogdmFsdWUgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gX0NvbXBpbGVWYWx1ZUNvbnZlcnRlcjtcbn0oVmFsdWVUcmFuc2Zvcm1lcikpO1xuLyoqXG4gKiBAcGFyYW0gez99IHR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVR5cGUodHlwZSkge1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgKyBcIiBpbiBcIiArIHR5cGUuZmlsZVBhdGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gybVzdHJpbmdpZnkodHlwZSk7XG4gICAgfVxufVxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBhIGNvbXBvbmVudCBpcyBzdGlsbCBiZWluZyBsb2FkZWQgaW4gYSBzeW5jaHJvbm91cyBjb21waWxlLlxuICogQHBhcmFtIHs/fSBjb21wVHlwZVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29tcG9uZW50U3RpbGxMb2FkaW5nRXJyb3IoY29tcFR5cGUpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcnJvciA9IEVycm9yKFwiQ2FuJ3QgY29tcGlsZSBzeW5jaHJvbm91c2x5IGFzIFwiICsgybVzdHJpbmdpZnkoY29tcFR5cGUpICsgXCIgaXMgc3RpbGwgYmVpbmcgbG9hZGVkIVwiKTtcbiAgICAoKGVycm9yKSlbybVFUlJPUl9DT01QT05FTlRfVFlQRV0gPSBjb21wVHlwZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgVHlwZU1vZGlmaWVyID0ge307XG5UeXBlTW9kaWZpZXIuQ29uc3QgPSAwO1xuVHlwZU1vZGlmaWVyW1R5cGVNb2RpZmllci5Db25zdF0gPSBcIkNvbnN0XCI7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgVHlwZSQxID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUeXBlJDEobW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHRoaXMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICAgICAgICBpZiAoIW1vZGlmaWVycykge1xuICAgICAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFR5cGUkMS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZGlmaWVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBUeXBlJDEucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgcmV0dXJuIFR5cGUkMTtcbn0oKSk7XG52YXIgQnVpbHRpblR5cGVOYW1lID0ge307XG5CdWlsdGluVHlwZU5hbWUuRHluYW1pYyA9IDA7XG5CdWlsdGluVHlwZU5hbWUuQm9vbCA9IDE7XG5CdWlsdGluVHlwZU5hbWUuU3RyaW5nID0gMjtcbkJ1aWx0aW5UeXBlTmFtZS5JbnQgPSAzO1xuQnVpbHRpblR5cGVOYW1lLk51bWJlciA9IDQ7XG5CdWlsdGluVHlwZU5hbWUuRnVuY3Rpb24gPSA1O1xuQnVpbHRpblR5cGVOYW1lLkluZmVycmVkID0gNjtcbkJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWUuRHluYW1pY10gPSBcIkR5bmFtaWNcIjtcbkJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWUuQm9vbF0gPSBcIkJvb2xcIjtcbkJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWUuU3RyaW5nXSA9IFwiU3RyaW5nXCI7XG5CdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lLkludF0gPSBcIkludFwiO1xuQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZS5OdW1iZXJdID0gXCJOdW1iZXJcIjtcbkJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWUuRnVuY3Rpb25dID0gXCJGdW5jdGlvblwiO1xuQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZS5JbmZlcnJlZF0gPSBcIkluZmVycmVkXCI7XG52YXIgQnVpbHRpblR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCdWlsdGluVHlwZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCdWlsdGluVHlwZShuYW1lLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEJ1aWx0aW5UeXBlLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJ1aWx0aW50VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBCdWlsdGluVHlwZTtcbn0oVHlwZSQxKSk7XG52YXIgRXhwcmVzc2lvblR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHByZXNzaW9uVHlwZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvblR5cGUodmFsdWUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uVHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHByZXNzaW9uVHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBFeHByZXNzaW9uVHlwZTtcbn0oVHlwZSQxKSk7XG52YXIgQXJyYXlUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlUeXBlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb2ZcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBcnJheVR5cGUob2YsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtb2RpZmllcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9mID0gb2Y7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBcnJheVR5cGUucHJvdG90eXBlLnZpc2l0VHlwZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJyYXlUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5VHlwZTtcbn0oVHlwZSQxKSk7XG52YXIgTWFwVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFR5cGUsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBUeXBlKHZhbHVlVHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1vZGlmaWVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWVUeXBlID0gdmFsdWVUeXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWFwVHlwZS5wcm90b3R5cGUudmlzaXRUeXBlID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgcmV0dXJuIHZpc2l0b3IudmlzaXRNYXBUeXBlKHRoaXMsIGNvbnRleHQpOyB9O1xuICAgIHJldHVybiBNYXBUeXBlO1xufShUeXBlJDEpKTtcbnZhciBEWU5BTUlDX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkR5bmFtaWMpO1xudmFyIElORkVSUkVEX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkluZmVycmVkKTtcbnZhciBCT09MX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkJvb2wpO1xudmFyIElOVF9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5JbnQpO1xudmFyIE5VTUJFUl9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5OdW1iZXIpO1xudmFyIFNUUklOR19UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5TdHJpbmcpO1xudmFyIEZVTkNUSU9OX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkZ1bmN0aW9uKTtcbnZhciBCaW5hcnlPcGVyYXRvciA9IHt9O1xuQmluYXJ5T3BlcmF0b3IuRXF1YWxzID0gMDtcbkJpbmFyeU9wZXJhdG9yLk5vdEVxdWFscyA9IDE7XG5CaW5hcnlPcGVyYXRvci5JZGVudGljYWwgPSAyO1xuQmluYXJ5T3BlcmF0b3IuTm90SWRlbnRpY2FsID0gMztcbkJpbmFyeU9wZXJhdG9yLk1pbnVzID0gNDtcbkJpbmFyeU9wZXJhdG9yLlBsdXMgPSA1O1xuQmluYXJ5T3BlcmF0b3IuRGl2aWRlID0gNjtcbkJpbmFyeU9wZXJhdG9yLk11bHRpcGx5ID0gNztcbkJpbmFyeU9wZXJhdG9yLk1vZHVsbyA9IDg7XG5CaW5hcnlPcGVyYXRvci5BbmQgPSA5O1xuQmluYXJ5T3BlcmF0b3IuT3IgPSAxMDtcbkJpbmFyeU9wZXJhdG9yLkxvd2VyID0gMTE7XG5CaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFscyA9IDEyO1xuQmluYXJ5T3BlcmF0b3IuQmlnZ2VyID0gMTM7XG5CaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHMgPSAxNDtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLkVxdWFsc10gPSBcIkVxdWFsc1wiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzXSA9IFwiTm90RXF1YWxzXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5JZGVudGljYWxdID0gXCJJZGVudGljYWxcIjtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbF0gPSBcIk5vdElkZW50aWNhbFwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTWludXNdID0gXCJNaW51c1wiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuUGx1c10gPSBcIlBsdXNcIjtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLkRpdmlkZV0gPSBcIkRpdmlkZVwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHldID0gXCJNdWx0aXBseVwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuTW9kdWxvXSA9IFwiTW9kdWxvXCI7XG5CaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvci5BbmRdID0gXCJBbmRcIjtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLk9yXSA9IFwiT3JcIjtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLkxvd2VyXSA9IFwiTG93ZXJcIjtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzXSA9IFwiTG93ZXJFcXVhbHNcIjtcbkJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yLkJpZ2dlcl0gPSBcIkJpZ2dlclwiO1xuQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzXSA9IFwiQmlnZ2VyRXF1YWxzXCI7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV4cHJlc3Npb24odHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUucHJvcCA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFByb3BFeHByKHRoaXMsIG5hbWUsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5rZXkgPSBmdW5jdGlvbiAoaW5kZXgsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbmV3IFJlYWRLZXlFeHByKHRoaXMsIGluZGV4LCB0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuY2FsbE1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZva2VNZXRob2RFeHByKHRoaXMsIG5hbWUsIHBhcmFtcywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmNhbGxGbiA9IGZ1bmN0aW9uIChwYXJhbXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZva2VGdW5jdGlvbkV4cHIodGhpcywgcGFyYW1zLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmluc3RhbnRpYXRlID0gZnVuY3Rpb24gKHBhcmFtcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFudGlhdGVFeHByKHRoaXMsIHBhcmFtcywgdHlwZSwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRydWVDYXNlXG4gICAgICogQHBhcmFtIHs/PX0gZmFsc2VDYXNlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuY29uZGl0aW9uYWwgPSBmdW5jdGlvbiAodHJ1ZUNhc2UsIGZhbHNlQ2FzZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAoZmFsc2VDYXNlID09PSB2b2lkIDApIHsgZmFsc2VDYXNlID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsRXhwcih0aGlzLCB0cnVlQ2FzZSwgZmFsc2VDYXNlLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5FcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5pZGVudGljYWwgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbCwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubm90SWRlbnRpY2FsID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWwsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm1pbnVzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NaW51cywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUucGx1cyA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuUGx1cywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5EaXZpZGUsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NdWx0aXBseSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Nb2R1bG8sIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQW5kLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuT3IsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJoc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4cHJlc3Npb24ucHJvdG90eXBlLmxvd2VyID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Mb3dlciwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUubG93ZXJFcXVhbHMgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByaHNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5iaWdnZXIgPSBmdW5jdGlvbiAocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkJpZ2dlciwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUuYmlnZ2VyRXF1YWxzID0gZnVuY3Rpb24gKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5pc0JsYW5rID0gZnVuY3Rpb24gKHNvdXJjZVNwYW4pIHtcbiAgICAgICAgLy8gTm90ZTogV2UgdXNlIGVxdWFscyBieSBwdXJwb3NlIGhlcmUgdG8gY29tcGFyZSB0byBudWxsIGFuZCB1bmRlZmluZWQgaW4gSlMuXG4gICAgICAgIC8vIFdlIHVzZSB0aGUgdHlwZWQgbnVsbCB0byBhbGxvdyBzdHJpY3ROdWxsQ2hlY2tzIHRvIG5hcnJvdyB0eXBlcy5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFRZUEVEX05VTExfRVhQUiwgc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHByZXNzaW9uLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24gKHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXN0RXhwcih0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvbi5wcm90b3R5cGUudG9TdG10ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodGhpcyk7IH07XG4gICAgcmV0dXJuIEV4cHJlc3Npb247XG59KCkpO1xudmFyIEJ1aWx0aW5WYXIgPSB7fTtcbkJ1aWx0aW5WYXIuVGhpcyA9IDA7XG5CdWlsdGluVmFyLlN1cGVyID0gMTtcbkJ1aWx0aW5WYXIuQ2F0Y2hFcnJvciA9IDI7XG5CdWlsdGluVmFyLkNhdGNoU3RhY2sgPSAzO1xuQnVpbHRpblZhcltCdWlsdGluVmFyLlRoaXNdID0gXCJUaGlzXCI7XG5CdWlsdGluVmFyW0J1aWx0aW5WYXIuU3VwZXJdID0gXCJTdXBlclwiO1xuQnVpbHRpblZhcltCdWlsdGluVmFyLkNhdGNoRXJyb3JdID0gXCJDYXRjaEVycm9yXCI7XG5CdWlsdGluVmFyW0J1aWx0aW5WYXIuQ2F0Y2hTdGFja10gPSBcIkNhdGNoU3RhY2tcIjtcbnZhciBSZWFkVmFyRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlYWRWYXJFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVhZFZhckV4cHIobmFtZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgX3RoaXMuYnVpbHRpbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmJ1aWx0aW4gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWFkVmFyRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkVmFyRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlYWRWYXJFeHByLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZVZhckV4cHIodGhpcy5uYW1lLCB2YWx1ZSwgbnVsbCwgdGhpcy5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWFkVmFyRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFdyaXRlVmFyRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdyaXRlVmFyRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBXcml0ZVZhckV4cHIobmFtZSwgdmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlIHx8IHZhbHVlLnR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV3JpdGVWYXJFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlVmFyRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFdyaXRlVmFyRXhwci5wcm90b3R5cGUudG9EZWNsU3RtdCA9IGZ1bmN0aW9uICh0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHRoaXMubmFtZSwgdGhpcy52YWx1ZSwgdHlwZSwgbW9kaWZpZXJzLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlVmFyRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFdyaXRlS2V5RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdyaXRlS2V5RXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBpbmRleFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdyaXRlS2V5RXhwcihyZWNlaXZlciwgaW5kZXgsIHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCB2YWx1ZS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV3JpdGVLZXlFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBXcml0ZUtleUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBXcml0ZVByb3BFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV3JpdGVQcm9wRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gV3JpdGVQcm9wRXhwcihyZWNlaXZlciwgbmFtZSwgdmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlIHx8IHZhbHVlLnR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgV3JpdGVQcm9wRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZVByb3BFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlUHJvcEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBCdWlsdGluTWV0aG9kID0ge307XG5CdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5ID0gMDtcbkJ1aWx0aW5NZXRob2QuU3Vic2NyaWJlT2JzZXJ2YWJsZSA9IDE7XG5CdWlsdGluTWV0aG9kLkJpbmQgPSAyO1xuQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kLkNvbmNhdEFycmF5XSA9IFwiQ29uY2F0QXJyYXlcIjtcbkJ1aWx0aW5NZXRob2RbQnVpbHRpbk1ldGhvZC5TdWJzY3JpYmVPYnNlcnZhYmxlXSA9IFwiU3Vic2NyaWJlT2JzZXJ2YWJsZVwiO1xuQnVpbHRpbk1ldGhvZFtCdWlsdGluTWV0aG9kLkJpbmRdID0gXCJCaW5kXCI7XG52YXIgSW52b2tlTWV0aG9kRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEludm9rZU1ldGhvZEV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZWNlaXZlclxuICAgICAqIEBwYXJhbSB7P30gbWV0aG9kXG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbnZva2VNZXRob2RFeHByKHJlY2VpdmVyLCBtZXRob2QsIGFyZ3MsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gbWV0aG9kO1xuICAgICAgICAgICAgX3RoaXMuYnVpbHRpbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmJ1aWx0aW4gPSBtZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEludm9rZU1ldGhvZEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW52b2tlTWV0aG9kRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJbnZva2VNZXRob2RFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgSW52b2tlRnVuY3Rpb25FeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW52b2tlRnVuY3Rpb25FeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEludm9rZUZ1bmN0aW9uRXhwcihmbiwgYXJncywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZuID0gZm47XG4gICAgICAgIF90aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW52b2tlRnVuY3Rpb25FeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludm9rZUZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBJbnZva2VGdW5jdGlvbkV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBJbnN0YW50aWF0ZUV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnN0YW50aWF0ZUV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjbGFzc0V4cHJcbiAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEluc3RhbnRpYXRlRXhwcihjbGFzc0V4cHIsIGFyZ3MsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2xhc3NFeHByID0gY2xhc3NFeHByO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEluc3RhbnRpYXRlRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnN0YW50aWF0ZUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5zdGFudGlhdGVFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTGl0ZXJhbEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXRlcmFsRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXRlcmFsRXhwcih2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXRlcmFsRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIEV4dGVybmFsRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV4dGVybmFsRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVQYXJhbXNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxFeHByKHZhbHVlLCB0eXBlLCB0eXBlUGFyYW1zLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBfdGhpcy50eXBlUGFyYW1zID0gdHlwZVBhcmFtcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4dGVybmFsRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHRlcm5hbEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRXh0ZXJuYWxFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgQ29uZGl0aW9uYWxFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uZGl0aW9uYWxFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHs/fSB0cnVlQ2FzZVxuICAgICAqIEBwYXJhbSB7Pz19IGZhbHNlQ2FzZVxuICAgICAqIEBwYXJhbSB7Pz19IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByKGNvbmRpdGlvbiwgdHJ1ZUNhc2UsIGZhbHNlQ2FzZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAoZmFsc2VDYXNlID09PSB2b2lkIDApIHsgZmFsc2VDYXNlID0gbnVsbDsgfVxuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUgfHwgdHJ1ZUNhc2UudHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICBfdGhpcy5mYWxzZUNhc2UgPSBmYWxzZUNhc2U7XG4gICAgICAgIF90aGlzLnRydWVDYXNlID0gdHJ1ZUNhc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb25kaXRpb25hbEV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmRpdGlvbmFsRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIE5vdEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3RFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29uZGl0aW9uXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5vdEV4cHIoY29uZGl0aW9uLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIEJPT0xfVFlQRSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTm90RXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXROb3RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vdEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBDYXN0RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhc3RFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2FzdEV4cHIodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENhc3RFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENhc3RFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENhc3RFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgRm5QYXJhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZuUGFyYW0obmFtZSwgdHlwZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7IHR5cGUgPSBudWxsOyB9XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIHJldHVybiBGblBhcmFtO1xufSgpKTtcbnZhciBGdW5jdGlvbkV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGdW5jdGlvbkV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uRXhwcihwYXJhbXMsIHN0YXRlbWVudHMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIF90aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRnVuY3Rpb25FeHByLnByb3RvdHlwZS50b0RlY2xTdG10ID0gZnVuY3Rpb24gKG5hbWUsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgdGhpcy5wYXJhbXMsIHRoaXMuc3RhdGVtZW50cywgdGhpcy50eXBlLCBtb2RpZmllcnMsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICByZXR1cm4gRnVuY3Rpb25FeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgQmluYXJ5T3BlcmF0b3JFeHByID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmluYXJ5T3BlcmF0b3JFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gb3BlcmF0b3JcbiAgICAgKiBAcGFyYW0gez99IGxoc1xuICAgICAqIEBwYXJhbSB7P30gcmhzXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCaW5hcnlPcGVyYXRvckV4cHIob3BlcmF0b3IsIGxocywgcmhzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSB8fCBsaHMudHlwZSwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgX3RoaXMucmhzID0gcmhzO1xuICAgICAgICBfdGhpcy5saHMgPSBsaHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5hcnlPcGVyYXRvckV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmFyeU9wZXJhdG9yRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIFJlYWRQcm9wRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlYWRQcm9wRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlY2VpdmVyXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWFkUHJvcEV4cHIocmVjZWl2ZXIsIG5hbWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlYWRQcm9wRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkUHJvcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWFkUHJvcEV4cHIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlUHJvcEV4cHIodGhpcy5yZWNlaXZlciwgdGhpcy5uYW1lLCB2YWx1ZSwgbnVsbCwgdGhpcy5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWFkUHJvcEV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBSZWFkS2V5RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlYWRLZXlFeHByLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IGluZGV4XG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZWFkS2V5RXhwcihyZWNlaXZlciwgaW5kZXgsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICBfdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVhZEtleUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZEtleUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWFkS2V5RXhwci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVLZXlFeHByKHRoaXMucmVjZWl2ZXIsIHRoaXMuaW5kZXgsIHZhbHVlLCBudWxsLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlYWRLZXlFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTGl0ZXJhbEFycmF5RXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWxBcnJheUV4cHIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbnRyaWVzXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXRlcmFsQXJyYXlFeHByKGVudHJpZXMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIExpdGVyYWxBcnJheUV4cHIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEFycmF5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsQXJyYXlFeHByO1xufShFeHByZXNzaW9uKSk7XG52YXIgTGl0ZXJhbE1hcEVudHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcGFyYW0gez89fSBxdW90ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXRlcmFsTWFwRW50cnkoa2V5LCB2YWx1ZSwgcXVvdGVkKSB7XG4gICAgICAgIGlmIChxdW90ZWQgPT09IHZvaWQgMCkgeyBxdW90ZWQgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnF1b3RlZCA9IHF1b3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIExpdGVyYWxNYXBFbnRyeTtcbn0oKSk7XG52YXIgTGl0ZXJhbE1hcEV4cHIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaXRlcmFsTWFwRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVudHJpZXNcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpdGVyYWxNYXBFeHByKGVudHJpZXMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICAgICAgX3RoaXMudmFsdWVUeXBlID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlVHlwZSA9IHR5cGUudmFsdWVUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBMaXRlcmFsTWFwRXhwci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsTWFwRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBMaXRlcmFsTWFwRXhwcjtcbn0oRXhwcmVzc2lvbikpO1xudmFyIENvbW1hRXhwciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbW1hRXhwciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcnRzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbW1hRXhwcihwYXJ0cywgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS50eXBlLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQ29tbWFFeHByLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb24gPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbW1hRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBDb21tYUV4cHI7XG59KEV4cHJlc3Npb24pKTtcbnZhciBUSElTX0VYUFIgPSBuZXcgUmVhZFZhckV4cHIoQnVpbHRpblZhci5UaGlzKTtcbnZhciBTVVBFUl9FWFBSID0gbmV3IFJlYWRWYXJFeHByKEJ1aWx0aW5WYXIuU3VwZXIpO1xudmFyIENBVENIX0VSUk9SX1ZBUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLkNhdGNoRXJyb3IpO1xudmFyIENBVENIX1NUQUNLX1ZBUiA9IG5ldyBSZWFkVmFyRXhwcihCdWlsdGluVmFyLkNhdGNoU3RhY2spO1xudmFyIE5VTExfRVhQUiA9IG5ldyBMaXRlcmFsRXhwcihudWxsLCBudWxsKTtcbnZhciBUWVBFRF9OVUxMX0VYUFIgPSBuZXcgTGl0ZXJhbEV4cHIobnVsbCwgSU5GRVJSRURfVFlQRSk7XG52YXIgU3RtdE1vZGlmaWVyID0ge307XG5TdG10TW9kaWZpZXIuRmluYWwgPSAwO1xuU3RtdE1vZGlmaWVyLlByaXZhdGUgPSAxO1xuU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllci5GaW5hbF0gPSBcIkZpbmFsXCI7XG5TdG10TW9kaWZpZXJbU3RtdE1vZGlmaWVyLlByaXZhdGVdID0gXCJQcml2YXRlXCI7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgU3RhdGVtZW50ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBtb2RpZmllcnNcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGVtZW50KG1vZGlmaWVycywgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgaWYgKCFtb2RpZmllcnMpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZpZXJzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnQucHJvdG90eXBlLnZpc2l0U3RhdGVtZW50ID0gZnVuY3Rpb24gKHZpc2l0b3IsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZGlmaWVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnQucHJvdG90eXBlLmhhc01vZGlmaWVyID0gZnVuY3Rpb24gKG1vZGlmaWVyKSB7IHJldHVybiB0aGlzLm1vZGlmaWVycy5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTE7IH07XG4gICAgcmV0dXJuIFN0YXRlbWVudDtcbn0oKSk7XG52YXIgRGVjbGFyZVZhclN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWNsYXJlVmFyU3RtdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEZWNsYXJlVmFyU3RtdChuYW1lLCB2YWx1ZSwgdHlwZSwgbW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGUgfHwgdmFsdWUudHlwZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlY2xhcmVWYXJTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZVZhclN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjbGFyZVZhclN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIERlY2xhcmVGdW5jdGlvblN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWNsYXJlRnVuY3Rpb25TdG10LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEZWNsYXJlRnVuY3Rpb25TdG10KG5hbWUsIHBhcmFtcywgc3RhdGVtZW50cywgdHlwZSwgbW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBfdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgX3RoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2aXNpdG9yXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEZWNsYXJlRnVuY3Rpb25TdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBEZWNsYXJlRnVuY3Rpb25TdG10O1xufShTdGF0ZW1lbnQpKTtcbnZhciBFeHByZXNzaW9uU3RhdGVtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXhwcmVzc2lvblN0YXRlbWVudCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXhwcmVzc2lvblN0YXRlbWVudChleHByLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmV4cHIgPSBleHByO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRXhwcmVzc2lvblN0YXRlbWVudC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb25TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIEV4cHJlc3Npb25TdGF0ZW1lbnQ7XG59KFN0YXRlbWVudCkpO1xudmFyIFJldHVyblN0YXRlbWVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJldHVyblN0YXRlbWVudCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJldHVyblN0YXRlbWVudCh2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmV0dXJuU3RhdGVtZW50LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmV0dXJuU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXR1cm5TdGF0ZW1lbnQ7XG59KFN0YXRlbWVudCkpO1xudmFyIEFic3RyYWN0Q2xhc3NQYXJ0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQWJzdHJhY3RDbGFzc1BhcnQodHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgIGlmICghbW9kaWZpZXJzKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGlmaWVycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kaWZpZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0Q2xhc3NQYXJ0LnByb3RvdHlwZS5oYXNNb2RpZmllciA9IGZ1bmN0aW9uIChtb2RpZmllcikgeyByZXR1cm4gdGhpcy5tb2RpZmllcnMuaW5kZXhPZihtb2RpZmllcikgIT09IC0xOyB9O1xuICAgIHJldHVybiBBYnN0cmFjdENsYXNzUGFydDtcbn0oKSk7XG52YXIgQ2xhc3NGaWVsZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsYXNzRmllbGQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENsYXNzRmllbGQobmFtZSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2xhc3NGaWVsZDtcbn0oQWJzdHJhY3RDbGFzc1BhcnQpKTtcbnZhciBDbGFzc01ldGhvZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsYXNzTWV0aG9kLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICogQHBhcmFtIHs/fSBib2R5XG4gICAgICogQHBhcmFtIHs/PX0gdHlwZVxuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENsYXNzTWV0aG9kKG5hbWUsIHBhcmFtcywgYm9keSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICBfdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2xhc3NNZXRob2Q7XG59KEFic3RyYWN0Q2xhc3NQYXJ0KSk7XG52YXIgQ2xhc3NHZXR0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDbGFzc0dldHRlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IGJvZHlcbiAgICAgKiBAcGFyYW0gez89fSB0eXBlXG4gICAgICogQHBhcmFtIHs/PX0gbW9kaWZpZXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xhc3NHZXR0ZXIobmFtZSwgYm9keSwgdHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgbW9kaWZpZXJzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENsYXNzR2V0dGVyO1xufShBYnN0cmFjdENsYXNzUGFydCkpO1xudmFyIENsYXNzU3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENsYXNzU3RtdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IHBhcmVudFxuICAgICAqIEBwYXJhbSB7P30gZmllbGRzXG4gICAgICogQHBhcmFtIHs/fSBnZXR0ZXJzXG4gICAgICogQHBhcmFtIHs/fSBjb25zdHJ1Y3Rvck1ldGhvZFxuICAgICAqIEBwYXJhbSB7P30gbWV0aG9kc1xuICAgICAqIEBwYXJhbSB7Pz19IG1vZGlmaWVyc1xuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDbGFzc1N0bXQobmFtZSwgcGFyZW50LCBmaWVsZHMsIGdldHRlcnMsIGNvbnN0cnVjdG9yTWV0aG9kLCBtZXRob2RzLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IG51bGw7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kaWZpZXJzLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBfdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIF90aGlzLmdldHRlcnMgPSBnZXR0ZXJzO1xuICAgICAgICBfdGhpcy5jb25zdHJ1Y3Rvck1ldGhvZCA9IGNvbnN0cnVjdG9yTWV0aG9kO1xuICAgICAgICBfdGhpcy5tZXRob2RzID0gbWV0aG9kcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIENsYXNzU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmVDbGFzc1N0bXQodGhpcywgY29udGV4dCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2xhc3NTdG10O1xufShTdGF0ZW1lbnQpKTtcbnZhciBJZlN0bXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJZlN0bXQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb25kaXRpb25cbiAgICAgKiBAcGFyYW0gez99IHRydWVDYXNlXG4gICAgICogQHBhcmFtIHs/PX0gZmFsc2VDYXNlXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIElmU3RtdChjb25kaXRpb24sIHRydWVDYXNlLCBmYWxzZUNhc2UsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKGZhbHNlQ2FzZSA9PT0gdm9pZCAwKSB7IGZhbHNlQ2FzZSA9IFtdOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG51bGwsIHNvdXJjZVNwYW4pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgX3RoaXMudHJ1ZUNhc2UgPSB0cnVlQ2FzZTtcbiAgICAgICAgX3RoaXMuZmFsc2VDYXNlID0gZmFsc2VDYXNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSWZTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SWZTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIElmU3RtdDtcbn0oU3RhdGVtZW50KSk7XG52YXIgVHJ5Q2F0Y2hTdG10ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVHJ5Q2F0Y2hTdG10LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYm9keVN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBjYXRjaFN0bXRzXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyeUNhdGNoU3RtdChib2R5U3RtdHMsIGNhdGNoU3RtdHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbnVsbCwgc291cmNlU3BhbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYm9keVN0bXRzID0gYm9keVN0bXRzO1xuICAgICAgICBfdGhpcy5jYXRjaFN0bXRzID0gY2F0Y2hTdG10cztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpc2l0b3JcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFRyeUNhdGNoU3RtdC5wcm90b3R5cGUudmlzaXRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRyeUNhdGNoU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBUcnlDYXRjaFN0bXQ7XG59KFN0YXRlbWVudCkpO1xudmFyIFRocm93U3RtdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRocm93U3RtdCwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGVycm9yXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRocm93U3RtdChlcnJvciwgc291cmNlU3Bhbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCBzb3VyY2VTcGFuKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmlzaXRvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVGhyb3dTdG10LnByb3RvdHlwZS52aXNpdFN0YXRlbWVudCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGhyb3dTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFRocm93U3RtdDtcbn0oU3RhdGVtZW50KSk7XG52YXIgQXN0VHJhbnNmb3JtZXIkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN0VHJhbnNmb3JtZXIkMSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS50cmFuc2Zvcm1FeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHsgcmV0dXJuIGV4cHI7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS50cmFuc2Zvcm1TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHsgcmV0dXJuIHN0bXQ7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0UmVhZFZhckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIoYXN0LCBjb250ZXh0KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0V3JpdGVWYXJFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgV3JpdGVWYXJFeHByKGV4cHIubmFtZSwgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIudHlwZSwgZXhwci5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0V3JpdGVLZXlFeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgV3JpdGVLZXlFeHByKGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIudHlwZSwgZXhwci5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IFdyaXRlUHJvcEV4cHIoZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIubmFtZSwgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGV4cHIudHlwZSwgZXhwci5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRJbnZva2VNZXRob2RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRob2QgPSBhc3QuYnVpbHRpbiB8fCBhc3QubmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgSW52b2tlTWV0aG9kRXhwcihhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBtZXRob2QsIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBJbnZva2VGdW5jdGlvbkV4cHIoYXN0LmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IEluc3RhbnRpYXRlRXhwcihhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihhc3QsIGNvbnRleHQpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihhc3QsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBDb25kaXRpb25hbEV4cHIoYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50cnVlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IE5vdEV4cHIoYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgQ2FzdEV4cHIoYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IEZ1bmN0aW9uRXhwcihhc3QucGFyYW1zLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhhc3Quc3RhdGVtZW50cywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoYXN0Lm9wZXJhdG9yLCBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1FeHByKG5ldyBSZWFkUHJvcEV4cHIoYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgYXN0Lm5hbWUsIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0UmVhZEtleUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IFJlYWRLZXlFeHByKGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIGFzdC50eXBlLCBhc3Quc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtRXhwcihuZXcgTGl0ZXJhbEFycmF5RXhwcih0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGNvbnRleHQpLCBhc3QudHlwZSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdExpdGVyYWxNYXBFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyaWVzID0gYXN0LmVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gbmV3IExpdGVyYWxNYXBFbnRyeShlbnRyeS5rZXksIGVudHJ5LnZhbHVlLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCksIGVudHJ5LnF1b3RlZCk7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXBUeXBlID0gbmV3IE1hcFR5cGUoYXN0LnZhbHVlVHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IExpdGVyYWxNYXBFeHByKGVudHJpZXMsIG1hcFR5cGUsIGFzdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRDb21tYUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUV4cHIobmV3IENvbW1hRXhwcih0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LnBhcnRzLCBjb250ZXh0KSwgYXN0LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwcnNcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0QWxsRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGV4cHJzLm1hcChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IERlY2xhcmVWYXJTdG10KHN0bXQubmFtZSwgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHN0bXQudHlwZSwgc3RtdC5tb2RpZmllcnMsIHN0bXQuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KG5ldyBEZWNsYXJlRnVuY3Rpb25TdG10KHN0bXQubmFtZSwgc3RtdC5wYXJhbXMsIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY29udGV4dCksIHN0bXQudHlwZSwgc3RtdC5tb2RpZmllcnMsIHN0bXQuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgRXhwcmVzc2lvblN0YXRlbWVudChzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgUmV0dXJuU3RhdGVtZW50KHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpLCBzdG10LnNvdXJjZVNwYW4pLCBjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50ID0gc3RtdC5wYXJlbnQudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnZXR0ZXJzID0gc3RtdC5nZXR0ZXJzLm1hcChmdW5jdGlvbiAoZ2V0dGVyKSB7IHJldHVybiBuZXcgQ2xhc3NHZXR0ZXIoZ2V0dGVyLm5hbWUsIF90aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhnZXR0ZXIuYm9keSwgY29udGV4dCksIGdldHRlci50eXBlLCBnZXR0ZXIubW9kaWZpZXJzKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0b3JNZXRob2QgPSBzdG10LmNvbnN0cnVjdG9yTWV0aG9kICYmXG4gICAgICAgICAgICBuZXcgQ2xhc3NNZXRob2Qoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5uYW1lLCBzdG10LmNvbnN0cnVjdG9yTWV0aG9kLnBhcmFtcywgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5LCBjb250ZXh0KSwgc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC50eXBlLCBzdG10LmNvbnN0cnVjdG9yTWV0aG9kLm1vZGlmaWVycyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1ldGhvZHMgPSBzdG10Lm1ldGhvZHMubWFwKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIG5ldyBDbGFzc01ldGhvZChtZXRob2QubmFtZSwgbWV0aG9kLnBhcmFtcywgX3RoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKG1ldGhvZC5ib2R5LCBjb250ZXh0KSwgbWV0aG9kLnR5cGUsIG1ldGhvZC5tb2RpZmllcnMpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtU3RtdChuZXcgQ2xhc3NTdG10KHN0bXQubmFtZSwgcGFyZW50LCBzdG10LmZpZWxkcywgZ2V0dGVycywgY3Rvck1ldGhvZCwgbWV0aG9kcywgc3RtdC5tb2RpZmllcnMsIHN0bXQuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IElmU3RtdChzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCksIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGNvbnRleHQpLCB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY29udGV4dCksIHN0bXQuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IFRyeUNhdGNoU3RtdCh0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY29udGV4dCksIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY2F0Y2hTdG10cywgY29udGV4dCksIHN0bXQuc291cmNlU3BhbiksIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBc3RUcmFuc2Zvcm1lciQxLnByb3RvdHlwZS52aXNpdFRocm93U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybVN0bXQobmV3IFRocm93U3RtdChzdG10LmVycm9yLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSwgc3RtdC5zb3VyY2VTcGFuKSwgY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFzdFRyYW5zZm9ybWVyJDEucHJvdG90eXBlLnZpc2l0Q29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1TdG10KHN0bXQsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10c1xuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQXN0VHJhbnNmb3JtZXIkMS5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0bXRzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzdG10cy5tYXAoZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBc3RUcmFuc2Zvcm1lciQxO1xufSgpKTtcbnZhciBSZWN1cnNpdmVBc3RWaXNpdG9yJDEgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgcmV0dXJuIGFzdDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFdyaXRlUHJvcEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY29udGV4dCkge1xuICAgICAgICBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRJbnZva2VNZXRob2RFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyByZXR1cm4gYXN0OyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdE5vdEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhhc3Quc3RhdGVtZW50cywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRSZWFkUHJvcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYXN0LmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5LnZhbHVlLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRDb21tYUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QucGFydHMsIGNvbnRleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByc1xuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdEFsbEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGV4cHJzLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGV4cHJzLmZvckVhY2goZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXREZWNsYXJlVmFyU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnN0YXRlbWVudHMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN0bXQucGFyZW50LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjb250ZXh0KTsgfSk7XG4gICAgICAgIGlmIChzdG10LmNvbnN0cnVjdG9yTWV0aG9kKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHN0bXQubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIF90aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhtZXRob2QuYm9keSwgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUmVjdXJzaXZlQXN0VmlzaXRvciQxLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMS5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuY2F0Y2hTdG10cywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC5lcnJvci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0Q29tbWVudFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkgeyByZXR1cm4gc3RtdDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yJDEucHJvdG90eXBlLnZpc2l0QWxsU3RhdGVtZW50cyA9IGZ1bmN0aW9uIChzdG10cywgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzdG10cy5mb3JFYWNoKGZ1bmN0aW9uIChzdG10KSB7IHJldHVybiBzdG10LnZpc2l0U3RhdGVtZW50KF90aGlzLCBjb250ZXh0KTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVjdXJzaXZlQXN0VmlzaXRvciQxO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBzdG10c1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZmluZFJlYWRWYXJOYW1lcyhzdG10cykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX1JlYWRWYXJWaXNpdG9yKCk7XG4gICAgdmlzaXRvci52aXNpdEFsbFN0YXRlbWVudHMoc3RtdHMsIG51bGwpO1xuICAgIHJldHVybiB2aXNpdG9yLnZhck5hbWVzO1xufVxudmFyIF9SZWFkVmFyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9SZWFkVmFyVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBfUmVhZFZhclZpc2l0b3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZhck5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1JlYWRWYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGZ1bmN0aW9uc1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1JlYWRWYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY29udGV4dCkge1xuICAgICAgICAvLyBEb24ndCBkZXNjZW5kIGludG8gbmVzdGVkIGNsYXNzZXNcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1JlYWRWYXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZhck5hbWVzLmFkZChhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIF9SZWFkVmFyVmlzaXRvcjtcbn0oUmVjdXJzaXZlQXN0VmlzaXRvciQxKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gc3RtdFxuICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhcHBseVNvdXJjZVNwYW5Ub1N0YXRlbWVudElmTmVlZGVkKHN0bXQsIHNvdXJjZVNwYW4pIHtcbiAgICBpZiAoIXNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVyID0gbmV3IF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lcihzb3VyY2VTcGFuKTtcbiAgICByZXR1cm4gc3RtdC52aXNpdFN0YXRlbWVudCh0cmFuc2Zvcm1lciwgbnVsbCk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZXhwclxuICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBhcHBseVNvdXJjZVNwYW5Ub0V4cHJlc3Npb25JZk5lZWRlZChleHByLCBzb3VyY2VTcGFuKSB7XG4gICAgaWYgKCFzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lciA9IG5ldyBfQXBwbHlTb3VyY2VTcGFuVHJhbnNmb3JtZXIoc291cmNlU3Bhbik7XG4gICAgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKHRyYW5zZm9ybWVyLCBudWxsKTtcbn1cbnZhciBfQXBwbHlTb3VyY2VTcGFuVHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhfQXBwbHlTb3VyY2VTcGFuVHJhbnNmb3JtZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyKHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvYmpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9BcHBseVNvdXJjZVNwYW5UcmFuc2Zvcm1lci5wcm90b3R5cGUuX2Nsb25lID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9uZSA9IE9iamVjdC5jcmVhdGUob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGNsb25lW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1FeHByID0gZnVuY3Rpb24gKGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFleHByLnNvdXJjZVNwYW4pIHtcbiAgICAgICAgICAgIGV4cHIgPSB0aGlzLl9jbG9uZShleHByKTtcbiAgICAgICAgICAgIGV4cHIuc291cmNlU3BhbiA9IHRoaXMuc291cmNlU3BhbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FwcGx5U291cmNlU3BhblRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFzdG10LnNvdXJjZVNwYW4pIHtcbiAgICAgICAgICAgIHN0bXQgPSB0aGlzLl9jbG9uZShzdG10KTtcbiAgICAgICAgICAgIHN0bXQuc291cmNlU3BhbiA9IHRoaXMuc291cmNlU3BhbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9O1xuICAgIHJldHVybiBfQXBwbHlTb3VyY2VTcGFuVHJhbnNmb3JtZXI7XG59KEFzdFRyYW5zZm9ybWVyJDEpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBuYW1lXG4gKiBAcGFyYW0gez89fSB0eXBlXG4gKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB2YXJpYWJsZShuYW1lLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIobmFtZSwgdHlwZSwgc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaWRcbiAqIEBwYXJhbSB7Pz19IHR5cGVQYXJhbXNcbiAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGltcG9ydEV4cHIoaWQsIHR5cGVQYXJhbXMsIHNvdXJjZVNwYW4pIHtcbiAgICBpZiAodHlwZVBhcmFtcyA9PT0gdm9pZCAwKSB7IHR5cGVQYXJhbXMgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBFeHRlcm5hbEV4cHIoaWQsIG51bGwsIHR5cGVQYXJhbXMsIHNvdXJjZVNwYW4pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGlkXG4gKiBAcGFyYW0gez89fSB0eXBlUGFyYW1zXG4gKiBAcGFyYW0gez89fSB0eXBlTW9kaWZpZXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpbXBvcnRUeXBlKGlkLCB0eXBlUGFyYW1zLCB0eXBlTW9kaWZpZXJzKSB7XG4gICAgaWYgKHR5cGVQYXJhbXMgPT09IHZvaWQgMCkgeyB0eXBlUGFyYW1zID0gbnVsbDsgfVxuICAgIGlmICh0eXBlTW9kaWZpZXJzID09PSB2b2lkIDApIHsgdHlwZU1vZGlmaWVycyA9IG51bGw7IH1cbiAgICByZXR1cm4gaWQgIT0gbnVsbCA/IGV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoaWQsIHR5cGVQYXJhbXMpLCB0eXBlTW9kaWZpZXJzKSA6IG51bGw7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZXhwclxuICogQHBhcmFtIHs/PX0gdHlwZU1vZGlmaWVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXhwcmVzc2lvblR5cGUoZXhwciwgdHlwZU1vZGlmaWVycykge1xuICAgIGlmICh0eXBlTW9kaWZpZXJzID09PSB2b2lkIDApIHsgdHlwZU1vZGlmaWVycyA9IG51bGw7IH1cbiAgICByZXR1cm4gZXhwciAhPSBudWxsID8gbmV3IEV4cHJlc3Npb25UeXBlKGV4cHIsIHR5cGVNb2RpZmllcnMpIDogbnVsbDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YWx1ZXNcbiAqIEBwYXJhbSB7Pz19IHR5cGVcbiAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGxpdGVyYWxBcnIodmFsdWVzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5RXhwcih2YWx1ZXMsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlc1xuICogQHBhcmFtIHs/PX0gdHlwZVxuICogQHBhcmFtIHs/PX0gcXVvdGVkXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBsaXRlcmFsTWFwKHZhbHVlcywgdHlwZSwgcXVvdGVkKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIGlmIChxdW90ZWQgPT09IHZvaWQgMCkgeyBxdW90ZWQgPSBmYWxzZTsgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEV4cHIodmFsdWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRW50cnkoZW50cnlbMF0sIGVudHJ5WzFdLCBxdW90ZWQpOyB9KSwgdHlwZSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZXhwclxuICogQHBhcmFtIHs/PX0gc291cmNlU3BhblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbm90KGV4cHIsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IE5vdEV4cHIoZXhwciwgc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gcGFyYW1zXG4gKiBAcGFyYW0gez99IGJvZHlcbiAqIEBwYXJhbSB7Pz19IHR5cGVcbiAqIEBwYXJhbSB7Pz19IHNvdXJjZVNwYW5cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZuKHBhcmFtcywgYm9keSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRXhwcihwYXJhbXMsIGJvZHksIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcGFyYW0gez89fSB0eXBlXG4gKiBAcGFyYW0gez89fSBzb3VyY2VTcGFuXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBsaXRlcmFsKHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHIodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY2xhc3Mgc3RtdHMgYmFzZWQgb24gdGhlIGdpdmVuIGRhdGEuXG4gKiBAcGFyYW0gez99IGNvbmZpZ1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2xhc3NTdG10KGNvbmZpZykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudEFyZ3MgPSBjb25maWcucGFyZW50QXJncyB8fCBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdXBlckN0b3JTdG10cyA9IGNvbmZpZy5wYXJlbnQgPyBbU1VQRVJfRVhQUi5jYWxsRm4ocGFyZW50QXJncykudG9TdG10KCldIDogW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYnVpbGRlciA9IGNvbmNhdENsYXNzQnVpbGRlclBhcnRzKEFycmF5LmlzQXJyYXkoY29uZmlnLmJ1aWxkZXJzKSA/IGNvbmZpZy5idWlsZGVycyA6IFtjb25maWcuYnVpbGRlcnNdKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdG9yID0gbmV3IENsYXNzTWV0aG9kKG51bGwsIGNvbmZpZy5jdG9yUGFyYW1zIHx8IFtdLCBzdXBlckN0b3JTdG10cy5jb25jYXQoYnVpbGRlci5jdG9yU3RtdHMpKTtcbiAgICByZXR1cm4gbmV3IENsYXNzU3RtdChjb25maWcubmFtZSwgY29uZmlnLnBhcmVudCwgYnVpbGRlci5maWVsZHMsIGJ1aWxkZXIuZ2V0dGVycywgY3RvciwgYnVpbGRlci5tZXRob2RzLCBjb25maWcubW9kaWZpZXJzIHx8IFtdLCBjb25maWcuc291cmNlU3Bhbik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYnVpbGRlcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdENsYXNzQnVpbGRlclBhcnRzKGJ1aWxkZXJzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmllbGRzOiBbXS5jb25jYXQuYXBwbHkoW10sIGJ1aWxkZXJzLm1hcChmdW5jdGlvbiAoYnVpbGRlcikgeyByZXR1cm4gYnVpbGRlci5maWVsZHMgfHwgW107IH0pKSxcbiAgICAgICAgbWV0aG9kczogW10uY29uY2F0LmFwcGx5KFtdLCBidWlsZGVycy5tYXAoZnVuY3Rpb24gKGJ1aWxkZXIpIHsgcmV0dXJuIGJ1aWxkZXIubWV0aG9kcyB8fCBbXTsgfSkpLFxuICAgICAgICBnZXR0ZXJzOiBbXS5jb25jYXQuYXBwbHkoW10sIGJ1aWxkZXJzLm1hcChmdW5jdGlvbiAoYnVpbGRlcikgeyByZXR1cm4gYnVpbGRlci5nZXR0ZXJzIHx8IFtdOyB9KSksXG4gICAgICAgIGN0b3JTdG10czogW10uY29uY2F0LmFwcGx5KFtdLCBidWlsZGVycy5tYXAoZnVuY3Rpb24gKGJ1aWxkZXIpIHsgcmV0dXJuIGJ1aWxkZXIuY3RvclN0bXRzIHx8IFtdOyB9KSksXG4gICAgfTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBRVU9URURfS0VZUyA9ICckcXVvdGVkJCc7XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEBwYXJhbSB7Pz19IHR5cGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09IHZvaWQgMCkgeyB0eXBlID0gbnVsbDsgfVxuICAgIHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBuZXcgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIoKSwgdHlwZSk7XG59XG52YXIgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9WYWx1ZU91dHB1dEFzdFRyYW5zZm9ybWVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFyclxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0QXJyYXkgPSBmdW5jdGlvbiAoYXJyLCB0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBsaXRlcmFsQXJyKGFyci5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCBfdGhpcywgbnVsbCk7IH0pLCB0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCB0eXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVudHJpZXMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVvdGVkU2V0ID0gbmV3IFNldChtYXAgJiYgbWFwW1FVT1RFRF9LRVlTXSk7XG4gICAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2gobmV3IExpdGVyYWxNYXBFbnRyeShrZXksIHZpc2l0VmFsdWUobWFwW2tleV0sIF90aGlzLCBudWxsKSwgcXVvdGVkU2V0LmhhcyhrZXkpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXBFeHByKGVudHJpZXMsIHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1ZhbHVlT3V0cHV0QXN0VHJhbnNmb3JtZXIucHJvdG90eXBlLnZpc2l0UHJpbWl0aXZlID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7IHJldHVybiBsaXRlcmFsKHZhbHVlLCB0eXBlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRPdGhlciA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcih7IHJlZmVyZW5jZTogdmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfVmFsdWVPdXRwdXRBc3RUcmFuc2Zvcm1lcjtcbn0oKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFRoaXMgaXMgY3VycmVudGx5IG5vdCByZWFkLCBidXQgd2lsbCBwcm9iYWJseSBiZSB1c2VkIGluIHRoZSBmdXR1cmUuXG4gKiBXZSBrZWVwIGl0IGFzIHdlIGFscmVhZHkgcGFzcyBpdCB0aHJvdWdoIGFsbCB0aGUgcmlndGggcGxhY2VzLi4uXG4gKi9cbnZhciBDb21wb25lbnRGYWN0b3J5RGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wVHlwZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5KGNvbXBUeXBlKSB7XG4gICAgICAgIHRoaXMuY29tcFR5cGUgPSBjb21wVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBvbmVudEZhY3RvcnlEZXBlbmRlbmN5O1xufSgpKTtcbnZhciBOZ01vZHVsZUNvbXBpbGVSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGVtZW50c1xuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVGYWN0b3J5VmFyXG4gICAgICogQHBhcmFtIHs/fSBkZXBlbmRlbmNpZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOZ01vZHVsZUNvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgbmdNb2R1bGVGYWN0b3J5VmFyLCBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgdGhpcy5uZ01vZHVsZUZhY3RvcnlWYXIgPSBuZ01vZHVsZUZhY3RvcnlWYXI7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICByZXR1cm4gTmdNb2R1bGVDb21waWxlUmVzdWx0O1xufSgpKTtcbnZhciBOZ01vZHVsZUNvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZ01vZHVsZUNvbXBpbGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlTWV0YVxuICAgICAqIEBwYXJhbSB7P30gZXh0cmFQcm92aWRlcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE5nTW9kdWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAobmdNb2R1bGVNZXRhLCBleHRyYVByb3ZpZGVycykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VTcGFuID0gdHlwZVNvdXJjZVNwYW4oJ05nTW9kdWxlJywgbmdNb2R1bGVNZXRhLnR5cGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJvb3RzdHJhcENvbXBvbmVudEZhY3RvcmllcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbnRyeUNvbXBvbmVudEZhY3RvcmllcyA9IG5nTW9kdWxlTWV0YS50cmFuc2l0aXZlTW9kdWxlLmVudHJ5Q29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAobmdNb2R1bGVNZXRhLmJvb3RzdHJhcENvbXBvbmVudHMuc29tZShmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkLnJlZmVyZW5jZSA9PT0gZW50cnlDb21wb25lbnQuY29tcG9uZW50VHlwZTsgfSkpIHtcbiAgICAgICAgICAgICAgICBib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXMucHVzaCh7IHJlZmVyZW5jZTogZW50cnlDb21wb25lbnQuY29tcG9uZW50RmFjdG9yeSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlcHMucHVzaChuZXcgQ29tcG9uZW50RmFjdG9yeURlcGVuZGVuY3koZW50cnlDb21wb25lbnQuY29tcG9uZW50VHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVmZXJlbmNlOiBlbnRyeUNvbXBvbmVudC5jb21wb25lbnRGYWN0b3J5IH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBidWlsZGVyID0gbmV3IF9JbmplY3RvckJ1aWxkZXIobmdNb2R1bGVNZXRhLCBlbnRyeUNvbXBvbmVudEZhY3RvcmllcywgYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvdmlkZXJQYXJzZXIgPSBuZXcgTmdNb2R1bGVQcm92aWRlckFuYWx5emVyKG5nTW9kdWxlTWV0YSwgZXh0cmFQcm92aWRlcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICBwcm92aWRlclBhcnNlci5wYXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKHByb3ZpZGVyKSB7IHJldHVybiBidWlsZGVyLmFkZFByb3ZpZGVyKHByb3ZpZGVyKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluamVjdG9yQ2xhc3MgPSBidWlsZGVyLmJ1aWxkKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlRmFjdG9yeVZhciA9IGlkZW50aWZpZXJOYW1lKG5nTW9kdWxlTWV0YS50eXBlKSArIFwiTmdGYWN0b3J5XCI7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlRmFjdG9yeVN0bXQgPSB2YXJpYWJsZShuZ01vZHVsZUZhY3RvcnlWYXIpXG4gICAgICAgICAgICAuc2V0KGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkpKVxuICAgICAgICAgICAgLmluc3RhbnRpYXRlKFt2YXJpYWJsZShpbmplY3RvckNsYXNzLm5hbWUpLCBpbXBvcnRFeHByKG5nTW9kdWxlTWV0YS50eXBlKV0sIGltcG9ydFR5cGUoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkpLCBbaW1wb3J0VHlwZShuZ01vZHVsZU1ldGEudHlwZSldLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpKVxuICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdG10cyA9IFtpbmplY3RvckNsYXNzLCBuZ01vZHVsZUZhY3RvcnlTdG10XTtcbiAgICAgICAgaWYgKG5nTW9kdWxlTWV0YS5pZCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVnaXN0ZXJGYWN0b3J5U3RtdCA9IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5SZWdpc3Rlck1vZHVsZUZhY3RvcnlGbikpXG4gICAgICAgICAgICAgICAgLmNhbGxGbihbbGl0ZXJhbChuZ01vZHVsZU1ldGEuaWQpLCB2YXJpYWJsZShuZ01vZHVsZUZhY3RvcnlWYXIpXSlcbiAgICAgICAgICAgICAgICAudG9TdG10KCk7XG4gICAgICAgICAgICBzdG10cy5wdXNoKHJlZ2lzdGVyRmFjdG9yeVN0bXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTmdNb2R1bGVDb21waWxlUmVzdWx0KHN0bXRzLCBuZ01vZHVsZUZhY3RvcnlWYXIsIGRlcHMpO1xuICAgIH07XG4gICAgcmV0dXJuIE5nTW9kdWxlQ29tcGlsZXI7XG59KCkpO1xuTmdNb2R1bGVDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5OZ01vZHVsZUNvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG52YXIgX0luamVjdG9yQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfbmdNb2R1bGVNZXRhXG4gICAgICogQHBhcmFtIHs/fSBfZW50cnlDb21wb25lbnRGYWN0b3JpZXNcbiAgICAgKiBAcGFyYW0gez99IF9ib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXNcbiAgICAgKiBAcGFyYW0gez99IF9zb3VyY2VTcGFuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX0luamVjdG9yQnVpbGRlcihfbmdNb2R1bGVNZXRhLCBfZW50cnlDb21wb25lbnRGYWN0b3JpZXMsIF9ib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXMsIF9zb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlTWV0YSA9IF9uZ01vZHVsZU1ldGE7XG4gICAgICAgIHRoaXMuX2VudHJ5Q29tcG9uZW50RmFjdG9yaWVzID0gX2VudHJ5Q29tcG9uZW50RmFjdG9yaWVzO1xuICAgICAgICB0aGlzLl9ib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXMgPSBfYm9vdHN0cmFwQ29tcG9uZW50RmFjdG9yaWVzO1xuICAgICAgICB0aGlzLl9zb3VyY2VTcGFuID0gX3NvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuZmllbGRzID0gW107XG4gICAgICAgIHRoaXMuZ2V0dGVycyA9IFtdO1xuICAgICAgICB0aGlzLm1ldGhvZHMgPSBbXTtcbiAgICAgICAgdGhpcy5jdG9yU3RtdHMgPSBbXTtcbiAgICAgICAgdGhpcy5fbGF6eVByb3BzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl90b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jcmVhdGVTdG10cyA9IFtdO1xuICAgICAgICB0aGlzLl9kZXN0cm95U3RtdHMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSByZXNvbHZlZFByb3ZpZGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfSW5qZWN0b3JCdWlsZGVyLnByb3RvdHlwZS5hZGRQcm92aWRlciA9IGZ1bmN0aW9uIChyZXNvbHZlZFByb3ZpZGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucyA9IHJlc29sdmVkUHJvdmlkZXIucHJvdmlkZXJzLm1hcChmdW5jdGlvbiAocHJvdmlkZXIpIHsgcmV0dXJuIF90aGlzLl9nZXRQcm92aWRlclZhbHVlKHByb3ZpZGVyKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3BOYW1lID0gXCJfXCIgKyB0b2tlbk5hbWUocmVzb2x2ZWRQcm92aWRlci50b2tlbikgKyBcIl9cIiArIHRoaXMuX2luc3RhbmNlcy5zaXplO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0YW5jZSA9IHRoaXMuX2NyZWF0ZVByb3ZpZGVyUHJvcGVydHkocHJvcE5hbWUsIHJlc29sdmVkUHJvdmlkZXIsIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucywgcmVzb2x2ZWRQcm92aWRlci5tdWx0aVByb3ZpZGVyLCByZXNvbHZlZFByb3ZpZGVyLmVhZ2VyKTtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvdmlkZXIubGlmZWN5Y2xlSG9va3MuaW5kZXhPZijJtUxpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYWxsTmdPbkRlc3Ryb3kgPSBpbnN0YW5jZS5jYWxsTWV0aG9kKCduZ09uRGVzdHJveScsIFtdKTtcbiAgICAgICAgICAgIGlmICghcmVzb2x2ZWRQcm92aWRlci5lYWdlcikge1xuICAgICAgICAgICAgICAgIGNhbGxOZ09uRGVzdHJveSA9IHRoaXMuX2xhenlQcm9wcy5nZXQoaW5zdGFuY2UubmFtZSkuYW5kKGNhbGxOZ09uRGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95U3RtdHMucHVzaChjYWxsTmdPbkRlc3Ryb3kudG9TdG10KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rva2Vucy5wdXNoKHJlc29sdmVkUHJvdmlkZXIudG9rZW4pO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXMuc2V0KHRva2VuUmVmZXJlbmNlKHJlc29sdmVkUHJvdmlkZXIudG9rZW4pLCBpbnN0YW5jZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JbmplY3RvckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBnZXRNZXRob2RTdG10cyA9IHRoaXMuX3Rva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlckV4cHIgPSBfdGhpcy5faW5zdGFuY2VzLmdldCh0b2tlblJlZmVyZW5jZSh0b2tlbikpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJZlN0bXQoSW5qZWN0TWV0aG9kVmFycy50b2tlbi5pZGVudGljYWwoY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24odG9rZW4pKSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQocHJvdmlkZXJFeHByKV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWV0aG9kcyA9IFtcbiAgICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnY3JlYXRlSW50ZXJuYWwnLCBbXSwgdGhpcy5fY3JlYXRlU3RtdHMuY29uY2F0KG5ldyBSZXR1cm5TdGF0ZW1lbnQodGhpcy5faW5zdGFuY2VzLmdldCh0aGlzLl9uZ01vZHVsZU1ldGEudHlwZS5yZWZlcmVuY2UpKSksIGltcG9ydFR5cGUodGhpcy5fbmdNb2R1bGVNZXRhLnR5cGUpKSxcbiAgICAgICAgICAgIG5ldyBDbGFzc01ldGhvZCgnZ2V0SW50ZXJuYWwnLCBbXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oSW5qZWN0TWV0aG9kVmFycy50b2tlbi5uYW1lLCBEWU5BTUlDX1RZUEUpLFxuICAgICAgICAgICAgICAgIG5ldyBGblBhcmFtKEluamVjdE1ldGhvZFZhcnMubm90Rm91bmRSZXN1bHQubmFtZSwgRFlOQU1JQ19UWVBFKVxuICAgICAgICAgICAgXSwgZ2V0TWV0aG9kU3RtdHMuY29uY2F0KFtuZXcgUmV0dXJuU3RhdGVtZW50KEluamVjdE1ldGhvZFZhcnMubm90Rm91bmRSZXN1bHQpXSksIERZTkFNSUNfVFlQRSksXG4gICAgICAgICAgICBuZXcgQ2xhc3NNZXRob2QoJ2Rlc3Ryb3lJbnRlcm5hbCcsIFtdLCB0aGlzLl9kZXN0cm95U3RtdHMpLFxuICAgICAgICBdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRBcmdzID0gW1xuICAgICAgICAgICAgdmFyaWFibGUoSW5qZWN0b3JQcm9wcy5wYXJlbnQubmFtZSksXG4gICAgICAgICAgICBsaXRlcmFsQXJyKHRoaXMuX2VudHJ5Q29tcG9uZW50RmFjdG9yaWVzLm1hcChmdW5jdGlvbiAoY29tcG9uZW50RmFjdG9yeSkgeyByZXR1cm4gaW1wb3J0RXhwcihjb21wb25lbnRGYWN0b3J5KTsgfSkpLFxuICAgICAgICAgICAgbGl0ZXJhbEFycih0aGlzLl9ib290c3RyYXBDb21wb25lbnRGYWN0b3JpZXMubWFwKGZ1bmN0aW9uIChjb21wb25lbnRGYWN0b3J5KSB7IHJldHVybiBpbXBvcnRFeHByKGNvbXBvbmVudEZhY3RvcnkpOyB9KSlcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5qQ2xhc3NOYW1lID0gaWRlbnRpZmllck5hbWUodGhpcy5fbmdNb2R1bGVNZXRhLnR5cGUpICsgXCJJbmplY3RvclwiO1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2xhc3NTdG10KHtcbiAgICAgICAgICAgIG5hbWU6IGluakNsYXNzTmFtZSxcbiAgICAgICAgICAgIGN0b3JQYXJhbXM6IFtuZXcgRm5QYXJhbShJbmplY3RvclByb3BzLnBhcmVudC5uYW1lLCBpbXBvcnRUeXBlKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuSW5qZWN0b3IpKSldLFxuICAgICAgICAgICAgcGFyZW50OiBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuTmdNb2R1bGVJbmplY3RvciksIFtpbXBvcnRUeXBlKHRoaXMuX25nTW9kdWxlTWV0YS50eXBlKV0pLFxuICAgICAgICAgICAgcGFyZW50QXJnczogcGFyZW50QXJncyxcbiAgICAgICAgICAgIGJ1aWxkZXJzOiBbeyBtZXRob2RzOiBtZXRob2RzIH0sIHRoaXNdXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0luamVjdG9yQnVpbGRlci5wcm90b3R5cGUuX2dldFByb3ZpZGVyVmFsdWUgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0O1xuICAgICAgICBpZiAocHJvdmlkZXIudXNlRXhpc3RpbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0RGVwZW5kZW5jeSh7IHRva2VuOiBwcm92aWRlci51c2VFeGlzdGluZyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHMgPSBwcm92aWRlci5kZXBzIHx8IHByb3ZpZGVyLnVzZUZhY3RvcnkuZGlEZXBzO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwc0V4cHIgPSBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBfdGhpcy5fZ2V0RGVwZW5kZW5jeShkZXApOyB9KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGltcG9ydEV4cHIocHJvdmlkZXIudXNlRmFjdG9yeSkuY2FsbEZuKGRlcHNFeHByKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VDbGFzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzID0gcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VDbGFzcy5kaURlcHM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzRXhwciA9IGRlcHMubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIF90aGlzLl9nZXREZXBlbmRlbmN5KGRlcCk7IH0pO1xuICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICBpbXBvcnRFeHByKHByb3ZpZGVyLnVzZUNsYXNzKS5pbnN0YW50aWF0ZShkZXBzRXhwciwgaW1wb3J0VHlwZShwcm92aWRlci51c2VDbGFzcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29udmVydFZhbHVlVG9PdXRwdXRBc3QocHJvdmlkZXIudXNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3BOYW1lXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlclxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zXG4gICAgICogQHBhcmFtIHs/fSBpc011bHRpXG4gICAgICogQHBhcmFtIHs/fSBpc0VhZ2VyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfSW5qZWN0b3JCdWlsZGVyLnByb3RvdHlwZS5fY3JlYXRlUHJvdmlkZXJQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgcHJvdmlkZXIsIHByb3ZpZGVyVmFsdWVFeHByZXNzaW9ucywgaXNNdWx0aSwgaXNFYWdlcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlO1xuICAgICAgICBpZiAoaXNNdWx0aSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwciA9IGxpdGVyYWxBcnIocHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zKTtcbiAgICAgICAgICAgIHR5cGUgPSBuZXcgQXJyYXlUeXBlKERZTkFNSUNfVFlQRSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlZFByb3ZpZGVyVmFsdWVFeHByID0gcHJvdmlkZXJWYWx1ZUV4cHJlc3Npb25zWzBdO1xuICAgICAgICAgICAgdHlwZSA9IHByb3ZpZGVyVmFsdWVFeHByZXNzaW9uc1swXS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IERZTkFNSUNfVFlQRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNFYWdlcikge1xuICAgICAgICAgICAgdGhpcy5maWVsZHMucHVzaChuZXcgQ2xhc3NGaWVsZChwcm9wTmFtZSwgdHlwZSkpO1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU3RtdHMucHVzaChUSElTX0VYUFIucHJvcChwcm9wTmFtZSkuc2V0KHJlc29sdmVkUHJvdmlkZXJWYWx1ZUV4cHIpLnRvU3RtdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGludGVybmFsRmllbGRQcm9wID0gVEhJU19FWFBSLnByb3AoXCJfXCIgKyBwcm9wTmFtZSk7XG4gICAgICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKG5ldyBDbGFzc0ZpZWxkKGludGVybmFsRmllbGRQcm9wLm5hbWUsIHR5cGUpKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IEVxdWFscyBpcyBpbXBvcnRhbnQgZm9yIEpTIHNvIHRoYXQgaXQgYWxzbyBjaGVja3MgdGhlIHVuZGVmaW5lZCBjYXNlIVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZ2V0dGVyU3RtdHMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IElmU3RtdChpbnRlcm5hbEZpZWxkUHJvcC5pc0JsYW5rKCksIFtpbnRlcm5hbEZpZWxkUHJvcC5zZXQocmVzb2x2ZWRQcm92aWRlclZhbHVlRXhwcikudG9TdG10KCldKSxcbiAgICAgICAgICAgICAgICBuZXcgUmV0dXJuU3RhdGVtZW50KGludGVybmFsRmllbGRQcm9wKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHRoaXMuZ2V0dGVycy5wdXNoKG5ldyBDbGFzc0dldHRlcihwcm9wTmFtZSwgZ2V0dGVyU3RtdHMsIHR5cGUpKTtcbiAgICAgICAgICAgIHRoaXMuX2xhenlQcm9wcy5zZXQocHJvcE5hbWUsIGludGVybmFsRmllbGRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVEhJU19FWFBSLnByb3AocHJvcE5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9JbmplY3RvckJ1aWxkZXIucHJvdG90eXBlLl9nZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAoZGVwLmlzVmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGxpdGVyYWwoZGVwLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcC5pc1NraXBTZWxmKSB7XG4gICAgICAgICAgICBpZiAoZGVwLnRva2VuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkluamVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBUSElTX0VYUFI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuUmVmZXJlbmNlKGRlcC50b2tlbikgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gVEhJU19FWFBSLnByb3AoJ2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5faW5zdGFuY2VzLmdldCh0b2tlblJlZmVyZW5jZShkZXAudG9rZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IFtjcmVhdGVEaVRva2VuRXhwcmVzc2lvbihkZXAudG9rZW4pXTtcbiAgICAgICAgICAgIGlmIChkZXAuaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChOVUxMX0VYUFIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gSW5qZWN0b3JQcm9wcy5wYXJlbnQuY2FsbE1ldGhvZCgnZ2V0JywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBfSW5qZWN0b3JCdWlsZGVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB0b2tlblxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGlUb2tlbkV4cHJlc3Npb24odG9rZW4pIHtcbiAgICBpZiAodG9rZW4udmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbCh0b2tlbi52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaW1wb3J0RXhwcih0b2tlbi5pZGVudGlmaWVyKTtcbiAgICB9XG59XG52YXIgSW5qZWN0b3JQcm9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5qZWN0b3JQcm9wcygpIHtcbiAgICB9XG4gICAgcmV0dXJuIEluamVjdG9yUHJvcHM7XG59KCkpO1xuSW5qZWN0b3JQcm9wcy5wYXJlbnQgPSBUSElTX0VYUFIucHJvcCgncGFyZW50Jyk7XG52YXIgSW5qZWN0TWV0aG9kVmFycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5qZWN0TWV0aG9kVmFycygpIHtcbiAgICB9XG4gICAgcmV0dXJuIEluamVjdE1ldGhvZFZhcnM7XG59KCkpO1xuSW5qZWN0TWV0aG9kVmFycy50b2tlbiA9IHZhcmlhYmxlKCd0b2tlbicpO1xuSW5qZWN0TWV0aG9kVmFycy5ub3RGb3VuZFJlc3VsdCA9IHZhcmlhYmxlKCdub3RGb3VuZFJlc3VsdCcpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0XG52YXIgVkVSU0lPTiQxID0gMztcbnZhciBKU19CNjRfUFJFRklYID0gJyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCc7XG52YXIgU291cmNlTWFwR2VuZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSBmaWxlXG4gICAgICovXG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGZpbGUpIHtcbiAgICAgICAgaWYgKGZpbGUgPT09IHZvaWQgMCkgeyBmaWxlID0gbnVsbDsgfVxuICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB0aGlzLnNvdXJjZXNDb250ZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpbmVzID0gW107XG4gICAgICAgIHRoaXMubGFzdENvbDAgPSAwO1xuICAgICAgICB0aGlzLmhhc01hcHBpbmdzID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/PX0gY29udGVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRTb3VyY2UgPSBmdW5jdGlvbiAodXJsLCBjb250ZW50KSB7XG4gICAgICAgIGlmIChjb250ZW50ID09PSB2b2lkIDApIHsgY29udGVudCA9IG51bGw7IH1cbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50Lmhhcyh1cmwpKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZXNDb250ZW50LnNldCh1cmwsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGluZXMucHVzaChbXSk7XG4gICAgICAgIHRoaXMubGFzdENvbDAgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29sMFxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZVVybFxuICAgICAqIEBwYXJhbSB7Pz19IHNvdXJjZUxpbmUwXG4gICAgICogQHBhcmFtIHs/PX0gc291cmNlQ29sMFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID0gZnVuY3Rpb24gKGNvbDAsIHNvdXJjZVVybCwgc291cmNlTGluZTAsIHNvdXJjZUNvbDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRMaW5lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGxpbmUgbXVzdCBiZSBhZGRlZCBiZWZvcmUgbWFwcGluZ3MgY2FuIGJlIGFkZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VVcmwgIT0gbnVsbCAmJiAhdGhpcy5zb3VyY2VzQ29udGVudC5oYXMoc291cmNlVXJsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzb3VyY2UgZmlsZSBcXFwiXCIgKyBzb3VyY2VVcmwgKyBcIlxcXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbDAgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbHVtbiBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUgbXVzdCBiZSBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sMCA8IHRoaXMubGFzdENvbDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hcHBpbmcgc2hvdWxkIGJlIGFkZGVkIGluIG91dHB1dCBvcmRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlVXJsICYmIChzb3VyY2VMaW5lMCA9PSBudWxsIHx8IHNvdXJjZUNvbDAgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzb3VyY2UgbG9jYXRpb24gbXVzdCBiZSBwcm92aWRlZCB3aGVuIGEgc291cmNlIHVybCBpcyBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc01hcHBpbmdzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXN0Q29sMCA9IGNvbDA7XG4gICAgICAgIHRoaXMuY3VycmVudExpbmUucHVzaCh7IGNvbDA6IGNvbDAsIHNvdXJjZVVybDogc291cmNlVXJsLCBzb3VyY2VMaW5lMDogc291cmNlTGluZTAsIHNvdXJjZUNvbDA6IHNvdXJjZUNvbDAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUsIFwiY3VycmVudExpbmVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5saW5lcy5zbGljZSgtMSlbMF07IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5oYXNNYXBwaW5ncykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZXNDb250ZW50ID0gW107XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5zb3VyY2VzQ29udGVudC5rZXlzKCkpLmZvckVhY2goZnVuY3Rpb24gKHVybCwgaSkge1xuICAgICAgICAgICAgc291cmNlc0luZGV4LnNldCh1cmwsIGkpO1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHVybCk7XG4gICAgICAgICAgICBzb3VyY2VzQ29udGVudC5wdXNoKF90aGlzLnNvdXJjZXNDb250ZW50LmdldCh1cmwpIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwcGluZ3MgPSAnJztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdENvbDAgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0U291cmNlSW5kZXggPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0U291cmNlTGluZTAgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0U291cmNlQ29sMCA9IDA7XG4gICAgICAgIHRoaXMubGluZXMuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudHMpIHtcbiAgICAgICAgICAgIGxhc3RDb2wwID0gMDtcbiAgICAgICAgICAgIG1hcHBpbmdzICs9IHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIHplcm8tYmFzZWQgc3RhcnRpbmcgY29sdW1uIG9mIHRoZSBsaW5lIGluIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlZ0FzU3RyID0gdG9CYXNlNjRWTFEoc2VnbWVudC5jb2wwIC0gbGFzdENvbDApO1xuICAgICAgICAgICAgICAgIGxhc3RDb2wwID0gc2VnbWVudC5jb2wwO1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LnNvdXJjZVVybCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHplcm8tYmFzZWQgaW5kZXggaW50byB0aGUg4oCcc291cmNlc+KAnSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIHNlZ0FzU3RyICs9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0Jhc2U2NFZMUShzb3VyY2VzSW5kZXguZ2V0KHNlZ21lbnQuc291cmNlVXJsKSAtIGxhc3RTb3VyY2VJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VJbmRleCA9IHNvdXJjZXNJbmRleC5nZXQoc2VnbWVudC5zb3VyY2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgemVyby1iYXNlZCBzdGFydGluZyBsaW5lIGluIHRoZSBvcmlnaW5hbCBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgc2VnQXNTdHIgKz0gdG9CYXNlNjRWTFEoc2VnbWVudC5zb3VyY2VMaW5lMCAtIGxhc3RTb3VyY2VMaW5lMCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VMaW5lMCA9IHNlZ21lbnQuc291cmNlTGluZTA7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB6ZXJvLWJhc2VkIHN0YXJ0aW5nIGNvbHVtbiBpbiB0aGUgb3JpZ2luYWwgc291cmNlXG4gICAgICAgICAgICAgICAgICAgIHNlZ0FzU3RyICs9IHRvQmFzZTY0VkxRKHNlZ21lbnQuc291cmNlQ29sMCAtIGxhc3RTb3VyY2VDb2wwKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNvdXJjZUNvbDAgPSBzZWdtZW50LnNvdXJjZUNvbDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWdBc1N0cjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgICAgIG1hcHBpbmdzICs9ICc7JztcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcHBpbmdzID0gbWFwcGluZ3Muc2xpY2UoMCwgLTEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2ZpbGUnOiB0aGlzLmZpbGUgfHwgJycsXG4gICAgICAgICAgICAndmVyc2lvbic6IFZFUlNJT04kMSxcbiAgICAgICAgICAgICdzb3VyY2VSb290JzogJycsXG4gICAgICAgICAgICAnc291cmNlcyc6IHNvdXJjZXMsXG4gICAgICAgICAgICAnc291cmNlc0NvbnRlbnQnOiBzb3VyY2VzQ29udGVudCxcbiAgICAgICAgICAgICdtYXBwaW5ncyc6IG1hcHBpbmdzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSnNDb21tZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNNYXBwaW5ncyA/ICcvLycgKyBKU19CNjRfUFJFRklYICsgdG9CYXNlNjRTdHJpbmcoSlNPTi5zdHJpbmdpZnkodGhpcywgbnVsbCwgMCkpIDpcbiAgICAgICAgICAgICcnO1xuICAgIH07XG4gICAgcmV0dXJuIFNvdXJjZU1hcEdlbmVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRvQmFzZTY0U3RyaW5nKHZhbHVlKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYjY0ID0gJyc7XG4gICAgdmFsdWUgPSB1dGY4RW5jb2RlKHZhbHVlKTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMSA9IHZhbHVlLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaTIgPSB2YWx1ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGkzID0gdmFsdWUuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBiNjQgKz0gdG9CYXNlNjREaWdpdChpMSA+PiAyKTtcbiAgICAgICAgYjY0ICs9IHRvQmFzZTY0RGlnaXQoKChpMSAmIDMpIDw8IDQpIHwgKGlzTmFOKGkyKSA/IDAgOiBpMiA+PiA0KSk7XG4gICAgICAgIGI2NCArPSBpc05hTihpMikgPyAnPScgOiB0b0Jhc2U2NERpZ2l0KCgoaTIgJiAxNSkgPDwgMikgfCAoaTMgPj4gNikpO1xuICAgICAgICBiNjQgKz0gaXNOYU4oaTIpIHx8IGlzTmFOKGkzKSA/ICc9JyA6IHRvQmFzZTY0RGlnaXQoaTMgJiA2Myk7XG4gICAgfVxuICAgIHJldHVybiBiNjQ7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gdmFsdWVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHRvQmFzZTY0VkxRKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSA8IDAgPyAoKC12YWx1ZSkgPDwgMSkgKyAxIDogdmFsdWUgPDwgMTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXQgPSAnJztcbiAgICBkbyB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpZ2l0ID0gdmFsdWUgJiAzMTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiA1O1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICBkaWdpdCA9IGRpZ2l0IHwgMzI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IHRvQmFzZTY0RGlnaXQoZGlnaXQpO1xuICAgIH0gd2hpbGUgKHZhbHVlID4gMCk7XG4gICAgcmV0dXJuIG91dDtcbn1cbnZhciBCNjRfRElHSVRTID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0b0Jhc2U2NERpZ2l0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gb25seSBlbmNvZGUgdmFsdWUgaW4gdGhlIHJhbmdlIFswLCA2M11cIik7XG4gICAgfVxuICAgIHJldHVybiBCNjRfRElHSVRTW3ZhbHVlXTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBfU0lOR0xFX1FVT1RFX0VTQ0FQRV9TVFJJTkdfUkUgPSAvJ3xcXFxcfFxcbnxcXHJ8XFwkL2c7XG52YXIgX0xFR0FMX0lERU5USUZJRVJfUkUgPSAvXlskQS1aX11bMC05QS1aXyRdKiQvaTtcbnZhciBfSU5ERU5UX1dJVEggPSAnICAnO1xudmFyIENBVENIX0VSUk9SX1ZBUiQxID0gdmFyaWFibGUoJ2Vycm9yJyk7XG52YXIgQ0FUQ0hfU1RBQ0tfVkFSJDEgPSB2YXJpYWJsZSgnc3RhY2snKTtcbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBfRW1pdHRlZExpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5kZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gX0VtaXR0ZWRMaW5lKGluZGVudCkge1xuICAgICAgICB0aGlzLmluZGVudCA9IGluZGVudDtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnNyY1NwYW5zID0gW107XG4gICAgfVxuICAgIHJldHVybiBfRW1pdHRlZExpbmU7XG59KCkpO1xudmFyIEVtaXR0ZXJWaXNpdG9yQ29udGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZXhwb3J0ZWRWYXJzXG4gICAgICogQHBhcmFtIHs/fSBfaW5kZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gRW1pdHRlclZpc2l0b3JDb250ZXh0KF9leHBvcnRlZFZhcnMsIF9pbmRlbnQpIHtcbiAgICAgICAgdGhpcy5fZXhwb3J0ZWRWYXJzID0gX2V4cG9ydGVkVmFycztcbiAgICAgICAgdGhpcy5faW5kZW50ID0gX2luZGVudDtcbiAgICAgICAgdGhpcy5fY2xhc3NlcyA9IFtdO1xuICAgICAgICB0aGlzLl9saW5lcyA9IFtuZXcgX0VtaXR0ZWRMaW5lKF9pbmRlbnQpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHBvcnRlZFZhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290ID0gZnVuY3Rpb24gKGV4cG9ydGVkVmFycykge1xuICAgICAgICByZXR1cm4gbmV3IEVtaXR0ZXJWaXNpdG9yQ29udGV4dChleHBvcnRlZFZhcnMsIDApO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUsIFwiX2N1cnJlbnRMaW5lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xpbmVzW3RoaXMuX2xpbmVzLmxlbmd0aCAtIDFdOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhck5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUuaXNFeHBvcnRlZFZhciA9IGZ1bmN0aW9uICh2YXJOYW1lKSB7IHJldHVybiB0aGlzLl9leHBvcnRlZFZhcnMuaW5kZXhPZih2YXJOYW1lKSAhPT0gLTE7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gZnJvbVxuICAgICAqIEBwYXJhbSB7Pz19IGxhc3RQYXJ0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnByaW50bG4gPSBmdW5jdGlvbiAoZnJvbSwgbGFzdFBhcnQpIHtcbiAgICAgICAgaWYgKGxhc3RQYXJ0ID09PSB2b2lkIDApIHsgbGFzdFBhcnQgPSAnJzsgfVxuICAgICAgICB0aGlzLnByaW50KGZyb20sIGxhc3RQYXJ0LCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS5saW5lSXNFbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzLmxlbmd0aCA9PT0gMDsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZyb21cbiAgICAgKiBAcGFyYW0gez99IHBhcnRcbiAgICAgKiBAcGFyYW0gez89fSBuZXdMaW5lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKGZyb20sIHBhcnQsIG5ld0xpbmUpIHtcbiAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHBhcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmUucGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLnNyY1NwYW5zLnB1c2goZnJvbSAmJiBmcm9tLnNvdXJjZVNwYW4gfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0xpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobmV3IF9FbWl0dGVkTGluZSh0aGlzLl9pbmRlbnQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnJlbW92ZUVtcHR5TGFzdExpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVJc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUuaW5jSW5kZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pbmRlbnQrKztcbiAgICAgICAgdGhpcy5fY3VycmVudExpbmUuaW5kZW50ID0gdGhpcy5faW5kZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLmRlY0luZGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5kZW50LS07XG4gICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCA9IHRoaXMuX2luZGVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY2xhenpcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUucHVzaENsYXNzID0gZnVuY3Rpb24gKGNsYXp6KSB7IHRoaXMuX2NsYXNzZXMucHVzaChjbGF6eik7IH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLnBvcENsYXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY2xhc3Nlcy5wb3AoKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZSwgXCJjdXJyZW50Q2xhc3NcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzZXMubGVuZ3RoID4gMCA/IHRoaXMuX2NsYXNzZXNbdGhpcy5fY2xhc3Nlcy5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRW1pdHRlclZpc2l0b3JDb250ZXh0LnByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTGluZXNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwucGFydHMubGVuZ3RoID4gMCA/IF9jcmVhdGVJbmRlbnQobC5pbmRlbnQpICsgbC5wYXJ0cy5qb2luKCcnKSA6ICcnOyB9KVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VGaWxlUGF0aFxuICAgICAqIEBwYXJhbSB7P30gZ2VuRmlsZVBhdGhcbiAgICAgKiBAcGFyYW0gez89fSBzdGFydHNBdExpbmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5wcm90b3R5cGUudG9Tb3VyY2VNYXBHZW5lcmF0b3IgPSBmdW5jdGlvbiAoc291cmNlRmlsZVBhdGgsIGdlbkZpbGVQYXRoLCBzdGFydHNBdExpbmUpIHtcbiAgICAgICAgaWYgKHN0YXJ0c0F0TGluZSA9PT0gdm9pZCAwKSB7IHN0YXJ0c0F0TGluZSA9IDA7IH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihnZW5GaWxlUGF0aCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpcnN0T2Zmc2V0TWFwcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcEZpcnN0T2Zmc2V0SWZOZWVkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0T2Zmc2V0TWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgc2luZ2xlIHNwYWNlIHNvIHRoYXQgdG9vbHMgd29uJ3QgdHJ5IHRvIGxvYWQgdGhlIGZpbGUgZnJvbSBkaXNrLlxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdlIGFyZSB1c2luZyB2aXJ0dWFsIHVybHMgbGlrZSBgbmc6Ly8vYCwgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIHByb3ZpZGUgYSBjb250ZW50IGhlcmUuXG4gICAgICAgICAgICAgICAgbWFwLmFkZFNvdXJjZShzb3VyY2VGaWxlUGF0aCwgJyAnKS5hZGRNYXBwaW5nKDAsIHNvdXJjZUZpbGVQYXRoLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBmaXJzdE9mZnNldE1hcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzdGFydHNBdExpbmU7IGkrKykge1xuICAgICAgICAgICAgbWFwLmFkZExpbmUoKTtcbiAgICAgICAgICAgIG1hcEZpcnN0T2Zmc2V0SWZOZWVkZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZUxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUsIGxpbmVJZHgpIHtcbiAgICAgICAgICAgIG1hcC5hZGRMaW5lKCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGFucyA9IGxpbmUuc3JjU3BhbnM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IGxpbmUucGFydHM7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb2wwID0gbGluZS5pbmRlbnQgKiBfSU5ERU5UX1dJVEgubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BhbklkeCA9IDA7XG4gICAgICAgICAgICAvLyBza2lwIGxlYWRpbmcgcGFydHMgd2l0aG91dCBzb3VyY2Ugc3BhbnNcbiAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmICFzcGFuc1tzcGFuSWR4XSkge1xuICAgICAgICAgICAgICAgIGNvbDAgKz0gcGFydHNbc3BhbklkeF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNwYW5JZHgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmIGxpbmVJZHggPT09IDAgJiYgY29sMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpcnN0T2Zmc2V0TWFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcEZpcnN0T2Zmc2V0SWZOZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3BhbiA9IHNwYW5zW3NwYW5JZHhdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZSA9IHNwYW4uc3RhcnQuZmlsZTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VMaW5lID0gc3Bhbi5zdGFydC5saW5lO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZUNvbCA9IHNwYW4uc3RhcnQuY29sO1xuICAgICAgICAgICAgICAgIG1hcC5hZGRTb3VyY2Uoc291cmNlLnVybCwgc291cmNlLmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRNYXBwaW5nKGNvbDAsIHNvdXJjZS51cmwsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbCk7XG4gICAgICAgICAgICAgICAgY29sMCArPSBwYXJ0c1tzcGFuSWR4XS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgc3BhbklkeCsrO1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBwYXJ0cyB3aXRob3V0IHNwYW4gb3IgdGhlIHNhbWUgc3BhbiB0byB0aGUgcHJldmlvdXMgc2VnbWVudFxuICAgICAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmIChzcGFuID09PSBzcGFuc1tzcGFuSWR4XSB8fCAhc3BhbnNbc3BhbklkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDAgKz0gcGFydHNbc3BhbklkeF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzcGFuSWR4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbWl0dGVyVmlzaXRvckNvbnRleHQucHJvdG90eXBlLCBcInNvdXJjZUxpbmVzXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lcy5sZW5ndGggJiYgdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV0ucGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEVtaXR0ZXJWaXNpdG9yQ29udGV4dDtcbn0oKSk7XG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG52YXIgQWJzdHJhY3RFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZXNjYXBlRG9sbGFySW5TdHJpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQWJzdHJhY3RFbWl0dGVyVmlzaXRvcihfZXNjYXBlRG9sbGFySW5TdHJpbmdzKSB7XG4gICAgICAgIHRoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncyA9IF9lc2NhcGVEb2xsYXJJblN0cmluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEV4cHJlc3Npb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsICc7Jyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmV0dXJuU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwicmV0dXJuIFwiKTtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgJzsnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdElmU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiaWYgKFwiKTtcbiAgICAgICAgc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcIikge1wiKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFzRWxzZUNhc2UgPSBzdG10LmZhbHNlQ2FzZSAhPSBudWxsICYmIHN0bXQuZmFsc2VDYXNlLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmIChzdG10LnRydWVDYXNlLmxlbmd0aCA8PSAxICYmICFoYXNFbHNlQ2FzZSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiIFwiKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICBjdHgucmVtb3ZlRW1wdHlMYXN0TGluZSgpO1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKCk7XG4gICAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgaWYgKGhhc0Vsc2VDYXNlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9IGVsc2Uge1wiKTtcbiAgICAgICAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGhyb3dTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJ0aHJvdyBcIik7XG4gICAgICAgIHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiO1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGluZXMgPSBzdG10LmNvbW1lbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7IGN0eC5wcmludGxuKHN0bXQsIFwiLy8gXCIgKyBsaW5lKTsgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVWYXJFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKCcpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChleHByLCBleHByLm5hbWUgKyBcIiA9IFwiKTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0V3JpdGVLZXlFeHByID0gZnVuY3Rpb24gKGV4cHIsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKCcpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIltcIik7XG4gICAgICAgIGV4cHIuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIl0gPSBcIik7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFdyaXRlUHJvcEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiLlwiICsgZXhwci5uYW1lICsgXCIgPSBcIik7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBleHByLm5hbWU7XG4gICAgICAgIGlmIChleHByLmJ1aWx0aW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMuZ2V0QnVpbHRpbk1ldGhvZE5hbWUoZXhwci5idWlsdGluKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBzb21lIGJ1aWx0aW5zIGp1c3QgbWVhbiB0byBza2lwIHRoZSBjYWxsLlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIi5cIiArIG5hbWUgKyBcIihcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgXCIsXCIpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gbWV0aG9kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5nZXRCdWlsdGluTWV0aG9kTmFtZSA9IGZ1bmN0aW9uIChtZXRob2QpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIGV4cHIuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBcIihcIik7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFJlYWRWYXJFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhck5hbWUgPSBhc3QubmFtZTtcbiAgICAgICAgaWYgKGFzdC5idWlsdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXN0LmJ1aWx0aW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuU3VwZXI6XG4gICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSAnc3VwZXInO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuVGhpczpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9ICd0aGlzJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLkNhdGNoRXJyb3I6XG4gICAgICAgICAgICAgICAgICAgIHZhck5hbWUgPSBDQVRDSF9FUlJPUl9WQVIkMS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hTdGFjazpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9IENBVENIX1NUQUNLX1ZBUiQxLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYnVpbHRpbiB2YXJpYWJsZSBcIiArIGFzdC5idWlsdGluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoYXN0LCB2YXJOYW1lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIm5ldyBcIik7XG4gICAgICAgIGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gYXN0LnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgZXNjYXBlSWRlbnRpZmllcih2YWx1ZSwgdGhpcy5fZXNjYXBlRG9sbGFySW5TdHJpbmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBcIlwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIihcIik7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICc/ICcpO1xuICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICc6ICcpO1xuICAgICAgICBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIilcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXROb3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsICchJyk7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRGdW5jdGlvbkV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BTdHI7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc9PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc9PT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyYmJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuT3I6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnfHwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJysnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICctJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRGl2aWRlOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJy8nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcqJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlcjpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc8JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPD0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc+PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3IgXCIgKyBhc3Qub3BlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKFwiKTtcbiAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIgXCIgKyBvcFN0ciArIFwiIFwiKTtcbiAgICAgICAgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIuXCIpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkS2V5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiW1wiKTtcbiAgICAgICAgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIl1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVzZU5ld0xpbmUgPSBhc3QuZW50cmllcy5sZW5ndGggPiAxO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIltcIiwgdXNlTmV3TGluZSk7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjdHgsICcsJywgdXNlTmV3TGluZSk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJdXCIsIHVzZU5ld0xpbmUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXNlTmV3TGluZSA9IGFzdC5lbnRyaWVzLmxlbmd0aCA+IDE7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwie1wiLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIGVzY2FwZUlkZW50aWZpZXIoZW50cnkua2V5LCBfdGhpcy5fZXNjYXBlRG9sbGFySW5TdHJpbmdzLCBlbnRyeS5xdW90ZWQpICsgXCI6IFwiKTtcbiAgICAgICAgICAgIGVudHJ5LnZhbHVlLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTtcbiAgICAgICAgfSwgYXN0LmVudHJpZXMsIGN0eCwgJywnLCB1c2VOZXdMaW5lKTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIn1cIiwgdXNlTmV3TGluZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb21tYUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJygnKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5wYXJ0cywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnKScpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvbnNcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEBwYXJhbSB7P30gc2VwYXJhdG9yXG4gICAgICogQHBhcmFtIHs/PX0gbmV3TGluZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKGV4cHIpIHsgcmV0dXJuIGV4cHIudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9LCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcGFyYW0gez99IHNlcGFyYXRvclxuICAgICAqIEBwYXJhbSB7Pz19IG5ld0xpbmVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0QWxsT2JqZWN0cyA9IGZ1bmN0aW9uIChoYW5kbGVyLCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IsIG5ld0xpbmUpIHtcbiAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkgeyBuZXdMaW5lID0gZmFsc2U7IH1cbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgc2VwYXJhdG9yLCBuZXdMaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZXIoZXhwcmVzc2lvbnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdMaW5lKSB7XG4gICAgICAgICAgICBjdHgucHJpbnRsbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRBbGxTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHN0YXRlbWVudHMsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIHN0bXQudmlzaXRTdGF0ZW1lbnQoX3RoaXMsIGN0eCk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0RW1pdHRlclZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcGFyYW0gez99IGVzY2FwZURvbGxhclxuICogQHBhcmFtIHs/PX0gYWx3YXlzUXVvdGVcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUlkZW50aWZpZXIoaW5wdXQsIGVzY2FwZURvbGxhciwgYWx3YXlzUXVvdGUpIHtcbiAgICBpZiAoYWx3YXlzUXVvdGUgPT09IHZvaWQgMCkgeyBhbHdheXNRdW90ZSA9IHRydWU7IH1cbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYm9keSA9IGlucHV0LnJlcGxhY2UoX1NJTkdMRV9RVU9URV9FU0NBUEVfU1RSSU5HX1JFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbWF0Y2hbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbMF0gPT0gJyQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlRG9sbGFyID8gJ1xcXFwkJyA6ICckJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaFswXSA9PSAnXFxuJykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT0gJ1xccicpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXFwiICsgbWF0Y2hbMF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXF1aXJlc1F1b3RlcyA9IGFsd2F5c1F1b3RlIHx8ICFfTEVHQUxfSURFTlRJRklFUl9SRS50ZXN0KGJvZHkpO1xuICAgIHJldHVybiByZXF1aXJlc1F1b3RlcyA/IFwiJ1wiICsgYm9keSArIFwiJ1wiIDogYm9keTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb3VudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZUluZGVudChjb3VudCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHJlcyArPSBfSU5ERU5UX1dJVEg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgX2RlYnVnRmlsZVBhdGggPSAnL2RlYnVnL2xpYic7XG4vKipcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkZWJ1Z091dHB1dEFzdEFzVHlwZVNjcmlwdChhc3QpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZXIgPSBuZXcgX1RzRW1pdHRlclZpc2l0b3IoX2RlYnVnRmlsZVBhdGgsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250YWluaW5nRmlsZVBhdGhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZpbGVOYW1lVG9Nb2R1bGVOYW1lOiBmdW5jdGlvbiAoZmlsZVBhdGgsIGNvbnRhaW5pbmdGaWxlUGF0aCkgeyByZXR1cm4gZmlsZVBhdGg7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHN5bWJvbFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW1wb3J0QXM6IGZ1bmN0aW9uIChzeW1ib2wpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIGdldFR5cGVBcml0eTogZnVuY3Rpb24gKHN5bWJvbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KFtdKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhc3RzID0gQXJyYXkuaXNBcnJheShhc3QpID8gYXN0IDogW2FzdF07XG4gICAgYXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIFN0YXRlbWVudCkge1xuICAgICAgICAgICAgYXN0LnZpc2l0U3RhdGVtZW50KGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBhc3QudmlzaXRFeHByZXNzaW9uKGNvbnZlcnRlciwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QgaW5zdGFuY2VvZiBUeXBlJDEpIHtcbiAgICAgICAgICAgIGFzdC52aXNpdFR5cGUoY29udmVydGVyLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG9uJ3Qga25vdyBob3cgdG8gcHJpbnQgZGVidWcgaW5mbyBmb3IgXCIgKyBhc3QpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGN0eC50b1NvdXJjZSgpO1xufVxudmFyIFR5cGVTY3JpcHRFbWl0dGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9pbXBvcnRSZXNvbHZlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFR5cGVTY3JpcHRFbWl0dGVyKF9pbXBvcnRSZXNvbHZlcikge1xuICAgICAgICB0aGlzLl9pbXBvcnRSZXNvbHZlciA9IF9pbXBvcnRSZXNvbHZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNGaWxlUGF0aFxuICAgICAqIEBwYXJhbSB7P30gZ2VuRmlsZVBhdGhcbiAgICAgKiBAcGFyYW0gez99IHN0bXRzXG4gICAgICogQHBhcmFtIHs/fSBleHBvcnRlZFZhcnNcbiAgICAgKiBAcGFyYW0gez89fSBwcmVhbWJsZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVHlwZVNjcmlwdEVtaXR0ZXIucHJvdG90eXBlLmVtaXRTdGF0ZW1lbnRzID0gZnVuY3Rpb24gKHNyY0ZpbGVQYXRoLCBnZW5GaWxlUGF0aCwgc3RtdHMsIGV4cG9ydGVkVmFycywgcHJlYW1ibGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHByZWFtYmxlID09PSB2b2lkIDApIHsgcHJlYW1ibGUgPSAnJzsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZXIgPSBuZXcgX1RzRW1pdHRlclZpc2l0b3IoZ2VuRmlsZVBhdGgsIHRoaXMuX2ltcG9ydFJlc29sdmVyKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3R4ID0gRW1pdHRlclZpc2l0b3JDb250ZXh0LmNyZWF0ZVJvb3QoZXhwb3J0ZWRWYXJzKTtcbiAgICAgICAgY29udmVydGVyLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10cywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlYW1ibGVMaW5lcyA9IHByZWFtYmxlID8gcHJlYW1ibGUuc3BsaXQoJ1xcbicpIDogW107XG4gICAgICAgIGNvbnZlcnRlci5yZWV4cG9ydHMuZm9yRWFjaChmdW5jdGlvbiAocmVleHBvcnRzLCBleHBvcnRlZEZpbGVQYXRoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWV4cG9ydHNDb2RlID0gcmVleHBvcnRzLm1hcChmdW5jdGlvbiAocmVleHBvcnQpIHsgcmV0dXJuIHJlZXhwb3J0Lm5hbWUgKyBcIiBhcyBcIiArIHJlZXhwb3J0LmFzOyB9KS5qb2luKCcsJyk7XG4gICAgICAgICAgICBwcmVhbWJsZUxpbmVzLnB1c2goXCJleHBvcnQge1wiICsgcmVleHBvcnRzQ29kZSArIFwifSBmcm9tICdcIiArIF90aGlzLl9pbXBvcnRSZXNvbHZlci5maWxlTmFtZVRvTW9kdWxlTmFtZShleHBvcnRlZEZpbGVQYXRoLCBnZW5GaWxlUGF0aCkgKyBcIic7XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29udmVydGVyLmltcG9ydHNXaXRoUHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4LCBpbXBvcnRlZEZpbGVQYXRoKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBjYW4ndCB3cml0ZSB0aGUgcmVhbCB3b3JkIGZvciBpbXBvcnQgYXMgaXQgc2NyZXdzIHVwIHN5c3RlbS5qcyBhdXRvIGRldGVjdGlvbi4uLlxuICAgICAgICAgICAgcHJlYW1ibGVMaW5lcy5wdXNoKFwiaW1wXCIgK1xuICAgICAgICAgICAgICAgIChcIm9ydCAqIGFzIFwiICsgcHJlZml4ICsgXCIgZnJvbSAnXCIgKyBfdGhpcy5faW1wb3J0UmVzb2x2ZXIuZmlsZU5hbWVUb01vZHVsZU5hbWUoaW1wb3J0ZWRGaWxlUGF0aCwgZ2VuRmlsZVBhdGgpICsgXCInO1wiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzbSA9IGN0eC50b1NvdXJjZU1hcEdlbmVyYXRvcihzcmNGaWxlUGF0aCwgZ2VuRmlsZVBhdGgsIHByZWFtYmxlTGluZXMubGVuZ3RoKS50b0pzQ29tbWVudCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaW5lcyA9IHByZWFtYmxlTGluZXMuY29uY2F0KFtjdHgudG9Tb3VyY2UoKSwgc21dKTtcbiAgICAgICAgaWYgKHNtKSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgYWRkIGEgbmV3bGluZSBhdCB0aGUgZW5kLCBhcyBzb21lIHRvb2xzIGhhdmUgYnVncyB3aXRob3V0IGl0LlxuICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH07XG4gICAgcmV0dXJuIFR5cGVTY3JpcHRFbWl0dGVyO1xufSgpKTtcbnZhciBfVHNFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKF9Uc0VtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2dlbkZpbGVQYXRoXG4gICAgICogQHBhcmFtIHs/fSBfaW1wb3J0UmVzb2x2ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfVHNFbWl0dGVyVmlzaXRvcihfZ2VuRmlsZVBhdGgsIF9pbXBvcnRSZXNvbHZlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBmYWxzZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2dlbkZpbGVQYXRoID0gX2dlbkZpbGVQYXRoO1xuICAgICAgICBfdGhpcy5faW1wb3J0UmVzb2x2ZXIgPSBfaW1wb3J0UmVzb2x2ZXI7XG4gICAgICAgIF90aGlzLnR5cGVFeHByZXNzaW9uID0gMDtcbiAgICAgICAgX3RoaXMuaW1wb3J0c1dpdGhQcmVmaXhlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMucmVleHBvcnRzID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdFR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFR5cGUgPSBmdW5jdGlvbiAodCwgY3R4LCBkZWZhdWx0VHlwZSkge1xuICAgICAgICBpZiAoZGVmYXVsdFR5cGUgPT09IHZvaWQgMCkgeyBkZWZhdWx0VHlwZSA9ICdhbnknOyB9XG4gICAgICAgIGlmICh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24rKztcbiAgICAgICAgICAgIHQudmlzaXRUeXBlKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICB0aGlzLnR5cGVFeHByZXNzaW9uLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgZGVmYXVsdFR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGFzdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgYXN0LnR5cGUgIT0gSU5GRVJSRURfVFlQRSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgXCIoXCIgKyB2YWx1ZSArIFwiIGFzIGFueSlcIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdExpdGVyYWxFeHByLmNhbGwodGhpcywgYXN0LCBjdHgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBpZiAoYXN0LmVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCAnKCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByLmNhbGwodGhpcywgYXN0LCBjdHgpO1xuICAgICAgICBpZiAoYXN0LmVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCAnIGFzIGFueVtdKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHRlcm5hbEV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdGhpcy5fdmlzaXRJZGVudGlmaWVyKGFzdC52YWx1ZSwgYXN0LnR5cGVQYXJhbXMsIGN0eCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVWYXJTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoY3R4LmlzRXhwb3J0ZWRWYXIoc3RtdC5uYW1lKSAmJiBzdG10LnZhbHVlIGluc3RhbmNlb2YgRXh0ZXJuYWxFeHByICYmICFzdG10LnR5cGUpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBhIHJlZXhwb3J0XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9yZXNvbHZlU3RhdGljU3ltYm9sKHN0bXQudmFsdWUudmFsdWUpLCBuYW1lID0gX2EubmFtZSwgZmlsZVBhdGggPSBfYS5maWxlUGF0aCwgbWVtYmVycyA9IF9hLm1lbWJlcnM7XG4gICAgICAgICAgICBpZiAobWVtYmVycy5sZW5ndGggPT09IDAgJiYgZmlsZVBhdGggIT09IHRoaXMuX2dlbkZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVleHBvcnRzID0gdGhpcy5yZWV4cG9ydHMuZ2V0KGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZXhwb3J0cykge1xuICAgICAgICAgICAgICAgICAgICByZWV4cG9ydHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWV4cG9ydHMuc2V0KGZpbGVQYXRoLCByZWV4cG9ydHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWV4cG9ydHMucHVzaCh7IG5hbWU6IG5hbWUsIGFzOiBzdG10Lm5hbWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5pc0V4cG9ydGVkVmFyKHN0bXQubmFtZSkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBcImV4cG9ydCBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkZpbmFsKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiY29uc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJ2YXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiIFwiICsgc3RtdC5uYW1lKTtcbiAgICAgICAgdGhpcy5fcHJpbnRDb2xvblR5cGUoc3RtdC50eXBlLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgPSBcIik7XG4gICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiO1wiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIig8XCIpO1xuICAgICAgICBhc3QudHlwZS52aXNpdFR5cGUodGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCI+XCIpO1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCJuZXcgXCIpO1xuICAgICAgICB0aGlzLnR5cGVFeHByZXNzaW9uKys7XG4gICAgICAgIGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24tLTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIoXCIpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWNsYXJlQ2xhc3NTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjdHgucHVzaENsYXNzKHN0bXQpO1xuICAgICAgICBpZiAoY3R4LmlzRXhwb3J0ZWRWYXIoc3RtdC5uYW1lKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZXhwb3J0IFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCJjbGFzcyBcIiArIHN0bXQubmFtZSk7XG4gICAgICAgIGlmIChzdG10LnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIgZXh0ZW5kcyBcIik7XG4gICAgICAgICAgICB0aGlzLnR5cGVFeHByZXNzaW9uKys7XG4gICAgICAgICAgICBzdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIHRoaXMudHlwZUV4cHJlc3Npb24tLTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIiB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHN0bXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7IHJldHVybiBfdGhpcy5fdmlzaXRDbGFzc0ZpZWxkKGZpZWxkLCBjdHgpOyB9KTtcbiAgICAgICAgaWYgKHN0bXQuY29uc3RydWN0b3JNZXRob2QgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yKHN0bXQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RtdC5nZXR0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGdldHRlcikgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NHZXR0ZXIoZ2V0dGVyLCBjdHgpOyB9KTtcbiAgICAgICAgc3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyByZXR1cm4gX3RoaXMuX3Zpc2l0Q2xhc3NNZXRob2QobWV0aG9kLCBjdHgpOyB9KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgICAgIGN0eC5wb3BDbGFzcygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmllbGRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzRmllbGQgPSBmdW5jdGlvbiAoZmllbGQsIGN0eCkge1xuICAgICAgICBpZiAoZmllbGQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICAvLyBjb21tZW50IG91dCBhcyBhIHdvcmthcm91bmQgZm9yICMxMDk2N1xuICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIFwiLypwcml2YXRlKi8gXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChudWxsLCBmaWVsZC5uYW1lKTtcbiAgICAgICAgdGhpcy5fcHJpbnRDb2xvblR5cGUoZmllbGQudHlwZSwgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4obnVsbCwgXCI7XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBnZXR0ZXJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzR2V0dGVyID0gZnVuY3Rpb24gKGdldHRlciwgY3R4KSB7XG4gICAgICAgIGlmIChnZXR0ZXIuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLlByaXZhdGUpKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJwcml2YXRlIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQobnVsbCwgXCJnZXQgXCIgKyBnZXR0ZXIubmFtZSArIFwiKClcIik7XG4gICAgICAgIHRoaXMuX3ByaW50Q29sb25UeXBlKGdldHRlci50eXBlLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihudWxsLCBcIiB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKG51bGwsIFwifVwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0Q2xhc3NDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiY29uc3RydWN0b3IoXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCIpIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5LCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0aG9kXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc01ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QsIGN0eCkge1xuICAgICAgICBpZiAobWV0aG9kLmhhc01vZGlmaWVyKFN0bXRNb2RpZmllci5Qcml2YXRlKSkge1xuICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIFwicHJpdmF0ZSBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KG51bGwsIG1ldGhvZC5uYW1lICsgXCIoXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhtZXRob2QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQobnVsbCwgXCIpXCIpO1xuICAgICAgICB0aGlzLl9wcmludENvbG9uVHlwZShtZXRob2QudHlwZSwgY3R4LCAndm9pZCcpO1xuICAgICAgICBjdHgucHJpbnRsbihudWxsLCBcIiB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKG1ldGhvZC5ib2R5LCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKG51bGwsIFwifVwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBcIihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKGFzdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiKVwiKTtcbiAgICAgICAgdGhpcy5fcHJpbnRDb2xvblR5cGUoYXN0LnR5cGUsIGN0eCwgJ3ZvaWQnKTtcbiAgICAgICAgY3R4LnByaW50bG4oYXN0LCBcIiA9PiB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgaWYgKGN0eC5pc0V4cG9ydGVkVmFyKHN0bXQubmFtZSkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBcImV4cG9ydCBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KHN0bXQsIFwiZnVuY3Rpb24gXCIgKyBzdG10Lm5hbWUgKyBcIihcIik7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgXCIpXCIpO1xuICAgICAgICB0aGlzLl9wcmludENvbG9uVHlwZShzdG10LnR5cGUsIGN0eCwgJ3ZvaWQnKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCIge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRUcnlDYXRjaFN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwidHJ5IHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5ib2R5U3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9IGNhdGNoIChcIiArIENBVENIX0VSUk9SX1ZBUiQxLm5hbWUgKyBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjYXRjaFN0bXRzID0gWy8qKiBAdHlwZSB7P30gKi8gKENBVENIX1NUQUNLX1ZBUiQxLnNldChDQVRDSF9FUlJPUl9WQVIkMS5wcm9wKCdzdGFjaycpKS50b0RlY2xTdG10KG51bGwsIFtcbiAgICAgICAgICAgICAgICBTdG10TW9kaWZpZXIuRmluYWxcbiAgICAgICAgICAgIF0pKV0uY29uY2F0KHN0bXQuY2F0Y2hTdG10cyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGNhdGNoU3RtdHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRCdWlsdGludFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVTdHI7XG4gICAgICAgIHN3aXRjaCAodHlwZS5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5Cb29sOlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnYm9vbGVhbic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5EeW5hbWljOlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnYW55JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnRnVuY3Rpb24nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluVHlwZU5hbWUuTnVtYmVyOlxuICAgICAgICAgICAgICAgIHR5cGVTdHIgPSAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpblR5cGVOYW1lLkludDpcbiAgICAgICAgICAgICAgICB0eXBlU3RyID0gJ251bWJlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5UeXBlTmFtZS5TdHJpbmc6XG4gICAgICAgICAgICAgICAgdHlwZVN0ciA9ICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBidWlsdGluIHR5cGUgXCIgKyB0eXBlLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChudWxsLCB0eXBlU3RyKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRFeHByZXNzaW9uVHlwZSA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFycmF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBjdHgpIHtcbiAgICAgICAgdGhpcy52aXNpdFR5cGUodHlwZS5vZiwgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KG51bGwsIFwiW11cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdE1hcFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChudWxsLCBcIntba2V5OiBzdHJpbmddOlwiKTtcbiAgICAgICAgdGhpcy52aXNpdFR5cGUodHlwZS52YWx1ZVR5cGUsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChudWxsLCBcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5nZXRCdWlsdGluTWV0aG9kTmFtZSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmFtZTtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICBuYW1lID0gJ2NvbmNhdCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuU3Vic2NyaWJlT2JzZXJ2YWJsZTpcbiAgICAgICAgICAgICAgICBuYW1lID0gJ3N1YnNjcmliZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQmluZDpcbiAgICAgICAgICAgICAgICBuYW1lID0gJ2JpbmQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gbWV0aG9kOiBcIiArIG1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBhcmFtc1xuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0UGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcywgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgX3RoaXMuX3ByaW50Q29sb25UeXBlKHBhcmFtLnR5cGUsIGN0eCk7XG4gICAgICAgIH0sIHBhcmFtcywgY3R4LCAnLCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX1RzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl9yZXNvbHZlU3RhdGljU3ltYm9sID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlZmVyZW5jZSA9IHZhbHVlLnJlZmVyZW5jZTtcbiAgICAgICAgaWYgKCEocmVmZXJlbmNlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3I6IHVua25vd24gaWRlbnRpZmllciBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJpdHkgPSB0aGlzLl9pbXBvcnRSZXNvbHZlci5nZXRUeXBlQXJpdHkocmVmZXJlbmNlKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydFJlZmVyZW5jZSA9IHRoaXMuX2ltcG9ydFJlc29sdmVyLmdldEltcG9ydEFzKHJlZmVyZW5jZSkgfHwgcmVmZXJlbmNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogaW1wb3J0UmVmZXJlbmNlLm5hbWUsXG4gICAgICAgICAgICBmaWxlUGF0aDogaW1wb3J0UmVmZXJlbmNlLmZpbGVQYXRoLFxuICAgICAgICAgICAgbWVtYmVyczogaW1wb3J0UmVmZXJlbmNlLm1lbWJlcnMsIGFyaXR5OiBhcml0eVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P30gdHlwZVBhcmFtc1xuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfVHNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuX3Zpc2l0SWRlbnRpZmllciA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZVBhcmFtcywgY3R4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3Jlc29sdmVTdGF0aWNTeW1ib2wodmFsdWUpLCBuYW1lID0gX2EubmFtZSwgZmlsZVBhdGggPSBfYS5maWxlUGF0aCwgbWVtYmVycyA9IF9hLm1lbWJlcnMsIGFyaXR5ID0gX2EuYXJpdHk7XG4gICAgICAgIGlmIChmaWxlUGF0aCAhPSB0aGlzLl9nZW5GaWxlUGF0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlZml4ID0gdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLmdldChmaWxlUGF0aCk7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcImltcG9ydFwiICsgdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLnNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRzV2l0aFByZWZpeGVzLnNldChmaWxlUGF0aCwgcHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBwcmVmaXggKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgbmFtZSk7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJy4nKTtcbiAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBtZW1iZXJzLmpvaW4oJy4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHlwZUV4cHJlc3Npb24gPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaW4gYSB0eXBlIGV4cHJlc3Npb24gdGhhdCByZWZlcnMgdG8gYSBnZW5lcmljIHR5cGUgdGhlbiBzdXBwbHlcbiAgICAgICAgICAgIC8vIHRoZSByZXF1aXJlZCB0eXBlIHBhcmFtZXRlcnMuIElmIHRoZXJlIHdlcmUgbm90IGVub3VnaCB0eXBlIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIC8vIHN1cHBsaWVkLCBzdXBwbHkgYW55IGFzIHRoZSB0eXBlLiBPdXRzaWRlIGEgdHlwZSBleHByZXNzaW9uIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBub3Qgc3VwcGx5IHR5cGUgcGFyYW1ldGVycyBhbmQgYmUgdHJlYXRlZCBhcyBhIHNpbXBsZSB2YWx1ZSByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpdHNlbGYuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdXBwbGllZFBhcmFtZXRlcnMgPSAodHlwZVBhcmFtcyAmJiB0eXBlUGFyYW1zLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFkZGl0aW9uYWxQYXJhbWV0ZXJzID0gKGFyaXR5IHx8IDApIC0gc3VwcGxpZWRQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgaWYgKHN1cHBsaWVkUGFyYW1ldGVycyA+IDAgfHwgYWRkaXRpb25hbFBhcmFtZXRlcnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIFwiPFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcGxpZWRQYXJhbWV0ZXJzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS52aXNpdFR5cGUoX3RoaXMsIGN0eCk7IH0sIHR5cGVQYXJhbXMsIGN0eCwgJywnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxQYXJhbWV0ZXJzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgYWRkaXRpb25hbFBhcmFtZXRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwIHx8IHN1cHBsaWVkUGFyYW1ldGVycyA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnByaW50KG51bGwsICcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgJ2FueScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBcIj5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHBhcmFtIHs/PX0gZGVmYXVsdFR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Uc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fcHJpbnRDb2xvblR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY3R4LCBkZWZhdWx0VHlwZSkge1xuICAgICAgICBpZiAodHlwZSAhPT0gSU5GRVJSRURfVFlQRSkge1xuICAgICAgICAgICAgY3R4LnByaW50KG51bGwsICc6Jyk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0VHlwZSh0eXBlLCBjdHgsIGRlZmF1bHRUeXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIF9Uc0VtaXR0ZXJWaXNpdG9yO1xufShBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PSBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgID09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gICAgICAgIERPIE5PVCBFRElUIFRISVMgTElTVCBPRiBTRUNVUklUWSBTRU5TSVRJVkUgUFJPUEVSVElFUyBXSVRIT1VUIEEgU0VDVVJJVFkgUkVWSUVXIVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY2ggb3V0IHRvIG1wcm9ic3QgZm9yIGRldGFpbHMuXG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLyoqIE1hcCBmcm9tIHRhZ05hbWV8cHJvcGVydHlOYW1lIFNlY3VyaXR5Q29udGV4dC4gUHJvcGVydGllcyBhcHBseWluZyB0byBhbGwgdGFncyB1c2UgJyonLiAqL1xudmFyIFNFQ1VSSVRZX1NDSEVNQSA9IHt9O1xuLyoqXG4gKiBAcGFyYW0gez99IGN0eFxuICogQHBhcmFtIHs/fSBzcGVjc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDb250ZXh0KGN0eCwgc3BlY3MpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNwZWNzXzEgPSBzcGVjczsgX2kgPCBzcGVjc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc3BlYyA9IHNwZWNzXzFbX2ldO1xuICAgICAgICBTRUNVUklUWV9TQ0hFTUFbc3BlYy50b0xvd2VyQ2FzZSgpXSA9IGN0eDtcbiAgICB9XG59XG4vLyBDYXNlIGlzIGluc2lnbmlmaWNhbnQgYmVsb3csIGFsbCBlbGVtZW50IGFuZCBhdHRyaWJ1dGUgbmFtZXMgYXJlIGxvd2VyLWNhc2VkIGZvciBsb29rdXAuXG5yZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LkhUTUwsIFtcbiAgICAnaWZyYW1lfHNyY2RvYycsXG4gICAgJyp8aW5uZXJIVE1MJyxcbiAgICAnKnxvdXRlckhUTUwnLFxuXSk7XG5yZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LlNUWUxFLCBbJyp8c3R5bGUnXSk7XG4vLyBOQjogbm8gU0NSSVBUIGNvbnRleHRzIGhlcmUsIHRoZXkgYXJlIG5ldmVyIGFsbG93ZWQgZHVlIHRvIHRoZSBwYXJzZXIgc3RyaXBwaW5nIHRoZW0uXG5yZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LlVSTCwgW1xuICAgICcqfGZvcm1BY3Rpb24nLCAnYXJlYXxocmVmJywgJ2FyZWF8cGluZycsICdhdWRpb3xzcmMnLCAnYXxocmVmJyxcbiAgICAnYXxwaW5nJywgJ2Jsb2NrcXVvdGV8Y2l0ZScsICdib2R5fGJhY2tncm91bmQnLCAnZGVsfGNpdGUnLCAnZm9ybXxhY3Rpb24nLFxuICAgICdpbWd8c3JjJywgJ2ltZ3xzcmNzZXQnLCAnaW5wdXR8c3JjJywgJ2luc3xjaXRlJywgJ3F8Y2l0ZScsXG4gICAgJ3NvdXJjZXxzcmMnLCAnc291cmNlfHNyY3NldCcsICd0cmFja3xzcmMnLCAndmlkZW98cG9zdGVyJywgJ3ZpZGVvfHNyYycsXG5dKTtcbnJlZ2lzdGVyQ29udGV4dChTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMLCBbXG4gICAgJ2FwcGxldHxjb2RlJyxcbiAgICAnYXBwbGV0fGNvZGViYXNlJyxcbiAgICAnYmFzZXxocmVmJyxcbiAgICAnZW1iZWR8c3JjJyxcbiAgICAnZnJhbWV8c3JjJyxcbiAgICAnaGVhZHxwcm9maWxlJyxcbiAgICAnaHRtbHxtYW5pZmVzdCcsXG4gICAgJ2lmcmFtZXxzcmMnLFxuICAgICdsaW5rfGhyZWYnLFxuICAgICdtZWRpYXxzcmMnLFxuICAgICdvYmplY3R8Y29kZWJhc2UnLFxuICAgICdvYmplY3R8ZGF0YScsXG4gICAgJ3NjcmlwdHxzcmMnLFxuXSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQk9PTEVBTiA9ICdib29sZWFuJztcbnZhciBOVU1CRVIgPSAnbnVtYmVyJztcbnZhciBTVFJJTkcgPSAnc3RyaW5nJztcbnZhciBPQkpFQ1QgPSAnb2JqZWN0Jztcbi8qKlxuICogVGhpcyBhcnJheSByZXByZXNlbnRzIHRoZSBET00gc2NoZW1hLiBJdCBlbmNvZGVzIGluaGVyaXRhbmNlLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzLlxuICpcbiAqICMjIE92ZXJ2aWV3XG4gKlxuICogRWFjaCBsaW5lIHJlcHJlc2VudHMgb25lIGtpbmQgb2YgZWxlbWVudC4gVGhlIGBlbGVtZW50X2luaGVyaXRhbmNlYCBhbmQgcHJvcGVydGllcyBhcmUgam9pbmVkXG4gKiB1c2luZyBgZWxlbWVudF9pbmhlcml0YW5jZXxwcm9wZXJ0aWVzYCBzeW50YXguXG4gKlxuICogIyMgRWxlbWVudCBJbmhlcml0YW5jZVxuICpcbiAqIFRoZSBgZWxlbWVudF9pbmhlcml0YW5jZWAgY2FuIGJlIGZ1cnRoZXIgc3ViZGl2aWRlZCBhcyBgZWxlbWVudDEsZWxlbWVudDIsLi4uXnBhcmVudEVsZW1lbnRgLlxuICogSGVyZSB0aGUgaW5kaXZpZHVhbCBlbGVtZW50cyBhcmUgc2VwYXJhdGVkIGJ5IGAsYCAoY29tbWFzKS4gRXZlcnkgZWxlbWVudCBpbiB0aGUgbGlzdFxuICogaGFzIGlkZW50aWNhbCBwcm9wZXJ0aWVzLlxuICpcbiAqIEFuIGBlbGVtZW50YCBtYXkgaW5oZXJpdCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgZnJvbSBgcGFyZW50RWxlbWVudGAgSWYgbm8gYF5wYXJlbnRFbGVtZW50YCBpc1xuICogc3BlY2lmaWVkIHRoZW4gYFwiXCJgIChibGFuaykgZWxlbWVudCBpcyBhc3N1bWVkLlxuICpcbiAqIE5PVEU6IFRoZSBibGFuayBlbGVtZW50IGluaGVyaXRzIGZyb20gcm9vdCBgW0VsZW1lbnRdYCBlbGVtZW50LCB0aGUgc3VwZXIgZWxlbWVudCBvZiBhbGxcbiAqIGVsZW1lbnRzLlxuICpcbiAqIE5PVEUgYW4gZWxlbWVudCBwcmVmaXggc3VjaCBhcyBgOnN2ZzpgIGhhcyBubyBzcGVjaWFsIG1lYW5pbmcgdG8gdGhlIHNjaGVtYS5cbiAqXG4gKiAjIyBQcm9wZXJ0aWVzXG4gKlxuICogRWFjaCBlbGVtZW50IGhhcyBhIHNldCBvZiBwcm9wZXJ0aWVzIHNlcGFyYXRlZCBieSBgLGAgKGNvbW1hcykuIEVhY2ggcHJvcGVydHkgY2FuIGJlIHByZWZpeGVkXG4gKiBieSBhIHNwZWNpYWwgY2hhcmFjdGVyIGRlc2lnbmF0aW5nIGl0cyB0eXBlOlxuICpcbiAqIC0gKG5vIHByZWZpeCk6IHByb3BlcnR5IGlzIGEgc3RyaW5nLlxuICogLSBgKmA6IHByb3BlcnR5IHJlcHJlc2VudHMgYW4gZXZlbnQuXG4gKiAtIGAhYDogcHJvcGVydHkgaXMgYSBib29sZWFuLlxuICogLSBgI2A6IHByb3BlcnR5IGlzIGEgbnVtYmVyLlxuICogLSBgJWA6IHByb3BlcnR5IGlzIGFuIG9iamVjdC5cbiAqXG4gKiAjIyBRdWVyeVxuICpcbiAqIFRoZSBjbGFzcyBjcmVhdGVzIGFuIGludGVybmFsIHNxdWFzIHJlcHJlc2VudGF0aW9uIHdoaWNoIGFsbG93cyB0byBlYXNpbHkgYW5zd2VyIHRoZSBxdWVyeSBvZlxuICogaWYgYSBnaXZlbiBwcm9wZXJ0eSBleGlzdCBvbiBhIGdpdmVuIGVsZW1lbnQuXG4gKlxuICogTk9URTogV2UgZG9uJ3QgeWV0IHN1cHBvcnQgcXVlcnlpbmcgZm9yIHR5cGVzIG9yIGV2ZW50cy5cbiAqIE5PVEU6IFRoaXMgc2NoZW1hIGlzIGF1dG8gZXh0cmFjdGVkIGZyb20gYHNjaGVtYV9leHRyYWN0b3IudHNgIGxvY2F0ZWQgaW4gdGhlIHRlc3QgZm9sZGVyLFxuICogICAgICAgc2VlIGRvbV9lbGVtZW50X3NjaGVtYV9yZWdpc3RyeV9zcGVjLnRzXG4gKi9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09IFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgPT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyAgICAgICAgICAgICAgICAgICAgICAgRE8gTk9UIEVESVQgVEhJUyBET00gU0NIRU1BIFdJVEhPVVQgQSBTRUNVUklUWSBSRVZJRVchXG4vL1xuLy8gTmV3bHkgYWRkZWQgcHJvcGVydGllcyBtdXN0IGJlIHNlY3VyaXR5IHJldmlld2VkIGFuZCBhc3NpZ25lZCBhbiBhcHByb3ByaWF0ZSBTZWN1cml0eUNvbnRleHQgaW5cbi8vIGRvbV9zZWN1cml0eV9zY2hlbWEudHMuIFJlYWNoIG91dCB0byBtcHJvYnN0ICYgcmphbWV0IGZvciBkZXRhaWxzLlxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbnZhciBTQ0hFTUEgPSBbXG4gICAgJ1tFbGVtZW50XXx0ZXh0Q29udGVudCwlY2xhc3NMaXN0LGNsYXNzTmFtZSxpZCxpbm5lckhUTUwsKmJlZm9yZWNvcHksKmJlZm9yZWN1dCwqYmVmb3JlcGFzdGUsKmNvcHksKmN1dCwqcGFzdGUsKnNlYXJjaCwqc2VsZWN0c3RhcnQsKndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UsKndlYmtpdGZ1bGxzY3JlZW5lcnJvciwqd2hlZWwsb3V0ZXJIVE1MLCNzY3JvbGxMZWZ0LCNzY3JvbGxUb3AnLFxuICAgICdbSFRNTEVsZW1lbnRdXltFbGVtZW50XXxhY2Nlc3NLZXksY29udGVudEVkaXRhYmxlLGRpciwhZHJhZ2dhYmxlLCFoaWRkZW4saW5uZXJUZXh0LGxhbmcsKmFib3J0LCpiZWZvcmVjb3B5LCpiZWZvcmVjdXQsKmJlZm9yZXBhc3RlLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmNvcHksKmN1ZWNoYW5nZSwqY3V0LCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCppbnB1dCwqaW52YWxpZCwqa2V5ZG93biwqa2V5cHJlc3MsKmtleXVwLCpsb2FkLCpsb2FkZWRkYXRhLCpsb2FkZWRtZXRhZGF0YSwqbG9hZHN0YXJ0LCptZXNzYWdlLCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqbW96ZnVsbHNjcmVlbmNoYW5nZSwqbW96ZnVsbHNjcmVlbmVycm9yLCptb3pwb2ludGVybG9ja2NoYW5nZSwqbW96cG9pbnRlcmxvY2tlcnJvciwqcGFzdGUsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWFyY2gsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzZWxlY3RzdGFydCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZywqd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvciwqd2ViZ2xjb250ZXh0bG9zdCwqd2ViZ2xjb250ZXh0cmVzdG9yZWQsKndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UsKndlYmtpdGZ1bGxzY3JlZW5lcnJvciwqd2hlZWwsb3V0ZXJUZXh0LCFzcGVsbGNoZWNrLCVzdHlsZSwjdGFiSW5kZXgsdGl0bGUsIXRyYW5zbGF0ZScsXG4gICAgJ2FiYnIsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGIsYmRpLGJkbyxjaXRlLGNvZGUsZGQsZGZuLGR0LGVtLGZpZ2NhcHRpb24sZmlndXJlLGZvb3RlcixoZWFkZXIsaSxrYmQsbWFpbixtYXJrLG5hdixub3NjcmlwdCxyYixycCxydCxydGMscnVieSxzLHNhbXAsc2VjdGlvbixzbWFsbCxzdHJvbmcsc3ViLHN1cCx1LHZhcix3YnJeW0hUTUxFbGVtZW50XXxhY2Nlc3NLZXksY29udGVudEVkaXRhYmxlLGRpciwhZHJhZ2dhYmxlLCFoaWRkZW4saW5uZXJUZXh0LGxhbmcsKmFib3J0LCpiZWZvcmVjb3B5LCpiZWZvcmVjdXQsKmJlZm9yZXBhc3RlLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmNvcHksKmN1ZWNoYW5nZSwqY3V0LCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCppbnB1dCwqaW52YWxpZCwqa2V5ZG93biwqa2V5cHJlc3MsKmtleXVwLCpsb2FkLCpsb2FkZWRkYXRhLCpsb2FkZWRtZXRhZGF0YSwqbG9hZHN0YXJ0LCptZXNzYWdlLCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqbW96ZnVsbHNjcmVlbmNoYW5nZSwqbW96ZnVsbHNjcmVlbmVycm9yLCptb3pwb2ludGVybG9ja2NoYW5nZSwqbW96cG9pbnRlcmxvY2tlcnJvciwqcGFzdGUsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWFyY2gsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzZWxlY3RzdGFydCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZywqd2ViZ2xjb250ZXh0Y3JlYXRpb25lcnJvciwqd2ViZ2xjb250ZXh0bG9zdCwqd2ViZ2xjb250ZXh0cmVzdG9yZWQsKndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UsKndlYmtpdGZ1bGxzY3JlZW5lcnJvciwqd2hlZWwsb3V0ZXJUZXh0LCFzcGVsbGNoZWNrLCVzdHlsZSwjdGFiSW5kZXgsdGl0bGUsIXRyYW5zbGF0ZScsXG4gICAgJ21lZGlhXltIVE1MRWxlbWVudF18IWF1dG9wbGF5LCFjb250cm9scywlY3Jvc3NPcmlnaW4sI2N1cnJlbnRUaW1lLCFkZWZhdWx0TXV0ZWQsI2RlZmF1bHRQbGF5YmFja1JhdGUsIWRpc2FibGVSZW1vdGVQbGF5YmFjaywhbG9vcCwhbXV0ZWQsKmVuY3J5cHRlZCwjcGxheWJhY2tSYXRlLHByZWxvYWQsc3JjLCVzcmNPYmplY3QsI3ZvbHVtZScsXG4gICAgJzpzdmc6XltIVE1MRWxlbWVudF18KmFib3J0LCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmN1ZWNoYW5nZSwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZywlc3R5bGUsI3RhYkluZGV4JyxcbiAgICAnOnN2ZzpncmFwaGljc146c3ZnOnwnLFxuICAgICc6c3ZnOmFuaW1hdGlvbl46c3ZnOnwqYmVnaW4sKmVuZCwqcmVwZWF0JyxcbiAgICAnOnN2ZzpnZW9tZXRyeV46c3ZnOnwnLFxuICAgICc6c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25eOnN2Zzp8JyxcbiAgICAnOnN2ZzpncmFkaWVudF46c3ZnOnwnLFxuICAgICc6c3ZnOnRleHRDb250ZW50Xjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2Zzp0ZXh0UG9zaXRpb25pbmdeOnN2Zzp0ZXh0Q29udGVudHwnLFxuICAgICdhXltIVE1MRWxlbWVudF18Y2hhcnNldCxjb29yZHMsZG93bmxvYWQsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsaHJlZmxhbmcsbmFtZSxwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wscmVmZXJyZXJQb2xpY3kscmVsLHJldixzZWFyY2gsc2hhcGUsdGFyZ2V0LHRleHQsdHlwZSx1c2VybmFtZScsXG4gICAgJ2FyZWFeW0hUTUxFbGVtZW50XXxhbHQsY29vcmRzLGhhc2gsaG9zdCxob3N0bmFtZSxocmVmLCFub0hyZWYscGFzc3dvcmQscGF0aG5hbWUscGluZyxwb3J0LHByb3RvY29sLHJlZmVycmVyUG9saWN5LHNlYXJjaCxzaGFwZSx0YXJnZXQsdXNlcm5hbWUnLFxuICAgICdhdWRpb15tZWRpYXwnLFxuICAgICdicl5bSFRNTEVsZW1lbnRdfGNsZWFyJyxcbiAgICAnYmFzZV5bSFRNTEVsZW1lbnRdfGhyZWYsdGFyZ2V0JyxcbiAgICAnYm9keV5bSFRNTEVsZW1lbnRdfGFMaW5rLGJhY2tncm91bmQsYmdDb2xvcixsaW5rLCpiZWZvcmV1bmxvYWQsKmJsdXIsKmVycm9yLCpmb2N1cywqaGFzaGNoYW5nZSwqbGFuZ3VhZ2VjaGFuZ2UsKmxvYWQsKm1lc3NhZ2UsKm9mZmxpbmUsKm9ubGluZSwqcGFnZWhpZGUsKnBhZ2VzaG93LCpwb3BzdGF0ZSwqcmVqZWN0aW9uaGFuZGxlZCwqcmVzaXplLCpzY3JvbGwsKnN0b3JhZ2UsKnVuaGFuZGxlZHJlamVjdGlvbiwqdW5sb2FkLHRleHQsdkxpbmsnLFxuICAgICdidXR0b25eW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsbmFtZSx0eXBlLHZhbHVlJyxcbiAgICAnY2FudmFzXltIVE1MRWxlbWVudF18I2hlaWdodCwjd2lkdGgnLFxuICAgICdjb250ZW50XltIVE1MRWxlbWVudF18c2VsZWN0JyxcbiAgICAnZGxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ2RhdGFsaXN0XltIVE1MRWxlbWVudF18JyxcbiAgICAnZGV0YWlsc15bSFRNTEVsZW1lbnRdfCFvcGVuJyxcbiAgICAnZGlhbG9nXltIVE1MRWxlbWVudF18IW9wZW4scmV0dXJuVmFsdWUnLFxuICAgICdkaXJeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ2Rpdl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnZW1iZWReW0hUTUxFbGVtZW50XXxhbGlnbixoZWlnaHQsbmFtZSxzcmMsdHlwZSx3aWR0aCcsXG4gICAgJ2ZpZWxkc2V0XltIVE1MRWxlbWVudF18IWRpc2FibGVkLG5hbWUnLFxuICAgICdmb250XltIVE1MRWxlbWVudF18Y29sb3IsZmFjZSxzaXplJyxcbiAgICAnZm9ybV5bSFRNTEVsZW1lbnRdfGFjY2VwdENoYXJzZXQsYWN0aW9uLGF1dG9jb21wbGV0ZSxlbmNvZGluZyxlbmN0eXBlLG1ldGhvZCxuYW1lLCFub1ZhbGlkYXRlLHRhcmdldCcsXG4gICAgJ2ZyYW1lXltIVE1MRWxlbWVudF18ZnJhbWVCb3JkZXIsbG9uZ0Rlc2MsbWFyZ2luSGVpZ2h0LG1hcmdpbldpZHRoLG5hbWUsIW5vUmVzaXplLHNjcm9sbGluZyxzcmMnLFxuICAgICdmcmFtZXNldF5bSFRNTEVsZW1lbnRdfGNvbHMsKmJlZm9yZXVubG9hZCwqYmx1ciwqZXJyb3IsKmZvY3VzLCpoYXNoY2hhbmdlLCpsYW5ndWFnZWNoYW5nZSwqbG9hZCwqbWVzc2FnZSwqb2ZmbGluZSwqb25saW5lLCpwYWdlaGlkZSwqcGFnZXNob3csKnBvcHN0YXRlLCpyZWplY3Rpb25oYW5kbGVkLCpyZXNpemUsKnNjcm9sbCwqc3RvcmFnZSwqdW5oYW5kbGVkcmVqZWN0aW9uLCp1bmxvYWQscm93cycsXG4gICAgJ2hyXltIVE1MRWxlbWVudF18YWxpZ24sY29sb3IsIW5vU2hhZGUsc2l6ZSx3aWR0aCcsXG4gICAgJ2hlYWReW0hUTUxFbGVtZW50XXwnLFxuICAgICdoMSxoMixoMyxoNCxoNSxoNl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnaHRtbF5bSFRNTEVsZW1lbnRdfHZlcnNpb24nLFxuICAgICdpZnJhbWVeW0hUTUxFbGVtZW50XXxhbGlnbiwhYWxsb3dGdWxsc2NyZWVuLGZyYW1lQm9yZGVyLGhlaWdodCxsb25nRGVzYyxtYXJnaW5IZWlnaHQsbWFyZ2luV2lkdGgsbmFtZSxyZWZlcnJlclBvbGljeSwlc2FuZGJveCxzY3JvbGxpbmcsc3JjLHNyY2RvYyx3aWR0aCcsXG4gICAgJ2ltZ15bSFRNTEVsZW1lbnRdfGFsaWduLGFsdCxib3JkZXIsJWNyb3NzT3JpZ2luLCNoZWlnaHQsI2hzcGFjZSwhaXNNYXAsbG9uZ0Rlc2MsbG93c3JjLG5hbWUscmVmZXJyZXJQb2xpY3ksc2l6ZXMsc3JjLHNyY3NldCx1c2VNYXAsI3ZzcGFjZSwjd2lkdGgnLFxuICAgICdpbnB1dF5bSFRNTEVsZW1lbnRdfGFjY2VwdCxhbGlnbixhbHQsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLCFhdXRvZm9jdXMsIWNoZWNrZWQsIWRlZmF1bHRDaGVja2VkLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwlZmlsZXMsZm9ybUFjdGlvbixmb3JtRW5jdHlwZSxmb3JtTWV0aG9kLCFmb3JtTm9WYWxpZGF0ZSxmb3JtVGFyZ2V0LCNoZWlnaHQsIWluY3JlbWVudGFsLCFpbmRldGVybWluYXRlLG1heCwjbWF4TGVuZ3RoLG1pbiwjbWluTGVuZ3RoLCFtdWx0aXBsZSxuYW1lLHBhdHRlcm4scGxhY2Vob2xkZXIsIXJlYWRPbmx5LCFyZXF1aXJlZCxzZWxlY3Rpb25EaXJlY3Rpb24sI3NlbGVjdGlvbkVuZCwjc2VsZWN0aW9uU3RhcnQsI3NpemUsc3JjLHN0ZXAsdHlwZSx1c2VNYXAsdmFsdWUsJXZhbHVlQXNEYXRlLCN2YWx1ZUFzTnVtYmVyLCN3aWR0aCcsXG4gICAgJ2tleWdlbl5bSFRNTEVsZW1lbnRdfCFhdXRvZm9jdXMsY2hhbGxlbmdlLCFkaXNhYmxlZCxrZXl0eXBlLG5hbWUnLFxuICAgICdsaV5bSFRNTEVsZW1lbnRdfHR5cGUsI3ZhbHVlJyxcbiAgICAnbGFiZWxeW0hUTUxFbGVtZW50XXxodG1sRm9yJyxcbiAgICAnbGVnZW5kXltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICdsaW5rXltIVE1MRWxlbWVudF18YXMsY2hhcnNldCwlY3Jvc3NPcmlnaW4sIWRpc2FibGVkLGhyZWYsaHJlZmxhbmcsaW50ZWdyaXR5LG1lZGlhLHJlbCwlcmVsTGlzdCxyZXYsJXNpemVzLHRhcmdldCx0eXBlJyxcbiAgICAnbWFwXltIVE1MRWxlbWVudF18bmFtZScsXG4gICAgJ21hcnF1ZWVeW0hUTUxFbGVtZW50XXxiZWhhdmlvcixiZ0NvbG9yLGRpcmVjdGlvbixoZWlnaHQsI2hzcGFjZSwjbG9vcCwjc2Nyb2xsQW1vdW50LCNzY3JvbGxEZWxheSwhdHJ1ZVNwZWVkLCN2c3BhY2Usd2lkdGgnLFxuICAgICdtZW51XltIVE1MRWxlbWVudF18IWNvbXBhY3QnLFxuICAgICdtZXRhXltIVE1MRWxlbWVudF18Y29udGVudCxodHRwRXF1aXYsbmFtZSxzY2hlbWUnLFxuICAgICdtZXRlcl5bSFRNTEVsZW1lbnRdfCNoaWdoLCNsb3csI21heCwjbWluLCNvcHRpbXVtLCN2YWx1ZScsXG4gICAgJ2lucyxkZWxeW0hUTUxFbGVtZW50XXxjaXRlLGRhdGVUaW1lJyxcbiAgICAnb2xeW0hUTUxFbGVtZW50XXwhY29tcGFjdCwhcmV2ZXJzZWQsI3N0YXJ0LHR5cGUnLFxuICAgICdvYmplY3ReW0hUTUxFbGVtZW50XXxhbGlnbixhcmNoaXZlLGJvcmRlcixjb2RlLGNvZGVCYXNlLGNvZGVUeXBlLGRhdGEsIWRlY2xhcmUsaGVpZ2h0LCNoc3BhY2UsbmFtZSxzdGFuZGJ5LHR5cGUsdXNlTWFwLCN2c3BhY2Usd2lkdGgnLFxuICAgICdvcHRncm91cF5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxsYWJlbCcsXG4gICAgJ29wdGlvbl5bSFRNTEVsZW1lbnRdfCFkZWZhdWx0U2VsZWN0ZWQsIWRpc2FibGVkLGxhYmVsLCFzZWxlY3RlZCx0ZXh0LHZhbHVlJyxcbiAgICAnb3V0cHV0XltIVE1MRWxlbWVudF18ZGVmYXVsdFZhbHVlLCVodG1sRm9yLG5hbWUsdmFsdWUnLFxuICAgICdwXltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICdwYXJhbV5bSFRNTEVsZW1lbnRdfG5hbWUsdHlwZSx2YWx1ZSx2YWx1ZVR5cGUnLFxuICAgICdwaWN0dXJlXltIVE1MRWxlbWVudF18JyxcbiAgICAncHJlXltIVE1MRWxlbWVudF18I3dpZHRoJyxcbiAgICAncHJvZ3Jlc3NeW0hUTUxFbGVtZW50XXwjbWF4LCN2YWx1ZScsXG4gICAgJ3EsYmxvY2txdW90ZSxjaXRlXltIVE1MRWxlbWVudF18JyxcbiAgICAnc2NyaXB0XltIVE1MRWxlbWVudF18IWFzeW5jLGNoYXJzZXQsJWNyb3NzT3JpZ2luLCFkZWZlcixldmVudCxodG1sRm9yLGludGVncml0eSxzcmMsdGV4dCx0eXBlJyxcbiAgICAnc2VsZWN0XltIVE1MRWxlbWVudF18IWF1dG9mb2N1cywhZGlzYWJsZWQsI2xlbmd0aCwhbXVsdGlwbGUsbmFtZSwhcmVxdWlyZWQsI3NlbGVjdGVkSW5kZXgsI3NpemUsdmFsdWUnLFxuICAgICdzaGFkb3deW0hUTUxFbGVtZW50XXwnLFxuICAgICdzb3VyY2VeW0hUTUxFbGVtZW50XXxtZWRpYSxzaXplcyxzcmMsc3Jjc2V0LHR5cGUnLFxuICAgICdzcGFuXltIVE1MRWxlbWVudF18JyxcbiAgICAnc3R5bGVeW0hUTUxFbGVtZW50XXwhZGlzYWJsZWQsbWVkaWEsdHlwZScsXG4gICAgJ2NhcHRpb25eW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ3RoLHRkXltIVE1MRWxlbWVudF18YWJicixhbGlnbixheGlzLGJnQ29sb3IsY2gsY2hPZmYsI2NvbFNwYW4saGVhZGVycyxoZWlnaHQsIW5vV3JhcCwjcm93U3BhbixzY29wZSx2QWxpZ24sd2lkdGgnLFxuICAgICdjb2wsY29sZ3JvdXBeW0hUTUxFbGVtZW50XXxhbGlnbixjaCxjaE9mZiwjc3Bhbix2QWxpZ24sd2lkdGgnLFxuICAgICd0YWJsZV5bSFRNTEVsZW1lbnRdfGFsaWduLGJnQ29sb3IsYm9yZGVyLCVjYXB0aW9uLGNlbGxQYWRkaW5nLGNlbGxTcGFjaW5nLGZyYW1lLHJ1bGVzLHN1bW1hcnksJXRGb290LCV0SGVhZCx3aWR0aCcsXG4gICAgJ3RyXltIVE1MRWxlbWVudF18YWxpZ24sYmdDb2xvcixjaCxjaE9mZix2QWxpZ24nLFxuICAgICd0Zm9vdCx0aGVhZCx0Ym9keV5bSFRNTEVsZW1lbnRdfGFsaWduLGNoLGNoT2ZmLHZBbGlnbicsXG4gICAgJ3RlbXBsYXRlXltIVE1MRWxlbWVudF18JyxcbiAgICAndGV4dGFyZWFeW0hUTUxFbGVtZW50XXxhdXRvY2FwaXRhbGl6ZSwhYXV0b2ZvY3VzLCNjb2xzLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwjbWF4TGVuZ3RoLCNtaW5MZW5ndGgsbmFtZSxwbGFjZWhvbGRlciwhcmVhZE9ubHksIXJlcXVpcmVkLCNyb3dzLHNlbGVjdGlvbkRpcmVjdGlvbiwjc2VsZWN0aW9uRW5kLCNzZWxlY3Rpb25TdGFydCx2YWx1ZSx3cmFwJyxcbiAgICAndGl0bGVeW0hUTUxFbGVtZW50XXx0ZXh0JyxcbiAgICAndHJhY2teW0hUTUxFbGVtZW50XXwhZGVmYXVsdCxraW5kLGxhYmVsLHNyYyxzcmNsYW5nJyxcbiAgICAndWxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCx0eXBlJyxcbiAgICAndW5rbm93bl5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3ZpZGVvXm1lZGlhfCNoZWlnaHQscG9zdGVyLCN3aWR0aCcsXG4gICAgJzpzdmc6YV46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6YW5pbWF0ZV46c3ZnOmFuaW1hdGlvbnwnLFxuICAgICc6c3ZnOmFuaW1hdGVNb3Rpb25eOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzphbmltYXRlVHJhbnNmb3JtXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgJzpzdmc6Y2lyY2xlXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpjbGlwUGF0aF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6Y3Vyc29yXjpzdmc6fCcsXG4gICAgJzpzdmc6ZGVmc146c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6ZGVzY146c3ZnOnwnLFxuICAgICc6c3ZnOmRpc2NhcmReOnN2Zzp8JyxcbiAgICAnOnN2ZzplbGxpcHNlXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpmZUJsZW5kXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVDb2xvck1hdHJpeF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29tcG9uZW50VHJhbnNmZXJeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUNvbXBvc2l0ZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29udm9sdmVNYXRyaXheOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURpZmZ1c2VMaWdodGluZ146c3ZnOnwnLFxuICAgICc6c3ZnOmZlRGlzcGxhY2VtZW50TWFwXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVEaXN0YW50TGlnaHReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURyb3BTaGFkb3deOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUZsb29kXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVGdW5jQV46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUZ1bmNCXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICc6c3ZnOmZlRnVuY0deOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJzpzdmc6ZmVGdW5jUl46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUdhdXNzaWFuQmx1cl46c3ZnOnwnLFxuICAgICc6c3ZnOmZlSW1hZ2VeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU1lcmdlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVNZXJnZU5vZGVeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU1vcnBob2xvZ3leOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU9mZnNldF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlUG9pbnRMaWdodF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlU3BlY3VsYXJMaWdodGluZ146c3ZnOnwnLFxuICAgICc6c3ZnOmZlU3BvdExpZ2h0Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVUaWxlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVUdXJidWxlbmNlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmlsdGVyXjpzdmc6fCcsXG4gICAgJzpzdmc6Zm9yZWlnbk9iamVjdF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6Z146c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6aW1hZ2VeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmxpbmVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOmxpbmVhckdyYWRpZW50Xjpzdmc6Z3JhZGllbnR8JyxcbiAgICAnOnN2ZzptcGF0aF46c3ZnOnwnLFxuICAgICc6c3ZnOm1hcmtlcl46c3ZnOnwnLFxuICAgICc6c3ZnOm1hc2teOnN2Zzp8JyxcbiAgICAnOnN2ZzptZXRhZGF0YV46c3ZnOnwnLFxuICAgICc6c3ZnOnBhdGheOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnBhdHRlcm5eOnN2Zzp8JyxcbiAgICAnOnN2Zzpwb2x5Z29uXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2Zzpwb2x5bGluZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6cmFkaWFsR3JhZGllbnReOnN2ZzpncmFkaWVudHwnLFxuICAgICc6c3ZnOnJlY3ReOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnN2Z146c3ZnOmdyYXBoaWNzfCNjdXJyZW50U2NhbGUsI3pvb21BbmRQYW4nLFxuICAgICc6c3ZnOnNjcmlwdF46c3ZnOnx0eXBlJyxcbiAgICAnOnN2ZzpzZXReOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzpzdG9wXjpzdmc6fCcsXG4gICAgJzpzdmc6c3R5bGVeOnN2Zzp8IWRpc2FibGVkLG1lZGlhLHRpdGxlLHR5cGUnLFxuICAgICc6c3ZnOnN3aXRjaF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6c3ltYm9sXjpzdmc6fCcsXG4gICAgJzpzdmc6dHNwYW5eOnN2Zzp0ZXh0UG9zaXRpb25pbmd8JyxcbiAgICAnOnN2Zzp0ZXh0Xjpzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgJzpzdmc6dGV4dFBhdGheOnN2Zzp0ZXh0Q29udGVudHwnLFxuICAgICc6c3ZnOnRpdGxlXjpzdmc6fCcsXG4gICAgJzpzdmc6dXNlXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2Zzp2aWV3Xjpzdmc6fCN6b29tQW5kUGFuJyxcbiAgICAnZGF0YV5bSFRNTEVsZW1lbnRdfHZhbHVlJyxcbiAgICAnbWVudWl0ZW1eW0hUTUxFbGVtZW50XXx0eXBlLGxhYmVsLGljb24sIWRpc2FibGVkLCFjaGVja2VkLHJhZGlvZ3JvdXAsIWRlZmF1bHQnLFxuICAgICdzdW1tYXJ5XltIVE1MRWxlbWVudF18JyxcbiAgICAndGltZV5bSFRNTEVsZW1lbnRdfGRhdGVUaW1lJyxcbl07XG52YXIgX0FUVFJfVE9fUFJPUCA9IHtcbiAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgICAnZm9yJzogJ2h0bWxGb3InLFxuICAgICdmb3JtYWN0aW9uJzogJ2Zvcm1BY3Rpb24nLFxuICAgICdpbm5lckh0bWwnOiAnaW5uZXJIVE1MJyxcbiAgICAncmVhZG9ubHknOiAncmVhZE9ubHknLFxuICAgICd0YWJpbmRleCc6ICd0YWJJbmRleCcsXG59O1xudmFyIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9zY2hlbWEgPSB7fTtcbiAgICAgICAgU0NIRU1BLmZvckVhY2goZnVuY3Rpb24gKGVuY29kZWRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHt9O1xuICAgICAgICAgICAgdmFyIF9hID0gZW5jb2RlZFR5cGUuc3BsaXQoJ3wnKSwgc3RyVHlwZSA9IF9hWzBdLCBzdHJQcm9wZXJ0aWVzID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHN0clByb3BlcnRpZXMuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciBfYiA9IHN0clR5cGUuc3BsaXQoJ14nKSwgdHlwZU5hbWVzID0gX2JbMF0sIHN1cGVyTmFtZSA9IF9iWzFdO1xuICAgICAgICAgICAgdHlwZU5hbWVzLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7IHJldHVybiBfdGhpcy5fc2NoZW1hW3RhZy50b0xvd2VyQ2FzZSgpXSA9IHR5cGU7IH0pO1xuICAgICAgICAgICAgdmFyIHN1cGVyVHlwZSA9IHN1cGVyTmFtZSAmJiBfdGhpcy5fc2NoZW1hW3N1cGVyTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmIChzdXBlclR5cGUpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdXBlclR5cGUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgdHlwZVtwcm9wXSA9IHN1cGVyVHlwZVtwcm9wXTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwcm9wZXJ0eVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgeWV0IHN1cHBvcnQgZXZlbnRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGV2ZXIgYWxsb3dpbmcgdG8gYmluZCB0byBldmVudHMsIEdPIFRIUk9VR0ggQSBTRUNVUklUWSBSRVZJRVcsIGFsbG93aW5nIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbG1vc3QgY2VydGFpbmx5IGludHJvZHVjZSBiYWQgWFNTIHZ1bG5lcmFiaWxpdGllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBFVkVOVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHkuc3Vic3RyaW5nKDEpXSA9IEJPT0xFQU47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBOVU1CRVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBPQkpFQ1Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcGVydHldID0gU1RSSU5HO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFnTmFtZVxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcGFyYW0gez99IHNjaGVtYU1ldGFzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmhhc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BOYW1lLCBzY2hlbWFNZXRhcykge1xuICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gTk9fRVJST1JTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnbmctY29udGFpbmVyJyB8fCB0YWdOYW1lID09PSAnbmctY29udGVudCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgIC8vIENhbid0IHRlbGwgbm93IGFzIHdlIGRvbid0IGtub3cgd2hpY2ggcHJvcGVydGllcyBhIGN1c3RvbSBlbGVtZW50IHdpbGwgZ2V0XG4gICAgICAgICAgICAgICAgLy8gb25jZSBpdCBpcyBpbnN0YW50aWF0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50UHJvcGVydGllcyA9IHRoaXMuX3NjaGVtYVt0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IHRoaXMuX3NjaGVtYVsndW5rbm93biddO1xuICAgICAgICByZXR1cm4gISFlbGVtZW50UHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRhZ05hbWVcbiAgICAgKiBAcGFyYW0gez99IHNjaGVtYU1ldGFzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmhhc0VsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSwgc2NoZW1hTWV0YXMpIHtcbiAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoZnVuY3Rpb24gKHNjaGVtYSkgeyByZXR1cm4gc2NoZW1hLm5hbWUgPT09IE5PX0VSUk9SU19TQ0hFTUEubmFtZTsgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ25nLWNvbnRhaW5lcicgfHwgdGFnTmFtZSA9PT0gJ25nLWNvbnRlbnQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZShmdW5jdGlvbiAoc2NoZW1hKSB7IHJldHVybiBzY2hlbWEubmFtZSA9PT0gQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQS5uYW1lOyB9KSkge1xuICAgICAgICAgICAgICAgIC8vIEFsbG93IGFueSBjdXN0b20gZWxlbWVudHNcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISF0aGlzLl9zY2hlbWFbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNlY3VyaXR5Q29udGV4dCByZXR1cm5zIHRoZSBzZWN1cml0eSBjb250ZXh0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgb24gdGhlIGdpdmVuIERPTSB0YWcuXG4gICAgICpcbiAgICAgKiBUYWcgYW5kIHByb3BlcnR5IG5hbWUgYXJlIHN0YXRpY2FsbHkga25vd24gYW5kIGNhbm5vdCBjaGFuZ2UgYXQgcnVudGltZSwgaS5lLiBpdCBpcyBub3RcbiAgICAgKiBwb3NzaWJsZSB0byBiaW5kIGEgdmFsdWUgaW50byBhIGNoYW5naW5nIGF0dHJpYnV0ZSBvciB0YWcgbmFtZS5cbiAgICAgKlxuICAgICAqIFRoZSBmaWx0ZXJpbmcgaXMgd2hpdGUgbGlzdCBiYXNlZC4gQWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHNjaGVtYSBhYm92ZSBhcmUgYXNzdW1lZCB0byBoYXZlIHRoZVxuICAgICAqICdOT05FJyBzZWN1cml0eSBjb250ZXh0LCBpLmUuIHRoYXQgdGhleSBhcmUgc2FmZSBpbmVydCBzdHJpbmcgdmFsdWVzLiBPbmx5IHNwZWNpZmljIHdlbGwga25vd25cbiAgICAgKiBhdHRhY2sgdmVjdG9ycyBhcmUgYXNzaWduZWQgdGhlaXIgYXBwcm9wcmlhdGUgY29udGV4dC5cbiAgICAgKiBAcGFyYW0gez99IHRhZ05hbWVcbiAgICAgKiBAcGFyYW0gez99IHByb3BOYW1lXG4gICAgICogQHBhcmFtIHs/fSBpc0F0dHJpYnV0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5zZWN1cml0eUNvbnRleHQgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSB7XG4gICAgICAgIGlmIChpc0F0dHJpYnV0ZSkge1xuICAgICAgICAgICAgLy8gTkI6IEZvciBzZWN1cml0eSBwdXJwb3NlcywgdXNlIHRoZSBtYXBwZWQgcHJvcGVydHkgbmFtZSwgbm90IHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICAgICAgICAgIHByb3BOYW1lID0gdGhpcy5nZXRNYXBwZWRQcm9wTmFtZShwcm9wTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIGNvbXBhcmlzb25zIGFyZSBjYXNlIGluc2Vuc2l0aXZlLCBzbyB0aGF0IGNhc2UgZGlmZmVyZW5jZXMgYmV0d2VlbiBhdHRyaWJ1dGUgYW5kXG4gICAgICAgIC8vIHByb3BlcnR5IG5hbWVzIGRvIG5vdCBoYXZlIGEgc2VjdXJpdHkgaW1wYWN0LlxuICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBwcm9wTmFtZSA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eCA9IFNFQ1VSSVRZX1NDSEVNQVt0YWdOYW1lICsgJ3wnICsgcHJvcE5hbWVdO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgICB9XG4gICAgICAgIGN0eCA9IFNFQ1VSSVRZX1NDSEVNQVsnKnwnICsgcHJvcE5hbWVdO1xuICAgICAgICByZXR1cm4gY3R4ID8gY3R4IDogU2VjdXJpdHlDb250ZXh0Lk5PTkU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3BOYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLmdldE1hcHBlZFByb3BOYW1lID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7IHJldHVybiBfQVRUUl9UT19QUk9QW3Byb3BOYW1lXSB8fCBwcm9wTmFtZTsgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuZ2V0RGVmYXVsdENvbXBvbmVudEVsZW1lbnROYW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ25nLWNvbXBvbmVudCc7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnZhbGlkYXRlUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ29uJykpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1zZyA9IFwiQmluZGluZyB0byBldmVudCBwcm9wZXJ0eSAnXCIgKyBuYW1lICsgXCInIGlzIGRpc2FsbG93ZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJwbGVhc2UgdXNlIChcIiArIG5hbWUuc2xpY2UoMikgKyBcIik9Li4uXCIpICtcbiAgICAgICAgICAgICAgICAoXCJcXG5JZiAnXCIgKyBuYW1lICsgXCInIGlzIGEgZGlyZWN0aXZlIGlucHV0LCBtYWtlIHN1cmUgdGhlIGRpcmVjdGl2ZSBpcyBpbXBvcnRlZCBieSB0aGVcIikgK1xuICAgICAgICAgICAgICAgIFwiIGN1cnJlbnQgbW9kdWxlLlwiO1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIG1zZzogbXNnIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkucHJvdG90eXBlLnZhbGlkYXRlQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdvbicpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtc2cgPSBcIkJpbmRpbmcgdG8gZXZlbnQgYXR0cmlidXRlICdcIiArIG5hbWUgKyBcIicgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgXCIgK1xuICAgICAgICAgICAgICAgIChcInBsZWFzZSB1c2UgKFwiICsgbmFtZS5zbGljZSgyKSArIFwiKT0uLi5cIik7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgbXNnOiBtc2cgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUuYWxsS25vd25FbGVtZW50TmFtZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zY2hlbWEpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvcE5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5wcm90b3R5cGUubm9ybWFsaXplQW5pbWF0aW9uU3R5bGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICByZXR1cm4gZGFzaENhc2VUb0NhbWVsQ2FzZShwcm9wTmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNhbWVsQ2FzZVByb3BcbiAgICAgKiBAcGFyYW0gez99IHVzZXJQcm92aWRlZFByb3BcbiAgICAgKiBAcGFyYW0gez99IHZhbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnByb3RvdHlwZS5ub3JtYWxpemVBbmltYXRpb25TdHlsZVZhbHVlID0gZnVuY3Rpb24gKGNhbWVsQ2FzZVByb3AsIHVzZXJQcm92aWRlZFByb3AsIHZhbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1bml0ID0gJyc7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0clZhbCA9IHZhbC50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JNc2cgPSBudWxsO1xuICAgICAgICBpZiAoX2lzUGl4ZWxEaW1lbnNpb25TdHlsZShjYW1lbENhc2VQcm9wKSAmJiB2YWwgIT09IDAgJiYgdmFsICE9PSAnMCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsQW5kU3VmZml4TWF0Y2ggPSB2YWwubWF0Y2goL15bKy1dP1tcXGRcXC5dKyhbYS16XSopJC8pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxBbmRTdWZmaXhNYXRjaCAmJiB2YWxBbmRTdWZmaXhNYXRjaFsxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1zZyA9IFwiUGxlYXNlIHByb3ZpZGUgYSBDU1MgdW5pdCB2YWx1ZSBmb3IgXCIgKyB1c2VyUHJvdmlkZWRQcm9wICsgXCI6XCIgKyB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGVycm9yOiBlcnJvck1zZywgdmFsdWU6IHN0clZhbCArIHVuaXQgfTtcbiAgICB9O1xuICAgIHJldHVybiBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnk7XG59KEVsZW1lbnRTY2hlbWFSZWdpc3RyeSkpO1xuRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgeyB0eXBlOiBDb21waWxlckluamVjdGFibGUgfSxcbl07XG4vKipcbiAqIEBub2NvbGxhcHNlXG4gKi9cbkRvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IHByb3BcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9pc1BpeGVsRGltZW5zaW9uU3R5bGUocHJvcCkge1xuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgIGNhc2UgJ21pbldpZHRoJzpcbiAgICAgICAgY2FzZSAnbWluSGVpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWF4V2lkdGgnOlxuICAgICAgICBjYXNlICdtYXhIZWlnaHQnOlxuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBjYXNlICdmb250U2l6ZSc6XG4gICAgICAgIGNhc2UgJ291dGxpbmVXaWR0aCc6XG4gICAgICAgIGNhc2UgJ291dGxpbmVPZmZzZXQnOlxuICAgICAgICBjYXNlICdwYWRkaW5nVG9wJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ0xlZnQnOlxuICAgICAgICBjYXNlICdwYWRkaW5nQm90dG9tJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ1JpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWFyZ2luVG9wJzpcbiAgICAgICAgY2FzZSAnbWFyZ2luTGVmdCc6XG4gICAgICAgIGNhc2UgJ21hcmdpbkJvdHRvbSc6XG4gICAgICAgIGNhc2UgJ21hcmdpblJpZ2h0JzpcbiAgICAgICAgY2FzZSAnYm9yZGVyUmFkaXVzJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyV2lkdGgnOlxuICAgICAgICBjYXNlICdib3JkZXJUb3BXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlckxlZnRXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlclJpZ2h0V2lkdGgnOlxuICAgICAgICBjYXNlICdib3JkZXJCb3R0b21XaWR0aCc6XG4gICAgICAgIGNhc2UgJ3RleHRJbmRlbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxudmFyIFNoYWRvd0NzcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2hhZG93Q3NzKCkge1xuICAgICAgICB0aGlzLnN0cmljdFN0eWxpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1RleHRcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/PX0gaG9zdFNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLnNoaW1Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGhvc3RTZWxlY3RvciA9PT0gdm9pZCAwKSB7IGhvc3RTZWxlY3RvciA9ICcnOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZU1hcHBpbmdVcmwgPSBleHRyYWN0U291cmNlTWFwcGluZ1VybChjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHN0cmlwQ29tbWVudHMoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnREaXJlY3RpdmVzKGNzc1RleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGVDc3NUZXh0KGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpICsgc291cmNlTWFwcGluZ1VybDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5faW5zZXJ0RGlyZWN0aXZlcyA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1bMl0gKyAneyc7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSB3aXRoIHdlYmNvbXBvbmVudHMuanM6IGRvZXMgbm90IGhhbmRsZSBjb21tZW50c1xuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb250ZW50UnVsZVJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBtW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBydWxlID0gbVswXS5yZXBsYWNlKG1bMV0sICcnKS5yZXBsYWNlKG1bMl0sICcnKTtcbiAgICAgICAgICAgIHJldHVybiBtWzRdICsgcnVsZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1RleHRcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVDc3NUZXh0ID0gZnVuY3Rpb24gKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1bnNjb3BlZFJ1bGVzID0gdGhpcy5fZXh0cmFjdFVuc2NvcGVkUnVsZXNGcm9tQ3NzVGV4dChjc3NUZXh0KTtcbiAgICAgICAgLy8gcmVwbGFjZSA6aG9zdCBhbmQgOmhvc3QtY29udGV4dCAtc2hhZG93Y3NzaG9zdCBhbmQgLXNoYWRvd2Nzc2hvc3QgcmVzcGVjdGl2ZWx5XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0Q29sb25Ib3N0KGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gdGhpcy5fY29udmVydENvbG9uSG9zdENvbnRleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzKGNzc1RleHQpO1xuICAgICAgICBpZiAoc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX3Njb3BlU2VsZWN0b3JzKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQgKyAnXFxuJyArIHVuc2NvcGVkUnVsZXM7XG4gICAgICAgIHJldHVybiBjc3NUZXh0LnRyaW0oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fZXh0cmFjdFVuc2NvcGVkUnVsZXNGcm9tQ3NzVGV4dCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gciA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtO1xuICAgICAgICBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlICgobSA9IF9jc3NDb250ZW50VW5zY29wZWRSdWxlUmUuZXhlYyhjc3NUZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJ1bGUgPSBtWzBdLnJlcGxhY2UobVsyXSwgJycpLnJlcGxhY2UobVsxXSwgbVs0XSk7XG4gICAgICAgICAgICByICs9IHJ1bGUgKyAnXFxuXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uSG9zdCA9IGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0Q29sb25SdWxlKGNzc1RleHQsIF9jc3NDb2xvbkhvc3RSZSwgdGhpcy5fY29sb25Ib3N0UGFydFJlcGxhY2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fY29udmVydENvbG9uSG9zdENvbnRleHQgPSBmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydENvbG9uUnVsZShjc3NUZXh0LCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlLCB0aGlzLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY3NzVGV4dFxuICAgICAqIEBwYXJhbSB7P30gcmVnRXhwXG4gICAgICogQHBhcmFtIHs/fSBwYXJ0UmVwbGFjZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbnZlcnRDb2xvblJ1bGUgPSBmdW5jdGlvbiAoY3NzVGV4dCwgcmVnRXhwLCBwYXJ0UmVwbGFjZXIpIHtcbiAgICAgICAgLy8gbVsxXSA9IDpob3N0KC1jb250ZXh0KSwgbVsyXSA9IGNvbnRlbnRzIG9mICgpLCBtWzNdIHJlc3Qgb2YgcnVsZVxuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKHJlZ0V4cCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1bMl0pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJ0cyA9IG1bMl0uc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHAgPSBwYXJ0c1tpXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICByLnB1c2gocGFydFJlcGxhY2VyKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IsIHAsIG1bM10pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IgKyBtWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7P30gcGFydFxuICAgICAqIEBwYXJhbSB7P30gc3VmZml4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb2xvbkhvc3RDb250ZXh0UGFydFJlcGxhY2VyID0gZnVuY3Rpb24gKGhvc3QsIHBhcnQsIHN1ZmZpeCkge1xuICAgICAgICBpZiAocGFydC5pbmRleE9mKF9wb2x5ZmlsbEhvc3QpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvbkhvc3RQYXJ0UmVwbGFjZXIoaG9zdCwgcGFydCwgc3VmZml4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBob3N0ICsgcGFydCArIHN1ZmZpeCArICcsICcgKyBwYXJ0ICsgJyAnICsgaG9zdCArIHN1ZmZpeDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBob3N0XG4gICAgICogQHBhcmFtIHs/fSBwYXJ0XG4gICAgICogQHBhcmFtIHs/fSBzdWZmaXhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2NvbG9uSG9zdFBhcnRSZXBsYWNlciA9IGZ1bmN0aW9uIChob3N0LCBwYXJ0LCBzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIGhvc3QgKyBwYXJ0LnJlcGxhY2UoX3BvbHlmaWxsSG9zdCwgJycpICsgc3VmZml4O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjc3NUZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzID0gZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgICAgICAgcmV0dXJuIF9zaGFkb3dET01TZWxlY3RvcnNSZS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgcGF0dGVybikgeyByZXR1cm4gcmVzdWx0LnJlcGxhY2UocGF0dGVybiwgJyAnKTsgfSwgY3NzVGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNzc1RleHRcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVTZWxlY3RvcnMgPSBmdW5jdGlvbiAoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUnVsZXMoY3NzVGV4dCwgZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdG9yID0gcnVsZS5zZWxlY3RvcjtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnRlbnQgPSBydWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAocnVsZS5zZWxlY3RvclswXSAhPSAnQCcpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY29wZVNlbGVjdG9yKHJ1bGUuc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3RvciwgX3RoaXMuc3RyaWN0U3R5bGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BtZWRpYScpIHx8IHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQHN1cHBvcnRzJykgfHxcbiAgICAgICAgICAgICAgICBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BwYWdlJykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAZG9jdW1lbnQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBfdGhpcy5fc2NvcGVTZWxlY3RvcnMocnVsZS5jb250ZW50LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBzY29wZVNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBob3N0U2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IHN0cmljdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fc2NvcGVTZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnNwbGl0KCcsJylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIHBhcnQudHJpbSgpLnNwbGl0KF9zaGFkb3dEZWVwU2VsZWN0b3JzKTsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRlZXBQYXJ0cykge1xuICAgICAgICAgICAgdmFyIHNoYWxsb3dQYXJ0ID0gZGVlcFBhcnRzWzBdLCBvdGhlclBhcnRzID0gZGVlcFBhcnRzLnNsaWNlKDEpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXBwbHlTY29wZSA9IGZ1bmN0aW9uIChzaGFsbG93UGFydCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc2VsZWN0b3JOZWVkc1Njb3Bpbmcoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpY3QgP1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGx5U3RyaWN0U2VsZWN0b3JTY29wZShzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlTZWxlY3RvclNjb3BlKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3dQYXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gW2FwcGx5U2NvcGUoc2hhbGxvd1BhcnQpXS5jb25jYXQob3RoZXJQYXJ0cykuam9pbignICcpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBzY29wZVNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9zZWxlY3Rvck5lZWRzU2NvcGluZyA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZSA9IHRoaXMuX21ha2VTY29wZU1hdGNoZXIoc2NvcGVTZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiAhcmUudGVzdChzZWxlY3Rvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX21ha2VTY29wZU1hdGNoZXIgPSBmdW5jdGlvbiAoc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBscmUgPSAvXFxbL2c7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJyZSA9IC9cXF0vZztcbiAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShscmUsICdcXFxcWycpLnJlcGxhY2UocnJlLCAnXFxcXF0nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14oJyArIHNjb3BlU2VsZWN0b3IgKyAnKScgKyBfc2VsZWN0b3JSZVN1ZmZpeCwgJ20nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fYXBwbHlTZWxlY3RvclNjb3BlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSBmcm9tIHdlYmNvbXBvbmVudHMuanM6IHNjb3BlU2VsZWN0b3IgY291bGQgbm90IGJlIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBzY29wZVNlbGVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBob3N0U2VsZWN0b3JcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNoYWRvd0Nzcy5wcm90b3R5cGUuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIC8vIEluIEFuZHJvaWQgYnJvd3NlciwgdGhlIGxhc3RJbmRleCBpcyBub3QgcmVzZXQgd2hlbiB0aGUgcmVnZXggaXMgdXNlZCBpbiBTdHJpbmcucmVwbGFjZSgpXG4gICAgICAgIF9wb2x5ZmlsbEhvc3RSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAoX3BvbHlmaWxsSG9zdFJlLnRlc3Qoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXBsYWNlQnlfMSA9IHRoaXMuc3RyaWN0U3R5bGluZyA/IFwiW1wiICsgaG9zdFNlbGVjdG9yICsgXCJdXCIgOiBzY29wZVNlbGVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvclJlLCBmdW5jdGlvbiAoaG5jLCBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKC8oW146XSopKDoqKSguKikvLCBmdW5jdGlvbiAoXywgYmVmb3JlLCBjb2xvbiwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZSArIHJlcGxhY2VCeV8xICsgY29sb24gKyBhZnRlcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoX3BvbHlmaWxsSG9zdFJlLCByZXBsYWNlQnlfMSArICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlU2VsZWN0b3IgKyAnICcgKyBzZWxlY3RvcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IHNjb3BlU2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gez99IGhvc3RTZWxlY3RvclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2hhZG93Q3NzLnByb3RvdHlwZS5fYXBwbHlTdHJpY3RTZWxlY3RvclNjb3BlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNSZSA9IC9cXFtpcz0oW15cXF1dKilcXF0vZztcbiAgICAgICAgc2NvcGVTZWxlY3RvciA9IHNjb3BlU2VsZWN0b3IucmVwbGFjZShpc1JlLCBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHBhcnRzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXR0ck5hbWUgPSAnWycgKyBzY29wZVNlbGVjdG9yICsgJ10nO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBfc2NvcGVTZWxlY3RvclBhcnQgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NvcGVkUCA9IHAudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFzY29wZWRQKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVkUCA9IF90aGlzLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUocCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSA6aG9zdCBzaW5jZSBpdCBzaG91bGQgYmUgdW5uZWNlc3NhcnlcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ID0gcC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3RSZSwgJycpO1xuICAgICAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlcyA9IHQubWF0Y2goLyhbXjpdKikoOiopKC4qKS8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVkUCA9IG1hdGNoZXNbMV0gKyBhdHRyTmFtZSArIG1hdGNoZXNbMl0gKyBtYXRjaGVzWzNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNjb3BlZFA7XG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNhZmVDb250ZW50ID0gbmV3IFNhZmVTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIHNlbGVjdG9yID0gc2FmZUNvbnRlbnQuY29udGVudCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY29wZWRTZWxlY3RvciA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXAgPSAvKCB8PnxcXCt8fig/IT0pKVxccyovZztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2NvcGVBZnRlciA9IHNlbGVjdG9yLmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcik7XG4gICAgICAgIHdoaWxlICgocmVzID0gc2VwLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VwYXJhdG9yID0gcmVzWzFdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydCA9IHNlbGVjdG9yLnNsaWNlKHN0YXJ0SW5kZXgsIHJlcy5pbmRleCkudHJpbSgpO1xuICAgICAgICAgICAgLy8gaWYgYSBzZWxlY3RvciBhcHBlYXJzIGJlZm9yZSA6aG9zdC1jb250ZXh0IGl0IHNob3VsZCBub3QgYmUgc2hpbW1lZCBhcyBpdFxuICAgICAgICAgICAgLy8gbWF0Y2hlcyBvbiBhbmNlc3RvciBlbGVtZW50cyBhbmQgbm90IG9uIGVsZW1lbnRzIGluIHRoZSBob3N0J3Mgc2hhZG93XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY29wZWRQYXJ0ID0gc3RhcnRJbmRleCA+PSBzY29wZUFmdGVyID8gX3Njb3BlU2VsZWN0b3JQYXJ0KHBhcnQpIDogcGFydDtcbiAgICAgICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IHNjb3BlZFBhcnQgKyBcIiBcIiArIHNlcGFyYXRvciArIFwiIFwiO1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IHNlcC5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgc2NvcGVkU2VsZWN0b3IgKz0gX3Njb3BlU2VsZWN0b3JQYXJ0KHNlbGVjdG9yLnN1YnN0cmluZyhzdGFydEluZGV4KSk7XG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVycyB3aXRoIHRoZWlyIG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICByZXR1cm4gc2FmZUNvbnRlbnQucmVzdG9yZShzY29wZWRTZWxlY3Rvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTaGFkb3dDc3MucHJvdG90eXBlLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoX2NvbG9uSG9zdENvbnRleHRSZSwgX3BvbHlmaWxsSG9zdENvbnRleHQpXG4gICAgICAgICAgICAucmVwbGFjZShfY29sb25Ib3N0UmUsIF9wb2x5ZmlsbEhvc3QpO1xuICAgIH07XG4gICAgcmV0dXJuIFNoYWRvd0Nzcztcbn0oKSk7XG52YXIgU2FmZVNlbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNlbGVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2FmZVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBSZXBsYWNlcyBhdHRyaWJ1dGUgc2VsZWN0b3JzIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAgICAvLyBUaGUgV1MgaW4gW2F0dHI9XCJ2YSBsdWVcIl0gd291bGQgb3RoZXJ3aXNlIGJlIGludGVycHJldGVkIGFzIGEgc2VsZWN0b3Igc2VwYXJhdG9yLlxuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoLyhcXFtbXlxcXV0qXFxdKS9nLCBmdW5jdGlvbiAoXywga2VlcCkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IFwiX19waC1cIiArIF90aGlzLmluZGV4ICsgXCJfX1wiO1xuICAgICAgICAgICAgX3RoaXMucGxhY2Vob2xkZXJzLnB1c2goa2VlcCk7XG4gICAgICAgICAgICBfdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VCeTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlcGxhY2VzIHRoZSBleHByZXNzaW9uIGluIGA6bnRoLWNoaWxkKDJuICsgMSlgIHdpdGggYSBwbGFjZWhvbGRlci5cbiAgICAgICAgLy8gV1MgYW5kIFwiK1wiIHdvdWxkIG90aGVyd2lzZSBiZSBpbnRlcnByZXRlZCBhcyBzZWxlY3RvciBzZXBhcmF0b3JzLlxuICAgICAgICB0aGlzLl9jb250ZW50ID0gc2VsZWN0b3IucmVwbGFjZSgvKDpudGgtWy1cXHddKykoXFwoW14pXStcXCkpL2csIGZ1bmN0aW9uIChfLCBwc2V1ZG8sIGV4cCkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VCeSA9IFwiX19waC1cIiArIF90aGlzLmluZGV4ICsgXCJfX1wiO1xuICAgICAgICAgICAgX3RoaXMucGxhY2Vob2xkZXJzLnB1c2goZXhwKTtcbiAgICAgICAgICAgIF90aGlzLmluZGV4Kys7XG4gICAgICAgICAgICByZXR1cm4gcHNldWRvICsgcmVwbGFjZUJ5O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU2FmZVNlbGVjdG9yLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvX19waC0oXFxkKylfXy9nLCBmdW5jdGlvbiAocGgsIGluZGV4KSB7IHJldHVybiBfdGhpcy5wbGFjZWhvbGRlcnNbK2luZGV4XTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNhZmVTZWxlY3Rvci5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7IH07XG4gICAgcmV0dXJuIFNhZmVTZWxlY3Rvcjtcbn0oKSk7XG52YXIgX2Nzc0NvbnRlbnROZXh0U2VsZWN0b3JSZSA9IC9wb2x5ZmlsbC1uZXh0LXNlbGVjdG9yW159XSpjb250ZW50OltcXHNdKj8oWydcIl0pKC4qPylcXDFbO1xcc10qfShbXntdKj8pey9naW07XG52YXIgX2Nzc0NvbnRlbnRSdWxlUmUgPSAvKHBvbHlmaWxsLXJ1bGUpW159XSooY29udGVudDpbXFxzXSooWydcIl0pKC4qPylcXDMpWztcXHNdKltefV0qfS9naW07XG52YXIgX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZSA9IC8ocG9seWZpbGwtdW5zY29wZWQtcnVsZSlbXn1dKihjb250ZW50OltcXHNdKihbJ1wiXSkoLio/KVxcMylbO1xcc10qW159XSp9L2dpbTtcbnZhciBfcG9seWZpbGxIb3N0ID0gJy1zaGFkb3djc3Nob3N0Jztcbi8vIG5vdGU6IDpob3N0LWNvbnRleHQgcHJlLXByb2Nlc3NlZCB0byAtc2hhZG93Y3NzaG9zdGNvbnRleHQuXG52YXIgX3BvbHlmaWxsSG9zdENvbnRleHQgPSAnLXNoYWRvd2Nzc2NvbnRleHQnO1xudmFyIF9wYXJlblN1ZmZpeCA9ICcpKD86XFxcXCgoJyArXG4gICAgJyg/OlxcXFwoW14pKF0qXFxcXCl8W14pKF0qKSs/JyArXG4gICAgJylcXFxcKSk/KFteLHtdKiknO1xudmFyIF9jc3NDb2xvbkhvc3RSZSA9IG5ldyBSZWdFeHAoJygnICsgX3BvbHlmaWxsSG9zdCArIF9wYXJlblN1ZmZpeCwgJ2dpbScpO1xudmFyIF9jc3NDb2xvbkhvc3RDb250ZXh0UmUgPSBuZXcgUmVnRXhwKCcoJyArIF9wb2x5ZmlsbEhvc3RDb250ZXh0ICsgX3BhcmVuU3VmZml4LCAnZ2ltJyk7XG52YXIgX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciA9IF9wb2x5ZmlsbEhvc3QgKyAnLW5vLWNvbWJpbmF0b3InO1xudmFyIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3JSZSA9IC8tc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yKFteXFxzXSopLztcbnZhciBfc2hhZG93RE9NU2VsZWN0b3JzUmUgPSBbXG4gICAgLzo6c2hhZG93L2csXG4gICAgLzo6Y29udGVudC9nLFxuICAgIC8vIERlcHJlY2F0ZWQgc2VsZWN0b3JzXG4gICAgL1xcL3NoYWRvdy1kZWVwXFwvL2csXG4gICAgL1xcL3NoYWRvd1xcLy9nLFxuXTtcbnZhciBfc2hhZG93RGVlcFNlbGVjdG9ycyA9IC8oPzo+Pj4pfCg/OlxcL2RlZXBcXC8pL2c7XG52YXIgX3NlbGVjdG9yUmVTdWZmaXggPSAnKFs+XFxcXHN+K1xcWy4sezpdW1xcXFxzXFxcXFNdKik/JCc7XG52YXIgX3BvbHlmaWxsSG9zdFJlID0gLy1zaGFkb3djc3Nob3N0L2dpbTtcbnZhciBfY29sb25Ib3N0UmUgPSAvOmhvc3QvZ2ltO1xudmFyIF9jb2xvbkhvc3RDb250ZXh0UmUgPSAvOmhvc3QtY29udGV4dC9naW07XG52YXIgX2NvbW1lbnRSZSA9IC9cXC9cXCpcXHMqW1xcc1xcU10qP1xcKlxcLy9nO1xuLyoqXG4gKiBAcGFyYW0gez99IGlucHV0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzdHJpcENvbW1lbnRzKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoX2NvbW1lbnRSZSwgJycpO1xufVxuLy8gYWxsIGNvbW1lbnRzIGV4Y2VwdCBpbmxpbmUgc291cmNlIG1hcHBpbmdcbnZhciBfc291cmNlTWFwcGluZ1VybFJlID0gL1xcL1xcKlxccyojXFxzKnNvdXJjZU1hcHBpbmdVUkw9W1xcc1xcU10rP1xcKlxcLy87XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RTb3VyY2VNYXBwaW5nVXJsKGlucHV0KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWF0Y2hlciA9IGlucHV0Lm1hdGNoKF9zb3VyY2VNYXBwaW5nVXJsUmUpO1xuICAgIHJldHVybiBtYXRjaGVyID8gbWF0Y2hlclswXSA6ICcnO1xufVxudmFyIF9ydWxlUmUgPSAvKFxccyopKFteO1xce1xcfV0rPykoXFxzKikoKD86eyVCTE9DSyV9P1xccyo7Pyl8KD86XFxzKjspKS9nO1xudmFyIF9jdXJseVJlID0gLyhbe31dKS9nO1xudmFyIE9QRU5fQ1VSTFkgPSAneyc7XG52YXIgQ0xPU0VfQ1VSTFkgPSAnfSc7XG52YXIgQkxPQ0tfUExBQ0VIT0xERVIgPSAnJUJMT0NLJSc7XG52YXIgQ3NzUnVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZWxlY3RvclxuICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gQ3NzUnVsZTtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gcnVsZUNhbGxiYWNrXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwcm9jZXNzUnVsZXMoaW5wdXQsIHJ1bGVDYWxsYmFjaykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlucHV0V2l0aEVzY2FwZWRCbG9ja3MgPSBlc2NhcGVCbG9ja3MoaW5wdXQpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5leHRCbG9ja0luZGV4ID0gMDtcbiAgICByZXR1cm4gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5lc2NhcGVkU3RyaW5nLnJlcGxhY2UoX3J1bGVSZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGVjdG9yID0gbVsyXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udGVudCA9ICcnO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdWZmaXggPSBtWzRdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb250ZW50UHJlZml4ID0gJyc7XG4gICAgICAgIGlmIChzdWZmaXggJiYgc3VmZml4LnN0YXJ0c1dpdGgoJ3snICsgQkxPQ0tfUExBQ0VIT0xERVIpKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5ibG9ja3NbbmV4dEJsb2NrSW5kZXgrK107XG4gICAgICAgICAgICBzdWZmaXggPSBzdWZmaXguc3Vic3RyaW5nKEJMT0NLX1BMQUNFSE9MREVSLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgY29udGVudFByZWZpeCA9ICd7JztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBydWxlID0gcnVsZUNhbGxiYWNrKG5ldyBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KSk7XG4gICAgICAgIHJldHVybiBcIlwiICsgbVsxXSArIHJ1bGUuc2VsZWN0b3IgKyBtWzNdICsgY29udGVudFByZWZpeCArIHJ1bGUuY29udGVudCArIHN1ZmZpeDtcbiAgICB9KTtcbn1cbnZhciBTdHJpbmdXaXRoRXNjYXBlZEJsb2NrcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlc2NhcGVkU3RyaW5nXG4gICAgICogQHBhcmFtIHs/fSBibG9ja3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdHJpbmdXaXRoRXNjYXBlZEJsb2Nrcyhlc2NhcGVkU3RyaW5nLCBibG9ja3MpIHtcbiAgICAgICAgdGhpcy5lc2NhcGVkU3RyaW5nID0gZXNjYXBlZFN0cmluZztcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmdXaXRoRXNjYXBlZEJsb2Nrcztcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUJsb2NrcyhpbnB1dCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlucHV0UGFydHMgPSBpbnB1dC5zcGxpdChfY3VybHlSZSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0UGFydHMgPSBbXTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlc2NhcGVkQmxvY2tzID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYnJhY2tldENvdW50ID0gMDtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50QmxvY2tQYXJ0cyA9IFtdO1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gcGFydEluZGV4ID0gMDsgcGFydEluZGV4IDwgaW5wdXRQYXJ0cy5sZW5ndGg7IHBhcnRJbmRleCsrKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcnQgPSBpbnB1dFBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgIGlmIChwYXJ0ID09IENMT1NFX0NVUkxZKSB7XG4gICAgICAgICAgICBicmFja2V0Q291bnQtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJhY2tldENvdW50ID4gMCkge1xuICAgICAgICAgICAgY3VycmVudEJsb2NrUGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9ja1BhcnRzLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50QmxvY2tQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0UGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydCA9PSBPUEVOX0NVUkxZKSB7XG4gICAgICAgICAgICBicmFja2V0Q291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudEJsb2NrUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBlc2NhcGVkQmxvY2tzLnB1c2goY3VycmVudEJsb2NrUGFydHMuam9pbignJykpO1xuICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdXaXRoRXNjYXBlZEJsb2NrcyhyZXN1bHRQYXJ0cy5qb2luKCcnKSwgZXNjYXBlZEJsb2Nrcyk7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQ09NUE9ORU5UX1ZBUklBQkxFID0gJyVDT01QJSc7XG52YXIgSE9TVF9BVFRSID0gXCJfbmdob3N0LVwiICsgQ09NUE9ORU5UX1ZBUklBQkxFO1xudmFyIENPTlRFTlRfQVRUUiA9IFwiX25nY29udGVudC1cIiArIENPTVBPTkVOVF9WQVJJQUJMRTtcbnZhciBTdHlsZXNDb21waWxlRGVwZW5kZW5jeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVVcmxcbiAgICAgKiBAcGFyYW0gez99IGlzU2hpbW1lZFxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVQbGFjZWhvbGRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5KG5hbWUsIG1vZHVsZVVybCwgaXNTaGltbWVkLCB2YWx1ZVBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubW9kdWxlVXJsID0gbW9kdWxlVXJsO1xuICAgICAgICB0aGlzLmlzU2hpbW1lZCA9IGlzU2hpbW1lZDtcbiAgICAgICAgdGhpcy52YWx1ZVBsYWNlaG9sZGVyID0gdmFsdWVQbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgcmV0dXJuIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5O1xufSgpKTtcbnZhciBTdHlsZXNDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFN0eWxlc2hlZXRcbiAgICAgKiBAcGFyYW0gez99IGV4dGVybmFsU3R5bGVzaGVldHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdHlsZXNDb21waWxlUmVzdWx0KGNvbXBvbmVudFN0eWxlc2hlZXQsIGV4dGVybmFsU3R5bGVzaGVldHMpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRTdHlsZXNoZWV0ID0gY29tcG9uZW50U3R5bGVzaGVldDtcbiAgICAgICAgdGhpcy5leHRlcm5hbFN0eWxlc2hlZXRzID0gZXh0ZXJuYWxTdHlsZXNoZWV0cztcbiAgICB9XG4gICAgcmV0dXJuIFN0eWxlc0NvbXBpbGVSZXN1bHQ7XG59KCkpO1xudmFyIENvbXBpbGVkU3R5bGVzaGVldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNWYXJcbiAgICAgKiBAcGFyYW0gez99IGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSB7P30gaXNTaGltbWVkXG4gICAgICogQHBhcmFtIHs/fSBtZXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZWRTdHlsZXNoZWV0KHN0YXRlbWVudHMsIHN0eWxlc1ZhciwgZGVwZW5kZW5jaWVzLCBpc1NoaW1tZWQsIG1ldGEpIHtcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgdGhpcy5zdHlsZXNWYXIgPSBzdHlsZXNWYXI7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLmlzU2hpbW1lZCA9IGlzU2hpbW1lZDtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICB9XG4gICAgcmV0dXJuIENvbXBpbGVkU3R5bGVzaGVldDtcbn0oKSk7XG52YXIgU3R5bGVDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfdXJsUmVzb2x2ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdHlsZUNvbXBpbGVyKF91cmxSZXNvbHZlcikge1xuICAgICAgICB0aGlzLl91cmxSZXNvbHZlciA9IF91cmxSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fc2hhZG93Q3NzID0gbmV3IFNoYWRvd0NzcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHRlcm5hbFN0eWxlc2hlZXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBvbmVudFN0eWxlc2hlZXQgPSB0aGlzLl9jb21waWxlU3R5bGVzKGNvbXAsIG5ldyBDb21waWxlU3R5bGVzaGVldE1ldGFkYXRhKHtcbiAgICAgICAgICAgIHN0eWxlczogY29tcC50ZW1wbGF0ZS5zdHlsZXMsXG4gICAgICAgICAgICBzdHlsZVVybHM6IGNvbXAudGVtcGxhdGUuc3R5bGVVcmxzLFxuICAgICAgICAgICAgbW9kdWxlVXJsOiBpZGVudGlmaWVyTW9kdWxlVXJsKGNvbXAudHlwZSlcbiAgICAgICAgfSksIHRydWUpO1xuICAgICAgICBjb21wLnRlbXBsYXRlLmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGVzaGVldE1ldGEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVkU3R5bGVzaGVldCA9IF90aGlzLl9jb21waWxlU3R5bGVzKGNvbXAsIHN0eWxlc2hlZXRNZXRhLCBmYWxzZSk7XG4gICAgICAgICAgICBleHRlcm5hbFN0eWxlc2hlZXRzLnB1c2goY29tcGlsZWRTdHlsZXNoZWV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgU3R5bGVzQ29tcGlsZVJlc3VsdChjb21wb25lbnRTdHlsZXNoZWV0LCBleHRlcm5hbFN0eWxlc2hlZXRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzaGVldFxuICAgICAqIEBwYXJhbSB7P30gaXNDb21wb25lbnRTdHlsZXNoZWV0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdHlsZUNvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZVN0eWxlcyA9IGZ1bmN0aW9uIChjb21wLCBzdHlsZXNoZWV0LCBpc0NvbXBvbmVudFN0eWxlc2hlZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2hpbSA9IGNvbXAudGVtcGxhdGUuZW5jYXBzdWxhdGlvbiA9PT0gVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQ7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlRXhwcmVzc2lvbnMgPSBzdHlsZXNoZWV0LnN0eWxlcy5tYXAoZnVuY3Rpb24gKHBsYWluU3R5bGUpIHsgcmV0dXJuIGxpdGVyYWwoX3RoaXMuX3NoaW1JZk5lZWRlZChwbGFpblN0eWxlLCBzaGltKSk7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHN0eWxlc2hlZXQuc3R5bGVVcmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZGVudGlmaWVyID0geyByZWZlcmVuY2U6IG51bGwgfTtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKG5ldyBTdHlsZXNDb21waWxlRGVwZW5kZW5jeShnZXRTdHlsZXNWYXJOYW1lKG51bGwpLCBzdHlsZXNoZWV0LnN0eWxlVXJsc1tpXSwgc2hpbSwgaWRlbnRpZmllcikpO1xuICAgICAgICAgICAgc3R5bGVFeHByZXNzaW9ucy5wdXNoKG5ldyBFeHRlcm5hbEV4cHIoaWRlbnRpZmllcikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0eWxlcyB2YXJpYWJsZSBjb250YWlucyBwbGFpbiBzdHJpbmdzIGFuZCBhcnJheXMgb2Ygb3RoZXIgc3R5bGVzIGFycmF5cyAocmVjdXJzaXZlKSxcbiAgICAgICAgLy8gc28gd2Ugc2V0IGl0cyB0eXBlIHRvIGR5bmFtaWMuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlc1ZhciA9IGdldFN0eWxlc1Zhck5hbWUoaXNDb21wb25lbnRTdHlsZXNoZWV0ID8gY29tcCA6IG51bGwpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdG10ID0gdmFyaWFibGUoc3R5bGVzVmFyKVxuICAgICAgICAgICAgLnNldChsaXRlcmFsQXJyKHN0eWxlRXhwcmVzc2lvbnMsIG5ldyBBcnJheVR5cGUoRFlOQU1JQ19UWVBFLCBbVHlwZU1vZGlmaWVyLkNvbnN0XSkpKVxuICAgICAgICAgICAgLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVkU3R5bGVzaGVldChbc3RtdF0sIHN0eWxlc1ZhciwgZGVwZW5kZW5jaWVzLCBzaGltLCBzdHlsZXNoZWV0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVcbiAgICAgKiBAcGFyYW0gez99IHNoaW1cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0eWxlQ29tcGlsZXIucHJvdG90eXBlLl9zaGltSWZOZWVkZWQgPSBmdW5jdGlvbiAoc3R5bGUkJDEsIHNoaW0pIHtcbiAgICAgICAgcmV0dXJuIHNoaW0gPyB0aGlzLl9zaGFkb3dDc3Muc2hpbUNzc1RleHQoc3R5bGUkJDEsIENPTlRFTlRfQVRUUiwgSE9TVF9BVFRSKSA6IHN0eWxlJCQxO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlQ29tcGlsZXI7XG59KCkpO1xuU3R5bGVDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5TdHlsZUNvbXBpbGVyLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgIHsgdHlwZTogVXJsUmVzb2x2ZXIsIH0sXG5dOyB9O1xuLyoqXG4gKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVzVmFyTmFtZShjb21wb25lbnQpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSBcInN0eWxlc1wiO1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiX1wiICsgaWRlbnRpZmllck5hbWUoY29tcG9uZW50LnR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEV2ZW50SGFuZGxlclZhcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50SGFuZGxlclZhcnMoKSB7XG4gICAgfVxuICAgIHJldHVybiBFdmVudEhhbmRsZXJWYXJzO1xufSgpKTtcbkV2ZW50SGFuZGxlclZhcnMuZXZlbnQgPSB2YXJpYWJsZSgnJGV2ZW50Jyk7XG52YXIgQ29udmVydEFjdGlvbkJpbmRpbmdSZXN1bHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdHNcbiAgICAgKiBAcGFyYW0gez99IGFsbG93RGVmYXVsdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0KHN0bXRzLCBhbGxvd0RlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5zdG10cyA9IHN0bXRzO1xuICAgICAgICB0aGlzLmFsbG93RGVmYXVsdCA9IGFsbG93RGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0O1xufSgpKTtcbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGV4cHJlc3Npb24gQVNUIGludG8gYW4gZXhlY3V0YWJsZSBvdXRwdXQgQVNULCBhc3N1bWluZyB0aGUgZXhwcmVzc2lvbiBpc1xuICogdXNlZCBpbiBhbiBhY3Rpb24gYmluZGluZyAoZS5nLiBhbiBldmVudCBoYW5kbGVyKS5cbiAqIEBwYXJhbSB7P30gbG9jYWxSZXNvbHZlclxuICogQHBhcmFtIHs/fSBpbXBsaWNpdFJlY2VpdmVyXG4gKiBAcGFyYW0gez99IGFjdGlvblxuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRBY3Rpb25CaW5kaW5nKGxvY2FsUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGFjdGlvbiwgYmluZGluZ0lkKSB7XG4gICAgaWYgKCFsb2NhbFJlc29sdmVyKSB7XG4gICAgICAgIGxvY2FsUmVzb2x2ZXIgPSBuZXcgRGVmYXVsdExvY2FsUmVzb2x2ZXIoKTtcbiAgICB9XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWN0aW9uV2l0aG91dEJ1aWx0aW5zID0gY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zKHtcbiAgICAgICAgY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyOiBmdW5jdGlvbiAoYXJnQ291bnQpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IG5vIGNhY2hpbmcgZm9yIGxpdGVyYWwgYXJyYXlzIGluIGFjdGlvbnMuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGxpdGVyYWxBcnIoYXJncyk7IH07XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXI6IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBubyBjYWNoaW5nIGZvciBsaXRlcmFsIG1hcHMgaW4gYWN0aW9ucy5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gbGl0ZXJhbE1hcCgvKiogQHR5cGUgez99ICovIChrZXlzLm1hcChmdW5jdGlvbiAoa2V5LCBpKSB7IHJldHVybiBba2V5LCBhcmdzW2ldXTsgfSkpKTsgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlUGlwZUNvbnZlcnRlcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgU3RhdGU6IEFjdGlvbnMgYXJlIG5vdCBhbGxvd2VkIHRvIGNvbnRhaW4gcGlwZXMuIFBpcGU6IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9LCBhY3Rpb24pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX0FzdFRvSXJWaXNpdG9yKGxvY2FsUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGJpbmRpbmdJZCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWN0aW9uU3RtdHMgPSBbXTtcbiAgICBmbGF0dGVuU3RhdGVtZW50cyhhY3Rpb25XaXRob3V0QnVpbHRpbnMudmlzaXQodmlzaXRvciwgX01vZGUuU3RhdGVtZW50KSwgYWN0aW9uU3RtdHMpO1xuICAgIHByZXBlbmRUZW1wb3JhcnlEZWNscyh2aXNpdG9yLnRlbXBvcmFyeUNvdW50LCBiaW5kaW5nSWQsIGFjdGlvblN0bXRzKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsYXN0SW5kZXggPSBhY3Rpb25TdG10cy5sZW5ndGggLSAxO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByZXZlbnREZWZhdWx0VmFyID0gbnVsbDtcbiAgICBpZiAobGFzdEluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGFzdFN0YXRlbWVudCA9IGFjdGlvblN0bXRzW2xhc3RJbmRleF07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJldHVybkV4cHIgPSBjb252ZXJ0U3RtdEludG9FeHByZXNzaW9uKGxhc3RTdGF0ZW1lbnQpO1xuICAgICAgICBpZiAocmV0dXJuRXhwcikge1xuICAgICAgICAgICAgLy8gTm90ZTogV2UgbmVlZCB0byBjYXN0IHRoZSByZXN1bHQgb2YgdGhlIG1ldGhvZCBjYWxsIHRvIGR5bmFtaWMsXG4gICAgICAgICAgICAvLyBhcyBpdCBtaWdodCBiZSBhIHZvaWQgbWV0aG9kIVxuICAgICAgICAgICAgcHJldmVudERlZmF1bHRWYXIgPSBjcmVhdGVQcmV2ZW50RGVmYXVsdFZhcihiaW5kaW5nSWQpO1xuICAgICAgICAgICAgYWN0aW9uU3RtdHNbbGFzdEluZGV4XSA9XG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHRWYXIuc2V0KHJldHVybkV4cHIuY2FzdChEWU5BTUlDX1RZUEUpLm5vdElkZW50aWNhbChsaXRlcmFsKGZhbHNlKSkpXG4gICAgICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KG51bGwsIFtTdG10TW9kaWZpZXIuRmluYWxdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbnZlcnRBY3Rpb25CaW5kaW5nUmVzdWx0KGFjdGlvblN0bXRzLCBwcmV2ZW50RGVmYXVsdFZhcik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gY29udmVydGVyRmFjdG9yeVxuICogQHBhcmFtIHs/fSBhc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmdCdWlsdGlucyhjb252ZXJ0ZXJGYWN0b3J5LCBhc3QpIHtcbiAgICByZXR1cm4gY29udmVydEJ1aWx0aW5zKGNvbnZlcnRlckZhY3RvcnksIGFzdCk7XG59XG52YXIgQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10c1xuICAgICAqIEBwYXJhbSB7P30gY3VyclZhbEV4cHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0KHN0bXRzLCBjdXJyVmFsRXhwcikge1xuICAgICAgICB0aGlzLnN0bXRzID0gc3RtdHM7XG4gICAgICAgIHRoaXMuY3VyclZhbEV4cHIgPSBjdXJyVmFsRXhwcjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQ7XG59KCkpO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBBU1QgaW50byBhbiBleGVjdXRhYmxlIG91dHB1dCBBU1QsIGFzc3VtaW5nIHRoZSBleHByZXNzaW9uXG4gKiBpcyB1c2VkIGluIHByb3BlcnR5IGJpbmRpbmcuIFRoZSBleHByZXNzaW9uIGhhcyB0byBiZSBwcmVwcm9jZXNzZWQgdmlhXG4gKiBgY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zYC5cbiAqIEBwYXJhbSB7P30gbG9jYWxSZXNvbHZlclxuICogQHBhcmFtIHs/fSBpbXBsaWNpdFJlY2VpdmVyXG4gKiBAcGFyYW0gez99IGV4cHJlc3Npb25XaXRob3V0QnVpbHRpbnNcbiAqIEBwYXJhbSB7P30gYmluZGluZ0lkXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKGxvY2FsUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGV4cHJlc3Npb25XaXRob3V0QnVpbHRpbnMsIGJpbmRpbmdJZCkge1xuICAgIGlmICghbG9jYWxSZXNvbHZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyID0gbmV3IERlZmF1bHRMb2NhbFJlc29sdmVyKCk7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN1cnJWYWxFeHByID0gY3JlYXRlQ3VyclZhbHVlRXhwcihiaW5kaW5nSWQpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0bXRzID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXRvciA9IG5ldyBfQXN0VG9JclZpc2l0b3IobG9jYWxSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgYmluZGluZ0lkKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXRFeHByID0gZXhwcmVzc2lvbldpdGhvdXRCdWlsdGlucy52aXNpdCh2aXNpdG9yLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICBpZiAodmlzaXRvci50ZW1wb3JhcnlDb3VudCkge1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdmlzaXRvci50ZW1wb3JhcnlDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBzdG10cy5wdXNoKHRlbXBvcmFyeURlY2xhcmF0aW9uKGJpbmRpbmdJZCwgaSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0bXRzLnB1c2goY3VyclZhbEV4cHIuc2V0KG91dHB1dEV4cHIpLnRvRGVjbFN0bXQobnVsbCwgW1N0bXRNb2RpZmllci5GaW5hbF0pKTtcbiAgICByZXR1cm4gbmV3IENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQoc3RtdHMsIGN1cnJWYWxFeHByKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBjb252ZXJ0ZXJGYWN0b3J5XG4gKiBAcGFyYW0gez99IGFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29udmVydEJ1aWx0aW5zKGNvbnZlcnRlckZhY3RvcnksIGFzdCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgX0J1aWx0aW5Bc3RDb252ZXJ0ZXIoY29udmVydGVyRmFjdG9yeSk7XG4gICAgcmV0dXJuIGFzdC52aXNpdCh2aXNpdG9yKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEBwYXJhbSB7P30gdGVtcG9yYXJ5TnVtYmVyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiB0ZW1wb3JhcnlOYW1lKGJpbmRpbmdJZCwgdGVtcG9yYXJ5TnVtYmVyKSB7XG4gICAgcmV0dXJuIFwidG1wX1wiICsgYmluZGluZ0lkICsgXCJfXCIgKyB0ZW1wb3JhcnlOdW1iZXI7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYmluZGluZ0lkXG4gKiBAcGFyYW0gez99IHRlbXBvcmFyeU51bWJlclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCB0ZW1wb3JhcnlOdW1iZXIpIHtcbiAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHRlbXBvcmFyeU5hbWUoYmluZGluZ0lkLCB0ZW1wb3JhcnlOdW1iZXIpLCBOVUxMX0VYUFIpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHRlbXBvcmFyeUNvdW50XG4gKiBAcGFyYW0gez99IGJpbmRpbmdJZFxuICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwcmVwZW5kVGVtcG9yYXJ5RGVjbHModGVtcG9yYXJ5Q291bnQsIGJpbmRpbmdJZCwgc3RhdGVtZW50cykge1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IHRlbXBvcmFyeUNvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgc3RhdGVtZW50cy51bnNoaWZ0KHRlbXBvcmFyeURlY2xhcmF0aW9uKGJpbmRpbmdJZCwgaSkpO1xuICAgIH1cbn1cbnZhciBfTW9kZSA9IHt9O1xuX01vZGUuU3RhdGVtZW50ID0gMDtcbl9Nb2RlLkV4cHJlc3Npb24gPSAxO1xuX01vZGVbX01vZGUuU3RhdGVtZW50XSA9IFwiU3RhdGVtZW50XCI7XG5fTW9kZVtfTW9kZS5FeHByZXNzaW9uXSA9IFwiRXhwcmVzc2lvblwiO1xuLyoqXG4gKiBAcGFyYW0gez99IG1vZGVcbiAqIEBwYXJhbSB7P30gYXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBlbnN1cmVTdGF0ZW1lbnRNb2RlKG1vZGUsIGFzdCkge1xuICAgIGlmIChtb2RlICE9PSBfTW9kZS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYSBzdGF0ZW1lbnQsIGJ1dCBzYXcgXCIgKyBhc3QpO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBtb2RlXG4gKiBAcGFyYW0gez99IGFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KSB7XG4gICAgaWYgKG1vZGUgIT09IF9Nb2RlLkV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiwgYnV0IHNhdyBcIiArIGFzdCk7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IG1vZGVcbiAqIEBwYXJhbSB7P30gZXhwclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgZXhwcikge1xuICAgIGlmIChtb2RlID09PSBfTW9kZS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGV4cHIudG9TdG10KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG59XG52YXIgX0J1aWx0aW5Bc3RDb252ZXJ0ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhfQnVpbHRpbkFzdENvbnZlcnRlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jb252ZXJ0ZXJGYWN0b3J5XG4gICAgICovXG4gICAgZnVuY3Rpb24gX0J1aWx0aW5Bc3RDb252ZXJ0ZXIoX2NvbnZlcnRlckZhY3RvcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2NvbnZlcnRlckZhY3RvcnkgPSBfY29udmVydGVyRmFjdG9yeTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0J1aWx0aW5Bc3RDb252ZXJ0ZXIucHJvdG90eXBlLnZpc2l0UGlwZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IFthc3QuZXhwXS5jb25jYXQoYXN0LmFyZ3MpLm1hcChmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKGFzdC5zcGFuLCBhcmdzLCB0aGlzLl9jb252ZXJ0ZXJGYWN0b3J5LmNyZWF0ZVBpcGVDb252ZXJ0ZXIoYXN0Lm5hbWUsIGFyZ3MubGVuZ3RoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0J1aWx0aW5Bc3RDb252ZXJ0ZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbEFycmF5ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gYXN0LmV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBhc3QudmlzaXQoX3RoaXMsIGNvbnRleHQpOyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKGFzdC5zcGFuLCBhcmdzLCB0aGlzLl9jb252ZXJ0ZXJGYWN0b3J5LmNyZWF0ZUxpdGVyYWxBcnJheUNvbnZlcnRlcihhc3QuZXhwcmVzc2lvbnMubGVuZ3RoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0J1aWx0aW5Bc3RDb252ZXJ0ZXIucHJvdG90eXBlLnZpc2l0TGl0ZXJhbE1hcCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IGFzdC52YWx1ZXMubWFwKGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGFzdC52aXNpdChfdGhpcywgY29udGV4dCk7IH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJ1aWx0aW5GdW5jdGlvbkNhbGwoYXN0LnNwYW4sIGFyZ3MsIHRoaXMuX2NvbnZlcnRlckZhY3RvcnkuY3JlYXRlTGl0ZXJhbE1hcENvbnZlcnRlcihhc3Qua2V5cykpO1xuICAgIH07XG4gICAgcmV0dXJuIF9CdWlsdGluQXN0Q29udmVydGVyO1xufShBc3RUcmFuc2Zvcm1lcikpO1xudmFyIF9Bc3RUb0lyVmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfbG9jYWxSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX2ltcGxpY2l0UmVjZWl2ZXJcbiAgICAgKiBAcGFyYW0gez99IGJpbmRpbmdJZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9Bc3RUb0lyVmlzaXRvcihfbG9jYWxSZXNvbHZlciwgX2ltcGxpY2l0UmVjZWl2ZXIsIGJpbmRpbmdJZCkge1xuICAgICAgICB0aGlzLl9sb2NhbFJlc29sdmVyID0gX2xvY2FsUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIgPSBfaW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgdGhpcy5iaW5kaW5nSWQgPSBiaW5kaW5nSWQ7XG4gICAgICAgIHRoaXMuX25vZGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Jlc3VsdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRlbXBvcmFyeSA9IDA7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5Q291bnQgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEJpbmFyeSA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3A7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5QbHVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5NaW51cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkRpdmlkZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTW9kdWxvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJiYnOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnfHwnOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuT3I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5FcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTG93ZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkJpZ2dlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBvcGVyYXRpb24gXCIgKyBhc3Qub3BlcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihvcCwgdGhpcy52aXNpdChhc3QubGVmdCwgX01vZGUuRXhwcmVzc2lvbiksIHRoaXMudmlzaXQoYXN0LnJpZ2h0LCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGFpbiA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgZW5zdXJlU3RhdGVtZW50TW9kZShtb2RlLCBhc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIG1vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRDb25kaXRpb25hbCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSB0aGlzLnZpc2l0KGFzdC5jb25kaXRpb24sIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdmFsdWUuY29uZGl0aW9uYWwodGhpcy52aXNpdChhc3QudHJ1ZUV4cCwgX01vZGUuRXhwcmVzc2lvbiksIHRoaXMudmlzaXQoYXN0LmZhbHNlRXhwLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQaXBlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHN0YXRlOiBQaXBlcyBzaG91bGQgaGF2ZSBiZWVuIGNvbnZlcnRlZCBpbnRvIGZ1bmN0aW9ucy4gUGlwZTogXCIgKyBhc3QubmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29udmVydGVkQXJncyA9IHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmblJlc3VsdDtcbiAgICAgICAgaWYgKGFzdCBpbnN0YW5jZW9mIEJ1aWx0aW5GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIGZuUmVzdWx0ID0gYXN0LmNvbnZlcnRlcihjb252ZXJ0ZWRBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZuUmVzdWx0ID0gdGhpcy52aXNpdChhc3QudGFyZ2V0LCBfTW9kZS5FeHByZXNzaW9uKS5jYWxsRm4oY29udmVydGVkQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGZuUmVzdWx0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW1wbGljaXRSZWNlaXZlciA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludGVycG9sYXRpb24gPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIGVuc3VyZUV4cHJlc3Npb25Nb2RlKG1vZGUsIGFzdCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSBbbGl0ZXJhbChhc3QuZXhwcmVzc2lvbnMubGVuZ3RoKV07XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBhc3Quc3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2ldKSk7XG4gICAgICAgICAgICBhcmdzLnB1c2godGhpcy52aXNpdChhc3QuZXhwcmVzc2lvbnNbaV0sIF9Nb2RlLkV4cHJlc3Npb24pKTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2gobGl0ZXJhbChhc3Quc3RyaW5nc1thc3Quc3RyaW5ncy5sZW5ndGggLSAxXSkpO1xuICAgICAgICByZXR1cm4gYXN0LmV4cHJlc3Npb25zLmxlbmd0aCA8PSA5ID9cbiAgICAgICAgICAgIGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5pbmxpbmVJbnRlcnBvbGF0ZSkpLmNhbGxGbihhcmdzKSA6XG4gICAgICAgICAgICBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuaW50ZXJwb2xhdGUpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGFyZ3NbMF0sIGxpdGVyYWxBcnIoYXJncy5zbGljZSgxKSlcbiAgICAgICAgICAgIF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRLZXllZFJlYWQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICBpZiAobGVmdE1vc3RTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGhpcy52aXNpdChhc3Qub2JqLCBfTW9kZS5FeHByZXNzaW9uKS5rZXkodGhpcy52aXNpdChhc3Qua2V5LCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEtleWVkV3JpdGUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9iaiA9IHRoaXMudmlzaXQoYXN0Lm9iaiwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGtleSA9IHRoaXMudmlzaXQoYXN0LmtleSwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdGhpcy52aXNpdChhc3QudmFsdWUsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgb2JqLmtleShrZXkpLnNldCh2YWx1ZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXkgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgU3RhdGU6IGxpdGVyYWwgYXJyYXlzIHNob3VsZCBoYXZlIGJlZW4gY29udmVydGVkIGludG8gZnVuY3Rpb25zXCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIFN0YXRlOiBsaXRlcmFsIG1hcHMgc2hvdWxkIGhhdmUgYmVlbiBjb252ZXJ0ZWQgaW50byBmdW5jdGlvbnNcIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdExpdGVyYWxQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBsaXRlcmFsKGFzdC52YWx1ZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLl9nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLl9sb2NhbFJlc29sdmVyLmdldExvY2FsKG5hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0TWV0aG9kQ2FsbCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNlaXZlciA9IHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PT0gdGhpcy5faW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhckV4cHIgPSB0aGlzLl9nZXRMb2NhbChhc3QubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhckV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFyRXhwci5jYWxsRm4oYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuY2FsbE1ldGhvZChhc3QubmFtZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcmVmaXhOb3QgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBub3QodGhpcy52aXNpdChhc3QuZXhwcmVzc2lvbiwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UHJvcGVydHlSZWFkID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsZWZ0TW9zdFNhZmUgPSB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KTtcbiAgICAgICAgaWYgKGxlZnRNb3N0U2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCBsZWZ0TW9zdFNhZmUsIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0TG9jYWwoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIucHJvcChhc3QubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXRQcm9wZXJ0eVdyaXRlID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWNlaXZlciA9IHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YXJFeHByID0gdGhpcy5fZ2V0TG9jYWwoYXN0Lm5hbWUpO1xuICAgICAgICAgICAgaWYgKHZhckV4cHIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhc3NpZ24gdG8gYSByZWZlcmVuY2Ugb3IgdmFyaWFibGUhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHJlY2VpdmVyLnByb3AoYXN0Lm5hbWUpLnNldCh0aGlzLnZpc2l0KGFzdC52YWx1ZSwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0U2FmZVByb3BlcnR5UmVhZCA9IGZ1bmN0aW9uIChhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KSwgbW9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFNhZmVNZXRob2RDYWxsID0gZnVuY3Rpb24gKGFzdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpLCBtb2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0c1xuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFsbCA9IGZ1bmN0aW9uIChhc3RzLCBtb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBhc3RzLm1hcChmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBfdGhpcy52aXNpdChhc3QsIG1vZGUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBtb2RlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLnZpc2l0UXVvdGUgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUXVvdGVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBldmFsdWF0aW9uIScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IG1vZGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMuX3Jlc3VsdE1hcC5nZXQoYXN0KTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJldHVybiAodGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHRoaXMsIG1vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGxlZnRNb3N0U2FmZVxuICAgICAqIEBwYXJhbSB7P30gbW9kZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5jb252ZXJ0U2FmZUFjY2VzcyA9IGZ1bmN0aW9uIChhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSkge1xuICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBjb250YWlucyBhIHNhZmUgYWNjZXNzIG5vZGUgb24gdGhlIGxlZnQgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvXG4gICAgICAgIC8vIGFuIGV4cHJlc3Npb24gdGhhdCBndWFyZHMgdGhlIGFjY2VzcyB0byB0aGUgbWVtYmVyIGJ5IGNoZWNraW5nIHRoZSByZWNlaXZlciBmb3IgYmxhbmsuIEFzXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBwcm9jZWVkcyBmcm9tIGxlZnQgdG8gcmlnaHQsIHRoZSBsZWZ0IG1vc3QgcGFydCBvZiB0aGUgZXhwcmVzc2lvbiBtdXN0IGJlIGd1YXJkZWRcbiAgICAgICAgLy8gZmlyc3QgYnV0LCBiZWNhdXNlIG1lbWJlciBhY2Nlc3MgaXMgbGVmdCBhc3NvY2lhdGl2ZSwgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGV4cHJlc3Npb24gaXMgYXRcbiAgICAgICAgLy8gdGhlIHRvcCBvZiB0aGUgQVNULiBUaGUgZGVzaXJlZCByZXN1bHQgcmVxdWlyZXMgbGlmdGluZyBhIGNvcHkgb2YgdGhlIHRoZSBsZWZ0IHBhcnQgb2YgdGhlXG4gICAgICAgIC8vIGV4cHJlc3Npb24gdXAgdG8gdGVzdCBpdCBmb3IgYmxhbmsgYmVmb3JlIGdlbmVyYXRpbmcgdGhlIHVuZ3VhcmRlZCB2ZXJzaW9uLlxuICAgICAgICAvLyBDb25zaWRlciwgZm9yIGV4YW1wbGUgdGhlIGZvbGxvd2luZyBleHByZXNzaW9uOiBhPy5iLmM/LmQuZVxuICAgICAgICAvLyBUaGlzIHJlc3VsdHMgaW4gdGhlIGFzdDpcbiAgICAgICAgLy8gICAgICAgICAuXG4gICAgICAgIC8vICAgICAgICAvIFxcXG4gICAgICAgIC8vICAgICAgID8uICAgZVxuICAgICAgICAvLyAgICAgIC8gIFxcXG4gICAgICAgIC8vICAgICAuICAgIGRcbiAgICAgICAgLy8gICAgLyBcXFxuICAgICAgICAvLyAgID8uICBjXG4gICAgICAgIC8vICAvICBcXFxuICAgICAgICAvLyBhICAgIGJcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB0cmVlIHNob3VsZCBiZSBnZW5lcmF0ZWQ6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICAvLS0tLSA/IC0tLS1cXFxuICAgICAgICAvLyAgICAgICAvICAgICAgfCAgICAgIFxcXG4gICAgICAgIC8vICAgICBhICAgLy0tLSA/IC0tLVxcICBudWxsXG4gICAgICAgIC8vICAgICAgICAvICAgICB8ICAgICBcXFxuICAgICAgICAvLyAgICAgICAuICAgICAgLiAgICAgbnVsbFxuICAgICAgICAvLyAgICAgIC8gXFwgICAgLyBcXFxuICAgICAgICAvLyAgICAgLiAgYyAgIC4gICBlXG4gICAgICAgIC8vICAgIC8gXFwgICAgLyBcXFxuICAgICAgICAvLyAgIGEgICBiICAsICAgZFxuICAgICAgICAvLyAgICAgICAgIC8gXFxcbiAgICAgICAgLy8gICAgICAgIC4gICBjXG4gICAgICAgIC8vICAgICAgIC8gXFxcbiAgICAgICAgLy8gICAgICBhICAgYlxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3RpY2UgdGhhdCB0aGUgZmlyc3QgZ3VhcmQgY29uZGl0aW9uIGlzIHRoZSBsZWZ0IGhhbmQgb2YgdGhlIGxlZnQgbW9zdCBzYWZlIGFjY2VzcyBub2RlXG4gICAgICAgIC8vIHdoaWNoIGNvbWVzIGluIGFzIGxlZnRNb3N0U2FmZSB0byB0aGlzIHJvdXRpbmUuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGd1YXJkZWRFeHByZXNzaW9uID0gdGhpcy52aXNpdChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wb3Jhcnk7XG4gICAgICAgIGlmICh0aGlzLm5lZWRzVGVtcG9yYXJ5KGxlZnRNb3N0U2FmZS5yZWNlaXZlcikpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBleHByZXNzaW9uIGhhcyBtZXRob2QgY2FsbHMgb3IgcGlwZXMgdGhlbiB3ZSBuZWVkIHRvIHNhdmUgdGhlIHJlc3VsdCBpbnRvIGFcbiAgICAgICAgICAgIC8vIHRlbXBvcmFyeSB2YXJpYWJsZSB0byBhdm9pZCBjYWxsaW5nIHN0YXRlZnVsIG9yIGltcHVyZSBjb2RlIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICAgICAgdGVtcG9yYXJ5ID0gdGhpcy5hbGxvY2F0ZVRlbXBvcmFyeSgpO1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgdGhlIHJlc3VsdCBpbiB0aGUgdGVtcG9yYXJ5IHZhcmlhYmxlXG4gICAgICAgICAgICBndWFyZGVkRXhwcmVzc2lvbiA9IHRlbXBvcmFyeS5zZXQoZ3VhcmRlZEV4cHJlc3Npb24pO1xuICAgICAgICAgICAgLy8gRW5zdXJlIGFsbCBmdXJ0aGVyIHJlZmVyZW5jZXMgdG8gdGhlIGd1YXJkZWQgZXhwcmVzc2lvbiByZWZlciB0byB0aGUgdGVtcG9yYXJ5IGluc3RlYWQuXG4gICAgICAgICAgICB0aGlzLl9yZXN1bHRNYXAuc2V0KGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgdGVtcG9yYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25kaXRpb24gPSBndWFyZGVkRXhwcmVzc2lvbi5pc0JsYW5rKCk7XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGFzdCB0byBhbiB1bmd1YXJkZWQgYWNjZXNzIHRvIHRoZSByZWNlaXZlcidzIG1lbWJlci4gVGhlIG1hcCB3aWxsIHN1YnN0aXR1dGVcbiAgICAgICAgLy8gbGVmdE1vc3ROb2RlIHdpdGggaXRzIHVuZ3VhcmRlZCB2ZXJzaW9uIGluIHRoZSBjYWxsIHRvIGB0aGlzLnZpc2l0KClgLlxuICAgICAgICBpZiAobGVmdE1vc3RTYWZlIGluc3RhbmNlb2YgU2FmZU1ldGhvZENhbGwpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVNYXAuc2V0KGxlZnRNb3N0U2FmZSwgbmV3IE1ldGhvZENhbGwobGVmdE1vc3RTYWZlLnNwYW4sIGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgbGVmdE1vc3RTYWZlLm5hbWUsIGxlZnRNb3N0U2FmZS5hcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlTWFwLnNldChsZWZ0TW9zdFNhZmUsIG5ldyBQcm9wZXJ0eVJlYWQobGVmdE1vc3RTYWZlLnNwYW4sIGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgbGVmdE1vc3RTYWZlLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHRoZSBub2RlIG5vdyB3aXRob3V0IHRoZSBndWFyZGVkIG1lbWJlciBhY2Nlc3MuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFjY2VzcyA9IHRoaXMudmlzaXQoYXN0LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBtYXBwaW5nLiBUaGlzIGlzIG5vdCBzdHJpY3RseSByZXF1aXJlZCBhcyB0aGUgY29udmVydGVyIG9ubHkgdHJhdmVyc2VzIGVhY2ggbm9kZVxuICAgICAgICAvLyBvbmNlIGJ1dCBpcyBzYWZlciBpZiB0aGUgY29udmVyc2lvbiBpcyBjaGFuZ2VkIHRvIHRyYXZlcnNlIHRoZSBub2RlcyBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgdGhpcy5fbm9kZU1hcC5kZWxldGUobGVmdE1vc3RTYWZlKTtcbiAgICAgICAgLy8gSWYgd2UgYWxsb2NhdGVkIGEgdGVtcG9yYXJ5LCByZWxlYXNlIGl0LlxuICAgICAgICBpZiAodGVtcG9yYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VUZW1wb3JhcnkodGVtcG9yYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm9kdWNlIHRoZSBjb25kaXRpb25hbFxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgY29uZGl0aW9uLmNvbmRpdGlvbmFsKGxpdGVyYWwobnVsbCksIGFjY2VzcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUubGVmdE1vc3RTYWZlTm9kZSA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvciwgYXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKF90aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhc3QudmlzaXQoe1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRCaW5hcnk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdENoYWluOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRDb25kaXRpb25hbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0RnVuY3Rpb25DYWxsOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRJbXBsaWNpdFJlY2VpdmVyOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRLZXllZFJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5vYmopOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRLZXllZFdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRMaXRlcmFsQXJyYXk6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxNYXA6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxQcmltaXRpdmU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdE1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcik7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFBpcGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFByZWZpeE5vdDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRRdW90ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0U2FmZU1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcikgfHwgYXN0OyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkOiBmdW5jdGlvbiAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcikgfHwgYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBfQXN0VG9JclZpc2l0b3IucHJvdG90eXBlLm5lZWRzVGVtcG9yYXJ5ID0gZnVuY3Rpb24gKGFzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aXNpdCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBhc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3QgJiYgKF90aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0U29tZSA9IGZ1bmN0aW9uICh2aXNpdG9yLCBhc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3Quc29tZShmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdCh2aXNpdG9yLCBhc3QpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFzdC52aXNpdCh7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEJpbmFyeTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LmxlZnQpIHx8IHZpc2l0KHRoaXMsIGFzdC5yaWdodCk7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdENoYWluOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0Q29uZGl0aW9uYWw6IGZ1bmN0aW9uIChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LmNvbmRpdGlvbikgfHwgdmlzaXQodGhpcywgYXN0LnRydWVFeHApIHx8XG4gICAgICAgICAgICAgICAgICAgIHZpc2l0KHRoaXMsIGFzdC5mYWxzZUV4cCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRGdW5jdGlvbkNhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXI6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiB2aXNpdFNvbWUodGhpcywgYXN0LmV4cHJlc3Npb25zKTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0S2V5ZWRSZWFkOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0S2V5ZWRXcml0ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxBcnJheTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbE1hcDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZTogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdE1ldGhvZENhbGw6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFBpcGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2aXNpdFByZWZpeE5vdDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdmlzaXQodGhpcywgYXN0LmV4cHJlc3Npb24pOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVJlYWQ6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlOiBmdW5jdGlvbiAoYXN0KSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0UXVvdGU6IGZ1bmN0aW9uIChhc3QpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaXRTYWZlTWV0aG9kQ2FsbDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZDogZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9Bc3RUb0lyVmlzaXRvci5wcm90b3R5cGUuYWxsb2NhdGVUZW1wb3JhcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBOdW1iZXIgPSB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5Kys7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5Q291bnQgPSBNYXRoLm1heCh0aGlzLl9jdXJyZW50VGVtcG9yYXJ5LCB0aGlzLnRlbXBvcmFyeUNvdW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkVmFyRXhwcih0ZW1wb3JhcnlOYW1lKHRoaXMuYmluZGluZ0lkLCB0ZW1wTnVtYmVyKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRlbXBvcmFyeVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgX0FzdFRvSXJWaXNpdG9yLnByb3RvdHlwZS5yZWxlYXNlVGVtcG9yYXJ5ID0gZnVuY3Rpb24gKHRlbXBvcmFyeSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5LS07XG4gICAgICAgIGlmICh0ZW1wb3JhcnkubmFtZSAhPSB0ZW1wb3JhcnlOYW1lKHRoaXMuYmluZGluZ0lkLCB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVtcG9yYXJ5IFwiICsgdGVtcG9yYXJ5Lm5hbWUgKyBcIiByZWxlYXNlZCBvdXQgb2Ygb3JkZXJcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBfQXN0VG9JclZpc2l0b3I7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGFyZ1xuICogQHBhcmFtIHs/fSBvdXRwdXRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TdGF0ZW1lbnRzKGFyZywgb3V0cHV0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAoKGFyZykpLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBmbGF0dGVuU3RhdGVtZW50cyhlbnRyeSwgb3V0cHV0KTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaChhcmcpO1xuICAgIH1cbn1cbnZhciBEZWZhdWx0TG9jYWxSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmYXVsdExvY2FsUmVzb2x2ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVmYXVsdExvY2FsUmVzb2x2ZXIucHJvdG90eXBlLmdldExvY2FsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdExvY2FsUmVzb2x2ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IGJpbmRpbmdJZFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3VyclZhbHVlRXhwcihiaW5kaW5nSWQpIHtcbiAgICByZXR1cm4gdmFyaWFibGUoXCJjdXJyVmFsX1wiICsgYmluZGluZ0lkKTsgLy8gZml4IHN5bnRheCBoaWdobGlnaHRpbmc6IGBcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBiaW5kaW5nSWRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByZXZlbnREZWZhdWx0VmFyKGJpbmRpbmdJZCkge1xuICAgIHJldHVybiB2YXJpYWJsZShcInBkX1wiICsgYmluZGluZ0lkKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdG10XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0U3RtdEludG9FeHByZXNzaW9uKHN0bXQpIHtcbiAgICBpZiAoc3RtdCBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQuZXhwcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RtdCBpbnN0YW5jZW9mIFJldHVyblN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gc3RtdC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgQnVpbHRpbkZ1bmN0aW9uQ2FsbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1aWx0aW5GdW5jdGlvbkNhbGwsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcGFuXG4gICAgICogQHBhcmFtIHs/fSBhcmdzXG4gICAgICogQHBhcmFtIHs/fSBjb252ZXJ0ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCdWlsdGluRnVuY3Rpb25DYWxsKHNwYW4sIGFyZ3MsIGNvbnZlcnRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGFuLCBudWxsLCBhcmdzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgX3RoaXMuY29udmVydGVyID0gY29udmVydGVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCdWlsdGluRnVuY3Rpb25DYWxsO1xufShGdW5jdGlvbkNhbGwpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBDTEFTU19BVFRSJDEgPSAnY2xhc3MnO1xudmFyIFNUWUxFX0FUVFIgPSAnc3R5bGUnO1xudmFyIElNUExJQ0lUX1RFTVBMQVRFX1ZBUiA9ICdcXCRpbXBsaWNpdCc7XG52YXIgTkdfQ09OVEFJTkVSX1RBRyA9ICduZy1jb250YWluZXInO1xudmFyIFZpZXdDb21waWxlUmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez99IHZpZXdDbGFzc1ZhclxuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJUeXBlVmFyXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlld0NvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgdmlld0NsYXNzVmFyLCByZW5kZXJlclR5cGVWYXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgdGhpcy52aWV3Q2xhc3NWYXIgPSB2aWV3Q2xhc3NWYXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXJUeXBlVmFyID0gcmVuZGVyZXJUeXBlVmFyO1xuICAgIH1cbiAgICByZXR1cm4gVmlld0NvbXBpbGVSZXN1bHQ7XG59KCkpO1xudmFyIFZpZXdDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZ2VuQ29uZmlnTmV4dFxuICAgICAqIEBwYXJhbSB7P30gX3NjaGVtYVJlZ2lzdHJ5XG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlld0NvbXBpbGVyKF9nZW5Db25maWdOZXh0LCBfc2NoZW1hUmVnaXN0cnkpIHtcbiAgICAgICAgdGhpcy5fZ2VuQ29uZmlnTmV4dCA9IF9nZW5Db25maWdOZXh0O1xuICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHs/fSBzdHlsZXNcbiAgICAgKiBAcGFyYW0gez99IHVzZWRQaXBlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0NvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgdGVtcGxhdGUsIHN0eWxlcywgdXNlZFBpcGVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVtYmVkZGVkVmlld0NvdW50ID0gMDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljUXVlcnlJZHMgPSBmaW5kU3RhdGljUXVlcnlJZHModGVtcGxhdGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlbmRlckNvbXBvbmVudFZhck5hbWU7XG4gICAgICAgIGlmICghY29tcG9uZW50LmlzSG9zdCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VzdG9tUmVuZGVyRGF0YSA9IFtdO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC50ZW1wbGF0ZS5hbmltYXRpb25zICYmIGNvbXBvbmVudC50ZW1wbGF0ZS5hbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGN1c3RvbVJlbmRlckRhdGEucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KCdhbmltYXRpb24nLCBjb252ZXJ0VmFsdWVUb091dHB1dEFzdChjb21wb25lbnQudGVtcGxhdGUuYW5pbWF0aW9ucyksIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlbmRlckNvbXBvbmVudFZhciA9IHZhcmlhYmxlKHJlbmRlcmVyVHlwZU5hbWUoY29tcG9uZW50LnR5cGUucmVmZXJlbmNlKSk7XG4gICAgICAgICAgICByZW5kZXJDb21wb25lbnRWYXJOYW1lID0gcmVuZGVyQ29tcG9uZW50VmFyLm5hbWU7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmVuZGVyQ29tcG9uZW50VmFyXG4gICAgICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuY3JlYXRlUmVuZGVyZXJUeXBlMikpXG4gICAgICAgICAgICAgICAgLmNhbGxGbihbbmV3IExpdGVyYWxNYXBFeHByKFtcbiAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFbnRyeSgnZW5jYXBzdWxhdGlvbicsIGxpdGVyYWwoY29tcG9uZW50LnRlbXBsYXRlLmVuY2Fwc3VsYXRpb24pKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFbnRyeSgnc3R5bGVzJywgc3R5bGVzKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFbnRyeSgnZGF0YScsIG5ldyBMaXRlcmFsTWFwRXhwcihjdXN0b21SZW5kZXJEYXRhKSlcbiAgICAgICAgICAgICAgICBdKV0pKVxuICAgICAgICAgICAgICAgIC50b0RlY2xTdG10KGltcG9ydFR5cGUoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5SZW5kZXJlclR5cGUyKSksIFtTdG10TW9kaWZpZXIuRmluYWxdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0J1aWxkZXJGYWN0b3J5ID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW1iZWRkZWRWaWV3SW5kZXggPSBlbWJlZGRlZFZpZXdDb3VudCsrO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWaWV3QnVpbGRlcihwYXJlbnQsIGNvbXBvbmVudCwgZW1iZWRkZWRWaWV3SW5kZXgsIHVzZWRQaXBlcywgc3RhdGljUXVlcnlJZHMsIHZpZXdCdWlsZGVyRmFjdG9yeSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSB2aWV3QnVpbGRlckZhY3RvcnkobnVsbCk7XG4gICAgICAgIHZpc2l0b3IudmlzaXRBbGwoW10sIHRlbXBsYXRlKTtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoLmFwcGx5KHN0YXRlbWVudHMsIHZpc2l0b3IuYnVpbGQoKSk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld0NvbXBpbGVSZXN1bHQoc3RhdGVtZW50cywgdmlzaXRvci52aWV3TmFtZSwgcmVuZGVyQ29tcG9uZW50VmFyTmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlld0NvbXBpbGVyO1xufSgpKTtcblZpZXdDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5WaWV3Q29tcGlsZXIuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBDb21waWxlckNvbmZpZywgfSxcbiAgICB7IHR5cGU6IEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgfSxcbl07IH07XG52YXIgTE9HX1ZBUiA9IHZhcmlhYmxlKCdsJyk7XG52YXIgVklFV19WQVIgPSB2YXJpYWJsZSgndicpO1xudmFyIENIRUNLX1ZBUiA9IHZhcmlhYmxlKCdjaycpO1xudmFyIENPTVBfVkFSID0gdmFyaWFibGUoJ2NvJyk7XG52YXIgRVZFTlRfTkFNRV9WQVIgPSB2YXJpYWJsZSgnZW4nKTtcbnZhciBBTExPV19ERUZBVUxUX1ZBUiA9IHZhcmlhYmxlKFwiYWRcIik7XG52YXIgVmlld0J1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0gez99IGVtYmVkZGVkVmlld0luZGV4XG4gICAgICogQHBhcmFtIHs/fSB1c2VkUGlwZXNcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1F1ZXJ5SWRzXG4gICAgICogQHBhcmFtIHs/fSB2aWV3QnVpbGRlckZhY3RvcnlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWV3QnVpbGRlcihwYXJlbnQsIGNvbXBvbmVudCwgZW1iZWRkZWRWaWV3SW5kZXgsIHVzZWRQaXBlcywgc3RhdGljUXVlcnlJZHMsIHZpZXdCdWlsZGVyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZW1iZWRkZWRWaWV3SW5kZXggPSBlbWJlZGRlZFZpZXdJbmRleDtcbiAgICAgICAgdGhpcy51c2VkUGlwZXMgPSB1c2VkUGlwZXM7XG4gICAgICAgIHRoaXMuc3RhdGljUXVlcnlJZHMgPSBzdGF0aWNRdWVyeUlkcztcbiAgICAgICAgdGhpcy52aWV3QnVpbGRlckZhY3RvcnkgPSB2aWV3QnVpbGRlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5wdXJlUGlwZU5vZGVJbmRpY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5yZWZOb2RlSW5kaWNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gW107XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLy8gVE9ETyh0Ym9zY2gpOiBUaGUgb2xkIHZpZXcgY29tcGlsZXIgdXNlZCB0byB1c2UgYW4gYGFueWAgdHlwZVxuICAgICAgICAvLyBmb3IgdGhlIGNvbnRleHQgaW4gYW55IGVtYmVkZGVkIHZpZXcuIFdlIGtlZXAgdGhpcyBiZWhhaXZvciBmb3Igbm93XG4gICAgICAgIC8vIHRvIGJlIGFibGUgdG8gaW50cm9kdWNlIHRoZSBuZXcgdmlldyBjb21waWxlciB3aXRob3V0IHRvbyBtYW55IGVycm9ycy5cbiAgICAgICAgdGhpcy5jb21wVHlwZSA9IHRoaXMuZW1iZWRkZWRWaWV3SW5kZXggPiAwID8gRFlOQU1JQ19UWVBFIDogaW1wb3J0VHlwZSh0aGlzLmNvbXBvbmVudC50eXBlKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdCdWlsZGVyLnByb3RvdHlwZSwgXCJ2aWV3TmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld0NsYXNzTmFtZSh0aGlzLmNvbXBvbmVudC50eXBlLnJlZmVyZW5jZSwgdGhpcy5lbWJlZGRlZFZpZXdJbmRleCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFyaWFibGVzXG4gICAgICogQHBhcmFtIHs/fSBhc3ROb2Rlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0QWxsID0gZnVuY3Rpb24gKHZhcmlhYmxlcywgYXN0Tm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgcGlwZXMgZm9yIHRoZSBwdXJlIHBpcGVzIGltbWVkaWF0ZWx5LCBzbyB0aGF0IHdlIGtub3cgdGhlaXIgaW5kaWNlcy5cbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy51c2VkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChwaXBlLnB1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHVyZVBpcGVOb2RlSW5kaWNlc1twaXBlLm5hbWVdID0gX3RoaXMuX2NyZWF0ZVBpcGUobnVsbCwgcGlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlJZHNfMSA9IHN0YXRpY1ZpZXdRdWVyeUlkcyh0aGlzLnN0YXRpY1F1ZXJ5SWRzKTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnZpZXdRdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5LCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogcXVlcmllcyBzdGFydCB3aXRoIGlkIDEgc28gd2UgY2FuIHVzZSB0aGUgbnVtYmVyIGluIGEgQmxvb20gZmlsdGVyIVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5SWQgPSBxdWVyeUluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nVHlwZSA9IHF1ZXJ5LmZpcnN0ID8gMCAvKiBGaXJzdCAqLyA6IDE7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSA2NzEwODg2NCAvKiBUeXBlVmlld1F1ZXJ5ICovIHwgY2FsY1N0YXRpY0R5bmFtaWNRdWVyeUZsYWdzKHF1ZXJ5SWRzXzEsIHF1ZXJ5SWQsIHF1ZXJ5LmZpcnN0KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVGbGFnczogZmxhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5xdWVyeURlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSwgbGl0ZXJhbChxdWVyeUlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBMaXRlcmFsTWFwRXhwcihbbmV3IExpdGVyYWxNYXBFbnRyeShxdWVyeS5wcm9wZXJ0eU5hbWUsIGxpdGVyYWwoYmluZGluZ1R5cGUpKV0pXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGVWaXNpdEFsbCh0aGlzLCBhc3ROb2Rlcyk7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAoYXN0Tm9kZXMubGVuZ3RoID09PSAwIHx8IG5lZWRzQWRkaXRpb25hbFJvb3ROb2RlKGFzdE5vZGVzKSkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSB2aWV3IGlzIGFuIGVtYmVkZGVkIHZpZXcsIHRoZW4gd2UgbmVlZCB0byBhZGQgYW4gYWRkaXRpb25hbCByb290IG5vZGUgaW4gc29tZSBjYXNlc1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogbnVsbCxcbiAgICAgICAgICAgICAgICBub2RlRmxhZ3M6IDEgLyogVHlwZUVsZW1lbnQgKi8sXG4gICAgICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmFuY2hvckRlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwoMCAvKiBOb25lICovKSwgTlVMTF9FWFBSLCBOVUxMX0VYUFIsIGxpdGVyYWwoMClcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez89fSB0YXJnZXRTdGF0ZW1lbnRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAodGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICBpZiAodGFyZ2V0U3RhdGVtZW50cyA9PT0gdm9pZCAwKSB7IHRhcmdldFN0YXRlbWVudHMgPSBbXTsgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5idWlsZCh0YXJnZXRTdGF0ZW1lbnRzKTsgfSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX2NyZWF0ZU5vZGVFeHByZXNzaW9ucygpLCB1cGRhdGVSZW5kZXJlclN0bXRzID0gX2EudXBkYXRlUmVuZGVyZXJTdG10cywgdXBkYXRlRGlyZWN0aXZlc1N0bXRzID0gX2EudXBkYXRlRGlyZWN0aXZlc1N0bXRzLCBub2RlRGVmRXhwcnMgPSBfYS5ub2RlRGVmRXhwcnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZVJlbmRlcmVyRm4gPSB0aGlzLl9jcmVhdGVVcGRhdGVGbih1cGRhdGVSZW5kZXJlclN0bXRzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdXBkYXRlRGlyZWN0aXZlc0ZuID0gdGhpcy5fY3JlYXRlVXBkYXRlRm4odXBkYXRlRGlyZWN0aXZlc1N0bXRzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0ZsYWdzID0gMDtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLmNvbXBvbmVudC5jaGFuZ2VEZXRlY3Rpb24gPT09IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCkge1xuICAgICAgICAgICAgdmlld0ZsYWdzIHw9IDIgLyogT25QdXNoICovO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpZXdGYWN0b3J5ID0gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQodGhpcy52aWV3TmFtZSwgW25ldyBGblBhcmFtKExPR19WQVIubmFtZSldLCBbbmV3IFJldHVyblN0YXRlbWVudChpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMudmlld0RlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbCh2aWV3RmxhZ3MpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWxBcnIobm9kZURlZkV4cHJzKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVEaXJlY3RpdmVzRm4sXG4gICAgICAgICAgICAgICAgdXBkYXRlUmVuZGVyZXJGbixcbiAgICAgICAgICAgIF0pKV0sIGltcG9ydFR5cGUoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3RGVmaW5pdGlvbikpKTtcbiAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHZpZXdGYWN0b3J5KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlbWVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHVwZGF0ZVN0bXRzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZVVwZGF0ZUZuID0gZnVuY3Rpb24gKHVwZGF0ZVN0bXRzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZUZuO1xuICAgICAgICBpZiAodXBkYXRlU3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlU3RtdHMgPSBbXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb21wb25lbnQuaXNIb3N0ICYmIGZpbmRSZWFkVmFyTmFtZXModXBkYXRlU3RtdHMpLmhhcyhDT01QX1ZBUi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHByZVN0bXRzLnB1c2goQ09NUF9WQVIuc2V0KFZJRVdfVkFSLnByb3AoJ2NvbXBvbmVudCcpKS50b0RlY2xTdG10KHRoaXMuY29tcFR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZUZuID0gZm4oW1xuICAgICAgICAgICAgICAgIG5ldyBGblBhcmFtKENIRUNLX1ZBUi5uYW1lLCBJTkZFUlJFRF9UWVBFKSxcbiAgICAgICAgICAgICAgICBuZXcgRm5QYXJhbShWSUVXX1ZBUi5uYW1lLCBJTkZFUlJFRF9UWVBFKVxuICAgICAgICAgICAgXSwgcHJlU3RtdHMuY29uY2F0KHVwZGF0ZVN0bXRzKSwgSU5GRVJSRURfVFlQRSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVGbiA9IE5VTExfRVhQUjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBkYXRlRm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0TmdDb250ZW50ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICAvLyBuZ0NvbnRlbnREZWYobmdDb250ZW50SW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlcik6IE5vZGVEZWY7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogYXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDQgLyogVHlwZU5nQ29udGVudCAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5uZ0NvbnRlbnREZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSwgbGl0ZXJhbChhc3QuaW5kZXgpXG4gICAgICAgICAgICBdKVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0VGV4dCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gdGV4dERlZihuZ0NvbnRlbnRJbmRleDogbnVtYmVyLCBjb25zdGFudHM6IHN0cmluZ1tdKTogTm9kZURlZjtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMiAvKiBUeXBlVGV4dCAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy50ZXh0RGVmKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGFzdC5uZ0NvbnRlbnRJbmRleCksIGxpdGVyYWxBcnIoW2xpdGVyYWwoYXN0LnZhbHVlKV0pXG4gICAgICAgICAgICBdKVxuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0Qm91bmRUZXh0ID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlSW5kZXggPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgLy8gcmVzZXJ2ZSB0aGUgc3BhY2UgaW4gdGhlIG5vZGVEZWZzIGFycmF5XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXN0V2l0aFNvdXJjZSA9IChhc3QudmFsdWUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnRlciA9IChhc3RXaXRoU291cmNlLmFzdCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnMgPSBpbnRlci5leHByZXNzaW9ucy5tYXAoZnVuY3Rpb24gKGV4cHIsIGJpbmRpbmdJbmRleCkgeyByZXR1cm4gX3RoaXMuX3ByZXByb2Nlc3NVcGRhdGVFeHByZXNzaW9uKHsgbm9kZUluZGV4OiBub2RlSW5kZXgsIGJpbmRpbmdJbmRleDogYmluZGluZ0luZGV4LCBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbiwgY29udGV4dDogQ09NUF9WQVIsIHZhbHVlOiBleHByIH0pOyB9KTtcbiAgICAgICAgLy8gdGV4dERlZihuZ0NvbnRlbnRJbmRleDogbnVtYmVyLCBjb25zdGFudHM6IHN0cmluZ1tdKTogTm9kZURlZjtcbiAgICAgICAgdGhpcy5ub2Rlc1tub2RlSW5kZXhdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiAyIC8qIFR5cGVUZXh0ICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLnRleHREZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSwgbGl0ZXJhbEFycihpbnRlci5zdHJpbmdzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gbGl0ZXJhbChzKTsgfSkpXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHVwZGF0ZVJlbmRlcmVyOiB1cGRhdGVSZW5kZXJlckV4cHJlc3Npb25zXG4gICAgICAgIH0pOyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEVtYmVkZGVkVGVtcGxhdGUgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyByZXNlcnZlIHRoZSBzcGFjZSBpbiB0aGUgbm9kZURlZnMgYXJyYXlcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl92aXNpdEVsZW1lbnRPclRlbXBsYXRlKG5vZGVJbmRleCwgYXN0KSwgZmxhZ3MgPSBfYS5mbGFncywgcXVlcnlNYXRjaGVzRXhwciA9IF9hLnF1ZXJ5TWF0Y2hlc0V4cHIsIGhvc3RFdmVudHMgPSBfYS5ob3N0RXZlbnRzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZFZpc2l0b3IgPSB0aGlzLnZpZXdCdWlsZGVyRmFjdG9yeSh0aGlzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkVmlzaXRvcik7XG4gICAgICAgIGNoaWxkVmlzaXRvci52aXNpdEFsbChhc3QudmFyaWFibGVzLCBhc3QuY2hpbGRyZW4pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZENvdW50ID0gdGhpcy5ub2Rlcy5sZW5ndGggLSBub2RlSW5kZXggLSAxO1xuICAgICAgICAvLyBhbmNob3JEZWYoXG4gICAgICAgIC8vICAgZmxhZ3M6IE5vZGVGbGFncywgbWF0Y2hlZFF1ZXJpZXM6IFtzdHJpbmcsIFF1ZXJ5VmFsdWVUeXBlXVtdLCBuZ0NvbnRlbnRJbmRleDogbnVtYmVyLFxuICAgICAgICAvLyAgIGNoaWxkQ291bnQ6IG51bWJlciwgaGFuZGxlRXZlbnRGbj86IEVsZW1lbnRIYW5kbGVFdmVudEZuLCB0ZW1wbGF0ZUZhY3Rvcnk/OlxuICAgICAgICAvLyAgIFZpZXdEZWZpbml0aW9uRmFjdG9yeSk6IE5vZGVEZWY7XG4gICAgICAgIHRoaXMubm9kZXNbbm9kZUluZGV4XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBhc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMSAvKiBUeXBlRWxlbWVudCAqLyB8IGZsYWdzLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmFuY2hvckRlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChmbGFncyksXG4gICAgICAgICAgICAgICAgcXVlcnlNYXRjaGVzRXhwcixcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGFzdC5uZ0NvbnRlbnRJbmRleCksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChjaGlsZENvdW50KSxcbiAgICAgICAgICAgICAgICBfdGhpcy5fY3JlYXRlRWxlbWVudEhhbmRsZUV2ZW50Rm4obm9kZUluZGV4LCBob3N0RXZlbnRzKSxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZShjaGlsZFZpc2l0b3Iudmlld05hbWUpLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgfSk7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RWxlbWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIC8vIHJlc2VydmUgdGhlIHNwYWNlIGluIHRoZSBub2RlRGVmcyBhcnJheSBzbyB3ZSBjYW4gYWRkIGNoaWxkcmVuXG4gICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZWxOYW1lID0gYXN0Lm5hbWU7XG4gICAgICAgIGlmIChhc3QubmFtZSA9PT0gTkdfQ09OVEFJTkVSX1RBRykge1xuICAgICAgICAgICAgLy8gVXNpbmcgYSBudWxsIGVsZW1lbnQgbmFtZSBjcmVhdGVzIGFuIGFuY2hvci5cbiAgICAgICAgICAgIGVsTmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdmlzaXRFbGVtZW50T3JUZW1wbGF0ZShub2RlSW5kZXgsIGFzdCksIGZsYWdzID0gX2EuZmxhZ3MsIHVzZWRFdmVudHMgPSBfYS51c2VkRXZlbnRzLCBxdWVyeU1hdGNoZXNFeHByID0gX2EucXVlcnlNYXRjaGVzRXhwciwgZGlySG9zdEJpbmRpbmdzID0gX2EuaG9zdEJpbmRpbmdzLCBob3N0RXZlbnRzID0gX2EuaG9zdEV2ZW50cztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5wdXREZWZzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3V0cHV0RGVmcyA9IFtdO1xuICAgICAgICBpZiAoZWxOYW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0QmluZGluZ3MgPSBhc3QuaW5wdXRzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaW5wdXRBc3QpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgY29udGV4dDogLyoqIEB0eXBlIHs/fSAqLyAoQ09NUF9WQVIpLFxuICAgICAgICAgICAgICAgIGlucHV0QXN0OiBpbnB1dEFzdCxcbiAgICAgICAgICAgICAgICBkaXJBc3Q6IG51bGwsXG4gICAgICAgICAgICB9KTsgfSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KGRpckhvc3RCaW5kaW5ncyk7XG4gICAgICAgICAgICBpZiAoaG9zdEJpbmRpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnMgPVxuICAgICAgICAgICAgICAgICAgICBob3N0QmluZGluZ3MubWFwKGZ1bmN0aW9uIChob3N0QmluZGluZywgYmluZGluZ0luZGV4KSB7IHJldHVybiBfdGhpcy5fcHJlcHJvY2Vzc1VwZGF0ZUV4cHJlc3Npb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogaG9zdEJpbmRpbmcuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleDogbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ0luZGV4OiBiaW5kaW5nSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBob3N0QmluZGluZy5pbnB1dEFzdC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhvc3RCaW5kaW5nLmlucHV0QXN0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICBpbnB1dERlZnMgPSBob3N0QmluZGluZ3MubWFwKGZ1bmN0aW9uIChob3N0QmluZGluZykgeyByZXR1cm4gZWxlbWVudEJpbmRpbmdEZWYoaG9zdEJpbmRpbmcuaW5wdXRBc3QsIGhvc3RCaW5kaW5nLmRpckFzdCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0RGVmcyA9IHVzZWRFdmVudHMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfYVswXSwgZXZlbnROYW1lID0gX2FbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW2xpdGVyYWwodGFyZ2V0KSwgbGl0ZXJhbChldmVudE5hbWUpXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZVZpc2l0QWxsKHRoaXMsIGFzdC5jaGlsZHJlbik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNoaWxkQ291bnQgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIG5vZGVJbmRleCAtIDE7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBBc3QgPSBhc3QuZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXJBc3QpIHsgcmV0dXJuIGRpckFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wUmVuZGVyZXJUeXBlID0gTlVMTF9FWFBSO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wVmlldyA9IE5VTExfRVhQUjtcbiAgICAgICAgaWYgKGNvbXBBc3QpIHtcbiAgICAgICAgICAgIGNvbXBWaWV3ID0gaW1wb3J0RXhwcih7IHJlZmVyZW5jZTogY29tcEFzdC5kaXJlY3RpdmUuY29tcG9uZW50Vmlld1R5cGUgfSk7XG4gICAgICAgICAgICBjb21wUmVuZGVyZXJUeXBlID0gaW1wb3J0RXhwcih7IHJlZmVyZW5jZTogY29tcEFzdC5kaXJlY3RpdmUucmVuZGVyZXJUeXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsZW1lbnREZWYoXG4gICAgICAgIC8vICAgZmxhZ3M6IE5vZGVGbGFncywgbWF0Y2hlZFF1ZXJpZXNEc2w6IFtzdHJpbmcgfCBudW1iZXIsIFF1ZXJ5VmFsdWVUeXBlXVtdLFxuICAgICAgICAvLyAgIG5nQ29udGVudEluZGV4OiBudW1iZXIsIGNoaWxkQ291bnQ6IG51bWJlciwgbmFtZXNwYWNlQW5kTmFtZTogc3RyaW5nLFxuICAgICAgICAvLyAgIGZpeGVkQXR0cnM6IFtzdHJpbmcsIHN0cmluZ11bXSA9IFtdLFxuICAgICAgICAvLyAgIGJpbmRpbmdzPzogW0JpbmRpbmdGbGFncywgc3RyaW5nLCBzdHJpbmcgfCBTZWN1cml0eUNvbnRleHRdW10sXG4gICAgICAgIC8vICAgb3V0cHV0cz86IChbT3V0cHV0VHlwZS5FbGVtZW50T3V0cHV0IHwgT3V0cHV0VHlwZS5EaXJlY3RpdmVIb3N0T3V0cHV0LCBzdHJpbmcsIHN0cmluZ10pW10sXG4gICAgICAgIC8vICAgaGFuZGxlRXZlbnQ/OiBFbGVtZW50SGFuZGxlRXZlbnRGbixcbiAgICAgICAgLy8gICBjb21wb25lbnRWaWV3PzogKCkgPT4gVmlld0RlZmluaXRpb24sIGNvbXBvbmVudFJlbmRlcmVyVHlwZT86IFJlbmRlcmVyVHlwZTIpOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogYXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDEgLyogVHlwZUVsZW1lbnQgKi8gfCBmbGFncyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5lbGVtZW50RGVmKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSxcbiAgICAgICAgICAgICAgICBxdWVyeU1hdGNoZXNFeHByLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoYXN0Lm5nQ29udGVudEluZGV4KSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGNoaWxkQ291bnQpLFxuICAgICAgICAgICAgICAgIGxpdGVyYWwoZWxOYW1lKSxcbiAgICAgICAgICAgICAgICBlbE5hbWUgPyBmaXhlZEF0dHJzRGVmKGFzdCkgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgaW5wdXREZWZzLmxlbmd0aCA/IGxpdGVyYWxBcnIoaW5wdXREZWZzKSA6IE5VTExfRVhQUixcbiAgICAgICAgICAgICAgICBvdXRwdXREZWZzLmxlbmd0aCA/IGxpdGVyYWxBcnIob3V0cHV0RGVmcykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgX3RoaXMuX2NyZWF0ZUVsZW1lbnRIYW5kbGVFdmVudEZuKG5vZGVJbmRleCwgaG9zdEV2ZW50cyksXG4gICAgICAgICAgICAgICAgY29tcFZpZXcsXG4gICAgICAgICAgICAgICAgY29tcFJlbmRlcmVyVHlwZSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdXBkYXRlUmVuZGVyZXI6IHVwZGF0ZVJlbmRlcmVyRXhwcmVzc2lvbnNcbiAgICAgICAgfSk7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5vZGVJbmRleFxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX3Zpc2l0RWxlbWVudE9yVGVtcGxhdGUgPSBmdW5jdGlvbiAobm9kZUluZGV4LCBhc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSAwO1xuICAgICAgICBpZiAoYXN0Lmhhc1ZpZXdDb250YWluZXIpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IDgzODg2MDggLyogRW1iZWRkZWRWaWV3cyAqLztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1c2VkRXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICBhc3Qub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hID0gZWxlbWVudEV2ZW50TmFtZUFuZFRhcmdldChldmVudCwgbnVsbCksIG5hbWUgPSBfYS5uYW1lLCB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgICAgICAgICB1c2VkRXZlbnRzLnNldCjJtWVsZW1lbnRFdmVudEZ1bGxOYW1lKHRhcmdldCwgbmFtZSksIFt0YXJnZXQsIG5hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFzdC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpckFzdCkge1xuICAgICAgICAgICAgZGlyQXN0Lmhvc3RFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBlbGVtZW50RXZlbnROYW1lQW5kVGFyZ2V0KGV2ZW50LCBkaXJBc3QpLCBuYW1lID0gX2EubmFtZSwgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHVzZWRFdmVudHMuc2V0KMm1ZWxlbWVudEV2ZW50RnVsbE5hbWUodGFyZ2V0LCBuYW1lKSwgW3RhcmdldCwgbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBob3N0QmluZGluZ3MgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdEV2ZW50cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJQcm92aWRlciA9IGNyZWF0ZUNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcihhc3QuZGlyZWN0aXZlcyk7XG4gICAgICAgIGlmIChjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJQcm92aWRlcikge1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRQcm92aWRlcihjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJQcm92aWRlciwgYXN0LnF1ZXJ5TWF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXN0LnByb3ZpZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwcm92aWRlckFzdCwgcHJvdmlkZXJJbmRleCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyQXN0O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlySW5kZXg7XG4gICAgICAgICAgICBhc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChsb2NhbERpckFzdCwgaSkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbERpckFzdC5kaXJlY3RpdmUudHlwZS5yZWZlcmVuY2UgPT09IHRva2VuUmVmZXJlbmNlKHByb3ZpZGVyQXN0LnRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJBc3QgPSBsb2NhbERpckFzdDtcbiAgICAgICAgICAgICAgICAgICAgZGlySW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGRpckFzdCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLl92aXNpdERpcmVjdGl2ZShwcm92aWRlckFzdCwgZGlyQXN0LCBkaXJJbmRleCwgbm9kZUluZGV4LCBhc3QucmVmZXJlbmNlcywgYXN0LnF1ZXJ5TWF0Y2hlcywgdXNlZEV2ZW50cywgX3RoaXMuc3RhdGljUXVlcnlJZHMuZ2V0KC8qKiBAdHlwZSB7P30gKi8gKGFzdCkpKSwgZGlySG9zdEJpbmRpbmdzID0gX2EuaG9zdEJpbmRpbmdzLCBkaXJIb3N0RXZlbnRzID0gX2EuaG9zdEV2ZW50cztcbiAgICAgICAgICAgICAgICBob3N0QmluZGluZ3MucHVzaC5hcHBseShob3N0QmluZGluZ3MsIGRpckhvc3RCaW5kaW5ncyk7XG4gICAgICAgICAgICAgICAgaG9zdEV2ZW50cy5wdXNoLmFwcGx5KGhvc3RFdmVudHMsIGRpckhvc3RFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Zpc2l0UHJvdmlkZXIocHJvdmlkZXJBc3QsIGFzdC5xdWVyeU1hdGNoZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcXVlcnlNYXRjaEV4cHJzID0gW107XG4gICAgICAgIGFzdC5xdWVyeU1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlVHlwZTtcbiAgICAgICAgICAgIGlmICh0b2tlblJlZmVyZW5jZShtYXRjaC52YWx1ZSkgPT09IHJlc29sdmVJZGVudGlmaWVyKElkZW50aWZpZXJzLkVsZW1lbnRSZWYpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMCAvKiBFbGVtZW50UmVmICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5SZWZlcmVuY2UobWF0Y2gudmFsdWUpID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5WaWV3Q29udGFpbmVyUmVmKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlVHlwZSA9IDMgLyogVmlld0NvbnRhaW5lclJlZiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuUmVmZXJlbmNlKG1hdGNoLnZhbHVlKSA9PT0gcmVzb2x2ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuVGVtcGxhdGVSZWYpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlID0gMiAvKiBUZW1wbGF0ZVJlZiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwobWF0Y2gucXVlcnlJZCksIGxpdGVyYWwodmFsdWVUeXBlKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFzdC5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVUeXBlO1xuICAgICAgICAgICAgaWYgKCFyZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAxIC8qIFJlbmRlckVsZW1lbnQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlblJlZmVyZW5jZShyZWYudmFsdWUpID09PSByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5UZW1wbGF0ZVJlZikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSAyIC8qIFRlbXBsYXRlUmVmICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmTm9kZUluZGljZXNbcmVmLm5hbWVdID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwocmVmLm5hbWUpLCBsaXRlcmFsKHZhbHVlVHlwZSldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhc3Qub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXRBc3QpIHtcbiAgICAgICAgICAgIGhvc3RFdmVudHMucHVzaCh7IGNvbnRleHQ6IENPTVBfVkFSLCBldmVudEFzdDogb3V0cHV0QXN0LCBkaXJBc3Q6IG51bGwgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLFxuICAgICAgICAgICAgdXNlZEV2ZW50czogQXJyYXkuZnJvbSh1c2VkRXZlbnRzLnZhbHVlcygpKSxcbiAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlc0V4cHI6IHF1ZXJ5TWF0Y2hFeHBycy5sZW5ndGggPyBsaXRlcmFsQXJyKHF1ZXJ5TWF0Y2hFeHBycykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICBob3N0QmluZGluZ3M6IGhvc3RCaW5kaW5ncyxcbiAgICAgICAgICAgIGhvc3RFdmVudHM6IGhvc3RFdmVudHNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcHJvdmlkZXJBc3RcbiAgICAgKiBAcGFyYW0gez99IGRpckFzdFxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlSW5kZXhcbiAgICAgKiBAcGFyYW0gez99IGVsZW1lbnROb2RlSW5kZXhcbiAgICAgKiBAcGFyYW0gez99IHJlZnNcbiAgICAgKiBAcGFyYW0gez99IHF1ZXJ5TWF0Y2hlc1xuICAgICAqIEBwYXJhbSB7P30gdXNlZEV2ZW50c1xuICAgICAqIEBwYXJhbSB7P30gcXVlcnlJZHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXREaXJlY3RpdmUgPSBmdW5jdGlvbiAocHJvdmlkZXJBc3QsIGRpckFzdCwgZGlyZWN0aXZlSW5kZXgsIGVsZW1lbnROb2RlSW5kZXgsIHJlZnMsIHF1ZXJ5TWF0Y2hlcywgdXNlZEV2ZW50cywgcXVlcnlJZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4ID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICAgIC8vIHJlc2VydmUgdGhlIHNwYWNlIGluIHRoZSBub2RlRGVmcyBhcnJheSBzbyB3ZSBjYW4gYWRkIGNoaWxkcmVuXG4gICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgZGlyQXN0LmRpcmVjdGl2ZS5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5LCBxdWVyeUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeUlkID0gZGlyQXN0LmNvbnRlbnRRdWVyeVN0YXJ0SWQgKyBxdWVyeUluZGV4O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSAzMzU1NDQzMiAvKiBUeXBlQ29udGVudFF1ZXJ5ICovIHwgY2FsY1N0YXRpY0R5bmFtaWNRdWVyeUZsYWdzKHF1ZXJ5SWRzLCBxdWVyeUlkLCBxdWVyeS5maXJzdCk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nVHlwZSA9IHF1ZXJ5LmZpcnN0ID8gMCAvKiBGaXJzdCAqLyA6IDE7XG4gICAgICAgICAgICBfdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogZGlyQXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgbm9kZUZsYWdzOiBmbGFncyxcbiAgICAgICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMucXVlcnlEZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKGZsYWdzKSwgbGl0ZXJhbChxdWVyeUlkKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IExpdGVyYWxNYXBFeHByKFtuZXcgTGl0ZXJhbE1hcEVudHJ5KHF1ZXJ5LnByb3BlcnR5TmFtZSwgbGl0ZXJhbChiaW5kaW5nVHlwZSkpXSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vdGU6IHRoZSBvcGVyYXRpb24gYmVsb3cgbWlnaHQgYWxzbyBjcmVhdGUgbmV3IG5vZGVEZWZzLFxuICAgICAgICAvLyBidXQgd2UgZG9uJ3Qgd2FudCB0aGVtIHRvIGJlIGEgY2hpbGQgb2YgYSBkaXJlY3RpdmUsXG4gICAgICAgIC8vIGFzIHRoZXkgbWlnaHQgYmUgYSBwcm92aWRlci9waXBlIG9uIHRoZWlyIG93bi5cbiAgICAgICAgLy8gSS5lLiB3ZSBvbmx5IGFsbG93IHF1ZXJpZXMgYXMgY2hpbGRyZW4gb2YgZGlyZWN0aXZlcyBub2Rlcy5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRDb3VudCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gbm9kZUluZGV4IC0gMTtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdmlzaXRQcm92aWRlck9yRGlyZWN0aXZlKHByb3ZpZGVyQXN0LCBxdWVyeU1hdGNoZXMpLCBmbGFncyA9IF9hLmZsYWdzLCBxdWVyeU1hdGNoRXhwcnMgPSBfYS5xdWVyeU1hdGNoRXhwcnMsIHByb3ZpZGVyRXhwciA9IF9hLnByb3ZpZGVyRXhwciwgZGVwc0V4cHIgPSBfYS5kZXBzRXhwcjtcbiAgICAgICAgcmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIGlmIChyZWYudmFsdWUgJiYgdG9rZW5SZWZlcmVuY2UocmVmLnZhbHVlKSA9PT0gdG9rZW5SZWZlcmVuY2UocHJvdmlkZXJBc3QudG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmTm9kZUluZGljZXNbcmVmLm5hbWVdID0gbm9kZUluZGV4O1xuICAgICAgICAgICAgICAgIHF1ZXJ5TWF0Y2hFeHBycy5wdXNoKGxpdGVyYWxBcnIoW2xpdGVyYWwocmVmLm5hbWUpLCBsaXRlcmFsKDQgLyogUHJvdmlkZXIgKi8pXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpckFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IDE2Mzg0IC8qIENvbXBvbmVudCAqLztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dERlZnMgPSBkaXJBc3QuaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXRBc3QsIGlucHV0SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcFZhbHVlID0gbGl0ZXJhbEFycihbbGl0ZXJhbChpbnB1dEluZGV4KSwgbGl0ZXJhbChpbnB1dEFzdC5kaXJlY3RpdmVOYW1lKV0pO1xuICAgICAgICAgICAgLy8gTm90ZTogaXQncyBpbXBvcnRhbnQgdG8gbm90IHF1b3RlIHRoZSBrZXkgc28gdGhhdCB3ZSBjYW4gY2FwdHVyZSByZW5hbWVzIGJ5IG1pbmlmaWVycyFcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEVudHJ5KGlucHV0QXN0LmRpcmVjdGl2ZU5hbWUsIG1hcFZhbHVlLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXREZWZzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpck1ldGEgPSBkaXJBc3QuZGlyZWN0aXZlO1xuICAgICAgICBPYmplY3Qua2V5cyhkaXJNZXRhLm91dHB1dHMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBldmVudE5hbWUgPSBkaXJNZXRhLm91dHB1dHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHVzZWRFdmVudHMuaGFzKGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBpdCdzIGltcG9ydGFudCB0byBub3QgcXVvdGUgdGhlIGtleSBzbyB0aGF0IHdlIGNhbiBjYXB0dXJlIHJlbmFtZXMgYnkgbWluaWZpZXJzIVxuICAgICAgICAgICAgICAgIG91dHB1dERlZnMucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KHByb3BOYW1lLCBsaXRlcmFsKGV2ZW50TmFtZSksIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVEaXJlY3RpdmVFeHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBpZiAoZGlyQXN0LmlucHV0cy5sZW5ndGggfHwgKGZsYWdzICYgKDEzMTA3MiAvKiBEb0NoZWNrICovIHwgMzI3NjggLyogT25Jbml0ICovKSkgPiAwKSB7XG4gICAgICAgICAgICB1cGRhdGVEaXJlY3RpdmVFeHByZXNzaW9ucyA9XG4gICAgICAgICAgICAgICAgZGlyQXN0LmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0LCBiaW5kaW5nSW5kZXgpIHsgcmV0dXJuIF90aGlzLl9wcmVwcm9jZXNzVXBkYXRlRXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleDogbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nSW5kZXg6IGJpbmRpbmdJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogaW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogQ09NUF9WQVIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJDb250ZXh0RXhwciA9IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5ub2RlVmFsdWUpKS5jYWxsRm4oW1xuICAgICAgICAgICAgVklFV19WQVIsIGxpdGVyYWwobm9kZUluZGV4KVxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdEJpbmRpbmdzID0gZGlyQXN0Lmhvc3RQcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAoaW5wdXRBc3QpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBjb250ZXh0OiBkaXJDb250ZXh0RXhwcixcbiAgICAgICAgICAgIGRpckFzdDogZGlyQXN0LFxuICAgICAgICAgICAgaW5wdXRBc3Q6IGlucHV0QXN0LFxuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RFdmVudHMgPSBkaXJBc3QuaG9zdEV2ZW50cy5tYXAoZnVuY3Rpb24gKGhvc3RFdmVudEFzdCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGRpckNvbnRleHRFeHByLFxuICAgICAgICAgICAgZXZlbnRBc3Q6IGhvc3RFdmVudEFzdCwgZGlyQXN0OiBkaXJBc3QsXG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgLy8gZGlyZWN0aXZlRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIG1hdGNoZWRRdWVyaWVzOiBbc3RyaW5nLCBRdWVyeVZhbHVlVHlwZV1bXSwgY2hpbGRDb3VudDogbnVtYmVyLCBjdG9yOlxuICAgICAgICAvLyAgIGFueSxcbiAgICAgICAgLy8gICBkZXBzOiAoW0RlcEZsYWdzLCBhbnldIHwgYW55KVtdLCBwcm9wcz86IHtbbmFtZTogc3RyaW5nXTogW251bWJlciwgc3RyaW5nXX0sXG4gICAgICAgIC8vICAgb3V0cHV0cz86IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSwgY29tcG9uZW50PzogKCkgPT4gVmlld0RlZmluaXRpb24pOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogZGlyQXN0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDgxOTIgLyogVHlwZURpcmVjdGl2ZSAqLyB8IGZsYWdzLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLmRpcmVjdGl2ZURlZikpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChmbGFncyksIHF1ZXJ5TWF0Y2hFeHBycy5sZW5ndGggPyBsaXRlcmFsQXJyKHF1ZXJ5TWF0Y2hFeHBycykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChjaGlsZENvdW50KSwgcHJvdmlkZXJFeHByLCBkZXBzRXhwcixcbiAgICAgICAgICAgICAgICBpbnB1dERlZnMubGVuZ3RoID8gbmV3IExpdGVyYWxNYXBFeHByKGlucHV0RGVmcykgOiBOVUxMX0VYUFIsXG4gICAgICAgICAgICAgICAgb3V0cHV0RGVmcy5sZW5ndGggPyBuZXcgTGl0ZXJhbE1hcEV4cHIob3V0cHV0RGVmcykgOiBOVUxMX0VYUFJcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdXBkYXRlRGlyZWN0aXZlczogdXBkYXRlRGlyZWN0aXZlRXhwcmVzc2lvbnMsXG4gICAgICAgICAgICBkaXJlY3RpdmU6IGRpckFzdC5kaXJlY3RpdmUudHlwZSxcbiAgICAgICAgfSk7IH07XG4gICAgICAgIHJldHVybiB7IGhvc3RCaW5kaW5nczogaG9zdEJpbmRpbmdzLCBob3N0RXZlbnRzOiBob3N0RXZlbnRzIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHByb3ZpZGVyQXN0XG4gICAgICogQHBhcmFtIHs/fSBxdWVyeU1hdGNoZXNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fdmlzaXRQcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlckFzdCwgcXVlcnlNYXRjaGVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyByZXNlcnZlIHRoZSBzcGFjZSBpbiB0aGUgbm9kZURlZnMgYXJyYXkgc28gd2UgY2FuIGFkZCBjaGlsZHJlblxuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3Zpc2l0UHJvdmlkZXJPckRpcmVjdGl2ZShwcm92aWRlckFzdCwgcXVlcnlNYXRjaGVzKSwgZmxhZ3MgPSBfYS5mbGFncywgcXVlcnlNYXRjaEV4cHJzID0gX2EucXVlcnlNYXRjaEV4cHJzLCBwcm92aWRlckV4cHIgPSBfYS5wcm92aWRlckV4cHIsIGRlcHNFeHByID0gX2EuZGVwc0V4cHI7XG4gICAgICAgIC8vIHByb3ZpZGVyRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIG1hdGNoZWRRdWVyaWVzOiBbc3RyaW5nLCBRdWVyeVZhbHVlVHlwZV1bXSwgdG9rZW46YW55LFxuICAgICAgICAvLyAgIHZhbHVlOiBhbnksIGRlcHM6IChbRGVwRmxhZ3MsIGFueV0gfCBhbnkpW10pOiBOb2RlRGVmO1xuICAgICAgICB0aGlzLm5vZGVzW25vZGVJbmRleF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3BhbjogcHJvdmlkZXJBc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogZmxhZ3MsXG4gICAgICAgICAgICBub2RlRGVmOiBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMucHJvdmlkZXJEZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLCBxdWVyeU1hdGNoRXhwcnMubGVuZ3RoID8gbGl0ZXJhbEFycihxdWVyeU1hdGNoRXhwcnMpIDogTlVMTF9FWFBSLFxuICAgICAgICAgICAgICAgIHRva2VuRXhwcihwcm92aWRlckFzdC50b2tlbiksIHByb3ZpZGVyRXhwciwgZGVwc0V4cHJcbiAgICAgICAgICAgIF0pXG4gICAgICAgIH0pOyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlckFzdFxuICAgICAqIEBwYXJhbSB7P30gcXVlcnlNYXRjaGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX3Zpc2l0UHJvdmlkZXJPckRpcmVjdGl2ZSA9IGZ1bmN0aW9uIChwcm92aWRlckFzdCwgcXVlcnlNYXRjaGVzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYWdzID0gMDtcbiAgICAgICAgaWYgKCFwcm92aWRlckFzdC5lYWdlcikge1xuICAgICAgICAgICAgZmxhZ3MgfD0gMjA0OCAvKiBMYXp5UHJvdmlkZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVyQXN0LnByb3ZpZGVyVHlwZSA9PT0gUHJvdmlkZXJBc3RUeXBlLlByaXZhdGVTZXJ2aWNlKSB7XG4gICAgICAgICAgICBmbGFncyB8PSA0MDk2IC8qIFByaXZhdGVQcm92aWRlciAqLztcbiAgICAgICAgfVxuICAgICAgICBwcm92aWRlckFzdC5saWZlY3ljbGVIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaWZlY3ljbGVIb29rKSB7XG4gICAgICAgICAgICAvLyBmb3IgcmVndWxhciBwcm92aWRlcnMsIHdlIG9ubHkgc3VwcG9ydCBuZ09uRGVzdHJveVxuICAgICAgICAgICAgaWYgKGxpZmVjeWNsZUhvb2sgPT09IMm1TGlmZWN5Y2xlSG9va3MuT25EZXN0cm95IHx8XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJBc3QucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJBc3QucHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gbGlmZWN5Y2xlSG9va1RvTm9kZUZsYWcobGlmZWN5Y2xlSG9vayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBxdWVyeU1hdGNoRXhwcnMgPSBbXTtcbiAgICAgICAgcXVlcnlNYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5SZWZlcmVuY2UobWF0Y2gudmFsdWUpID09PSB0b2tlblJlZmVyZW5jZShwcm92aWRlckFzdC50b2tlbikpIHtcbiAgICAgICAgICAgICAgICBxdWVyeU1hdGNoRXhwcnMucHVzaChsaXRlcmFsQXJyKFtsaXRlcmFsKG1hdGNoLnF1ZXJ5SWQpLCBsaXRlcmFsKDQgLyogUHJvdmlkZXIgKi8pXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9hID0gcHJvdmlkZXJEZWYocHJvdmlkZXJBc3QpLCBwcm92aWRlckV4cHIgPSBfYS5wcm92aWRlckV4cHIsIGRlcHNFeHByID0gX2EuZGVwc0V4cHIsIHByb3ZpZGVyVHlwZSA9IF9hLmZsYWdzO1xuICAgICAgICByZXR1cm4geyBmbGFnczogZmxhZ3MgfCBwcm92aWRlclR5cGUsIHF1ZXJ5TWF0Y2hFeHByczogcXVlcnlNYXRjaEV4cHJzLCBwcm92aWRlckV4cHI6IHByb3ZpZGVyRXhwciwgZGVwc0V4cHI6IGRlcHNFeHByIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5nZXRMb2NhbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09IEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyclZpZXdFeHByID0gVklFV19WQVI7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyckJ1aWxkZXIgPSB0aGlzOyBjdXJyQnVpbGRlcjsgY3VyckJ1aWxkZXIgPSBjdXJyQnVpbGRlci5wYXJlbnQsXG4gICAgICAgICAgICBjdXJyVmlld0V4cHIgPSBjdXJyVmlld0V4cHIucHJvcCgncGFyZW50JykuY2FzdChEWU5BTUlDX1RZUEUpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayByZWZlcmVuY2VzXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZWZOb2RlSW5kZXggPSBjdXJyQnVpbGRlci5yZWZOb2RlSW5kaWNlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChyZWZOb2RlSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMubm9kZVZhbHVlKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICAgICAgY3VyclZpZXdFeHByLCBsaXRlcmFsKHJlZk5vZGVJbmRleClcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIHZhcmlhYmxlc1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFyQXN0ID0gY3VyckJ1aWxkZXIudmFyaWFibGVzLmZpbmQoZnVuY3Rpb24gKHZhckFzdCkgeyByZXR1cm4gdmFyQXN0Lm5hbWUgPT09IG5hbWU7IH0pO1xuICAgICAgICAgICAgaWYgKHZhckFzdCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhclZhbHVlID0gdmFyQXN0LnZhbHVlIHx8IElNUExJQ0lUX1RFTVBMQVRFX1ZBUjtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyclZpZXdFeHByLnByb3AoJ2NvbnRleHQnKS5wcm9wKHZhclZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30gYXJnQ291bnRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoc291cmNlU3BhbiwgYXJnQ291bnQpIHtcbiAgICAgICAgaWYgKGFyZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZUV4cHJfMSA9IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5FTVBUWV9BUlJBWSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlRXhwcl8xOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyBwdXJlQXJyYXlEZWYoYXJnQ291bnQ6IG51bWJlcik6IE5vZGVEZWY7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgc291cmNlU3Bhbjogc291cmNlU3BhbixcbiAgICAgICAgICAgIG5vZGVGbGFnczogMTYgLyogVHlwZVB1cmVBcnJheSAqLyxcbiAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5wdXJlQXJyYXlEZWYpKS5jYWxsRm4oW2xpdGVyYWwoYXJnQ291bnQpXSlcbiAgICAgICAgfSk7IH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGNhbGxDaGVja1N0bXQobm9kZUluZGV4LCBhcmdzKTsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSB7P30ga2V5c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmNyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoc291cmNlU3Bhbiwga2V5cykge1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlRXhwcl8yID0gaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLkVNUFRZX01BUCkpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlRXhwcl8yOyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVJbmRleCA9IHRoaXMubm9kZXMubGVuZ3RoO1xuICAgICAgICAvLyBmdW5jdGlvbiBwdXJlT2JqZWN0RGVmKHByb3BlcnR5TmFtZXM6IHN0cmluZ1tdKTogTm9kZURlZlxuICAgICAgICB0aGlzLm5vZGVzLnB1c2goZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IHNvdXJjZVNwYW4sXG4gICAgICAgICAgICBub2RlRmxhZ3M6IDMyIC8qIFR5cGVQdXJlT2JqZWN0ICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLnB1cmVPYmplY3REZWYpKVxuICAgICAgICAgICAgICAgIC5jYWxsRm4oW2xpdGVyYWxBcnIoa2V5cy5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gbGl0ZXJhbChrZXkpOyB9KSldKVxuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gY2FsbENoZWNrU3RtdChub2RlSW5kZXgsIGFyZ3MpOyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBhcmdDb3VudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLmNyZWF0ZVBpcGVDb252ZXJ0ZXIgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgbmFtZSwgYXJnQ291bnQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZSA9IHRoaXMudXNlZFBpcGVzLmZpbmQoZnVuY3Rpb24gKHBpcGVTdW1tYXJ5KSB7IHJldHVybiBwaXBlU3VtbWFyeS5uYW1lID09PSBuYW1lOyB9KTtcbiAgICAgICAgaWYgKHBpcGUucHVyZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUluZGV4XzEgPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uIHB1cmVQaXBlRGVmKGFyZ0NvdW50OiBudW1iZXIpOiBOb2RlRGVmO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogZXhwcmVzc2lvbi5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgIG5vZGVGbGFnczogNjQgLyogVHlwZVB1cmVQaXBlICovLFxuICAgICAgICAgICAgICAgIG5vZGVEZWY6IGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy5wdXJlUGlwZURlZikpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsRm4oW2xpdGVyYWwoYXJnQ291bnQpXSlcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgIC8vIGZpbmQgdW5kZXJseWluZyBwaXBlIGluIHRoZSBjb21wb25lbnQgdmlld1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcFZpZXdFeHByID0gVklFV19WQVI7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wQnVpbGRlciA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoY29tcEJ1aWxkZXIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29tcEJ1aWxkZXIgPSBjb21wQnVpbGRlci5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgY29tcFZpZXdFeHByID0gY29tcFZpZXdFeHByLnByb3AoJ3BhcmVudCcpLmNhc3QoRFlOQU1JQ19UWVBFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVOb2RlSW5kZXggPSBjb21wQnVpbGRlci5wdXJlUGlwZU5vZGVJbmRpY2VzW25hbWVdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGlwZVZhbHVlRXhwcl8xID0gaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLm5vZGVWYWx1ZSkpLmNhbGxGbihbXG4gICAgICAgICAgICAgICAgY29tcFZpZXdFeHByLCBsaXRlcmFsKHBpcGVOb2RlSW5kZXgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gY2FsbFVud3JhcFZhbHVlKGV4cHJlc3Npb24ubm9kZUluZGV4LCBleHByZXNzaW9uLmJpbmRpbmdJbmRleCwgY2FsbENoZWNrU3RtdChub2RlSW5kZXhfMSwgW3BpcGVWYWx1ZUV4cHJfMV0uY29uY2F0KGFyZ3MpKSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlSW5kZXggPSB0aGlzLl9jcmVhdGVQaXBlKGV4cHJlc3Npb24uc291cmNlU3BhbiwgcGlwZSk7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlVmFsdWVFeHByXzEgPSBpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMubm9kZVZhbHVlKSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBWSUVXX1ZBUiwgbGl0ZXJhbChub2RlSW5kZXgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykgeyByZXR1cm4gY2FsbFVud3JhcFZhbHVlKGV4cHJlc3Npb24ubm9kZUluZGV4LCBleHByZXNzaW9uLmJpbmRpbmdJbmRleCwgbm9kZVZhbHVlRXhwcl8xLmNhbGxNZXRob2QoJ3RyYW5zZm9ybScsIGFyZ3MpKTsgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIHs/fSBwaXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZVBpcGUgPSBmdW5jdGlvbiAoc291cmNlU3BhbiwgcGlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlSW5kZXggPSB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmxhZ3MgPSAwO1xuICAgICAgICBwaXBlLnR5cGUubGlmZWN5Y2xlSG9va3MuZm9yRWFjaChmdW5jdGlvbiAobGlmZWN5Y2xlSG9vaykge1xuICAgICAgICAgICAgLy8gZm9yIHBpcGVzLCB3ZSBvbmx5IHN1cHBvcnQgbmdPbkRlc3Ryb3lcbiAgICAgICAgICAgIGlmIChsaWZlY3ljbGVIb29rID09PSDJtUxpZmVjeWNsZUhvb2tzLk9uRGVzdHJveSkge1xuICAgICAgICAgICAgICAgIGZsYWdzIHw9IGxpZmVjeWNsZUhvb2tUb05vZGVGbGFnKGxpZmVjeWNsZUhvb2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwRXhwcnMgPSBwaXBlLnR5cGUuZGlEZXBzLm1hcChkZXBEZWYpO1xuICAgICAgICAvLyBmdW5jdGlvbiBwaXBlRGVmKFxuICAgICAgICAvLyAgIGZsYWdzOiBOb2RlRmxhZ3MsIGN0b3I6IGFueSwgZGVwczogKFtEZXBGbGFncywgYW55XSB8IGFueSlbXSk6IE5vZGVEZWZcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBzb3VyY2VTcGFuLFxuICAgICAgICAgICAgbm9kZUZsYWdzOiA4IC8qIFR5cGVQaXBlICovLFxuICAgICAgICAgICAgbm9kZURlZjogaW1wb3J0RXhwcihjcmVhdGVJZGVudGlmaWVyKElkZW50aWZpZXJzLnBpcGVEZWYpKS5jYWxsRm4oW1xuICAgICAgICAgICAgICAgIGxpdGVyYWwoZmxhZ3MpLCBpbXBvcnRFeHByKHBpcGUudHlwZSksIGxpdGVyYWxBcnIoZGVwRXhwcnMpXG4gICAgICAgICAgICBdKVxuICAgICAgICB9KTsgfSk7XG4gICAgICAgIHJldHVybiBub2RlSW5kZXg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS5fcHJlcHJvY2Vzc1VwZGF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZUluZGV4OiBleHByZXNzaW9uLm5vZGVJbmRleCxcbiAgICAgICAgICAgIGJpbmRpbmdJbmRleDogZXhwcmVzc2lvbi5iaW5kaW5nSW5kZXgsXG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBleHByZXNzaW9uLnNvdXJjZVNwYW4sXG4gICAgICAgICAgICBjb250ZXh0OiBleHByZXNzaW9uLmNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zKHtcbiAgICAgICAgICAgICAgICBjcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXI6IGZ1bmN0aW9uIChhcmdDb3VudCkgeyByZXR1cm4gX3RoaXMuY3JlYXRlTGl0ZXJhbEFycmF5Q29udmVydGVyKGV4cHJlc3Npb24uc291cmNlU3BhbiwgYXJnQ291bnQpOyB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXI6IGZ1bmN0aW9uIChrZXlzKSB7IHJldHVybiBfdGhpcy5jcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyKGV4cHJlc3Npb24uc291cmNlU3Bhbiwga2V5cyk7IH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlUGlwZUNvbnZlcnRlcjogZnVuY3Rpb24gKG5hbWUsIGFyZ0NvdW50KSB7IHJldHVybiBfdGhpcy5jcmVhdGVQaXBlQ29udmVydGVyKGV4cHJlc3Npb24sIG5hbWUsIGFyZ0NvdW50KTsgfVxuICAgICAgICAgICAgfSwgZXhwcmVzc2lvbi52YWx1ZSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVOb2RlRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVCaW5kaW5nQ291bnQgPSAwO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cGRhdGVSZW5kZXJlclN0bXRzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZURpcmVjdGl2ZXNTdG10cyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub2RlRGVmRXhwcnMgPSB0aGlzLm5vZGVzLm1hcChmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBmYWN0b3J5KCksIG5vZGVEZWYgPSBfYS5ub2RlRGVmLCBub2RlRmxhZ3MgPSBfYS5ub2RlRmxhZ3MsIHVwZGF0ZURpcmVjdGl2ZXMgPSBfYS51cGRhdGVEaXJlY3RpdmVzLCB1cGRhdGVSZW5kZXJlciA9IF9hLnVwZGF0ZVJlbmRlcmVyLCBzb3VyY2VTcGFuID0gX2Euc291cmNlU3BhbjtcbiAgICAgICAgICAgIGlmICh1cGRhdGVSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVJlbmRlcmVyU3RtdHMucHVzaC5hcHBseSh1cGRhdGVSZW5kZXJlclN0bXRzLCBjcmVhdGVVcGRhdGVTdGF0ZW1lbnRzKG5vZGVJbmRleCwgc291cmNlU3BhbiwgdXBkYXRlUmVuZGVyZXIsIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlRGlyZWN0aXZlcykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZURpcmVjdGl2ZXNTdG10cy5wdXNoLmFwcGx5KHVwZGF0ZURpcmVjdGl2ZXNTdG10cywgY3JlYXRlVXBkYXRlU3RhdGVtZW50cyhub2RlSW5kZXgsIHNvdXJjZVNwYW4sIHVwZGF0ZURpcmVjdGl2ZXMsIChub2RlRmxhZ3MgJiAoMTMxMDcyIC8qIERvQ2hlY2sgKi8gfCAzMjc2OCAvKiBPbkluaXQgKi8pKSA+IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIHVzZSBhIGNvbW1hIGV4cHJlc3Npb24gdG8gY2FsbCB0aGUgbG9nIGZ1bmN0aW9uIGJlZm9yZVxuICAgICAgICAgICAgLy8gdGhlIG5vZGVEZWYgZnVuY3Rpb24sIGJ1dCBzdGlsbCB1c2UgdGhlIHJlc3VsdCBvZiB0aGUgbm9kZURlZiBmdW5jdGlvblxuICAgICAgICAgICAgLy8gYXMgdGhlIHZhbHVlLlxuICAgICAgICAgICAgLy8gTm90ZTogV2Ugb25seSBhZGQgdGhlIGxvZ2dlciB0byBlbGVtZW50cyAvIHRleHQgbm9kZXMsXG4gICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBnZW5lcmF0ZSB0b28gbXVjaCBjb2RlLlxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9nV2l0aE5vZGVEZWYgPSBub2RlRmxhZ3MgJiAzIC8qIENhdFJlbmRlck5vZGUgKi8gP1xuICAgICAgICAgICAgICAgIG5ldyBDb21tYUV4cHIoW0xPR19WQVIuY2FsbEZuKFtdKS5jYWxsRm4oW10pLCBub2RlRGVmXSkgOlxuICAgICAgICAgICAgICAgIG5vZGVEZWY7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHlTb3VyY2VTcGFuVG9FeHByZXNzaW9uSWZOZWVkZWQobG9nV2l0aE5vZGVEZWYsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgdXBkYXRlUmVuZGVyZXJTdG10czogdXBkYXRlUmVuZGVyZXJTdG10cywgdXBkYXRlRGlyZWN0aXZlc1N0bXRzOiB1cGRhdGVEaXJlY3RpdmVzU3RtdHMsIG5vZGVEZWZFeHByczogbm9kZURlZkV4cHJzIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG5vZGVJbmRleFxuICAgICAgICAgKiBAcGFyYW0gez99IHNvdXJjZVNwYW5cbiAgICAgICAgICogQHBhcmFtIHs/fSBleHByZXNzaW9uc1xuICAgICAgICAgKiBAcGFyYW0gez99IGFsbG93RW1wdHlFeHByc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlVXBkYXRlU3RhdGVtZW50cyhub2RlSW5kZXgsIHNvdXJjZVNwYW4sIGV4cHJlc3Npb25zLCBhbGxvd0VtcHR5RXhwcnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVwZGF0ZVN0bXRzID0gW107XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBycyA9IGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlU3BhbiA9IF9hLnNvdXJjZVNwYW4sIGNvbnRleHQgPSBfYS5jb250ZXh0LCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmdJZCA9IFwiXCIgKyB1cGRhdGVCaW5kaW5nQ291bnQrKztcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lUmVzb2x2ZXIgPSBjb250ZXh0ID09PSBDT01QX1ZBUiA/IHNlbGYgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobmFtZVJlc29sdmVyLCBjb250ZXh0LCB2YWx1ZSwgYmluZGluZ0lkKSwgc3RtdHMgPSBfYi5zdG10cywgY3VyclZhbEV4cHIgPSBfYi5jdXJyVmFsRXhwcjtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdG10cy5wdXNoLmFwcGx5KHVwZGF0ZVN0bXRzLCBzdG10cy5tYXAoZnVuY3Rpb24gKHN0bXQpIHsgcmV0dXJuIGFwcGx5U291cmNlU3BhblRvU3RhdGVtZW50SWZOZWVkZWQoc3RtdCwgc291cmNlU3Bhbik7IH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlTb3VyY2VTcGFuVG9FeHByZXNzaW9uSWZOZWVkZWQoY3VyclZhbEV4cHIsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoIHx8IGFsbG93RW1wdHlFeHBycykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVN0bXRzLnB1c2goYXBwbHlTb3VyY2VTcGFuVG9TdGF0ZW1lbnRJZk5lZWRlZChjYWxsQ2hlY2tTdG10KG5vZGVJbmRleCwgZXhwcnMpLnRvU3RtdCgpLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU3RtdHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbm9kZUluZGV4XG4gICAgICogQHBhcmFtIHs/fSBoYW5kbGVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVFbGVtZW50SGFuZGxlRXZlbnRGbiA9IGZ1bmN0aW9uIChub2RlSW5kZXgsIGhhbmRsZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhhbmRsZUV2ZW50U3RtdHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFuZGxlRXZlbnRCaW5kaW5nQ291bnQgPSAwO1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBfYS5jb250ZXh0LCBldmVudEFzdCA9IF9hLmV2ZW50QXN0LCBkaXJBc3QgPSBfYS5kaXJBc3Q7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiaW5kaW5nSWQgPSBcIlwiICsgaGFuZGxlRXZlbnRCaW5kaW5nQ291bnQrKztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVSZXNvbHZlciA9IGNvbnRleHQgPT09IENPTVBfVkFSID8gX3RoaXMgOiBudWxsO1xuICAgICAgICAgICAgdmFyIF9iID0gY29udmVydEFjdGlvbkJpbmRpbmcobmFtZVJlc29sdmVyLCBjb250ZXh0LCBldmVudEFzdC5oYW5kbGVyLCBiaW5kaW5nSWQpLCBzdG10cyA9IF9iLnN0bXRzLCBhbGxvd0RlZmF1bHQgPSBfYi5hbGxvd0RlZmF1bHQ7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cnVlU3RtdHMgPSBzdG10cztcbiAgICAgICAgICAgIGlmIChhbGxvd0RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICB0cnVlU3RtdHMucHVzaChBTExPV19ERUZBVUxUX1ZBUi5zZXQoYWxsb3dEZWZhdWx0LmFuZChBTExPV19ERUZBVUxUX1ZBUikpLnRvU3RtdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfYyA9IGVsZW1lbnRFdmVudE5hbWVBbmRUYXJnZXQoZXZlbnRBc3QsIGRpckFzdCksIGV2ZW50VGFyZ2V0ID0gX2MudGFyZ2V0LCBldmVudE5hbWUgPSBfYy5uYW1lO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZnVsbEV2ZW50TmFtZSA9IMm1ZWxlbWVudEV2ZW50RnVsbE5hbWUoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBoYW5kbGVFdmVudFN0bXRzLnB1c2goYXBwbHlTb3VyY2VTcGFuVG9TdGF0ZW1lbnRJZk5lZWRlZChuZXcgSWZTdG10KGxpdGVyYWwoZnVsbEV2ZW50TmFtZSkuaWRlbnRpY2FsKEVWRU5UX05BTUVfVkFSKSwgdHJ1ZVN0bXRzKSwgZXZlbnRBc3Quc291cmNlU3BhbikpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGFuZGxlRXZlbnRGbjtcbiAgICAgICAgaWYgKGhhbmRsZUV2ZW50U3RtdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJlU3RtdHMgPSBbQUxMT1dfREVGQVVMVF9WQVIuc2V0KGxpdGVyYWwodHJ1ZSkpLnRvRGVjbFN0bXQoQk9PTF9UWVBFKV07XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50LmlzSG9zdCAmJiBmaW5kUmVhZFZhck5hbWVzKGhhbmRsZUV2ZW50U3RtdHMpLmhhcyhDT01QX1ZBUi5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHByZVN0bXRzLnB1c2goQ09NUF9WQVIuc2V0KFZJRVdfVkFSLnByb3AoJ2NvbXBvbmVudCcpKS50b0RlY2xTdG10KHRoaXMuY29tcFR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUV2ZW50Rm4gPSBmbihbXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oVklFV19WQVIubmFtZSwgSU5GRVJSRURfVFlQRSksXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oRVZFTlRfTkFNRV9WQVIubmFtZSwgSU5GRVJSRURfVFlQRSksXG4gICAgICAgICAgICAgICAgbmV3IEZuUGFyYW0oRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lLCBJTkZFUlJFRF9UWVBFKVxuICAgICAgICAgICAgXSwgcHJlU3RtdHMuY29uY2F0KGhhbmRsZUV2ZW50U3RtdHMsIFtuZXcgUmV0dXJuU3RhdGVtZW50KEFMTE9XX0RFRkFVTFRfVkFSKV0pLCBJTkZFUlJFRF9UWVBFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50Rm4gPSBOVUxMX0VYUFI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZUV2ZW50Rm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RGlyZWN0aXZlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXREaXJlY3RpdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0UmVmZXJlbmNlID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBWaWV3QnVpbGRlci5wcm90b3R5cGUudmlzaXRWYXJpYWJsZSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0RXZlbnQgPSBmdW5jdGlvbiAoYXN0LCBjb250ZXh0KSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFZpZXdCdWlsZGVyLnByb3RvdHlwZS52aXNpdEVsZW1lbnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgVmlld0J1aWxkZXIucHJvdG90eXBlLnZpc2l0QXR0ciA9IGZ1bmN0aW9uIChhc3QsIGNvbnRleHQpIHsgfTtcbiAgICByZXR1cm4gVmlld0J1aWxkZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyQXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwcm92aWRlckRlZihwcm92aWRlckFzdCkge1xuICAgIHJldHVybiBwcm92aWRlckFzdC5tdWx0aVByb3ZpZGVyID9cbiAgICAgICAgbXVsdGlQcm92aWRlckRlZihwcm92aWRlckFzdC5wcm92aWRlcnMpIDpcbiAgICAgICAgc2luZ2xlUHJvdmlkZXJEZWYocHJvdmlkZXJBc3QucHJvdmlkZXJUeXBlLCBwcm92aWRlckFzdC5wcm92aWRlcnNbMF0pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb3ZpZGVyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gbXVsdGlQcm92aWRlckRlZihwcm92aWRlcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbGxEZXBEZWZzID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYWxsUGFyYW1zID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwcnMgPSBwcm92aWRlcnMubWFwKGZ1bmN0aW9uIChwcm92aWRlciwgcHJvdmlkZXJJbmRleCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHByO1xuICAgICAgICBpZiAocHJvdmlkZXIudXNlQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcEV4cHJzID0gY29udmVydERlcHMocHJvdmlkZXJJbmRleCwgcHJvdmlkZXIuZGVwcyB8fCBwcm92aWRlci51c2VDbGFzcy5kaURlcHMpO1xuICAgICAgICAgICAgZXhwciA9IGltcG9ydEV4cHIocHJvdmlkZXIudXNlQ2xhc3MpLmluc3RhbnRpYXRlKGRlcEV4cHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VGYWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBFeHBycyA9IGNvbnZlcnREZXBzKHByb3ZpZGVySW5kZXgsIHByb3ZpZGVyLmRlcHMgfHwgcHJvdmlkZXIudXNlRmFjdG9yeS5kaURlcHMpO1xuICAgICAgICAgICAgZXhwciA9IGltcG9ydEV4cHIocHJvdmlkZXIudXNlRmFjdG9yeSkuY2FsbEZuKGRlcEV4cHJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlci51c2VFeGlzdGluZykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVwRXhwcnMgPSBjb252ZXJ0RGVwcyhwcm92aWRlckluZGV4LCBbeyB0b2tlbjogcHJvdmlkZXIudXNlRXhpc3RpbmcgfV0pO1xuICAgICAgICAgICAgZXhwciA9IGRlcEV4cHJzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhwciA9IGNvbnZlcnRWYWx1ZVRvT3V0cHV0QXN0KHByb3ZpZGVyLnVzZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlckV4cHIgPSBmbihhbGxQYXJhbXMsIFtuZXcgUmV0dXJuU3RhdGVtZW50KGxpdGVyYWxBcnIoZXhwcnMpKV0sIElORkVSUkVEX1RZUEUpO1xuICAgIHJldHVybiB7IHByb3ZpZGVyRXhwcjogcHJvdmlkZXJFeHByLCBmbGFnczogNTEyIC8qIFR5cGVGYWN0b3J5UHJvdmlkZXIgKi8sIGRlcHNFeHByOiBsaXRlcmFsQXJyKGFsbERlcERlZnMpIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlckluZGV4XG4gICAgICogQHBhcmFtIHs/fSBkZXBzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb252ZXJ0RGVwcyhwcm92aWRlckluZGV4LCBkZXBzKSB7XG4gICAgICAgIHJldHVybiBkZXBzLm1hcChmdW5jdGlvbiAoZGVwLCBkZXBJbmRleCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1OYW1lID0gXCJwXCIgKyBwcm92aWRlckluZGV4ICsgXCJfXCIgKyBkZXBJbmRleDtcbiAgICAgICAgICAgIGFsbFBhcmFtcy5wdXNoKG5ldyBGblBhcmFtKHBhcmFtTmFtZSwgRFlOQU1JQ19UWVBFKSk7XG4gICAgICAgICAgICBhbGxEZXBEZWZzLnB1c2goZGVwRGVmKGRlcCkpO1xuICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlKHBhcmFtTmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwcm92aWRlclR5cGVcbiAqIEBwYXJhbSB7P30gcHJvdmlkZXJNZXRhXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzaW5nbGVQcm92aWRlckRlZihwcm92aWRlclR5cGUsIHByb3ZpZGVyTWV0YSkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3ZpZGVyRXhwcjtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbGFncztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZXBzO1xuICAgIGlmIChwcm92aWRlclR5cGUgPT09IFByb3ZpZGVyQXN0VHlwZS5EaXJlY3RpdmUgfHwgcHJvdmlkZXJUeXBlID09PSBQcm92aWRlckFzdFR5cGUuQ29tcG9uZW50KSB7XG4gICAgICAgIHByb3ZpZGVyRXhwciA9IGltcG9ydEV4cHIocHJvdmlkZXJNZXRhLnVzZUNsYXNzKTtcbiAgICAgICAgZmxhZ3MgPSA4MTkyIC8qIFR5cGVEaXJlY3RpdmUgKi87XG4gICAgICAgIGRlcHMgPSBwcm92aWRlck1ldGEuZGVwcyB8fCBwcm92aWRlck1ldGEudXNlQ2xhc3MuZGlEZXBzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHByb3ZpZGVyTWV0YS51c2VDbGFzcykge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gaW1wb3J0RXhwcihwcm92aWRlck1ldGEudXNlQ2xhc3MpO1xuICAgICAgICAgICAgZmxhZ3MgPSAyNTYgLyogVHlwZUNsYXNzUHJvdmlkZXIgKi87XG4gICAgICAgICAgICBkZXBzID0gcHJvdmlkZXJNZXRhLmRlcHMgfHwgcHJvdmlkZXJNZXRhLnVzZUNsYXNzLmRpRGVwcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlck1ldGEudXNlRmFjdG9yeSkge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gaW1wb3J0RXhwcihwcm92aWRlck1ldGEudXNlRmFjdG9yeSk7XG4gICAgICAgICAgICBmbGFncyA9IDUxMiAvKiBUeXBlRmFjdG9yeVByb3ZpZGVyICovO1xuICAgICAgICAgICAgZGVwcyA9IHByb3ZpZGVyTWV0YS5kZXBzIHx8IHByb3ZpZGVyTWV0YS51c2VGYWN0b3J5LmRpRGVwcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm92aWRlck1ldGEudXNlRXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyRXhwciA9IE5VTExfRVhQUjtcbiAgICAgICAgICAgIGZsYWdzID0gMTAyNCAvKiBUeXBlVXNlRXhpc3RpbmdQcm92aWRlciAqLztcbiAgICAgICAgICAgIGRlcHMgPSBbeyB0b2tlbjogcHJvdmlkZXJNZXRhLnVzZUV4aXN0aW5nIH1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvdmlkZXJFeHByID0gY29udmVydFZhbHVlVG9PdXRwdXRBc3QocHJvdmlkZXJNZXRhLnVzZVZhbHVlKTtcbiAgICAgICAgICAgIGZsYWdzID0gMTI4IC8qIFR5cGVWYWx1ZVByb3ZpZGVyICovO1xuICAgICAgICAgICAgZGVwcyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlcHNFeHByID0gbGl0ZXJhbEFycihkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBkZXBEZWYoZGVwKTsgfSkpO1xuICAgIHJldHVybiB7IHByb3ZpZGVyRXhwcjogcHJvdmlkZXJFeHByLCBmbGFnczogZmxhZ3MsIGRlcHNFeHByOiBkZXBzRXhwciB9O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHRva2VuTWV0YVxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdG9rZW5FeHByKHRva2VuTWV0YSkge1xuICAgIHJldHVybiB0b2tlbk1ldGEuaWRlbnRpZmllciA/IGltcG9ydEV4cHIodG9rZW5NZXRhLmlkZW50aWZpZXIpIDogbGl0ZXJhbCh0b2tlbk1ldGEudmFsdWUpO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGRlcFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZGVwRGVmKGRlcCkge1xuICAgIC8vIE5vdGU6IHRoZSBmb2xsb3dpbmcgZmllbGRzIGhhdmUgYWxyZWFkeSBiZWVuIG5vcm1hbGl6ZWQgb3V0IGJ5IHByb3ZpZGVyX2FuYWx5emVyOlxuICAgIC8vIC0gaXNBdHRyaWJ1dGUsIGlzU2VsZiwgaXNIb3N0XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwciA9IGRlcC5pc1ZhbHVlID8gY29udmVydFZhbHVlVG9PdXRwdXRBc3QoZGVwLnZhbHVlKSA6IHRva2VuRXhwcihkZXAudG9rZW4pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYWdzID0gMDtcbiAgICBpZiAoZGVwLmlzU2tpcFNlbGYpIHtcbiAgICAgICAgZmxhZ3MgfD0gMSAvKiBTa2lwU2VsZiAqLztcbiAgICB9XG4gICAgaWYgKGRlcC5pc09wdGlvbmFsKSB7XG4gICAgICAgIGZsYWdzIHw9IDIgLyogT3B0aW9uYWwgKi87XG4gICAgfVxuICAgIGlmIChkZXAuaXNWYWx1ZSkge1xuICAgICAgICBmbGFncyB8PSA4IC8qIFZhbHVlICovO1xuICAgIH1cbiAgICByZXR1cm4gZmxhZ3MgPT09IDAgLyogTm9uZSAqLyA/IGV4cHIgOiBsaXRlcmFsQXJyKFtsaXRlcmFsKGZsYWdzKSwgZXhwcl0pO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGFzdE5vZGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBuZWVkc0FkZGl0aW9uYWxSb290Tm9kZShhc3ROb2Rlcykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGxhc3RBc3ROb2RlID0gYXN0Tm9kZXNbYXN0Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RBc3ROb2RlIGluc3RhbmNlb2YgRW1iZWRkZWRUZW1wbGF0ZUFzdCkge1xuICAgICAgICByZXR1cm4gbGFzdEFzdE5vZGUuaGFzVmlld0NvbnRhaW5lcjtcbiAgICB9XG4gICAgaWYgKGxhc3RBc3ROb2RlIGluc3RhbmNlb2YgRWxlbWVudEFzdCkge1xuICAgICAgICBpZiAobGFzdEFzdE5vZGUubmFtZSA9PT0gTkdfQ09OVEFJTkVSX1RBRyAmJiBsYXN0QXN0Tm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZWVkc0FkZGl0aW9uYWxSb290Tm9kZShsYXN0QXN0Tm9kZS5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhc3RBc3ROb2RlLmhhc1ZpZXdDb250YWluZXI7XG4gICAgfVxuICAgIHJldHVybiBsYXN0QXN0Tm9kZSBpbnN0YW5jZW9mIE5nQ29udGVudEFzdDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBsaWZlY3ljbGVIb29rXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBsaWZlY3ljbGVIb29rVG9Ob2RlRmxhZyhsaWZlY3ljbGVIb29rKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbm9kZUZsYWcgPSAwO1xuICAgIHN3aXRjaCAobGlmZWN5Y2xlSG9vaykge1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuQWZ0ZXJDb250ZW50Q2hlY2tlZDpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gMTA0ODU3NiAvKiBBZnRlckNvbnRlbnRDaGVja2VkICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5BZnRlckNvbnRlbnRJbml0OlxuICAgICAgICAgICAgbm9kZUZsYWcgPSA1MjQyODggLyogQWZ0ZXJDb250ZW50SW5pdCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIMm1TGlmZWN5Y2xlSG9va3MuQWZ0ZXJWaWV3Q2hlY2tlZDpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gNDE5NDMwNCAvKiBBZnRlclZpZXdDaGVja2VkICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5BZnRlclZpZXdJbml0OlxuICAgICAgICAgICAgbm9kZUZsYWcgPSAyMDk3MTUyIC8qIEFmdGVyVmlld0luaXQgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLkRvQ2hlY2s6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDEzMTA3MiAvKiBEb0NoZWNrICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5PbkNoYW5nZXM6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDI2MjE0NCAvKiBPbkNoYW5nZXMgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSDJtUxpZmVjeWNsZUhvb2tzLk9uRGVzdHJveTpcbiAgICAgICAgICAgIG5vZGVGbGFnID0gNjU1MzYgLyogT25EZXN0cm95ICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgybVMaWZlY3ljbGVIb29rcy5PbkluaXQ6XG4gICAgICAgICAgICBub2RlRmxhZyA9IDMyNzY4IC8qIE9uSW5pdCAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZUZsYWc7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRBc3RcbiAqIEBwYXJhbSB7P30gZGlyQXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBlbGVtZW50QmluZGluZ0RlZihpbnB1dEFzdCwgZGlyQXN0KSB7XG4gICAgc3dpdGNoIChpbnB1dEFzdC50eXBlKSB7XG4gICAgICAgIGNhc2UgUHJvcGVydHlCaW5kaW5nVHlwZS5BdHRyaWJ1dGU6XG4gICAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbCgxIC8qIFR5cGVFbGVtZW50QXR0cmlidXRlICovKSwgbGl0ZXJhbChpbnB1dEFzdC5uYW1lKSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGlucHV0QXN0LnNlY3VyaXR5Q29udGV4dClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICBjYXNlIFByb3BlcnR5QmluZGluZ1R5cGUuUHJvcGVydHk6XG4gICAgICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbCg4IC8qIFR5cGVQcm9wZXJ0eSAqLyksIGxpdGVyYWwoaW5wdXRBc3QubmFtZSksXG4gICAgICAgICAgICAgICAgbGl0ZXJhbChpbnB1dEFzdC5zZWN1cml0eUNvbnRleHQpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgY2FzZSBQcm9wZXJ0eUJpbmRpbmdUeXBlLkFuaW1hdGlvbjpcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJpbmRpbmdUeXBlID0gOCAvKiBUeXBlUHJvcGVydHkgKi8gfFxuICAgICAgICAgICAgICAgIChkaXJBc3QgJiYgZGlyQXN0LmRpcmVjdGl2ZS5pc0NvbXBvbmVudCA/IDMyIC8qIFN5bnRoZXRpY0hvc3RQcm9wZXJ0eSAqLyA6XG4gICAgICAgICAgICAgICAgICAgIDE2IC8qIFN5bnRoZXRpY1Byb3BlcnR5ICovKTtcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsQXJyKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKGJpbmRpbmdUeXBlKSwgbGl0ZXJhbCgnQCcgKyBpbnB1dEFzdC5uYW1lKSwgbGl0ZXJhbChpbnB1dEFzdC5zZWN1cml0eUNvbnRleHQpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgY2FzZSBQcm9wZXJ0eUJpbmRpbmdUeXBlLkNsYXNzOlxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxBcnIoW2xpdGVyYWwoMiAvKiBUeXBlRWxlbWVudENsYXNzICovKSwgbGl0ZXJhbChpbnB1dEFzdC5uYW1lKSwgTlVMTF9FWFBSXSk7XG4gICAgICAgIGNhc2UgUHJvcGVydHlCaW5kaW5nVHlwZS5TdHlsZTpcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsQXJyKFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKDQgLyogVHlwZUVsZW1lbnRTdHlsZSAqLyksIGxpdGVyYWwoaW5wdXRBc3QubmFtZSksIGxpdGVyYWwoaW5wdXRBc3QudW5pdClcbiAgICAgICAgICAgIF0pO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBlbGVtZW50QXN0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmaXhlZEF0dHJzRGVmKGVsZW1lbnRBc3QpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXBSZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGVsZW1lbnRBc3QuYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0ckFzdCkgeyBtYXBSZXN1bHRbYXR0ckFzdC5uYW1lXSA9IGF0dHJBc3QudmFsdWU7IH0pO1xuICAgIGVsZW1lbnRBc3QuZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJBc3QpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZGlyQXN0LmRpcmVjdGl2ZS5ob3N0QXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBkaXJBc3QuZGlyZWN0aXZlLmhvc3RBdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJldlZhbHVlID0gbWFwUmVzdWx0W25hbWVdO1xuICAgICAgICAgICAgbWFwUmVzdWx0W25hbWVdID0gcHJldlZhbHVlICE9IG51bGwgPyBtZXJnZUF0dHJpYnV0ZVZhbHVlKG5hbWUsIHByZXZWYWx1ZSwgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcEVudHJpZXMgPSBbXTtcbiAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIHNvcnQgdG8gZ2V0IGEgZGVmaW5lZCBvdXRwdXQgb3JkZXJcbiAgICAvLyBmb3IgdGVzdHMgYW5kIGZvciBjYWNoaW5nIGdlbmVyYXRlZCBhcnRpZmFjdHMuLi5cbiAgICByZXR1cm4gbGl0ZXJhbEFycihPYmplY3Qua2V5cyhtYXBSZXN1bHQpLnNvcnQoKS5tYXAoZnVuY3Rpb24gKGF0dHJOYW1lKSB7IHJldHVybiBsaXRlcmFsQXJyKFtsaXRlcmFsKGF0dHJOYW1lKSwgbGl0ZXJhbChtYXBSZXN1bHRbYXR0ck5hbWVdKV0pOyB9KSk7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gYXR0ck5hbWVcbiAqIEBwYXJhbSB7P30gYXR0clZhbHVlMVxuICogQHBhcmFtIHs/fSBhdHRyVmFsdWUyXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZVZhbHVlKGF0dHJOYW1lLCBhdHRyVmFsdWUxLCBhdHRyVmFsdWUyKSB7XG4gICAgaWYgKGF0dHJOYW1lID09IENMQVNTX0FUVFIkMSB8fCBhdHRyTmFtZSA9PSBTVFlMRV9BVFRSKSB7XG4gICAgICAgIHJldHVybiBhdHRyVmFsdWUxICsgXCIgXCIgKyBhdHRyVmFsdWUyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGF0dHJWYWx1ZTI7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IG5vZGVJbmRleFxuICogQHBhcmFtIHs/fSBleHByc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY2FsbENoZWNrU3RtdChub2RlSW5kZXgsIGV4cHJzKSB7XG4gICAgaWYgKGV4cHJzLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIHJldHVybiBDSEVDS19WQVIuY2FsbEZuKFtWSUVXX1ZBUiwgbGl0ZXJhbChub2RlSW5kZXgpLCBsaXRlcmFsKDEgLyogRHluYW1pYyAqLyksIGxpdGVyYWxBcnIoZXhwcnMpXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gQ0hFQ0tfVkFSLmNhbGxGbihbVklFV19WQVIsIGxpdGVyYWwobm9kZUluZGV4KSwgbGl0ZXJhbCgwIC8qIElubGluZSAqLyldLmNvbmNhdChleHBycykpO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2RlSW5kZXhcbiAqIEBwYXJhbSB7P30gYmluZGluZ0lkeFxuICogQHBhcmFtIHs/fSBleHByXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjYWxsVW53cmFwVmFsdWUobm9kZUluZGV4LCBiaW5kaW5nSWR4LCBleHByKSB7XG4gICAgcmV0dXJuIGltcG9ydEV4cHIoY3JlYXRlSWRlbnRpZmllcihJZGVudGlmaWVycy51bndyYXBWYWx1ZSkpLmNhbGxGbihbXG4gICAgICAgIFZJRVdfVkFSLCBsaXRlcmFsKG5vZGVJbmRleCksIGxpdGVyYWwoYmluZGluZ0lkeCksIGV4cHJcbiAgICBdKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2Rlc1xuICogQHBhcmFtIHs/PX0gcmVzdWx0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBmaW5kU3RhdGljUXVlcnlJZHMobm9kZXMsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgeyByZXN1bHQgPSBuZXcgTWFwKCk7IH1cbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY1F1ZXJ5SWRzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkeW5hbWljUXVlcnlJZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHF1ZXJ5TWF0Y2hlcztcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50QXN0KSB7XG4gICAgICAgICAgICBmaW5kU3RhdGljUXVlcnlJZHMobm9kZS5jaGlsZHJlbiwgcmVzdWx0KTtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZERhdGEgPSByZXN1bHQuZ2V0KGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEuc3RhdGljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gc3RhdGljUXVlcnlJZHMuYWRkKHF1ZXJ5SWQpOyB9KTtcbiAgICAgICAgICAgICAgICBjaGlsZERhdGEuZHluYW1pY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIGR5bmFtaWNRdWVyeUlkcy5hZGQocXVlcnlJZCk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxdWVyeU1hdGNoZXMgPSBub2RlLnF1ZXJ5TWF0Y2hlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgRW1iZWRkZWRUZW1wbGF0ZUFzdCkge1xuICAgICAgICAgICAgZmluZFN0YXRpY1F1ZXJ5SWRzKG5vZGUuY2hpbGRyZW4sIHJlc3VsdCk7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGREYXRhID0gcmVzdWx0LmdldChjaGlsZCk7XG4gICAgICAgICAgICAgICAgY2hpbGREYXRhLnN0YXRpY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIGR5bmFtaWNRdWVyeUlkcy5hZGQocXVlcnlJZCk7IH0pO1xuICAgICAgICAgICAgICAgIGNoaWxkRGF0YS5keW5hbWljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gZHluYW1pY1F1ZXJ5SWRzLmFkZChxdWVyeUlkKTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlcyA9IG5vZGUucXVlcnlNYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeU1hdGNoZXMpIHtcbiAgICAgICAgICAgIHF1ZXJ5TWF0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gc3RhdGljUXVlcnlJZHMuYWRkKG1hdGNoLnF1ZXJ5SWQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBkeW5hbWljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gc3RhdGljUXVlcnlJZHMuZGVsZXRlKHF1ZXJ5SWQpOyB9KTtcbiAgICAgICAgcmVzdWx0LnNldChub2RlLCB7IHN0YXRpY1F1ZXJ5SWRzOiBzdGF0aWNRdWVyeUlkcywgZHluYW1pY1F1ZXJ5SWRzOiBkeW5hbWljUXVlcnlJZHMgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBub2RlU3RhdGljUXVlcnlJZHNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHN0YXRpY1ZpZXdRdWVyeUlkcyhub2RlU3RhdGljUXVlcnlJZHMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNRdWVyeUlkcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkeW5hbWljUXVlcnlJZHMgPSBuZXcgU2V0KCk7XG4gICAgQXJyYXkuZnJvbShub2RlU3RhdGljUXVlcnlJZHMudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIGVudHJ5LnN0YXRpY1F1ZXJ5SWRzLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5SWQpIHsgcmV0dXJuIHN0YXRpY1F1ZXJ5SWRzLmFkZChxdWVyeUlkKTsgfSk7XG4gICAgICAgIGVudHJ5LmR5bmFtaWNRdWVyeUlkcy5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeUlkKSB7IHJldHVybiBkeW5hbWljUXVlcnlJZHMuYWRkKHF1ZXJ5SWQpOyB9KTtcbiAgICB9KTtcbiAgICBkeW5hbWljUXVlcnlJZHMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJZCkgeyByZXR1cm4gc3RhdGljUXVlcnlJZHMuZGVsZXRlKHF1ZXJ5SWQpOyB9KTtcbiAgICByZXR1cm4geyBzdGF0aWNRdWVyeUlkczogc3RhdGljUXVlcnlJZHMsIGR5bmFtaWNRdWVyeUlkczogZHluYW1pY1F1ZXJ5SWRzIH07XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKGRpcmVjdGl2ZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnREaXJNZXRhID0gZGlyZWN0aXZlcy5maW5kKGZ1bmN0aW9uIChkaXJBc3QpIHsgcmV0dXJuIGRpckFzdC5kaXJlY3RpdmUuaXNDb21wb25lbnQ7IH0pO1xuICAgIGlmIChjb21wb25lbnREaXJNZXRhICYmIGNvbXBvbmVudERpck1ldGEuZGlyZWN0aXZlLmVudHJ5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZW50cnlDb21wb25lbnRGYWN0b3JpZXMgPSBjb21wb25lbnREaXJNZXRhLmRpcmVjdGl2ZS5lbnRyeUNvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChlbnRyeUNvbXBvbmVudCkgeyByZXR1cm4gaW1wb3J0RXhwcih7IHJlZmVyZW5jZTogZW50cnlDb21wb25lbnQuY29tcG9uZW50RmFjdG9yeSB9KTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRva2VuID0gY3JlYXRlSWRlbnRpZmllclRva2VuKElkZW50aWZpZXJzLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTWV0YSA9IHtcbiAgICAgICAgICAgIGRpRGVwczogW1xuICAgICAgICAgICAgICAgIHsgaXNWYWx1ZTogdHJ1ZSwgdmFsdWU6IGxpdGVyYWxBcnIoZW50cnlDb21wb25lbnRGYWN0b3JpZXMpIH0sXG4gICAgICAgICAgICAgICAgeyB0b2tlbjogdG9rZW4sIGlzU2tpcFNlbGY6IHRydWUsIGlzT3B0aW9uYWw6IHRydWUgfSxcbiAgICAgICAgICAgICAgICB7IHRva2VuOiBjcmVhdGVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuTmdNb2R1bGVSZWYpIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbGlmZWN5Y2xlSG9va3M6IFtdLFxuICAgICAgICAgICAgcmVmZXJlbmNlOiByZXNvbHZlSWRlbnRpZmllcihJZGVudGlmaWVycy5Db2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb3ZpZGVyQXN0KHRva2VuLCBmYWxzZSwgdHJ1ZSwgW3sgdG9rZW46IHRva2VuLCBtdWx0aTogZmFsc2UsIHVzZUNsYXNzOiBjbGFzc01ldGEgfV0sIFByb3ZpZGVyQXN0VHlwZS5Qcml2YXRlU2VydmljZSwgW10sIGNvbXBvbmVudERpck1ldGEuc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGV2ZW50QXN0XG4gKiBAcGFyYW0gez99IGRpckFzdFxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZWxlbWVudEV2ZW50TmFtZUFuZFRhcmdldChldmVudEFzdCwgZGlyQXN0KSB7XG4gICAgaWYgKGV2ZW50QXN0LmlzQW5pbWF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBcIkBcIiArIGV2ZW50QXN0Lm5hbWUgKyBcIi5cIiArIGV2ZW50QXN0LnBoYXNlLFxuICAgICAgICAgICAgdGFyZ2V0OiBkaXJBc3QgJiYgZGlyQXN0LmRpcmVjdGl2ZS5pc0NvbXBvbmVudCA/ICdjb21wb25lbnQnIDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50QXN0O1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIHs/fSBxdWVyeUlkc1xuICogQHBhcmFtIHs/fSBxdWVyeUlkXG4gKiBAcGFyYW0gez99IGlzRmlyc3RcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGNhbGNTdGF0aWNEeW5hbWljUXVlcnlGbGFncyhxdWVyeUlkcywgcXVlcnlJZCwgaXNGaXJzdCkge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZsYWdzID0gMDtcbiAgICAvLyBOb3RlOiBXZSBvbmx5IG1ha2UgcXVlcmllcyBzdGF0aWMgdGhhdCBxdWVyeSBmb3IgYSBzaW5nbGUgaXRlbS5cbiAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugb2YgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgb2xkIHZpZXcgY29tcGlsZXIuLi5cbiAgICBpZiAoaXNGaXJzdCAmJiAocXVlcnlJZHMuc3RhdGljUXVlcnlJZHMuaGFzKHF1ZXJ5SWQpIHx8ICFxdWVyeUlkcy5keW5hbWljUXVlcnlJZHMuaGFzKHF1ZXJ5SWQpKSkge1xuICAgICAgICBmbGFncyB8PSAxMzQyMTc3MjggLyogU3RhdGljUXVlcnkgKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmbGFncyB8PSAyNjg0MzU0NTYgLyogRHluYW1pY1F1ZXJ5ICovO1xuICAgIH1cbiAgICByZXR1cm4gZmxhZ3M7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgR2VuZXJhdGVkRmlsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNGaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBnZW5GaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBHZW5lcmF0ZWRGaWxlKHNyY0ZpbGVVcmwsIGdlbkZpbGVVcmwsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNyY0ZpbGVVcmwgPSBzcmNGaWxlVXJsO1xuICAgICAgICB0aGlzLmdlbkZpbGVVcmwgPSBnZW5GaWxlVXJsO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIEdlbmVyYXRlZEZpbGU7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IHN1bW1hcnlSZXNvbHZlclxuICogQHBhcmFtIHs/fSBzeW1ib2xSZXNvbHZlclxuICogQHBhcmFtIHs/fSBzeW1ib2xzXG4gKiBAcGFyYW0gez99IHR5cGVzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVTdW1tYXJpZXMoc3VtbWFyeVJlc29sdmVyLCBzeW1ib2xSZXNvbHZlciwgc3ltYm9scywgdHlwZXMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZXJpYWxpemVyID0gbmV3IFNlcmlhbGl6ZXIkMShzeW1ib2xSZXNvbHZlciwgc3VtbWFyeVJlc29sdmVyKTtcbiAgICAvLyBmb3Igc3ltYm9scywgd2UgdXNlIGV2ZXJ5dGhpbmcgZXhjZXB0IGZvciB0aGUgY2xhc3MgbWV0YWRhdGEgaXRzZWxmXG4gICAgLy8gKHdlIGtlZXAgdGhlIHN0YXRpY3MgdGhvdWdoKSwgYXMgdGhlIGNsYXNzIG1ldGFkYXRhIGlzIGNvbnRhaW5lZCBpbiB0aGVcbiAgICAvLyBDb21waWxlVHlwZVN1bW1hcnkuXG4gICAgc3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChyZXNvbHZlZFN5bWJvbCkgeyByZXR1cm4gc2VyaWFsaXplci5hZGRPck1lcmdlU3VtbWFyeSh7IHN5bWJvbDogcmVzb2x2ZWRTeW1ib2wuc3ltYm9sLCBtZXRhZGF0YTogcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgfSk7IH0pO1xuICAgIC8vIEFkZCBzdW1tYXJpZXMgdGhhdCBhcmUgcmVmZXJlbmNlZCBieSB0aGUgZ2l2ZW4gc3ltYm9scyAodHJhbnNpdGl2ZWx5KVxuICAgIC8vIE5vdGU6IHRoZSBzZXJpYWxpemVyLnN5bWJvbHMgYXJyYXkgbWlnaHQgYmUgZ3Jvd2luZyB3aGlsZVxuICAgIC8vIHdlIGV4ZWN1dGUgdGhlIGxvb3AhXG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9jZXNzZWRJbmRleCA9IDA7IHByb2Nlc3NlZEluZGV4IDwgc2VyaWFsaXplci5zeW1ib2xzLmxlbmd0aDsgcHJvY2Vzc2VkSW5kZXgrKykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2wgPSBzZXJpYWxpemVyLnN5bWJvbHNbcHJvY2Vzc2VkSW5kZXhdO1xuICAgICAgICBpZiAoc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUoc3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeSA9IHN1bW1hcnlSZXNvbHZlci5yZXNvbHZlU3VtbWFyeShzeW1ib2wpO1xuICAgICAgICAgICAgaWYgKCFzdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgLy8gc29tZSBzeW1ib2xzIG1pZ2h0IG9yaWdpbmF0ZSBmcm9tIGEgcGxhaW4gdHlwZXNjcmlwdCBsaWJyYXJ5XG4gICAgICAgICAgICAgICAgLy8gdGhhdCBqdXN0IGV4cG9ydGVkIC5kLnRzIGFuZCAubWV0YWRhdGEuanNvbiBmaWxlcywgaS5lLiB3aGVyZSBubyBzdW1tYXJ5XG4gICAgICAgICAgICAgICAgLy8gZmlsZXMgd2VyZSBjcmVhdGVkLlxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkU3ltYm9sID0gc3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5ID0geyBzeW1ib2w6IHJlc29sdmVkU3ltYm9sLnN5bWJvbCwgbWV0YWRhdGE6IHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVyLmFkZE9yTWVyZ2VTdW1tYXJ5KHN1bW1hcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCB0eXBlIHN1bW1hcmllcy5cbiAgICAvLyBOb3RlOiBXZSBkb24ndCBhZGQgdGhlIHN1bW1hcmllcyBvZiBhbGwgcmVmZXJlbmNlZCBzeW1ib2xzIGFzIGZvciB0aGUgUmVzb2x2ZWRTeW1ib2xzLFxuICAgIC8vIGFzIHRoZSB0eXBlIHN1bW1hcmllcyBhbHJlYWR5IGNvbnRhaW4gdGhlIHRyYW5zaXRpdmUgZGF0YSB0aGF0IHRoZXkgcmVxdWlyZVxuICAgIC8vIChpbiBhIG1pbmltYWwgd2F5KS5cbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlU3VtbWFyeSkge1xuICAgICAgICBzZXJpYWxpemVyLmFkZE9yTWVyZ2VTdW1tYXJ5KHsgc3ltYm9sOiB0eXBlU3VtbWFyeS50eXBlLnJlZmVyZW5jZSwgbWV0YWRhdGE6IG51bGwsIHR5cGU6IHR5cGVTdW1tYXJ5IH0pO1xuICAgICAgICBpZiAodHlwZVN1bW1hcnkuc3VtbWFyeUtpbmQgPT09IENvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVTdW1tYXJ5ID0gKHR5cGVTdW1tYXJ5KTtcbiAgICAgICAgICAgIG5nTW9kdWxlU3VtbWFyeS5leHBvcnRlZERpcmVjdGl2ZXMuY29uY2F0KG5nTW9kdWxlU3VtbWFyeS5leHBvcnRlZFBpcGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbCA9IGlkLnJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICBpZiAoc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUoc3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5ID0gc3VtbWFyeVJlc29sdmVyLnJlc29sdmVTdW1tYXJ5KHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVyLmFkZE9yTWVyZ2VTdW1tYXJ5KHN1bW1hcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VyaWFsaXplci5zZXJpYWxpemUoKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzeW1ib2xDYWNoZVxuICogQHBhcmFtIHs/fSBqc29uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVN1bW1hcmllcyhzeW1ib2xDYWNoZSwganNvbikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlc2VyaWFsaXplciA9IG5ldyBEZXNlcmlhbGl6ZXIoc3ltYm9sQ2FjaGUpO1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoanNvbik7XG59XG52YXIgU2VyaWFsaXplciQxID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VyaWFsaXplciQxLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sUmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez99IHN1bW1hcnlSZXNvbHZlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNlcmlhbGl6ZXIkMShzeW1ib2xSZXNvbHZlciwgc3VtbWFyeVJlc29sdmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN5bWJvbFJlc29sdmVyID0gc3ltYm9sUmVzb2x2ZXI7XG4gICAgICAgIF90aGlzLnN1bW1hcnlSZXNvbHZlciA9IHN1bW1hcnlSZXNvbHZlcjtcbiAgICAgICAgLy8gTm90ZTogVGhpcyBvbmx5IGNvbnRhaW5zIHN5bWJvbHMgd2l0aG91dCBtZW1iZXJzLlxuICAgICAgICBfdGhpcy5zeW1ib2xzID0gW107XG4gICAgICAgIF90aGlzLmluZGV4QnlTeW1ib2wgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLnByb2Nlc3NlZFN1bW1hcnlCeVN5bWJvbCA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMucHJvY2Vzc2VkU3VtbWFyaWVzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdW1tYXJ5XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJpYWxpemVyJDEucHJvdG90eXBlLmFkZE9yTWVyZ2VTdW1tYXJ5ID0gZnVuY3Rpb24gKHN1bW1hcnkpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sTWV0YSA9IHN1bW1hcnkubWV0YWRhdGE7XG4gICAgICAgIGlmIChzeW1ib2xNZXRhICYmIHN5bWJvbE1ldGEuX19zeW1ib2xpYyA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgLy8gRm9yIGNsYXNzZXMsIHdlIGtlZXAgZXZlcnl0aGluZyBleGNlcHQgdGhlaXIgY2xhc3MgZGVjb3JhdG9ycy5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8ga2VlcCBlLmcuIHRoZSBjdG9yIGFyZ3MsIG1ldGhvZCBuYW1lcywgbWV0aG9kIGRlY29yYXRvcnNcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIGNsYXNzIGNhbiBiZSBleHRlbmRlZCBpbiBhbm90aGVyIGNvbXBpbGF0aW9uIHVuaXQuXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBrZWVwIHRoZSBjbGFzcyBkZWNvcmF0b3JzIGFzXG4gICAgICAgICAgICAvLyAxKSB0aGV5IHJlZmVyIHRvIGRhdGFcbiAgICAgICAgICAgIC8vICAgdGhhdCBzaG91bGQgbm90IGNhdXNlIGEgcmVidWlsZCBvZiBkb3duc3RyZWFtIGNvbXBpbGF0aW9uIHVuaXRzXG4gICAgICAgICAgICAvLyAgIChlLmcuIGlubGluZSB0ZW1wbGF0ZXMgb2YgQENvbXBvbmVudCwgb3IgQE5nTW9kdWxlLmRlY2xhcmF0aW9ucylcbiAgICAgICAgICAgIC8vIDIpIHRoZWlyIGRhdGEgaXMgYWxyZWFkeSBjYXB0dXJlZCBpbiBUeXBlU3VtbWFyaWVzLCBlLmcuIERpcmVjdGl2ZVN1bW1hcnkuXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbG9uZV8xID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzeW1ib2xNZXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSAhPT0gJ2RlY29yYXRvcnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lXzFbcHJvcE5hbWVdID0gc3ltYm9sTWV0YVtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzeW1ib2xNZXRhID0gY2xvbmVfMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9jZXNzZWRTdW1tYXJ5ID0gdGhpcy5wcm9jZXNzZWRTdW1tYXJ5QnlTeW1ib2wuZ2V0KHN1bW1hcnkuc3ltYm9sKTtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRTdW1tYXJ5KSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRTdW1tYXJ5ID0gdGhpcy5wcm9jZXNzVmFsdWUoeyBzeW1ib2w6IHN1bW1hcnkuc3ltYm9sIH0pO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWRTdW1tYXJpZXMucHVzaChwcm9jZXNzZWRTdW1tYXJ5KTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkU3VtbWFyeUJ5U3ltYm9sLnNldChzdW1tYXJ5LnN5bWJvbCwgcHJvY2Vzc2VkU3VtbWFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogPT0gb24gcHVycG9zZSB0byBjb21wYXJlIHdpdGggdW5kZWZpbmVkIVxuICAgICAgICBpZiAocHJvY2Vzc2VkU3VtbWFyeS5tZXRhZGF0YSA9PSBudWxsICYmIHN5bWJvbE1ldGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvY2Vzc2VkU3VtbWFyeS5tZXRhZGF0YSA9IHRoaXMucHJvY2Vzc1ZhbHVlKHN5bWJvbE1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6ID09IG9uIHB1cnBvc2UgdG8gY29tcGFyZSB3aXRoIHVuZGVmaW5lZCFcbiAgICAgICAgaWYgKHByb2Nlc3NlZFN1bW1hcnkudHlwZSA9PSBudWxsICYmIHN1bW1hcnkudHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRTdW1tYXJ5LnR5cGUgPSB0aGlzLnByb2Nlc3NWYWx1ZShzdW1tYXJ5LnR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcmlhbGl6ZXIkMS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHBvcnRBcyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBqc29uID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgc3VtbWFyaWVzOiB0aGlzLnByb2Nlc3NlZFN1bW1hcmllcyxcbiAgICAgICAgICAgIHN5bWJvbHM6IHRoaXMuc3ltYm9scy5tYXAoZnVuY3Rpb24gKHN5bWJvbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wuYXNzZXJ0Tm9NZW1iZXJzKCk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW1wb3J0QXM7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHN5bWJvbC5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0QXMgPSBzeW1ib2wubmFtZSArIFwiX1wiICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzLnB1c2goeyBzeW1ib2w6IHN5bWJvbCwgZXhwb3J0QXM6IGltcG9ydEFzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBfX3N5bWJvbDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHN5bWJvbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjb252ZXJ0IHRoZSBzb3VyY2UgZmlsZW5hbWVzIHRpbnRvIG91dHB1dCBmaWxlbmFtZXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHRoZSBnZW5lcmF0ZWQgc3VtbWFyeSBmaWxlIHdpbGwgYmUgdXNlZCB3aGVuIHRlaCBjdXJyZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBpbGF0aW9uIHVuaXQgaXMgdXNlZCBhcyBhIGxpYnJhcnlcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGg6IF90aGlzLnN1bW1hcnlSZXNvbHZlci5nZXRMaWJyYXJ5RmlsZU5hbWUoc3ltYm9sLmZpbGVQYXRoKSxcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0QXM6IGltcG9ydEFzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBqc29uOiBqc29uLCBleHBvcnRBczogZXhwb3J0QXMgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFNlcmlhbGl6ZXIkMS5wcm90b3R5cGUucHJvY2Vzc1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2aXNpdFZhbHVlKHZhbHVlLCB0aGlzLCBudWxsKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTZXJpYWxpemVyJDEucHJvdG90eXBlLnZpc2l0T3RoZXIgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlU3ltYm9sID0gdGhpcy5zeW1ib2xSZXNvbHZlci5nZXRTdGF0aWNTeW1ib2wodmFsdWUuZmlsZVBhdGgsIHZhbHVlLm5hbWUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSB0aGlzLmluZGV4QnlTeW1ib2wuZ2V0KGJhc2VTeW1ib2wpO1xuICAgICAgICAgICAgLy8gTm90ZTogPT0gb24gcHVycG9zZSB0byBjb21wYXJlIHdpdGggdW5kZWZpbmVkIVxuICAgICAgICAgICAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXhCeVN5bWJvbC5zaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhCeVN5bWJvbC5zZXQoYmFzZVN5bWJvbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9scy5wdXNoKGJhc2VTeW1ib2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgX19zeW1ib2w6IGluZGV4LCBtZW1iZXJzOiB2YWx1ZS5tZW1iZXJzIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTZXJpYWxpemVyJDE7XG59KFZhbHVlVHJhbnNmb3JtZXIpKTtcbnZhciBEZXNlcmlhbGl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZXNlcmlhbGl6ZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzeW1ib2xDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERlc2VyaWFsaXplcihzeW1ib2xDYWNoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zeW1ib2xDYWNoZSA9IHN5bWJvbENhY2hlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30ganNvblxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgRGVzZXJpYWxpemVyLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbXBvcnRBcyA9IFtdO1xuICAgICAgICB0aGlzLnN5bWJvbHMgPSBbXTtcbiAgICAgICAgZGF0YS5zeW1ib2xzLmZvckVhY2goZnVuY3Rpb24gKHNlcmlhbGl6ZWRTeW1ib2wpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbCA9IF90aGlzLnN5bWJvbENhY2hlLmdldChzZXJpYWxpemVkU3ltYm9sLmZpbGVQYXRoLCBzZXJpYWxpemVkU3ltYm9sLm5hbWUpO1xuICAgICAgICAgICAgX3RoaXMuc3ltYm9scy5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZFN5bWJvbC5pbXBvcnRBcykge1xuICAgICAgICAgICAgICAgIGltcG9ydEFzLnB1c2goeyBzeW1ib2w6IHN5bWJvbCwgaW1wb3J0QXM6IHNlcmlhbGl6ZWRTeW1ib2wuaW1wb3J0QXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJpZXMgPSB2aXNpdFZhbHVlKGRhdGEuc3VtbWFyaWVzLCB0aGlzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHsgc3VtbWFyaWVzOiBzdW1tYXJpZXMsIGltcG9ydEFzOiBpbXBvcnRBcyB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtYXBcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIERlc2VyaWFsaXplci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICgnX19zeW1ib2wnIGluIG1hcCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZVN5bWJvbCA9IHRoaXMuc3ltYm9sc1ttYXBbJ19fc3ltYm9sJ11dO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVycyA9IG1hcFsnbWVtYmVycyddO1xuICAgICAgICAgICAgcmV0dXJuIG1lbWJlcnMubGVuZ3RoID8gdGhpcy5zeW1ib2xDYWNoZS5nZXQoYmFzZVN5bWJvbC5maWxlUGF0aCwgYmFzZVN5bWJvbC5uYW1lLCBtZW1iZXJzKSA6XG4gICAgICAgICAgICAgICAgYmFzZVN5bWJvbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnZpc2l0U3RyaW5nTWFwLmNhbGwodGhpcywgbWFwLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlc2VyaWFsaXplcjtcbn0oVmFsdWVUcmFuc2Zvcm1lcikpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIEFvdENvbXBpbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IF9jb25maWdcbiAgICAgKiBAcGFyYW0gez99IF9ob3N0XG4gICAgICogQHBhcmFtIHs/fSBfbWV0YWRhdGFSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX3RlbXBsYXRlUGFyc2VyXG4gICAgICogQHBhcmFtIHs/fSBfc3R5bGVDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX3ZpZXdDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX25nTW9kdWxlQ29tcGlsZXJcbiAgICAgKiBAcGFyYW0gez99IF9vdXRwdXRFbWl0dGVyXG4gICAgICogQHBhcmFtIHs/fSBfc3VtbWFyeVJlc29sdmVyXG4gICAgICogQHBhcmFtIHs/fSBfbG9jYWxlSWRcbiAgICAgKiBAcGFyYW0gez99IF90cmFuc2xhdGlvbkZvcm1hdFxuICAgICAqIEBwYXJhbSB7P30gX2dlbkZpbGVQcmVhbWJsZVxuICAgICAqIEBwYXJhbSB7P30gX3N5bWJvbFJlc29sdmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQW90Q29tcGlsZXIoX2NvbmZpZywgX2hvc3QsIF9tZXRhZGF0YVJlc29sdmVyLCBfdGVtcGxhdGVQYXJzZXIsIF9zdHlsZUNvbXBpbGVyLCBfdmlld0NvbXBpbGVyLCBfbmdNb2R1bGVDb21waWxlciwgX291dHB1dEVtaXR0ZXIsIF9zdW1tYXJ5UmVzb2x2ZXIsIF9sb2NhbGVJZCwgX3RyYW5zbGF0aW9uRm9ybWF0LCBfZ2VuRmlsZVByZWFtYmxlLCBfc3ltYm9sUmVzb2x2ZXIpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgdGhpcy5faG9zdCA9IF9ob3N0O1xuICAgICAgICB0aGlzLl9tZXRhZGF0YVJlc29sdmVyID0gX21ldGFkYXRhUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlUGFyc2VyID0gX3RlbXBsYXRlUGFyc2VyO1xuICAgICAgICB0aGlzLl9zdHlsZUNvbXBpbGVyID0gX3N0eWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdDb21waWxlciA9IF92aWV3Q29tcGlsZXI7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlQ29tcGlsZXIgPSBfbmdNb2R1bGVDb21waWxlcjtcbiAgICAgICAgdGhpcy5fb3V0cHV0RW1pdHRlciA9IF9vdXRwdXRFbWl0dGVyO1xuICAgICAgICB0aGlzLl9zdW1tYXJ5UmVzb2x2ZXIgPSBfc3VtbWFyeVJlc29sdmVyO1xuICAgICAgICB0aGlzLl9sb2NhbGVJZCA9IF9sb2NhbGVJZDtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25Gb3JtYXQgPSBfdHJhbnNsYXRpb25Gb3JtYXQ7XG4gICAgICAgIHRoaXMuX2dlbkZpbGVQcmVhbWJsZSA9IF9nZW5GaWxlUHJlYW1ibGU7XG4gICAgICAgIHRoaXMuX3N5bWJvbFJlc29sdmVyID0gX3N5bWJvbFJlc29sdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmNsZWFyQ2FjaGUoKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJvb3RGaWxlc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVBbGwgPSBmdW5jdGlvbiAocm9vdEZpbGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb2dyYW1TeW1ib2xzID0gZXh0cmFjdFByb2dyYW1TeW1ib2xzKHRoaXMuX3N5bWJvbFJlc29sdmVyLCByb290RmlsZXMsIHRoaXMuX2hvc3QpO1xuICAgICAgICB2YXIgX2EgPSBhbmFseXplQW5kVmFsaWRhdGVOZ01vZHVsZXMocHJvZ3JhbVN5bWJvbHMsIHRoaXMuX2hvc3QsIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIpLCBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlID0gX2EubmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSwgZmlsZXMgPSBfYS5maWxlcywgbmdNb2R1bGVzID0gX2EubmdNb2R1bGVzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVxuICAgICAgICAgICAgLmFsbChuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZSkgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIubG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhKG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlLCBmYWxzZSk7IH0pKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc291cmNlTW9kdWxlcyA9IGZpbGVzLm1hcChmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gX3RoaXMuX2NvbXBpbGVTcmNGaWxlKGZpbGUuc3JjVXJsLCBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlLCBmaWxlLmRpcmVjdGl2ZXMsIGZpbGUucGlwZXMsIGZpbGUubmdNb2R1bGVzLCBmaWxlLmluamVjdGFibGVzKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlbihzb3VyY2VNb2R1bGVzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHNyY0ZpbGVVcmxcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmVcbiAgICAgKiBAcGFyYW0gez99IGRpcmVjdGl2ZXNcbiAgICAgKiBAcGFyYW0gez99IHBpcGVzXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZXNcbiAgICAgKiBAcGFyYW0gez99IGluamVjdGFibGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBb3RDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVTcmNGaWxlID0gZnVuY3Rpb24gKHNyY0ZpbGVVcmwsIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZXMsIGluamVjdGFibGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGVTdWZmaXggPSBzcGxpdFR5cGVzY3JpcHRTdWZmaXgoc3JjRmlsZVVybClbMV07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXhwb3J0ZWRWYXJzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGdlbmVyYXRlZEZpbGVzID0gW107XG4gICAgICAgIGdlbmVyYXRlZEZpbGVzLnB1c2godGhpcy5fY3JlYXRlU3VtbWFyeShzcmNGaWxlVXJsLCBkaXJlY3RpdmVzLCBwaXBlcywgbmdNb2R1bGVzLCBpbmplY3RhYmxlcywgc3RhdGVtZW50cywgZXhwb3J0ZWRWYXJzKSk7XG4gICAgICAgIC8vIGNvbXBpbGUgYWxsIG5nIG1vZHVsZXNcbiAgICAgICAgZXhwb3J0ZWRWYXJzLnB1c2guYXBwbHkoZXhwb3J0ZWRWYXJzLCBuZ01vZHVsZXMubWFwKGZ1bmN0aW9uIChuZ01vZHVsZVR5cGUpIHsgcmV0dXJuIF90aGlzLl9jb21waWxlTW9kdWxlKG5nTW9kdWxlVHlwZSwgc3RhdGVtZW50cyk7IH0pKTtcbiAgICAgICAgLy8gY29tcGlsZSBjb21wb25lbnRzXG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyVHlwZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcE1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YSgvKiogQHR5cGUgez99ICovIChkaXJUeXBlKSk7XG4gICAgICAgICAgICBpZiAoIWNvbXBNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlID0gbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZS5nZXQoZGlyVHlwZSk7XG4gICAgICAgICAgICBpZiAoIW5nTW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgRXJyb3I6IGNhbm5vdCBkZXRlcm1pbmUgdGhlIG1vZHVsZSBmb3IgY29tcG9uZW50IFwiICsgaWRlbnRpZmllck5hbWUoY29tcE1ldGEudHlwZSkgKyBcIiFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfYXNzZXJ0Q29tcG9uZW50KGNvbXBNZXRhKTtcbiAgICAgICAgICAgIC8vIGNvbXBpbGUgc3R5bGVzXG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdHlsZXNDb21waWxlUmVzdWx0cyA9IF90aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgc3R5bGVzQ29tcGlsZVJlc3VsdHMuZXh0ZXJuYWxTdHlsZXNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21waWxlZFN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWRGaWxlcy5wdXNoKF90aGlzLl9jb2RnZW5TdHlsZXMoc3JjRmlsZVVybCwgY29tcGlsZWRTdHlsZVNoZWV0LCBmaWxlU3VmZml4KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNvbXBpbGUgY29tcG9uZW50c1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcFZpZXdWYXJzID0gX3RoaXMuX2NvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIG5nTW9kdWxlLCBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLmRpcmVjdGl2ZXMsIHN0eWxlc0NvbXBpbGVSZXN1bHRzLmNvbXBvbmVudFN0eWxlc2hlZXQsIGZpbGVTdWZmaXgsIHN0YXRlbWVudHMpO1xuICAgICAgICAgICAgZXhwb3J0ZWRWYXJzLnB1c2goX3RoaXMuX2NvbXBpbGVDb21wb25lbnRGYWN0b3J5KGNvbXBNZXRhLCBuZ01vZHVsZSwgZmlsZVN1ZmZpeCwgc3RhdGVtZW50cyksIGNvbXBWaWV3VmFycy52aWV3Q2xhc3NWYXIsIGNvbXBWaWV3VmFycy5jb21wUmVuZGVyVHlwZVZhcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RhdGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcmNNb2R1bGUgPSB0aGlzLl9jb2RlZ2VuU291cmNlTW9kdWxlKHNyY0ZpbGVVcmwsIG5nZmFjdG9yeUZpbGVQYXRoKHNyY0ZpbGVVcmwpLCBzdGF0ZW1lbnRzLCBleHBvcnRlZFZhcnMpO1xuICAgICAgICAgICAgZ2VuZXJhdGVkRmlsZXMudW5zaGlmdChzcmNNb2R1bGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZWRGaWxlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3JjRmlsZVVybFxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlc1xuICAgICAqIEBwYXJhbSB7P30gcGlwZXNcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlc1xuICAgICAqIEBwYXJhbSB7P30gaW5qZWN0YWJsZXNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFN0YXRlbWVudHNcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldEV4cG9ydGVkVmFyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jcmVhdGVTdW1tYXJ5ID0gZnVuY3Rpb24gKHNyY0ZpbGVVcmwsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZXMsIGluamVjdGFibGVzLCB0YXJnZXRTdGF0ZW1lbnRzLCB0YXJnZXRFeHBvcnRlZFZhcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sU3VtbWFyaWVzID0gdGhpcy5fc3ltYm9sUmVzb2x2ZXIuZ2V0U3ltYm9sc09mKHNyY0ZpbGVVcmwpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzeW1ib2wpIHsgcmV0dXJuIF90aGlzLl9zeW1ib2xSZXNvbHZlci5yZXNvbHZlU3ltYm9sKHN5bWJvbCk7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0eXBlU3VtbWFyaWVzID0gbmdNb2R1bGVzLm1hcChmdW5jdGlvbiAocmVmKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZVN1bW1hcnkocmVmKTsgfSkuY29uY2F0KGRpcmVjdGl2ZXMubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZVN1bW1hcnkocmVmKTsgfSksIHBpcGVzLm1hcChmdW5jdGlvbiAocmVmKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlU3VtbWFyeShyZWYpOyB9KSwgaW5qZWN0YWJsZXMubWFwKGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldEluamVjdGFibGVTdW1tYXJ5KHJlZik7IH0pKTtcbiAgICAgICAgdmFyIF9hID0gc2VyaWFsaXplU3VtbWFyaWVzKHRoaXMuX3N1bW1hcnlSZXNvbHZlciwgdGhpcy5fc3ltYm9sUmVzb2x2ZXIsIHN5bWJvbFN1bW1hcmllcywgdHlwZVN1bW1hcmllcyksIGpzb24gPSBfYS5qc29uLCBleHBvcnRBcyA9IF9hLmV4cG9ydEFzO1xuICAgICAgICBleHBvcnRBcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKGVudHJ5LmV4cG9ydEFzKS5zZXQoaW1wb3J0RXhwcih7IHJlZmVyZW5jZTogZW50cnkuc3ltYm9sIH0pKS50b0RlY2xTdG10KCkpO1xuICAgICAgICAgICAgdGFyZ2V0RXhwb3J0ZWRWYXJzLnB1c2goZW50cnkuZXhwb3J0QXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0ZWRGaWxlKHNyY0ZpbGVVcmwsIHN1bW1hcnlGaWxlTmFtZShzcmNGaWxlVXJsKSwganNvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0U3RhdGVtZW50c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlTW9kdWxlID0gZnVuY3Rpb24gKG5nTW9kdWxlVHlwZSwgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShuZ01vZHVsZVR5cGUpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm92aWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsZUlkKSB7XG4gICAgICAgICAgICBwcm92aWRlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdG9rZW46IGNyZWF0ZUlkZW50aWZpZXJUb2tlbihJZGVudGlmaWVycy5MT0NBTEVfSUQpLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB0aGlzLl9sb2NhbGVJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2xhdGlvbkZvcm1hdCkge1xuICAgICAgICAgICAgcHJvdmlkZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRva2VuOiBjcmVhdGVJZGVudGlmaWVyVG9rZW4oSWRlbnRpZmllcnMuVFJBTlNMQVRJT05TX0ZPUk1BVCksXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6IHRoaXMuX3RyYW5zbGF0aW9uRm9ybWF0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcHBDb21waWxlUmVzdWx0ID0gdGhpcy5fbmdNb2R1bGVDb21waWxlci5jb21waWxlKG5nTW9kdWxlLCBwcm92aWRlcnMpO1xuICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2guYXBwbHkodGFyZ2V0U3RhdGVtZW50cywgYXBwQ29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFwcENvbXBpbGVSZXN1bHQubmdNb2R1bGVGYWN0b3J5VmFyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVcbiAgICAgKiBAcGFyYW0gez99IGZpbGVTdWZmaXhcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFN0YXRlbWVudHNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZUNvbXBvbmVudEZhY3RvcnkgPSBmdW5jdGlvbiAoY29tcE1ldGEsIG5nTW9kdWxlLCBmaWxlU3VmZml4LCB0YXJnZXRTdGF0ZW1lbnRzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RUeXBlID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRIb3N0Q29tcG9uZW50VHlwZShjb21wTWV0YS50eXBlLnJlZmVyZW5jZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RNZXRhID0gY3JlYXRlSG9zdENvbXBvbmVudE1ldGEoaG9zdFR5cGUsIGNvbXBNZXRhLCB0aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldEhvc3RDb21wb25lbnRWaWV3Q2xhc3MoaG9zdFR5cGUpKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdFZpZXdGYWN0b3J5VmFyID0gdGhpcy5fY29tcGlsZUNvbXBvbmVudChob3N0TWV0YSwgbmdNb2R1bGUsIFtjb21wTWV0YS50eXBlXSwgbnVsbCwgZmlsZVN1ZmZpeCwgdGFyZ2V0U3RhdGVtZW50cylcbiAgICAgICAgICAgIC52aWV3Q2xhc3NWYXI7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBGYWN0b3J5VmFyID0gY29tcG9uZW50RmFjdG9yeU5hbWUoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnB1dHNFeHBycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIHByb3BOYW1lIGluIGNvbXBNZXRhLmlucHV0cykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGVtcGxhdGVOYW1lID0gY29tcE1ldGEuaW5wdXRzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIC8vIERvbid0IHF1b3RlIHNvIHRoYXQgdGhlIGtleSBnZXRzIG1pbmlmaWVkLi4uXG4gICAgICAgICAgICBpbnB1dHNFeHBycy5wdXNoKG5ldyBMaXRlcmFsTWFwRW50cnkocHJvcE5hbWUsIGxpdGVyYWwodGVtcGxhdGVOYW1lKSwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvdXRwdXRzRXhwcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wTmFtZSBpbiBjb21wTWV0YS5vdXRwdXRzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0ZW1wbGF0ZU5hbWUgPSBjb21wTWV0YS5vdXRwdXRzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIC8vIERvbid0IHF1b3RlIHNvIHRoYXQgdGhlIGtleSBnZXRzIG1pbmlmaWVkLi4uXG4gICAgICAgICAgICBvdXRwdXRzRXhwcnMucHVzaChuZXcgTGl0ZXJhbE1hcEVudHJ5KHByb3BOYW1lLCBsaXRlcmFsKHRlbXBsYXRlTmFtZSksIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0U3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKGNvbXBGYWN0b3J5VmFyKVxuICAgICAgICAgICAgLnNldChpbXBvcnRFeHByKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuY3JlYXRlQ29tcG9uZW50RmFjdG9yeSkpLmNhbGxGbihbXG4gICAgICAgICAgICBsaXRlcmFsKGNvbXBNZXRhLnNlbGVjdG9yKSwgaW1wb3J0RXhwcihjb21wTWV0YS50eXBlKSxcbiAgICAgICAgICAgIHZhcmlhYmxlKGhvc3RWaWV3RmFjdG9yeVZhciksIG5ldyBMaXRlcmFsTWFwRXhwcihpbnB1dHNFeHBycyksXG4gICAgICAgICAgICBuZXcgTGl0ZXJhbE1hcEV4cHIob3V0cHV0c0V4cHJzKSxcbiAgICAgICAgICAgIGxpdGVyYWxBcnIoY29tcE1ldGEudGVtcGxhdGUubmdDb250ZW50U2VsZWN0b3JzLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IpIHsgcmV0dXJuIGxpdGVyYWwoc2VsZWN0b3IpOyB9KSlcbiAgICAgICAgXSkpXG4gICAgICAgICAgICAudG9EZWNsU3RtdChpbXBvcnRUeXBlKGNyZWF0ZUlkZW50aWZpZXIoSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeSksIFtpbXBvcnRUeXBlKGNvbXBNZXRhLnR5cGUpXSwgW1R5cGVNb2RpZmllci5Db25zdF0pLCBbU3RtdE1vZGlmaWVyLkZpbmFsXSkpO1xuICAgICAgICByZXR1cm4gY29tcEZhY3RvcnlWYXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBNZXRhXG4gICAgICogQHBhcmFtIHs/fSBuZ01vZHVsZVxuICAgICAqIEBwYXJhbSB7P30gZGlyZWN0aXZlSWRlbnRpZmllcnNcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFN0eWxlc1xuICAgICAqIEBwYXJhbSB7P30gZmlsZVN1ZmZpeFxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0U3RhdGVtZW50c1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBNZXRhLCBuZ01vZHVsZSwgZGlyZWN0aXZlSWRlbnRpZmllcnMsIGNvbXBvbmVudFN0eWxlcywgZmlsZVN1ZmZpeCwgdGFyZ2V0U3RhdGVtZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJlY3RpdmVzID0gZGlyZWN0aXZlSWRlbnRpZmllcnMubWFwKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZVN1bW1hcnkoZGlyLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwaXBlcyA9IG5nTW9kdWxlLnRyYW5zaXRpdmVNb2R1bGUucGlwZXMubWFwKGZ1bmN0aW9uIChwaXBlKSB7IHJldHVybiBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQaXBlU3VtbWFyeShwaXBlLnJlZmVyZW5jZSk7IH0pO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl90ZW1wbGF0ZVBhcnNlci5wYXJzZShjb21wTWV0YSwgY29tcE1ldGEudGVtcGxhdGUudGVtcGxhdGUsIGRpcmVjdGl2ZXMsIHBpcGVzLCBuZ01vZHVsZS5zY2hlbWFzLCB0ZW1wbGF0ZVNvdXJjZVVybChuZ01vZHVsZS50eXBlLCBjb21wTWV0YSwgY29tcE1ldGEudGVtcGxhdGUpKSwgcGFyc2VkVGVtcGxhdGUgPSBfYS50ZW1wbGF0ZSwgdXNlZFBpcGVzID0gX2EucGlwZXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlc0V4cHIgPSBjb21wb25lbnRTdHlsZXMgPyB2YXJpYWJsZShjb21wb25lbnRTdHlsZXMuc3R5bGVzVmFyKSA6IGxpdGVyYWxBcnIoW10pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3UmVzdWx0ID0gdGhpcy5fdmlld0NvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEsIHBhcnNlZFRlbXBsYXRlLCBzdHlsZXNFeHByLCB1c2VkUGlwZXMpO1xuICAgICAgICBpZiAoY29tcG9uZW50U3R5bGVzKSB7XG4gICAgICAgICAgICB0YXJnZXRTdGF0ZW1lbnRzLnB1c2guYXBwbHkodGFyZ2V0U3RhdGVtZW50cywgX3Jlc29sdmVTdHlsZVN0YXRlbWVudHModGhpcy5fc3ltYm9sUmVzb2x2ZXIsIGNvbXBvbmVudFN0eWxlcywgZmlsZVN1ZmZpeCkpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFN0YXRlbWVudHMucHVzaC5hcHBseSh0YXJnZXRTdGF0ZW1lbnRzLCB2aWV3UmVzdWx0LnN0YXRlbWVudHMpO1xuICAgICAgICByZXR1cm4geyB2aWV3Q2xhc3NWYXI6IHZpZXdSZXN1bHQudmlld0NsYXNzVmFyLCBjb21wUmVuZGVyVHlwZVZhcjogdmlld1Jlc3VsdC5yZW5kZXJlclR5cGVWYXIgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVVybFxuICAgICAqIEBwYXJhbSB7P30gc3R5bGVzQ29tcGlsZVJlc3VsdFxuICAgICAqIEBwYXJhbSB7P30gZmlsZVN1ZmZpeFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90Q29tcGlsZXIucHJvdG90eXBlLl9jb2RnZW5TdHlsZXMgPSBmdW5jdGlvbiAoZmlsZVVybCwgc3R5bGVzQ29tcGlsZVJlc3VsdCwgZmlsZVN1ZmZpeCkge1xuICAgICAgICBfcmVzb2x2ZVN0eWxlU3RhdGVtZW50cyh0aGlzLl9zeW1ib2xSZXNvbHZlciwgc3R5bGVzQ29tcGlsZVJlc3VsdCwgZmlsZVN1ZmZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2RlZ2VuU291cmNlTW9kdWxlKGZpbGVVcmwsIF9zdHlsZXNNb2R1bGVVcmwoc3R5bGVzQ29tcGlsZVJlc3VsdC5tZXRhLm1vZHVsZVVybCwgc3R5bGVzQ29tcGlsZVJlc3VsdC5pc1NoaW1tZWQsIGZpbGVTdWZmaXgpLCBzdHlsZXNDb21waWxlUmVzdWx0LnN0YXRlbWVudHMsIFtzdHlsZXNDb21waWxlUmVzdWx0LnN0eWxlc1Zhcl0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzcmNGaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBnZW5GaWxlVXJsXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gICAgICogQHBhcmFtIHs/fSBleHBvcnRlZFZhcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdENvbXBpbGVyLnByb3RvdHlwZS5fY29kZWdlblNvdXJjZU1vZHVsZSA9IGZ1bmN0aW9uIChzcmNGaWxlVXJsLCBnZW5GaWxlVXJsLCBzdGF0ZW1lbnRzLCBleHBvcnRlZFZhcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmF0ZWRGaWxlKHNyY0ZpbGVVcmwsIGdlbkZpbGVVcmwsIHRoaXMuX291dHB1dEVtaXR0ZXIuZW1pdFN0YXRlbWVudHMoc291cmNlVXJsKHNyY0ZpbGVVcmwpLCBnZW5GaWxlVXJsLCBzdGF0ZW1lbnRzLCBleHBvcnRlZFZhcnMsIHRoaXMuX2dlbkZpbGVQcmVhbWJsZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIEFvdENvbXBpbGVyO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSByZWZsZWN0b3JcbiAqIEBwYXJhbSB7P30gY29tcGlsZVJlc3VsdFxuICogQHBhcmFtIHs/fSBmaWxlU3VmZml4XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfcmVzb2x2ZVN0eWxlU3RhdGVtZW50cyhyZWZsZWN0b3IsIGNvbXBpbGVSZXN1bHQsIGZpbGVTdWZmaXgpIHtcbiAgICBjb21waWxlUmVzdWx0LmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgZGVwLnZhbHVlUGxhY2Vob2xkZXIucmVmZXJlbmNlID0gcmVmbGVjdG9yLmdldFN0YXRpY1N5bWJvbChfc3R5bGVzTW9kdWxlVXJsKGRlcC5tb2R1bGVVcmwsIGRlcC5pc1NoaW1tZWQsIGZpbGVTdWZmaXgpLCBkZXAubmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBpbGVSZXN1bHQuc3RhdGVtZW50cztcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdHlsZXNoZWV0VXJsXG4gKiBAcGFyYW0gez99IHNoaW1cbiAqIEBwYXJhbSB7P30gc3VmZml4XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfc3R5bGVzTW9kdWxlVXJsKHN0eWxlc2hlZXRVcmwsIHNoaW0sIHN1ZmZpeCkge1xuICAgIHJldHVybiBcIlwiICsgc3R5bGVzaGVldFVybCArIChzaGltID8gJy5zaGltJyA6ICcnKSArIFwiLm5nc3R5bGVcIiArIHN1ZmZpeDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBtZXRhXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfYXNzZXJ0Q29tcG9uZW50KG1ldGEpIHtcbiAgICBpZiAoIW1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGNvbXBpbGUgJ1wiICsgaWRlbnRpZmllck5hbWUobWV0YS50eXBlKSArIFwiJyBiZWNhdXNlIGl0IGlzIG5vdCBhIGNvbXBvbmVudC5cIik7XG4gICAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb2dyYW1TdGF0aWNTeW1ib2xzXG4gKiBAcGFyYW0gez99IGhvc3RcbiAqIEBwYXJhbSB7P30gbWV0YWRhdGFSZXNvbHZlclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gYW5hbHl6ZU5nTW9kdWxlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgaG9zdCwgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgIHZhciBfYSA9IF9jcmVhdGVOZ01vZHVsZXMocHJvZ3JhbVN0YXRpY1N5bWJvbHMsIGhvc3QsIG1ldGFkYXRhUmVzb2x2ZXIpLCBuZ01vZHVsZXMgPSBfYS5uZ01vZHVsZXMsIHN5bWJvbHNNaXNzaW5nTW9kdWxlID0gX2Euc3ltYm9sc01pc3NpbmdNb2R1bGU7XG4gICAgcmV0dXJuIF9hbmFseXplTmdNb2R1bGVzKHByb2dyYW1TdGF0aWNTeW1ib2xzLCBuZ01vZHVsZXMsIHN5bWJvbHNNaXNzaW5nTW9kdWxlLCBtZXRhZGF0YVJlc29sdmVyKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwcm9ncmFtU3RhdGljU3ltYm9sc1xuICogQHBhcmFtIHs/fSBob3N0XG4gKiBAcGFyYW0gez99IG1ldGFkYXRhUmVzb2x2ZXJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFuYWx5emVBbmRWYWxpZGF0ZU5nTW9kdWxlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgaG9zdCwgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IGFuYWx5emVOZ01vZHVsZXMocHJvZ3JhbVN0YXRpY1N5bWJvbHMsIGhvc3QsIG1ldGFkYXRhUmVzb2x2ZXIpO1xuICAgIGlmIChyZXN1bHQuc3ltYm9sc01pc3NpbmdNb2R1bGUgJiYgcmVzdWx0LnN5bWJvbHNNaXNzaW5nTW9kdWxlLmxlbmd0aCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXNzYWdlcyA9IHJlc3VsdC5zeW1ib2xzTWlzc2luZ01vZHVsZS5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIFwiQ2Fubm90IGRldGVybWluZSB0aGUgbW9kdWxlIGZvciBjbGFzcyBcIiArIHMubmFtZSArIFwiIGluIFwiICsgcy5maWxlUGF0aCArIFwiISBBZGQgXCIgKyBzLm5hbWUgKyBcIiB0byB0aGUgTmdNb2R1bGUgdG8gZml4IGl0LlwiOyB9KTtcbiAgICAgICAgdGhyb3cgc3ludGF4RXJyb3IobWVzc2FnZXMuam9pbignXFxuJykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb2dyYW1TeW1ib2xzXG4gKiBAcGFyYW0gez99IG5nTW9kdWxlTWV0YXNcbiAqIEBwYXJhbSB7P30gc3ltYm9sc01pc3NpbmdNb2R1bGVcbiAqIEBwYXJhbSB7P30gbWV0YWRhdGFSZXNvbHZlclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2FuYWx5emVOZ01vZHVsZXMocHJvZ3JhbVN5bWJvbHMsIG5nTW9kdWxlTWV0YXMsIHN5bWJvbHNNaXNzaW5nTW9kdWxlLCBtZXRhZGF0YVJlc29sdmVyKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YXNCeVJlZiA9IG5ldyBNYXAoKTtcbiAgICBuZ01vZHVsZU1ldGFzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlKSB7IHJldHVybiBtb2R1bGVNZXRhc0J5UmVmLnNldChuZ01vZHVsZS50eXBlLnJlZmVyZW5jZSwgbmdNb2R1bGUpOyB9KTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlID0gbmV3IE1hcCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlc0J5RmlsZSA9IG5ldyBNYXAoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0RpcmVjdGl2ZXNCeUZpbGUgPSBuZXcgTWFwKCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdQaXBlc0J5RmlsZSA9IG5ldyBNYXAoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ0luamVjdGFibGVzQnlGaWxlID0gbmV3IE1hcCgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGVQYXRocyA9IG5ldyBTZXQoKTtcbiAgICAvLyBNYWtlIHN1cmUgd2UgcHJvZHVjZSBhbiBhbmFseXplZCBmaWxlIGZvciBlYWNoIGlucHV0IGZpbGVcbiAgICBwcm9ncmFtU3ltYm9scy5mb3JFYWNoKGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZVBhdGggPSBzeW1ib2wuZmlsZVBhdGg7XG4gICAgICAgIGZpbGVQYXRocy5hZGQoZmlsZVBhdGgpO1xuICAgICAgICBpZiAobWV0YWRhdGFSZXNvbHZlci5pc0luamVjdGFibGUoc3ltYm9sKSkge1xuICAgICAgICAgICAgbmdJbmplY3RhYmxlc0J5RmlsZS5zZXQoZmlsZVBhdGgsIChuZ0luamVjdGFibGVzQnlGaWxlLmdldChmaWxlUGF0aCkgfHwgW10pLmNvbmNhdChzeW1ib2wpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIExvb3Bpbmcgb3ZlciBhbGwgbW9kdWxlcyB0byBjb25zdHJ1Y3Q6XG4gICAgLy8gLSBhIG1hcCBmcm9tIGZpbGUgdG8gbW9kdWxlcyBgbmdNb2R1bGVzQnlGaWxlYCxcbiAgICAvLyAtIGEgbWFwIGZyb20gZmlsZSB0byBkaXJlY3RpdmVzIGBuZ0RpcmVjdGl2ZXNCeUZpbGVgLFxuICAgIC8vIC0gYSBtYXAgZnJvbSBmaWxlIHRvIHBpcGVzIGBuZ1BpcGVzQnlGaWxlYCxcbiAgICAvLyAtIGEgbWFwIGZyb20gZGlyZWN0aXZlL3BpcGUgdG8gbW9kdWxlIGBuZ01vZHVsZUJ5UGlwZU9yRGlyZWN0aXZlYC5cbiAgICBuZ01vZHVsZU1ldGFzLmZvckVhY2goZnVuY3Rpb24gKG5nTW9kdWxlTWV0YSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcmNGaWxlVXJsID0gbmdNb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlLmZpbGVQYXRoO1xuICAgICAgICBmaWxlUGF0aHMuYWRkKHNyY0ZpbGVVcmwpO1xuICAgICAgICBuZ01vZHVsZXNCeUZpbGUuc2V0KHNyY0ZpbGVVcmwsIChuZ01vZHVsZXNCeUZpbGUuZ2V0KHNyY0ZpbGVVcmwpIHx8IFtdKS5jb25jYXQobmdNb2R1bGVNZXRhLnR5cGUucmVmZXJlbmNlKSk7XG4gICAgICAgIG5nTW9kdWxlTWV0YS5kZWNsYXJlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlySWRlbnRpZmllcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZVVybCA9IGRpcklkZW50aWZpZXIucmVmZXJlbmNlLmZpbGVQYXRoO1xuICAgICAgICAgICAgZmlsZVBhdGhzLmFkZChmaWxlVXJsKTtcbiAgICAgICAgICAgIG5nRGlyZWN0aXZlc0J5RmlsZS5zZXQoZmlsZVVybCwgKG5nRGlyZWN0aXZlc0J5RmlsZS5nZXQoZmlsZVVybCkgfHwgW10pLmNvbmNhdChkaXJJZGVudGlmaWVyLnJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZS5zZXQoZGlySWRlbnRpZmllci5yZWZlcmVuY2UsIG5nTW9kdWxlTWV0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBuZ01vZHVsZU1ldGEuZGVjbGFyZWRQaXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChwaXBlSWRlbnRpZmllcikge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZVVybCA9IHBpcGVJZGVudGlmaWVyLnJlZmVyZW5jZS5maWxlUGF0aDtcbiAgICAgICAgICAgIGZpbGVQYXRocy5hZGQoZmlsZVVybCk7XG4gICAgICAgICAgICBuZ1BpcGVzQnlGaWxlLnNldChmaWxlVXJsLCAobmdQaXBlc0J5RmlsZS5nZXQoZmlsZVVybCkgfHwgW10pLmNvbmNhdChwaXBlSWRlbnRpZmllci5yZWZlcmVuY2UpKTtcbiAgICAgICAgICAgIG5nTW9kdWxlQnlQaXBlT3JEaXJlY3RpdmUuc2V0KHBpcGVJZGVudGlmaWVyLnJlZmVyZW5jZSwgbmdNb2R1bGVNZXRhKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZXMgPSBbXTtcbiAgICBmaWxlUGF0aHMuZm9yRWFjaChmdW5jdGlvbiAoc3JjVXJsKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRpcmVjdGl2ZXMgPSBuZ0RpcmVjdGl2ZXNCeUZpbGUuZ2V0KHNyY1VybCkgfHwgW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVzID0gbmdQaXBlc0J5RmlsZS5nZXQoc3JjVXJsKSB8fCBbXTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVzID0gbmdNb2R1bGVzQnlGaWxlLmdldChzcmNVcmwpIHx8IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbmplY3RhYmxlcyA9IG5nSW5qZWN0YWJsZXNCeUZpbGUuZ2V0KHNyY1VybCkgfHwgW107XG4gICAgICAgIGZpbGVzLnB1c2goeyBzcmNVcmw6IHNyY1VybCwgZGlyZWN0aXZlczogZGlyZWN0aXZlcywgcGlwZXM6IHBpcGVzLCBuZ01vZHVsZXM6IG5nTW9kdWxlcywgaW5qZWN0YWJsZXM6IGluamVjdGFibGVzIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIG1hcCBkaXJlY3RpdmUvcGlwZSB0byBtb2R1bGVcbiAgICAgICAgbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZTogbmdNb2R1bGVCeVBpcGVPckRpcmVjdGl2ZSxcbiAgICAgICAgLy8gbGlzdCBtb2R1bGVzIGFuZCBkaXJlY3RpdmVzIGZvciBldmVyeSBzb3VyY2UgZmlsZVxuICAgICAgICBmaWxlczogZmlsZXMsXG4gICAgICAgIG5nTW9kdWxlczogbmdNb2R1bGVNZXRhcywgc3ltYm9sc01pc3NpbmdNb2R1bGU6IHN5bWJvbHNNaXNzaW5nTW9kdWxlXG4gICAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xSZXNvbHZlclxuICogQHBhcmFtIHs/fSBmaWxlc1xuICogQHBhcmFtIHs/fSBob3N0XG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvZ3JhbVN5bWJvbHMoc3RhdGljU3ltYm9sUmVzb2x2ZXIsIGZpbGVzLCBob3N0KSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9scyA9IFtdO1xuICAgIGZpbGVzLmZpbHRlcihmdW5jdGlvbiAoZmlsZU5hbWUpIHsgcmV0dXJuIGhvc3QuaXNTb3VyY2VGaWxlKGZpbGVOYW1lKTsgfSkuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgICBzdGF0aWNTeW1ib2xSZXNvbHZlci5nZXRTeW1ib2xzT2Yoc291cmNlRmlsZSkuZm9yRWFjaChmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFN5bWJvbCA9IHN0YXRpY1N5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2woc3ltYm9sKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbE1ldGEgPSByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChzeW1ib2xNZXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbE1ldGEuX19zeW1ib2xpYyAhPSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBzeW1ib2xzIHRoYXQgYXJlIG9ubHkgaW5jbHVkZWQgdG8gcmVjb3JkIGVycm9yIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgICAgICAgICBzdGF0aWNTeW1ib2xzLnB1c2gocmVzb2x2ZWRTeW1ib2wuc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzdGF0aWNTeW1ib2xzO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IHByb2dyYW1TdGF0aWNTeW1ib2xzXG4gKiBAcGFyYW0gez99IGhvc3RcbiAqIEBwYXJhbSB7P30gbWV0YWRhdGFSZXNvbHZlclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZU5nTW9kdWxlcyhwcm9ncmFtU3RhdGljU3ltYm9scywgaG9zdCwgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlcyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9ncmFtUGlwZXNBbmREaXJlY3RpdmVzID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmdNb2R1bGVQaXBlc0FuZERpcmVjdGl2ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhZGROZ01vZHVsZSA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgaWYgKG5nTW9kdWxlcy5oYXMoc3RhdGljU3ltYm9sKSB8fCAhaG9zdC5pc1NvdXJjZUZpbGUoc3RhdGljU3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlID0gbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKHN0YXRpY1N5bWJvbCwgZmFsc2UpO1xuICAgICAgICBpZiAobmdNb2R1bGUpIHtcbiAgICAgICAgICAgIG5nTW9kdWxlcy5zZXQobmdNb2R1bGUudHlwZS5yZWZlcmVuY2UsIG5nTW9kdWxlKTtcbiAgICAgICAgICAgIG5nTW9kdWxlLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIG5nTW9kdWxlUGlwZXNBbmREaXJlY3RpdmUuYWRkKGRpci5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgICAgIG5nTW9kdWxlLmRlY2xhcmVkUGlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGlwZSkgeyByZXR1cm4gbmdNb2R1bGVQaXBlc0FuZERpcmVjdGl2ZS5hZGQocGlwZS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgICAgIC8vIEZvciBldmVyeSBpbnB1dCBtb2R1bGUgYWRkIHRoZSBsaXN0IG9mIHRyYW5zaXRpdmVseSBpbmNsdWRlZCBtb2R1bGVzXG4gICAgICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kTWV0YSkgeyByZXR1cm4gYWRkTmdNb2R1bGUobW9kTWV0YS5yZWZlcmVuY2UpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFuZ01vZHVsZTtcbiAgICB9O1xuICAgIHByb2dyYW1TdGF0aWNTeW1ib2xzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBpZiAoIWFkZE5nTW9kdWxlKHN0YXRpY1N5bWJvbCkgJiZcbiAgICAgICAgICAgIChtZXRhZGF0YVJlc29sdmVyLmlzRGlyZWN0aXZlKHN0YXRpY1N5bWJvbCkgfHwgbWV0YWRhdGFSZXNvbHZlci5pc1BpcGUoc3RhdGljU3ltYm9sKSkpIHtcbiAgICAgICAgICAgIHByb2dyYW1QaXBlc0FuZERpcmVjdGl2ZXMucHVzaChzdGF0aWNTeW1ib2wpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBwcm9ncmFtIHBpcGUgb3IgZGlyZWN0aXZlcyBpcyBub3QgZGVjbGFyZWQgYnkgYSBtb2R1bGVcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xzTWlzc2luZ01vZHVsZSA9IHByb2dyYW1QaXBlc0FuZERpcmVjdGl2ZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiAhbmdNb2R1bGVQaXBlc0FuZERpcmVjdGl2ZS5oYXMocyk7IH0pO1xuICAgIHJldHVybiB7IG5nTW9kdWxlczogQXJyYXkuZnJvbShuZ01vZHVsZXMudmFsdWVzKCkpLCBzeW1ib2xzTWlzc2luZ01vZHVsZTogc3ltYm9sc01pc3NpbmdNb2R1bGUgfTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNEZWxlZ2F0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKHN0YXRpY0RlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGljRGVsZWdhdGUgPSBzdGF0aWNEZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5keW5hbWljRGVsZWdhdGUgPSBuZXcgybVSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljRGVsZWdhdGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmluc3RhbGwgPSBmdW5jdGlvbiAoc3RhdGljRGVsZWdhdGUpIHtcbiAgICAgICAgybVyZWZsZWN0b3IudXBkYXRlQ2FwYWJpbGl0aWVzKG5ldyBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcyhzdGF0aWNEZWxlZ2F0ZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuaXNSZWZsZWN0aW9uRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuZmFjdG9yeSA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0aGlzLmR5bmFtaWNEZWxlZ2F0ZS5mYWN0b3J5KHR5cGUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gbGNQcm9wZXJ0eVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLmhhc0xpZmVjeWNsZUhvb2sgPSBmdW5jdGlvbiAodHlwZSwgbGNQcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gaXNTdGF0aWNUeXBlKHR5cGUpID8gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5oYXNMaWZlY3ljbGVIb29rKHR5cGUsIGxjUHJvcGVydHkpIDpcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY0RlbGVnYXRlLmhhc0xpZmVjeWNsZUhvb2sodHlwZSwgbGNQcm9wZXJ0eSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RhdGljVHlwZSh0eXBlKSA/IHRoaXMuc3RhdGljRGVsZWdhdGUucGFyYW1ldGVycyh0eXBlKSA6XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWxlZ2F0ZS5wYXJhbWV0ZXJzKHR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gaXNTdGF0aWNUeXBlKHR5cGUpID8gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5hbm5vdGF0aW9ucyh0eXBlKSA6XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWxlZ2F0ZS5hbm5vdGF0aW9ucyh0eXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZU9yRnVuY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnByb3BNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlT3JGdW5jKSB7XG4gICAgICAgIHJldHVybiBpc1N0YXRpY1R5cGUodHlwZU9yRnVuYykgPyB0aGlzLnN0YXRpY0RlbGVnYXRlLnByb3BNZXRhZGF0YSh0eXBlT3JGdW5jKSA6XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNEZWxlZ2F0ZS5wcm9wTWV0YWRhdGEodHlwZU9yRnVuYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5nZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdGhpcy5keW5hbWljRGVsZWdhdGUuZ2V0dGVyKG5hbWUpOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnNldHRlciA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLmR5bmFtaWNEZWxlZ2F0ZS5zZXR0ZXIobmFtZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUubWV0aG9kID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIHRoaXMuZHluYW1pY0RlbGVnYXRlLm1ldGhvZChuYW1lKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLnByb3RvdHlwZS5pbXBvcnRVcmkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5pbXBvcnRVcmkodHlwZSk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcy5wcm90b3R5cGUucmVzb3VyY2VVcmkgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5yZXNvdXJjZVVyaSh0eXBlKTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVVybFxuICAgICAqIEBwYXJhbSB7P30gbWVtYmVyc1xuICAgICAqIEBwYXJhbSB7P30gcnVudGltZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnJlc29sdmVJZGVudGlmaWVyID0gZnVuY3Rpb24gKG5hbWUsIG1vZHVsZVVybCwgbWVtYmVycywgcnVudGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5yZXNvbHZlSWRlbnRpZmllcihuYW1lLCBtb2R1bGVVcmwsIG1lbWJlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbnVtSWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljQW5kRHluYW1pY1JlZmxlY3Rpb25DYXBhYmlsaXRpZXMucHJvdG90eXBlLnJlc29sdmVFbnVtID0gZnVuY3Rpb24gKGVudW1JZGVudGlmaWVyLCBuYW1lKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY1R5cGUoZW51bUlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0aWNEZWxlZ2F0ZS5yZXNvbHZlRW51bShlbnVtSWRlbnRpZmllciwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSB0eXBlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBpc1N0YXRpY1R5cGUodHlwZSkge1xuICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZS5uYW1lICYmIHR5cGUuZmlsZVBhdGg7XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG52YXIgQU5HVUxBUl9DT1JFID0gJ0Bhbmd1bGFyL2NvcmUnO1xudmFyIEhJRERFTl9LRVkgPSAvXlxcJC4qXFwkJC87XG52YXIgSUdOT1JFID0ge1xuICAgIF9fc3ltYm9saWM6ICdpZ25vcmUnXG59O1xuLyoqXG4gKiBAcGFyYW0gez99IHZhbHVlXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBzaG91bGRJZ25vcmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX19zeW1ib2xpYyA9PSAnaWdub3JlJztcbn1cbi8qKlxuICogQSBzdGF0aWMgcmVmbGVjdG9yIGltcGxlbWVudHMgZW5vdWdoIG9mIHRoZSBSZWZsZWN0b3IgQVBJIHRoYXQgaXMgbmVjZXNzYXJ5IHRvIGNvbXBpbGVcbiAqIHRlbXBsYXRlcyBzdGF0aWNhbGx5LlxuICovXG52YXIgU3RhdGljUmVmbGVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN1bW1hcnlSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sUmVzb2x2ZXJcbiAgICAgKiBAcGFyYW0gez89fSBrbm93bk1ldGFkYXRhQ2xhc3Nlc1xuICAgICAqIEBwYXJhbSB7Pz19IGtub3duTWV0YWRhdGFGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0gez89fSBlcnJvclJlY29yZGVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdGljUmVmbGVjdG9yKHN1bW1hcnlSZXNvbHZlciwgc3ltYm9sUmVzb2x2ZXIsIGtub3duTWV0YWRhdGFDbGFzc2VzLCBrbm93bk1ldGFkYXRhRnVuY3Rpb25zLCBlcnJvclJlY29yZGVyKSB7XG4gICAgICAgIGlmIChrbm93bk1ldGFkYXRhQ2xhc3NlcyA9PT0gdm9pZCAwKSB7IGtub3duTWV0YWRhdGFDbGFzc2VzID0gW107IH1cbiAgICAgICAgaWYgKGtub3duTWV0YWRhdGFGdW5jdGlvbnMgPT09IHZvaWQgMCkgeyBrbm93bk1ldGFkYXRhRnVuY3Rpb25zID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdW1tYXJ5UmVzb2x2ZXIgPSBzdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuc3ltYm9sUmVzb2x2ZXIgPSBzeW1ib2xSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyID0gZXJyb3JSZWNvcmRlcjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucHJvcGVydHlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZXRob2RDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jb252ZXJzaW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvbnZlcnNpb25NYXAoKTtcbiAgICAgICAga25vd25NZXRhZGF0YUNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoa2MpIHsgcmV0dXJuIF90aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IoX3RoaXMuZ2V0U3RhdGljU3ltYm9sKGtjLmZpbGVQYXRoLCBrYy5uYW1lKSwga2MuY3Rvcik7IH0pO1xuICAgICAgICBrbm93bk1ldGFkYXRhRnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGtmKSB7IHJldHVybiBfdGhpcy5fcmVnaXN0ZXJGdW5jdGlvbihfdGhpcy5nZXRTdGF0aWNTeW1ib2woa2YuZmlsZVBhdGgsIGtmLm5hbWUpLCBrZi5mbik7IH0pO1xuICAgICAgICB0aGlzLmFubm90YXRpb25Gb3JQYXJlbnRDbGFzc1dpdGhTdW1tYXJ5S2luZC5zZXQoQ29tcGlsZVN1bW1hcnlLaW5kLkRpcmVjdGl2ZSwgW0RpcmVjdGl2ZSwgQ29tcG9uZW50XSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkZvclBhcmVudENsYXNzV2l0aFN1bW1hcnlLaW5kLnNldChDb21waWxlU3VtbWFyeUtpbmQuUGlwZSwgW1BpcGVdKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uRm9yUGFyZW50Q2xhc3NXaXRoU3VtbWFyeUtpbmQuc2V0KENvbXBpbGVTdW1tYXJ5S2luZC5OZ01vZHVsZSwgW05nTW9kdWxlXSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkZvclBhcmVudENsYXNzV2l0aFN1bW1hcnlLaW5kLnNldChDb21waWxlU3VtbWFyeUtpbmQuSW5qZWN0YWJsZSwgW0luamVjdGFibGUsIFBpcGUsIERpcmVjdGl2ZSwgQ29tcG9uZW50LCBOZ01vZHVsZV0pO1xuICAgICAgICB0aGlzLmFubm90YXRpb25OYW1lcy5zZXQoRGlyZWN0aXZlLCAnRGlyZWN0aXZlJyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk5hbWVzLnNldChDb21wb25lbnQsICdDb21wb25lbnQnKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTmFtZXMuc2V0KFBpcGUsICdQaXBlJyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk5hbWVzLnNldChOZ01vZHVsZSwgJ05nTW9kdWxlJyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbk5hbWVzLnNldChJbmplY3RhYmxlLCAnSW5qZWN0YWJsZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVPckZ1bmNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuaW1wb3J0VXJpID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sID0gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24odHlwZU9yRnVuYyk7XG4gICAgICAgIHJldHVybiBzdGF0aWNTeW1ib2wgPyBzdGF0aWNTeW1ib2wuZmlsZVBhdGggOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlT3JGdW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnJlc291cmNlVXJpID0gZnVuY3Rpb24gKHR5cGVPckZ1bmMpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sID0gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24odHlwZU9yRnVuYyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFJlc291cmNlUGF0aChzdGF0aWNTeW1ib2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVVcmxcbiAgICAgKiBAcGFyYW0gez99IG1lbWJlcnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucmVzb2x2ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAobmFtZSwgbW9kdWxlVXJsLCBtZW1iZXJzKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGltcG9ydFN5bWJvbCA9IHRoaXMuZ2V0U3RhdGljU3ltYm9sKG1vZHVsZVVybCwgbmFtZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJvb3RTeW1ib2wgPSB0aGlzLmZpbmREZWNsYXJhdGlvbihtb2R1bGVVcmwsIG5hbWUpO1xuICAgICAgICBpZiAoaW1wb3J0U3ltYm9sICE9IHJvb3RTeW1ib2wpIHtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sUmVzb2x2ZXIucmVjb3JkSW1wb3J0QXMocm9vdFN5bWJvbCwgaW1wb3J0U3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtYmVycyAmJiBtZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGljU3ltYm9sKHJvb3RTeW1ib2wuZmlsZVBhdGgsIHJvb3RTeW1ib2wubmFtZSwgbWVtYmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RTeW1ib2w7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVVybFxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEBwYXJhbSB7Pz19IGNvbnRhaW5pbmdGaWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChtb2R1bGVVcmwsIG5hbWUsIGNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRTeW1ib2xEZWNsYXJhdGlvbih0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN5bWJvbEJ5TW9kdWxlKG1vZHVsZVVybCwgbmFtZSwgY29udGFpbmluZ0ZpbGUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLmZpbmRTeW1ib2xEZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRTeW1ib2wgPSB0aGlzLnN5bWJvbFJlc29sdmVyLnJlc29sdmVTeW1ib2woc3ltYm9sKTtcbiAgICAgICAgaWYgKHJlc29sdmVkU3ltYm9sICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kU3ltYm9sRGVjbGFyYXRpb24ocmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlbnVtSWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5yZXNvbHZlRW51bSA9IGZ1bmN0aW9uIChlbnVtSWRlbnRpZmllciwgbmFtZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNTeW1ib2wgPSBlbnVtSWRlbnRpZmllcjtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVycyA9IChzdGF0aWNTeW1ib2wubWVtYmVycyB8fCBbXSkuY29uY2F0KG5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLmZpbGVQYXRoLCBzdGF0aWNTeW1ib2wubmFtZSwgbWVtYmVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuYW5ub3RhdGlvbnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhbm5vdGF0aW9ucyA9IHRoaXMuYW5ub3RhdGlvbkNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgYW5ub3RhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudFR5cGUgPSB0aGlzLmZpbmRQYXJlbnRUeXBlKHR5cGUsIGNsYXNzTWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRBbm5vdGF0aW9ucyA9IHRoaXMuYW5ub3RhdGlvbnMocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaC5hcHBseShhbm5vdGF0aW9ucywgcGFyZW50QW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3duQW5ub3RhdGlvbnNfMSA9IFtdO1xuICAgICAgICAgICAgaWYgKGNsYXNzTWV0YWRhdGFbJ2RlY29yYXRvcnMnXSkge1xuICAgICAgICAgICAgICAgIG93bkFubm90YXRpb25zXzEgPSB0aGlzLnNpbXBsaWZ5KHR5cGUsIGNsYXNzTWV0YWRhdGFbJ2RlY29yYXRvcnMnXSk7XG4gICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMucHVzaC5hcHBseShhbm5vdGF0aW9ucywgb3duQW5ub3RhdGlvbnNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50VHlwZSAmJiAhdGhpcy5zdW1tYXJ5UmVzb2x2ZXIuaXNMaWJyYXJ5RmlsZSh0eXBlLmZpbGVQYXRoKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUocGFyZW50VHlwZS5maWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5ID0gdGhpcy5zdW1tYXJ5UmVzb2x2ZXIucmVzb2x2ZVN1bW1hcnkocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1bW1hcnkgJiYgc3VtbWFyeS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlcXVpcmVkQW5ub3RhdGlvblR5cGVzID0gdGhpcy5hbm5vdGF0aW9uRm9yUGFyZW50Q2xhc3NXaXRoU3VtbWFyeUtpbmQuZ2V0KHN1bW1hcnkudHlwZS5zdW1tYXJ5S2luZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHR5cGVIYXNSZXF1aXJlZEFubm90YXRpb24gPSByZXF1aXJlZEFubm90YXRpb25UeXBlcy5zb21lKGZ1bmN0aW9uIChyZXF1aXJlZFR5cGUpIHsgcmV0dXJuIG93bkFubm90YXRpb25zXzEuc29tZShmdW5jdGlvbiAoYW5uKSB7IHJldHVybiBhbm4gaW5zdGFuY2VvZiByZXF1aXJlZFR5cGU7IH0pOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlSGFzUmVxdWlyZWRBbm5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKHN5bnRheEVycm9yKFwiQ2xhc3MgXCIgKyB0eXBlLm5hbWUgKyBcIiBpbiBcIiArIHR5cGUuZmlsZVBhdGggKyBcIiBleHRlbmRzIGZyb20gYSBcIiArIENvbXBpbGVTdW1tYXJ5S2luZFtzdW1tYXJ5LnR5cGUuc3VtbWFyeUtpbmRdICsgXCIgaW4gYW5vdGhlciBjb21waWxhdGlvbiB1bml0IHdpdGhvdXQgZHVwbGljYXRpbmcgdGhlIGRlY29yYXRvci4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIlBsZWFzZSBhZGQgYSBcIiArIHJlcXVpcmVkQW5ub3RhdGlvblR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuYW5ub3RhdGlvbk5hbWVzLmdldCh0eXBlKTsgfSkuam9pbignIG9yICcpICsgXCIgZGVjb3JhdG9yIHRvIHRoZSBjbGFzcy5cIikpLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhY2hlLnNldCh0eXBlLCBhbm5vdGF0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGFubikgeyByZXR1cm4gISFhbm47IH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucHJvcE1ldGFkYXRhID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcE1ldGFkYXRhID0gdGhpcy5wcm9wZXJ0eUNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgaWYgKCFwcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXNzTWV0YWRhdGEgPSB0aGlzLmdldFR5cGVNZXRhZGF0YSh0eXBlKTtcbiAgICAgICAgICAgIHByb3BNZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50VHlwZSA9IHRoaXMuZmluZFBhcmVudFR5cGUodHlwZSwgY2xhc3NNZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAocGFyZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudFByb3BNZXRhZGF0YV8xID0gdGhpcy5wcm9wTWV0YWRhdGEocGFyZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGFyZW50UHJvcE1ldGFkYXRhXzEpLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhW3BhcmVudFByb3BdID0gcGFyZW50UHJvcE1ldGFkYXRhXzFbcGFyZW50UHJvcF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZW1iZXJzXzEgPSBjbGFzc01ldGFkYXRhWydtZW1iZXJzJ10gfHwge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhtZW1iZXJzXzEpLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcERhdGEgPSBtZW1iZXJzXzFbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb3AgPSAoKHByb3BEYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbJ19fc3ltYm9saWMnXSA9PSAncHJvcGVydHknIHx8IGFbJ19fc3ltYm9saWMnXSA9PSAnbWV0aG9kJzsgfSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTWV0YWRhdGFbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRvcnMucHVzaC5hcHBseShkZWNvcmF0b3JzLCBwcm9wTWV0YWRhdGFbcHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvcE1ldGFkYXRhW3Byb3BOYW1lXSA9IGRlY29yYXRvcnM7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgJiYgcHJvcFsnZGVjb3JhdG9ycyddKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRvcnMucHVzaC5hcHBseShkZWNvcmF0b3JzLCBfdGhpcy5zaW1wbGlmeSh0eXBlLCBwcm9wWydkZWNvcmF0b3JzJ10pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHlDYWNoZS5zZXQodHlwZSwgcHJvcE1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcE1ldGFkYXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnBhcmFtZXRlcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihuZXcgRXJyb3IoXCJwYXJhbWV0ZXJzIHJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkodHlwZSkgKyBcIiB3aGljaCBpcyBub3QgYSBTdGF0aWNTeW1ib2xcIiksIHR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbWV0ZXJzXzEgPSB0aGlzLnBhcmFtZXRlckNhY2hlLmdldCh0eXBlKTtcbiAgICAgICAgICAgIGlmICghcGFyYW1ldGVyc18xKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xhc3NNZXRhZGF0YSA9IHRoaXMuZ2V0VHlwZU1ldGFkYXRhKHR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudFR5cGUgPSB0aGlzLmZpbmRQYXJlbnRUeXBlKHR5cGUsIGNsYXNzTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnMgPSBjbGFzc01ldGFkYXRhID8gY2xhc3NNZXRhZGF0YVsnbWVtYmVycyddIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdG9yRGF0YSA9IG1lbWJlcnMgPyBtZW1iZXJzWydfX2N0b3JfXyddIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoY3RvckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3RvciA9ICgoY3RvckRhdGEpKS5maW5kKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWydfX3N5bWJvbGljJ10gPT0gJ2NvbnN0cnVjdG9yJzsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtZXRlclR5cGVzID0gKHRoaXMuc2ltcGxpZnkodHlwZSwgY3RvclsncGFyYW1ldGVycyddIHx8IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtZXRlckRlY29yYXRvcnNfMSA9ICh0aGlzLnNpbXBsaWZ5KHR5cGUsIGN0b3JbJ3BhcmFtZXRlckRlY29yYXRvcnMnXSB8fCBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyVHlwZXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW1UeXBlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmVzdGVkUmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkUmVzdWx0LnB1c2gocGFyYW1UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlY29yYXRvcnMgPSBwYXJhbWV0ZXJEZWNvcmF0b3JzXzEgPyBwYXJhbWV0ZXJEZWNvcmF0b3JzXzFbaW5kZXhdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNvcmF0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkUmVzdWx0LnB1c2guYXBwbHkobmVzdGVkUmVzdWx0LCBkZWNvcmF0b3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNfMS5wdXNoKG5lc3RlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNfMSA9IHRoaXMucGFyYW1ldGVycyhwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbWV0ZXJzXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc18xID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyQ2FjaGUuc2V0KHR5cGUsIHBhcmFtZXRlcnNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyc18xO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIG9uIHR5cGUgXCIgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSArIFwiIHdpdGggZXJyb3IgXCIgKyBlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5fbWV0aG9kTmFtZXMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRob2ROYW1lcyA9IHRoaXMubWV0aG9kQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoIW1ldGhvZE5hbWVzKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGFzc01ldGFkYXRhID0gdGhpcy5nZXRUeXBlTWV0YWRhdGEodHlwZSk7XG4gICAgICAgICAgICBtZXRob2ROYW1lcyA9IHt9O1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyZW50VHlwZSA9IHRoaXMuZmluZFBhcmVudFR5cGUodHlwZSwgY2xhc3NNZXRhZGF0YSk7XG4gICAgICAgICAgICBpZiAocGFyZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmVudE1ldGhvZE5hbWVzXzEgPSB0aGlzLl9tZXRob2ROYW1lcyhwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJlbnRNZXRob2ROYW1lc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWVzW3BhcmVudFByb3BdID0gcGFyZW50TWV0aG9kTmFtZXNfMVtwYXJlbnRQcm9wXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnNfMiA9IGNsYXNzTWV0YWRhdGFbJ21lbWJlcnMnXSB8fCB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG1lbWJlcnNfMikuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wRGF0YSA9IG1lbWJlcnNfMltwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaXNNZXRob2QgPSAoKHByb3BEYXRhKSkuc29tZShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVsnX19zeW1ib2xpYyddID09ICdtZXRob2QnOyB9KTtcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lc1twcm9wTmFtZV0gPSBtZXRob2ROYW1lc1twcm9wTmFtZV0gfHwgaXNNZXRob2Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWV0aG9kQ2FjaGUuc2V0KHR5cGUsIG1ldGhvZE5hbWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWV0aG9kTmFtZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcGFyYW0gez99IGNsYXNzTWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuZmluZFBhcmVudFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgY2xhc3NNZXRhZGF0YSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJlbnRUeXBlID0gdGhpcy50cnlTaW1wbGlmeSh0eXBlLCBjbGFzc01ldGFkYXRhWydleHRlbmRzJ10pO1xuICAgICAgICBpZiAocGFyZW50VHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFR5cGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gbGNQcm9wZXJ0eVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5oYXNMaWZlY3ljbGVIb29rID0gZnVuY3Rpb24gKHR5cGUsIGxjUHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEodHlwZSBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IobmV3IEVycm9yKFwiaGFzTGlmZWN5Y2xlSG9vayByZWNlaXZlZCBcIiArIEpTT04uc3RyaW5naWZ5KHR5cGUpICsgXCIgd2hpY2ggaXMgbm90IGEgU3RhdGljU3ltYm9sXCIpLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5fbWV0aG9kTmFtZXModHlwZSlbbGNQcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgb24gdHlwZSBcIiArIEpTT04uc3RyaW5naWZ5KHR5cGUpICsgXCIgd2l0aCBlcnJvciBcIiArIGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHBhcmFtIHs/fSBjdG9yXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAodHlwZSwgY3Rvcikge1xuICAgICAgICB0aGlzLmNvbnZlcnNpb25NYXAuc2V0KHR5cGUsIGZ1bmN0aW9uIChjb250ZXh0LCBhcmdzKSB7IHJldHVybiBuZXcgKGN0b3IuYmluZC5hcHBseShjdG9yLCBbdm9pZCAwXS5jb25jYXQoYXJncykpKSgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuX3JlZ2lzdGVyRnVuY3Rpb24gPSBmdW5jdGlvbiAodHlwZSwgZm4pIHtcbiAgICAgICAgdGhpcy5jb252ZXJzaW9uTWFwLnNldCh0eXBlLCBmdW5jdGlvbiAoY29udGV4dCwgYXJncykgeyByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUuaW5pdGlhbGl6ZUNvbnZlcnNpb25NYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5qZWN0aW9uVG9rZW4gPSB0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdJbmplY3Rpb25Ub2tlbicpO1xuICAgICAgICB0aGlzLm9wYXF1ZVRva2VuID0gdGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnT3BhcXVlVG9rZW4nKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3QnKSwgSG9zdCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdJbmplY3RhYmxlJyksIEluamVjdGFibGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnU2VsZicpLCBTZWxmKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ1NraXBTZWxmJyksIFNraXBTZWxmKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0luamVjdCcpLCBJbmplY3QpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnT3B0aW9uYWwnKSwgT3B0aW9uYWwpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnQXR0cmlidXRlJyksIEF0dHJpYnV0ZSk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdDb250ZW50Q2hpbGQnKSwgQ29udGVudENoaWxkKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0NvbnRlbnRDaGlsZHJlbicpLCBDb250ZW50Q2hpbGRyZW4pO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnVmlld0NoaWxkJyksIFZpZXdDaGlsZCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdWaWV3Q2hpbGRyZW4nKSwgVmlld0NoaWxkcmVuKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0lucHV0JyksIElucHV0KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ091dHB1dCcpLCBPdXRwdXQpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnUGlwZScpLCBQaXBlKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3RCaW5kaW5nJyksIEhvc3RCaW5kaW5nKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3RMaXN0ZW5lcicpLCBIb3N0TGlzdGVuZXIpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnRGlyZWN0aXZlJyksIERpcmVjdGl2ZSk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdDb21wb25lbnQnKSwgQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ05nTW9kdWxlJyksIE5nTW9kdWxlKTtcbiAgICAgICAgLy8gTm90ZTogU29tZSBtZXRhZGF0YSBjbGFzc2VzIGNhbiBiZSB1c2VkIGRpcmVjdGx5IHdpdGggUHJvdmlkZXIuZGVwcy5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJEZWNvcmF0b3JPckNvbnN0cnVjdG9yKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ0hvc3QnKSwgSG9zdCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRGVjb3JhdG9yT3JDb25zdHJ1Y3Rvcih0aGlzLmZpbmREZWNsYXJhdGlvbihBTkdVTEFSX0NPUkUsICdTZWxmJyksIFNlbGYpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnU2tpcFNlbGYnKSwgU2tpcFNlbGYpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckRlY29yYXRvck9yQ29uc3RydWN0b3IodGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnT3B0aW9uYWwnKSwgT3B0aW9uYWwpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ3RyaWdnZXInKSwgdHJpZ2dlcik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRnVuY3Rpb24odGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnc3RhdGUnKSwgc3RhdGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ3RyYW5zaXRpb24nKSwgdHJhbnNpdGlvbik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRnVuY3Rpb24odGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnc3R5bGUnKSwgc3R5bGUpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ2FuaW1hdGUnKSwgYW5pbWF0ZSk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRnVuY3Rpb24odGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAna2V5ZnJhbWVzJyksIGtleWZyYW1lcyk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyRnVuY3Rpb24odGhpcy5maW5kRGVjbGFyYXRpb24oQU5HVUxBUl9DT1JFLCAnc2VxdWVuY2UnKSwgc2VxdWVuY2UpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckZ1bmN0aW9uKHRoaXMuZmluZERlY2xhcmF0aW9uKEFOR1VMQVJfQ09SRSwgJ2dyb3VwJyksIGdyb3VwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldFN0YXRpY1N5bWJvbCBwcm9kdWNlcyBhIFR5cGUgd2hvc2UgbWV0YWRhdGEgaXMga25vd24gYnV0IHdob3NlIGltcGxlbWVudGF0aW9uIGlzIG5vdCBsb2FkZWQuXG4gICAgICogQWxsIHR5cGVzIHBhc3NlZCB0byB0aGUgU3RhdGljUmVzb2x2ZXIgc2hvdWxkIGJlIHBzZXVkby10eXBlcyByZXR1cm5lZCBieSB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P30gZGVjbGFyYXRpb25GaWxlIHRoZSBhYnNvbHV0ZSBwYXRoIG9mIHRoZSBmaWxlIHdoZXJlIHRoZSBzeW1ib2wgaXMgZGVjbGFyZWRcbiAgICAgKiBAcGFyYW0gez99IG5hbWUgdGhlIG5hbWUgb2YgdGhlIHR5cGUuXG4gICAgICogQHBhcmFtIHs/PX0gbWVtYmVyc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5nZXRTdGF0aWNTeW1ib2wgPSBmdW5jdGlvbiAoZGVjbGFyYXRpb25GaWxlLCBuYW1lLCBtZW1iZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFJlc29sdmVyLmdldFN0YXRpY1N5bWJvbChkZWNsYXJhdGlvbkZpbGUsIG5hbWUsIG1lbWJlcnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IHBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1JlZmxlY3Rvci5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGNvbnRleHQsIHBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JSZWNvcmRlcikge1xuICAgICAgICAgICAgdGhpcy5lcnJvclJlY29yZGVyKGVycm9yLCAoY29udGV4dCAmJiBjb250ZXh0LmZpbGVQYXRoKSB8fCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaW1wbGlmeSBidXQgZGlzY2FyZCBhbnkgZXJyb3JzXG4gICAgICogQHBhcmFtIHs/fSBjb250ZXh0XG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS50cnlTaW1wbGlmeSA9IGZ1bmN0aW9uIChjb250ZXh0LCB2YWx1ZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5hbFJlY29yZGVyID0gdGhpcy5lcnJvclJlY29yZGVyO1xuICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSBmdW5jdGlvbiAoZXJyb3IsIGZpbGVOYW1lKSB7IH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IHRoaXMuc2ltcGxpZnkoY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIgPSBvcmlnaW5hbFJlY29yZGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogXFxAaW50ZXJuYWxcbiAgICAgKiBAcGFyYW0gez99IGNvbnRleHRcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNSZWZsZWN0b3IucHJvdG90eXBlLnNpbXBsaWZ5ID0gZnVuY3Rpb24gKGNvbnRleHQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzY29wZSA9IEJpbmRpbmdTY29wZS5lbXB0eTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2FsbGluZyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7P30gZGVwdGhcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNpbXBsaWZ5SW5Db250ZXh0KGNvbnRleHQsIHZhbHVlLCBkZXB0aCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZVJlZmVyZW5jZVZhbHVlKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkU3ltYm9sID0gc2VsZi5zeW1ib2xSZXNvbHZlci5yZXNvbHZlU3ltYm9sKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkU3ltYm9sID8gcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGZ1bmN0aW9uU3ltYm9sXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IHRhcmdldEZ1bmN0aW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGFyZ3NcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNpbXBsaWZ5Q2FsbChmdW5jdGlvblN5bWJvbCwgdGFyZ2V0RnVuY3Rpb24sIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RnVuY3Rpb24gJiYgdGFyZ2V0RnVuY3Rpb25bJ19fc3ltYm9saWMnXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsaW5nLmdldChmdW5jdGlvblN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjdXJzaW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsaW5nLnNldChmdW5jdGlvblN5bWJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZV8xID0gdGFyZ2V0RnVuY3Rpb25bJ3ZhbHVlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVfMSAmJiAoZGVwdGggIT0gMCB8fCB2YWx1ZV8xLl9fc3ltYm9saWMgIT0gJ2Vycm9yJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbWV0ZXJzID0gdGFyZ2V0RnVuY3Rpb25bJ3BhcmFtZXRlcnMnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWZhdWx0cyA9IHRhcmdldEZ1bmN0aW9uLmRlZmF1bHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCBhcmcsIGRlcHRoICsgMSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gc2hvdWxkSWdub3JlKGFyZykgPyB1bmRlZmluZWQgOiBhcmc7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0cyAmJiBkZWZhdWx0cy5sZW5ndGggPiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgZGVmYXVsdHMuc2xpY2UoYXJncy5sZW5ndGgpLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHNpbXBsaWZ5KHZhbHVlKTsgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmdW5jdGlvblNjb3BlID0gQmluZGluZ1Njb3BlLmJ1aWxkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25TY29wZS5kZWZpbmUocGFyYW1ldGVyc1tpXSwgYXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZFNjb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0XzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBmdW5jdGlvblNjb3BlLmRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzEgPSBzaW1wbGlmeUluQ29udGV4dChmdW5jdGlvblN5bWJvbCwgdmFsdWVfMSwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gb2xkU2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxpbmcuZGVsZXRlKGZ1bmN0aW9uU3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGVwdGggaXMgMCB3ZSBhcmUgZXZhbHVhdGluZyB0aGUgdG9wIGxldmVsIGV4cHJlc3Npb24gdGhhdCBpcyBkZXNjcmliaW5nIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVjb3JhdG9yLiBJbiB0aGlzIGNhc2UsIGl0IGlzIGEgZGVjb3JhdG9yIHdlIGRvbid0IHVuZGVyc3RhbmQsIHN1Y2ggYXMgYSBjdXN0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gbm9uLWFuZ3VsYXIgZGVjb3JhdG9yLCBhbmQgd2Ugc2hvdWxkIGp1c3QgaWdub3JlIGl0LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSUdOT1JFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnkoeyBfX3N5bWJvbGljOiAnZXJyb3InLCBtZXNzYWdlOiAnRnVuY3Rpb24gY2FsbCBub3Qgc3VwcG9ydGVkJywgY29udGV4dDogZnVuY3Rpb25TeW1ib2wgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gZXhwcmVzc2lvblxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gc2ltcGxpZnkoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZShleHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHRfMiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gKChleHByZXNzaW9uKSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhIHNwcmVhZCBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLl9fc3ltYm9saWMgPT09ICdzcHJlYWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ByZWFkQXJyYXkgPSBzaW1wbGlmeShpdGVtLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNwcmVhZEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIHNwcmVhZEFycmF5XzEgPSBzcHJlYWRBcnJheTsgX2IgPCBzcHJlYWRBcnJheV8xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwcmVhZEl0ZW0gPSBzcHJlYWRBcnJheV8xW19iXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8yLnB1c2goc3ByZWFkSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVfMiA9IHNpbXBsaWZ5KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZSh2YWx1ZV8yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0XzIucHVzaCh2YWx1ZV8yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3Agc2ltcGxpZmljYXRpb24gYXQgYnVpbHRpbiBzeW1ib2xzXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uID09PSBzZWxmLmluamVjdGlvblRva2VuIHx8IGV4cHJlc3Npb24gPT09IHNlbGYub3BhcXVlVG9rZW4gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29udmVyc2lvbk1hcC5oYXMoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGRlY2xhcmF0aW9uVmFsdWUgPSByZXNvbHZlUmVmZXJlbmNlVmFsdWUoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNsYXJhdGlvblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5SW5Db250ZXh0KHN0YXRpY1N5bWJvbCwgZGVjbGFyYXRpb25WYWx1ZSwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0aWNTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25bJ19fc3ltYm9saWMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChleHByZXNzaW9uWydfX3N5bWJvbGljJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiaW5vcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxlZnQgPSBzaW1wbGlmeShleHByZXNzaW9uWydsZWZ0J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlKGxlZnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJpZ2h0ID0gc2ltcGxpZnkoZXhwcmVzc2lvblsncmlnaHQnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmUocmlnaHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV4cHJlc3Npb25bJ29wZXJhdG9yJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAmJiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCB8fCByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0IHwgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCBeIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgJiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA9PSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAhPSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAhPT0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA8IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgPiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA8PSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA+PSByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzw8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA8PCByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz4+JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCA+PiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAtIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQgKiByaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0IC8gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdCAlIHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZGl0aW9uID0gc2ltcGxpZnkoZXhwcmVzc2lvblsnY29uZGl0aW9uJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gc2ltcGxpZnkoZXhwcmVzc2lvblsndGhlbkV4cHJlc3Npb24nXSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxpZnkoZXhwcmVzc2lvblsnZWxzZUV4cHJlc3Npb24nXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gb3BlcmFuZCA9IHNpbXBsaWZ5KGV4cHJlc3Npb25bJ29wZXJhbmQnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmUob3BlcmFuZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChleHByZXNzaW9uWydvcGVyYXRvciddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtb3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhb3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ34nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB+b3BlcmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbmRleCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluZGV4VGFyZ2V0ID0gc2ltcGxpZnkoZXhwcmVzc2lvblsnZXhwcmVzc2lvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBzaW1wbGlmeShleHByZXNzaW9uWydpbmRleCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4VGFyZ2V0ICYmIGlzUHJpbWl0aXZlKGluZGV4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleFRhcmdldFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlciA9IGV4cHJlc3Npb25bJ21lbWJlciddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzZWxlY3RDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZWN0VGFyZ2V0ID0gc2ltcGxpZnkoZXhwcmVzc2lvblsnZXhwcmVzc2lvbiddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdFRhcmdldCBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVtYmVycyA9IHNlbGVjdFRhcmdldC5tZW1iZXJzLmNvbmNhdChtZW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0Q29udGV4dCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5nZXRTdGF0aWNTeW1ib2woc2VsZWN0VGFyZ2V0LmZpbGVQYXRoLCBzZWxlY3RUYXJnZXQubmFtZSwgbWVtYmVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkZWNsYXJhdGlvblZhbHVlID0gcmVzb2x2ZVJlZmVyZW5jZVZhbHVlKHNlbGVjdENvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2xhcmF0aW9uVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlJbkNvbnRleHQoc2VsZWN0Q29udGV4dCwgZGVjbGFyYXRpb25WYWx1ZSwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RUYXJnZXQgJiYgaXNQcmltaXRpdmUobWVtYmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeUluQ29udGV4dChzZWxlY3RDb250ZXh0LCBzZWxlY3RUYXJnZXRbbWVtYmVyXSwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmVmZXJlbmNlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogVGhpcyBvbmx5IGhhcyB0byBkZWFsIHdpdGggdmFyaWFibGUgcmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgc3ltYm9sIHJlZmVyZW5jZXMgaGF2ZSBiZWVuIGNvbnZlcnRlZCBpbnRvIFN0YXRpY1N5bWJvbHMgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgU3RhdGljU3ltYm9sUmVzb2x2ZXIhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBleHByZXNzaW9uWyduYW1lJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxvY2FsVmFsdWUgPSBzY29wZS5yZXNvbHZlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxWYWx1ZSAhPSBCaW5kaW5nU2NvcGUubWlzc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25ldyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2FsbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgZnVuY3Rpb24gaXMgYSBidWlsdC1pbiBjb252ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY1N5bWJvbCA9IHNpbXBsaWZ5SW5Db250ZXh0KGNvbnRleHQsIGV4cHJlc3Npb25bJ2V4cHJlc3Npb24nXSwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRpY1N5bWJvbCBpbnN0YW5jZW9mIFN0YXRpY1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRpY1N5bWJvbCA9PT0gc2VsZi5pbmplY3Rpb25Ub2tlbiB8fCBzdGF0aWNTeW1ib2wgPT09IHNlbGYub3BhcXVlVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBzb21lYm9keSBjYWxscyBuZXcgSW5qZWN0aW9uVG9rZW4sIGRvbid0IGNyZWF0ZSBhbiBJbmplY3Rpb25Ub2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgcmF0aGVyIHJldHVybiB0aGUgc3ltYm9sIHRvIHdoaWNoIHRoZSBJbmplY3Rpb25Ub2tlbiBpcyBhc3NpZ25lZCB0by5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGFyZ0V4cHJlc3Npb25zID0gZXhwcmVzc2lvblsnYXJndW1lbnRzJ10gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb252ZXJ0ZXIgPSBzZWxmLmNvbnZlcnNpb25NYXAuZ2V0KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IGFyZ0V4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCBhcmcsIGRlcHRoICsgMSk7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gc2hvdWxkSWdub3JlKGFyZykgPyB1bmRlZmluZWQgOiBhcmc7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZXIoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGZ1bmN0aW9uIGlzIG9uZSB3ZSBjYW4gc2ltcGxpZnkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdGFyZ2V0RnVuY3Rpb24gPSByZXNvbHZlUmVmZXJlbmNlVmFsdWUoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlDYWxsKHN0YXRpY1N5bWJvbCwgdGFyZ2V0RnVuY3Rpb24sIGFyZ0V4cHJlc3Npb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2UgPSBwcm9kdWNlRXJyb3JNZXNzYWdlKGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvblsnbGluZSddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICsgXCIgKHBvc2l0aW9uIFwiICsgKGV4cHJlc3Npb25bJ2xpbmUnXSArIDEpICsgXCI6XCIgKyAoZXhwcmVzc2lvblsnY2hhcmFjdGVyJ10gKyAxKSArIFwiIGluIHRoZSBvcmlnaW5hbCAudHMgZmlsZSlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVwb3J0RXJyb3IocG9zaXRpb25hbEVycm9yKG1lc3NhZ2UsIGNvbnRleHQuZmlsZVBhdGgsIGV4cHJlc3Npb25bJ2xpbmUnXSwgZXhwcmVzc2lvblsnY2hhcmFjdGVyJ10pLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVwb3J0RXJyb3IobmV3IEVycm9yKG1lc3NhZ2UpLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSUdOT1JFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcFN0cmluZ01hcChleHByZXNzaW9uLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHsgcmV0dXJuIHNpbXBsaWZ5KHZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBJR05PUkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lbWJlcnMgPSBjb250ZXh0Lm1lbWJlcnMubGVuZ3RoID8gXCIuXCIgKyBjb250ZXh0Lm1lbWJlcnMuam9pbignLicpIDogJyc7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZSA9IGUubWVzc2FnZSArIFwiLCByZXNvbHZpbmcgc3ltYm9sIFwiICsgY29udGV4dC5uYW1lICsgbWVtYmVycyArIFwiIGluIFwiICsgY29udGV4dC5maWxlUGF0aDtcbiAgICAgICAgICAgICAgICBpZiAoZS5maWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBwb3NpdGlvbmFsRXJyb3IobWVzc2FnZSwgZS5maWxlTmFtZSwgZS5saW5lLCBlLmNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IHN5bnRheEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY29yZGVkU2ltcGxpZnlJbkNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgdmFsdWUsIGRlcHRoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCB2YWx1ZSwgZGVwdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXBvcnRFcnJvcihlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5lcnJvclJlY29yZGVyID8gcmVjb3JkZWRTaW1wbGlmeUluQ29udGV4dChjb250ZXh0LCB2YWx1ZSwgMCkgOlxuICAgICAgICAgICAgc2ltcGxpZnlJbkNvbnRleHQoY29udGV4dCwgdmFsdWUsIDApO1xuICAgICAgICBpZiAoc2hvdWxkSWdub3JlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljUmVmbGVjdG9yLnByb3RvdHlwZS5nZXRUeXBlTWV0YWRhdGEgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZFN5bWJvbCA9IHRoaXMuc3ltYm9sUmVzb2x2ZXIucmVzb2x2ZVN5bWJvbCh0eXBlKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkU3ltYm9sICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhID8gcmVzb2x2ZWRTeW1ib2wubWV0YWRhdGEgOlxuICAgICAgICAgICAgeyBfX3N5bWJvbGljOiAnY2xhc3MnIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljUmVmbGVjdG9yO1xufSgpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBlcnJvclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXhwYW5kZWRNZXNzYWdlKGVycm9yKSB7XG4gICAgc3dpdGNoIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgIGNhc2UgJ1JlZmVyZW5jZSB0byBub24tZXhwb3J0ZWQgY2xhc3MnOlxuICAgICAgICAgICAgaWYgKGVycm9yLmNvbnRleHQgJiYgZXJyb3IuY29udGV4dC5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSZWZlcmVuY2UgdG8gYSBub24tZXhwb3J0ZWQgY2xhc3MgXCIgKyBlcnJvci5jb250ZXh0LmNsYXNzTmFtZSArIFwiLiBDb25zaWRlciBleHBvcnRpbmcgdGhlIGNsYXNzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVmFyaWFibGUgbm90IGluaXRpYWxpemVkJzpcbiAgICAgICAgICAgIHJldHVybiAnT25seSBpbml0aWFsaXplZCB2YXJpYWJsZXMgYW5kIGNvbnN0YW50cyBjYW4gYmUgcmVmZXJlbmNlZCBiZWNhdXNlIHRoZSB2YWx1ZSBvZiB0aGlzIHZhcmlhYmxlIGlzIG5lZWRlZCBieSB0aGUgdGVtcGxhdGUgY29tcGlsZXInO1xuICAgICAgICBjYXNlICdEZXN0cnVjdHVyaW5nIG5vdCBzdXBwb3J0ZWQnOlxuICAgICAgICAgICAgcmV0dXJuICdSZWZlcmVuY2luZyBhbiBleHBvcnRlZCBkZXN0cnVjdHVyZWQgdmFyaWFibGUgb3IgY29uc3RhbnQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgdGVtcGxhdGUgY29tcGlsZXIuIENvbnNpZGVyIHNpbXBsaWZ5aW5nIHRoaXMgdG8gYXZvaWQgZGVzdHJ1Y3R1cmluZyc7XG4gICAgICAgIGNhc2UgJ0NvdWxkIG5vdCByZXNvbHZlIHR5cGUnOlxuICAgICAgICAgICAgaWYgKGVycm9yLmNvbnRleHQgJiYgZXJyb3IuY29udGV4dC50eXBlTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkNvdWxkIG5vdCByZXNvbHZlIHR5cGUgXCIgKyBlcnJvci5jb250ZXh0LnR5cGVOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0Z1bmN0aW9uIGNhbGwgbm90IHN1cHBvcnRlZCc6XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcmVmaXggPSBlcnJvci5jb250ZXh0ICYmIGVycm9yLmNvbnRleHQubmFtZSA/IFwiQ2FsbGluZyBmdW5jdGlvbiAnXCIgKyBlcnJvci5jb250ZXh0Lm5hbWUgKyBcIicsIGZcIiA6ICdGJztcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggK1xuICAgICAgICAgICAgICAgICd1bmN0aW9uIGNhbGxzIGFyZSBub3Qgc3VwcG9ydGVkLiBDb25zaWRlciByZXBsYWNpbmcgdGhlIGZ1bmN0aW9uIG9yIGxhbWJkYSB3aXRoIGEgcmVmZXJlbmNlIHRvIGFuIGV4cG9ydGVkIGZ1bmN0aW9uJztcbiAgICAgICAgY2FzZSAnUmVmZXJlbmNlIHRvIGEgbG9jYWwgc3ltYm9sJzpcbiAgICAgICAgICAgIGlmIChlcnJvci5jb250ZXh0ICYmIGVycm9yLmNvbnRleHQubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlJlZmVyZW5jZSB0byBhIGxvY2FsIChub24tZXhwb3J0ZWQpIHN5bWJvbCAnXCIgKyBlcnJvci5jb250ZXh0Lm5hbWUgKyBcIicuIENvbnNpZGVyIGV4cG9ydGluZyB0aGUgc3ltYm9sXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gZXJyb3JcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIHByb2R1Y2VFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgICByZXR1cm4gXCJFcnJvciBlbmNvdW50ZXJlZCByZXNvbHZpbmcgc3ltYm9sIHZhbHVlcyBzdGF0aWNhbGx5LiBcIiArIGV4cGFuZGVkTWVzc2FnZShlcnJvcik7XG59XG4vKipcbiAqIEBwYXJhbSB7P30gaW5wdXRcbiAqIEBwYXJhbSB7P30gdHJhbnNmb3JtXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBtYXBTdHJpbmdNYXAoaW5wdXQsIHRyYW5zZm9ybSkge1xuICAgIGlmICghaW5wdXQpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhpbnB1dCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gdHJhbnNmb3JtKGlucHV0W2tleV0sIGtleSk7XG4gICAgICAgIGlmICghc2hvdWxkSWdub3JlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKEhJRERFTl9LRVkudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAcGFyYW0gez99IG9cbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gbnVsbCB8fCAodHlwZW9mIG8gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG8gIT09ICdvYmplY3QnKTtcbn1cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBCaW5kaW5nU2NvcGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmRpbmdTY29wZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBCaW5kaW5nU2NvcGUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAobmFtZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQmluZGluZ1Njb3BlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjdXJyZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVmaW5lOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnNpemUgPiAwID8gbmV3IFBvcHVsYXRlZFNjb3BlKGN1cnJlbnQpIDogQmluZGluZ1Njb3BlLmVtcHR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmRpbmdTY29wZTtcbn0oKSk7XG5CaW5kaW5nU2NvcGUubWlzc2luZyA9IHt9O1xuQmluZGluZ1Njb3BlLmVtcHR5ID0geyByZXNvbHZlOiBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gQmluZGluZ1Njb3BlLm1pc3Npbmc7IH0gfTtcbnZhciBQb3B1bGF0ZWRTY29wZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBvcHVsYXRlZFNjb3BlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYmluZGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQb3B1bGF0ZWRTY29wZShiaW5kaW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgUG9wdWxhdGVkU2NvcGUucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5ncy5oYXMobmFtZSkgPyB0aGlzLmJpbmRpbmdzLmdldChuYW1lKSA6IEJpbmRpbmdTY29wZS5taXNzaW5nO1xuICAgIH07XG4gICAgcmV0dXJuIFBvcHVsYXRlZFNjb3BlO1xufShCaW5kaW5nU2NvcGUpKTtcbi8qKlxuICogQHBhcmFtIHs/fSBtZXNzYWdlXG4gKiBAcGFyYW0gez99IGZpbGVOYW1lXG4gKiBAcGFyYW0gez99IGxpbmVcbiAqIEBwYXJhbSB7P30gY29sdW1uXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBwb3NpdGlvbmFsRXJyb3IobWVzc2FnZSwgZmlsZU5hbWUsIGxpbmUsIGNvbHVtbikge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAoKHJlc3VsdCkpLmZpbGVOYW1lID0gZmlsZU5hbWU7XG4gICAgKChyZXN1bHQpKS5saW5lID0gbGluZTtcbiAgICAoKHJlc3VsdCkpLmNvbHVtbiA9IGNvbHVtbjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFJlc29sdmVkU3RhdGljU3ltYm9sID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN5bWJvbFxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlZFN0YXRpY1N5bWJvbChzeW1ib2wsIG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgfVxuICAgIHJldHVybiBSZXNvbHZlZFN0YXRpY1N5bWJvbDtcbn0oKSk7XG52YXIgU1VQUE9SVEVEX1NDSEVNQV9WRVJTSU9OID0gMztcbi8qKlxuICogVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZyBtZXRhZGF0YSBwZXIgc3ltYm9sLFxuICogYW5kIG5vcm1hbGl6aW5nIHJlZmVyZW5jZXMgYmV0d2VlbiBzeW1ib2xzLlxuICpcbiAqIEludGVybmFsbHksIGl0IG9ubHkgdXNlcyBzeW1ib2xzIHdpdGhvdXQgbWVtYmVycyxcbiAqIGFuZCBkZWR1Y2VzIHRoZSB2YWx1ZXMgZm9yIHN5bWJvbHMgd2l0aCBtZW1iZXJzIGJhc2VkXG4gKiBvbiB0aGVzZSBzeW1ib2xzLlxuICovXG52YXIgU3RhdGljU3ltYm9sUmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sQ2FjaGVcbiAgICAgKiBAcGFyYW0gez99IHN1bW1hcnlSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7Pz19IGVycm9yUmVjb3JkZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0aWNTeW1ib2xSZXNvbHZlcihob3N0LCBzdGF0aWNTeW1ib2xDYWNoZSwgc3VtbWFyeVJlc29sdmVyLCBlcnJvclJlY29yZGVyKSB7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuc3RhdGljU3ltYm9sQ2FjaGUgPSBzdGF0aWNTeW1ib2xDYWNoZTtcbiAgICAgICAgdGhpcy5zdW1tYXJ5UmVzb2x2ZXIgPSBzdW1tYXJ5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuZXJyb3JSZWNvcmRlciA9IGVycm9yUmVjb3JkZXI7XG4gICAgICAgIHRoaXMubWV0YWRhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFN5bWJvbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRGaWxlUGF0aHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuaW1wb3J0QXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc3ltYm9sUmVzb3VyY2VQYXRocyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zeW1ib2xGcm9tRmlsZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5yZXNvbHZlU3ltYm9sID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICBpZiAoc3RhdGljU3ltYm9sLm1lbWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVTeW1ib2xNZW1iZXJzKHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gdGhpcy5yZXNvbHZlZFN5bWJvbHMuZ2V0KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5fcmVzb2x2ZVN5bWJvbEZyb21TdW1tYXJ5KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogU29tZSB1c2VycyB1c2UgbGlicmFyaWVzIHRoYXQgd2VyZSBub3QgY29tcGlsZWQgd2l0aCBuZ2MsIGkuZS4gdGhleSBkb24ndFxuICAgICAgICAvLyBoYXZlIHN1bW1hcmllcywgb25seSAuZC50cyBmaWxlcy4gU28gd2UgYWx3YXlzIG5lZWQgdG8gY2hlY2sgYm90aCwgdGhlIHN1bW1hcnlcbiAgICAgICAgLy8gYW5kIG1ldGFkYXRhLlxuICAgICAgICB0aGlzLl9jcmVhdGVTeW1ib2xzT2Yoc3RhdGljU3ltYm9sLmZpbGVQYXRoKTtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXNvbHZlZFN5bWJvbHMuZ2V0KHN0YXRpY1N5bWJvbCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRJbXBvcnRBcyBwcm9kdWNlcyBhIHN5bWJvbCB0aGF0IGNhbiBiZSB1c2VkIHRvIGltcG9ydCB0aGUgZ2l2ZW4gc3ltYm9sLlxuICAgICAqIFRoZSBpbXBvcnQgbWlnaHQgYmUgZGlmZmVyZW50IHRoYW4gdGhlIHN5bWJvbCBpZiB0aGUgc3ltYm9sIGlzIGV4cG9ydGVkIGZyb21cbiAgICAgKiBhIGxpYnJhcnkgd2l0aCBhIHN1bW1hcnk7IGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBpbXBvcnQgdGhlIHN5bWJvbCBmcm9tIHRoZVxuICAgICAqIG5nZmFjdG9yeSByZS1leHBvcnQgaW5zdGVhZCBvZiBkaXJlY3RseSB0byBhdm9pZCBpbnRyb2R1Y2luZyBhIGRpcmVjdCBkZXBlbmRlbmN5XG4gICAgICogb24gYW4gb3RoZXJ3aXNlIGluZGlyZWN0IGRlcGVuZGVuY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbCB0aGUgc3ltYm9sIGZvciB3aGljaCB0byBnZW5lcmF0ZSBhIGltcG9ydCBzeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRJbXBvcnRBcyA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgaWYgKHN0YXRpY1N5bWJvbC5tZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZVN5bWJvbCA9IHRoaXMuZ2V0U3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbC5maWxlUGF0aCwgc3RhdGljU3ltYm9sLm5hbWUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYmFzZUltcG9ydEFzID0gdGhpcy5nZXRJbXBvcnRBcyhiYXNlU3ltYm9sKTtcbiAgICAgICAgICAgIHJldHVybiBiYXNlSW1wb3J0QXMgP1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0U3RhdGljU3ltYm9sKGJhc2VJbXBvcnRBcy5maWxlUGF0aCwgYmFzZUltcG9ydEFzLm5hbWUsIHN0YXRpY1N5bWJvbC5tZW1iZXJzKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB0aGlzLnN1bW1hcnlSZXNvbHZlci5nZXRJbXBvcnRBcyhzdGF0aWNTeW1ib2wpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5pbXBvcnRBcy5nZXQoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogZ2V0UmVzb3VyY2VQYXRoIHByb2R1Y2VzIHRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGUgc3ltYm9sIGFuZCBzaG91bGRcbiAgICAgKiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgcmVsYXRpdmUgbG9jYXRpb24gb2YgcmVzb3VyY2UgcmVmZXJlbmNlcyByZWNvcmRlZCBpblxuICAgICAqIHN5bWJvbCBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldFJlc291cmNlUGF0aCA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sUmVzb3VyY2VQYXRocy5nZXQoc3RhdGljU3ltYm9sKSB8fCBzdGF0aWNTeW1ib2wuZmlsZVBhdGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRUeXBlQXJpdHkgcmV0dXJucyB0aGUgbnVtYmVyIG9mIGdlbmVyaWMgdHlwZSBwYXJhbWV0ZXJzIHRoZSBnaXZlbiBzeW1ib2xcbiAgICAgKiBoYXMuIElmIHRoZSBzeW1ib2wgaXMgbm90IGEgdHlwZSB0aGUgcmVzdWx0IGlzIG51bGwuXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRUeXBlQXJpdHkgPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIC8vIElmIHRoZSBmaWxlIGlzIGEgZmFjdG9yeSBmaWxlLCBkb24ndCByZXNvbHZlIHRoZSBzeW1ib2wgYXMgZG9pbmcgc28gd291bGRcbiAgICAgICAgLy8gY2F1c2UgdGhlIG1ldGFkYXRhIGZvciBhbiBmYWN0b3J5IGZpbGUgdG8gYmUgbG9hZGVkIHdoaWNoIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgIC8vIEFsbCByZWZlcmVuY2VzIHRvIGdlbmVyYXRlZCBjbGFzc2VzIG11c3QgaW5jbHVkZSB0aGUgY29ycmVjdCBhcml0eSB3aGVuZXZlclxuICAgICAgICAvLyBnZW5lcmF0aW5nIGNvZGUuXG4gICAgICAgIGlmIChpc05nRmFjdG9yeUZpbGUoc3RhdGljU3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRTeW1ib2wgPSB0aGlzLnJlc29sdmVTeW1ib2woc3RhdGljU3ltYm9sKTtcbiAgICAgICAgd2hpbGUgKHJlc29sdmVkU3ltYm9sICYmIHJlc29sdmVkU3ltYm9sLm1ldGFkYXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXNvbHZlZFN5bWJvbCA9IHRoaXMucmVzb2x2ZVN5bWJvbChyZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChyZXNvbHZlZFN5bWJvbCAmJiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YSAmJiByZXNvbHZlZFN5bWJvbC5tZXRhZGF0YS5hcml0eSkgfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc291cmNlU3ltYm9sXG4gICAgICogQHBhcmFtIHs/fSB0YXJnZXRTeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5yZWNvcmRJbXBvcnRBcyA9IGZ1bmN0aW9uIChzb3VyY2VTeW1ib2wsIHRhcmdldFN5bWJvbCkge1xuICAgICAgICBzb3VyY2VTeW1ib2wuYXNzZXJ0Tm9NZW1iZXJzKCk7XG4gICAgICAgIHRhcmdldFN5bWJvbC5hc3NlcnROb01lbWJlcnMoKTtcbiAgICAgICAgdGhpcy5pbXBvcnRBcy5zZXQoc291cmNlU3ltYm9sLCB0YXJnZXRTeW1ib2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW52YWxpZGF0ZSBhbGwgaW5mb3JtYXRpb24gZGVyaXZlZCBmcm9tIHRoZSBnaXZlbiBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlTmFtZSB0aGUgZmlsZSB0byBpbnZhbGlkYXRlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuaW52YWxpZGF0ZUZpbGUgPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YUNhY2hlLmRlbGV0ZShmaWxlTmFtZSk7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRGaWxlUGF0aHMuZGVsZXRlKGZpbGVOYW1lKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9scyA9IHRoaXMuc3ltYm9sRnJvbUZpbGUuZ2V0KGZpbGVOYW1lKTtcbiAgICAgICAgaWYgKHN5bWJvbHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9sRnJvbUZpbGUuZGVsZXRlKGZpbGVOYW1lKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc3ltYm9sc18xID0gc3ltYm9sczsgX2kgPCBzeW1ib2xzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IHN5bWJvbHNfMVtfaV07XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFN5bWJvbHMuZGVsZXRlKHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRBcy5kZWxldGUoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbFJlc291cmNlUGF0aHMuZGVsZXRlKHN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuX3Jlc29sdmVTeW1ib2xNZW1iZXJzID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZW1iZXJzID0gc3RhdGljU3ltYm9sLm1lbWJlcnM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJhc2VSZXNvbHZlZFN5bWJvbCA9IHRoaXMucmVzb2x2ZVN5bWJvbCh0aGlzLmdldFN0YXRpY1N5bWJvbChzdGF0aWNTeW1ib2wuZmlsZVBhdGgsIHN0YXRpY1N5bWJvbC5uYW1lKSk7XG4gICAgICAgIGlmICghYmFzZVJlc29sdmVkU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBiYXNlTWV0YWRhdGEgPSBiYXNlUmVzb2x2ZWRTeW1ib2wubWV0YWRhdGE7XG4gICAgICAgIGlmIChiYXNlTWV0YWRhdGEgaW5zdGFuY2VvZiBTdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLCB0aGlzLmdldFN0YXRpY1N5bWJvbChiYXNlTWV0YWRhdGEuZmlsZVBhdGgsIGJhc2VNZXRhZGF0YS5uYW1lLCBtZW1iZXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmFzZU1ldGFkYXRhICYmIGJhc2VNZXRhZGF0YS5fX3N5bWJvbGljID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICBpZiAoYmFzZU1ldGFkYXRhLnN0YXRpY3MgJiYgbWVtYmVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkU3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbCwgYmFzZU1ldGFkYXRhLnN0YXRpY3NbbWVtYmVyc1swXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWUgPSBiYXNlTWV0YWRhdGE7XG4gICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgbWVtYmVycy5sZW5ndGggJiYgdmFsdWU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbbWVtYmVyc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkU3RhdGljU3ltYm9sKHN0YXRpY1N5bWJvbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5fcmVzb2x2ZVN5bWJvbEZyb21TdW1tYXJ5ID0gZnVuY3Rpb24gKHN0YXRpY1N5bWJvbCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5ID0gdGhpcy5zdW1tYXJ5UmVzb2x2ZXIucmVzb2x2ZVN1bW1hcnkoc3RhdGljU3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIHN1bW1hcnkgPyBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc3RhdGljU3ltYm9sLCBzdW1tYXJ5Lm1ldGFkYXRhKSA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXRTdGF0aWNTeW1ib2wgcHJvZHVjZXMgYSBUeXBlIHdob3NlIG1ldGFkYXRhIGlzIGtub3duIGJ1dCB3aG9zZSBpbXBsZW1lbnRhdGlvbiBpcyBub3QgbG9hZGVkLlxuICAgICAqIEFsbCB0eXBlcyBwYXNzZWQgdG8gdGhlIFN0YXRpY1Jlc29sdmVyIHNob3VsZCBiZSBwc2V1ZG8tdHlwZXMgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez99IGRlY2xhcmF0aW9uRmlsZSB0aGUgYWJzb2x1dGUgcGF0aCBvZiB0aGUgZmlsZSB3aGVyZSB0aGUgc3ltYm9sIGlzIGRlY2xhcmVkXG4gICAgICogQHBhcmFtIHs/fSBuYW1lIHRoZSBuYW1lIG9mIHRoZSB0eXBlLlxuICAgICAqIEBwYXJhbSB7Pz19IG1lbWJlcnMgYSBzeW1ib2wgZm9yIGEgc3RhdGljIG1lbWJlciBvZiB0aGUgbmFtZWQgdHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmdldFN0YXRpY1N5bWJvbCA9IGZ1bmN0aW9uIChkZWNsYXJhdGlvbkZpbGUsIG5hbWUsIG1lbWJlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGljU3ltYm9sQ2FjaGUuZ2V0KGRlY2xhcmF0aW9uRmlsZSwgbmFtZSwgbWVtYmVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGZpbGVQYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUuZ2V0U3ltYm9sc09mID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgIC8vIE5vdGU6IFNvbWUgdXNlcnMgdXNlIGxpYnJhcmllcyB0aGF0IHdlcmUgbm90IGNvbXBpbGVkIHdpdGggbmdjLCBpLmUuIHRoZXkgZG9uJ3RcbiAgICAgICAgLy8gaGF2ZSBzdW1tYXJpZXMsIG9ubHkgLmQudHMgZmlsZXMuIFNvIHdlIGFsd2F5cyBuZWVkIHRvIGNoZWNrIGJvdGgsIHRoZSBzdW1tYXJ5XG4gICAgICAgIC8vIGFuZCBtZXRhZGF0YS5cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9scyA9IG5ldyBTZXQodGhpcy5zdW1tYXJ5UmVzb2x2ZXIuZ2V0U3ltYm9sc09mKGZpbGVQYXRoKSk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVN5bWJvbHNPZihmaWxlUGF0aCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRTeW1ib2xzLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVkU3ltYm9sKSB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRTeW1ib2wuc3ltYm9sLmZpbGVQYXRoID09PSBmaWxlUGF0aCkge1xuICAgICAgICAgICAgICAgIHN5bWJvbHMuYWRkKHJlc29sdmVkU3ltYm9sLnN5bWJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzeW1ib2xzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5fY3JlYXRlU3ltYm9sc09mID0gZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVkRmlsZVBhdGhzLmhhcyhmaWxlUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmVkRmlsZVBhdGhzLmFkZChmaWxlUGF0aCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVkU3ltYm9scyA9IFtdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtZXRhZGF0YSA9IHRoaXMuZ2V0TW9kdWxlTWV0YWRhdGEoZmlsZVBhdGgpO1xuICAgICAgICBpZiAobWV0YWRhdGFbJ21ldGFkYXRhJ10pIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBkaXJlY3QgZGVjbGFyYXRpb25zIG9mIHRoZSBzeW1ib2xcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRvcExldmVsU3ltYm9sTmFtZXNfMSA9IG5ldyBTZXQoT2JqZWN0LmtleXMobWV0YWRhdGFbJ21ldGFkYXRhJ10pLm1hcCh1bmVzY2FwZUlkZW50aWZpZXIpKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9yaWdpbnNfMSA9IG1ldGFkYXRhWydvcmlnaW5zJ10gfHwge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhtZXRhZGF0YVsnbWV0YWRhdGEnXSkuZm9yRWFjaChmdW5jdGlvbiAobWV0YWRhdGFLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xNZXRhID0gbWV0YWRhdGFbJ21ldGFkYXRhJ11bbWV0YWRhdGFLZXldO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSB1bmVzY2FwZUlkZW50aWZpZXIobWV0YWRhdGFLZXkpO1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW1wb3J0U3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVsnaW1wb3J0QXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmRleCBidW5kbGUgaW5kZXhlcyBzaG91bGQgdXNlIHRoZSBpbXBvcnRBcyBtb2R1bGUgbmFtZSBpbnN0ZWFkIG9mIGEgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSAuZC50cyBmaWxlIGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRTeW1ib2wgPSBfdGhpcy5nZXRTdGF0aWNTeW1ib2wobWV0YWRhdGFbJ2ltcG9ydEFzJ10sIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWNvcmRJbXBvcnRBcyhzeW1ib2wsIGltcG9ydFN5bWJvbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9yaWdpbiA9IG9yaWdpbnNfMS5oYXNPd25Qcm9wZXJ0eShtZXRhZGF0YUtleSkgJiYgb3JpZ2luc18xW21ldGFkYXRhS2V5XTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzeW1ib2wgaXMgZnJvbSBhIGJ1bmRsZWQgaW5kZXgsIHVzZSB0aGUgZGVjbGFyYXRpb24gbG9jYXRpb24gb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN5bWJvbCBzbyByZWxhdGl2ZSByZWZlcmVuY2VzIChzdWNoIGFzICcuL215Lmh0bWwnKSB3aWxsIGJlIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBvcmlnaW5GaWxlUGF0aCA9IF90aGlzLnJlc29sdmVNb2R1bGUob3JpZ2luLCBmaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3JpZ2luRmlsZVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcG9ydEVycm9yKG5ldyBFcnJvcihcIkNvdWxkbid0IHJlc29sdmUgb3JpZ2luYWwgc3ltYm9sIGZvciBcIiArIG9yaWdpbiArIFwiIGZyb20gXCIgKyBmaWxlUGF0aCksIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3ltYm9sUmVzb3VyY2VQYXRocy5zZXQoc3ltYm9sLCBvcmlnaW5GaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRTeW1ib2xzLnB1c2goX3RoaXMuY3JlYXRlUmVzb2x2ZWRTeW1ib2woc3ltYm9sLCBmaWxlUGF0aCwgdG9wTGV2ZWxTeW1ib2xOYW1lc18xLCBzeW1ib2xNZXRhKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgdGhlIHN5bWJvbHMgaW4gb25lIG9mIHRoZSByZS1leHBvcnQgbG9jYXRpb25cbiAgICAgICAgaWYgKG1ldGFkYXRhWydleHBvcnRzJ10pIHtcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKG1vZHVsZUV4cG9ydCkge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSB0aGUgc3ltYm9scyBpbiB0aGUgbGlzdCBvZiBleHBsaWNpdGx5IHJlLWV4cG9ydGVkIHN5bWJvbHMuXG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZUV4cG9ydC5leHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlRXhwb3J0LmV4cG9ydC5mb3JFYWNoKGZ1bmN0aW9uIChleHBvcnRTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cG9ydFN5bWJvbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xOYW1lID0gZXhwb3J0U3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sTmFtZSA9IGV4cG9ydFN5bWJvbC5hcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbE5hbWUgPSB1bmVzY2FwZUlkZW50aWZpZXIoc3ltYm9sTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1OYW1lID0gc3ltYm9sTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwb3J0U3ltYm9sICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bU5hbWUgPSB1bmVzY2FwZUlkZW50aWZpZXIoZXhwb3J0U3ltYm9sLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZWRNb2R1bGUgPSBfdGhpcy5yZXNvbHZlTW9kdWxlKG1vZHVsZUV4cG9ydC5mcm9tLCBmaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0YXJnZXRTeW1ib2wgPSBfdGhpcy5nZXRTdGF0aWNTeW1ib2wocmVzb2x2ZWRNb2R1bGUsIHN5bU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNvdXJjZVN5bWJvbCA9IF90aGlzLmdldFN0YXRpY1N5bWJvbChmaWxlUGF0aCwgc3ltYm9sTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRTeW1ib2xzLnB1c2goX3RoaXMuY3JlYXRlRXhwb3J0KHNvdXJjZVN5bWJvbCwgdGFyZ2V0U3ltYm9sKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRoZSBzeW1ib2xzIHZpYSBleHBvcnQgKiBkaXJlY3RpdmVzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXNvbHZlZE1vZHVsZSA9IHRoaXNfMS5yZXNvbHZlTW9kdWxlKG1vZHVsZUV4cG9ydC5mcm9tLCBmaWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZE1vZHVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmVzdGVkRXhwb3J0cyA9IHRoaXNfMS5nZXRTeW1ib2xzT2YocmVzb2x2ZWRNb2R1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkRXhwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXRTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzb3VyY2VTeW1ib2wgPSBfdGhpcy5nZXRTdGF0aWNTeW1ib2woZmlsZVBhdGgsIHRhcmdldFN5bWJvbC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFN5bWJvbHMucHVzaChfdGhpcy5jcmVhdGVFeHBvcnQoc291cmNlU3ltYm9sLCB0YXJnZXRTeW1ib2wpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG1ldGFkYXRhWydleHBvcnRzJ107IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZHVsZUV4cG9ydCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlRXhwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlZFN5bWJvbHMuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2ZWRTeW1ib2wpIHsgcmV0dXJuIF90aGlzLnJlc29sdmVkU3ltYm9scy5zZXQocmVzb2x2ZWRTeW1ib2wuc3ltYm9sLCByZXNvbHZlZFN5bWJvbCk7IH0pO1xuICAgICAgICB0aGlzLnN5bWJvbEZyb21GaWxlLnNldChmaWxlUGF0aCwgcmVzb2x2ZWRTeW1ib2xzLm1hcChmdW5jdGlvbiAocmVzb2x2ZWRTeW1ib2wpIHsgcmV0dXJuIHJlc29sdmVkU3ltYm9sLnN5bWJvbDsgfSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTeW1ib2xcbiAgICAgKiBAcGFyYW0gez99IHRvcExldmVsUGF0aFxuICAgICAqIEBwYXJhbSB7P30gdG9wTGV2ZWxTeW1ib2xOYW1lc1xuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5jcmVhdGVSZXNvbHZlZFN5bWJvbCA9IGZ1bmN0aW9uIChzb3VyY2VTeW1ib2wsIHRvcExldmVsUGF0aCwgdG9wTGV2ZWxTeW1ib2xOYW1lcywgbWV0YWRhdGEpIHtcbiAgICAgICAgLy8gRm9yIGNsYXNzZXMgdGhhdCBkb24ndCBoYXZlIEFuZ3VsYXIgc3VtbWFyaWVzIC8gbWV0YWRhdGEsXG4gICAgICAgIC8vIHdlIG9ubHkga2VlcCB0aGVpciBhcml0eSwgYnV0IG5vdGhpbmcgZWxzZVxuICAgICAgICAvLyAoZS5nLiB0aGVpciBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzKS5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyB0byBwcmV2ZW50IGludHJvZHVjaW5nIGRlZXAgaW1wb3J0c1xuICAgICAgICAvLyBhcyB3ZSBkaWRuJ3QgZ2VuZXJhdGUgLm5nZmFjdG9yeS50cyBmaWxlcyB3aXRoIHByb3BlciByZWV4cG9ydHMuXG4gICAgICAgIGlmICh0aGlzLnN1bW1hcnlSZXNvbHZlci5pc0xpYnJhcnlGaWxlKHNvdXJjZVN5bWJvbC5maWxlUGF0aCkgJiYgbWV0YWRhdGEgJiZcbiAgICAgICAgICAgIG1ldGFkYXRhWydfX3N5bWJvbGljJ10gPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRyYW5zZm9ybWVkTWV0YV8xID0geyBfX3N5bWJvbGljOiAnY2xhc3MnLCBhcml0eTogbWV0YWRhdGEuYXJpdHkgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc291cmNlU3ltYm9sLCB0cmFuc2Zvcm1lZE1ldGFfMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBSZWZlcmVuY2VUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoUmVmZXJlbmNlVHJhbnNmb3JtZXIsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBSZWZlcmVuY2VUcmFuc2Zvcm1lcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gbWFwXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGZ1bmN0aW9uUGFyYW1zXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSZWZlcmVuY2VUcmFuc2Zvcm1lci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAgPSBmdW5jdGlvbiAobWFwLCBmdW5jdGlvblBhcmFtcykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN5bWJvbGljID0gbWFwWydfX3N5bWJvbGljJ107XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbGljID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9sZExlbiA9IGZ1bmN0aW9uUGFyYW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25QYXJhbXMucHVzaC5hcHBseShmdW5jdGlvblBhcmFtcywgKG1hcFsncGFyYW1ldGVycyddIHx8IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdCA9IF9zdXBlci5wcm90b3R5cGUudmlzaXRTdHJpbmdNYXAuY2FsbCh0aGlzLCBtYXAsIGZ1bmN0aW9uUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25QYXJhbXMubGVuZ3RoID0gb2xkTGVuO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzeW1ib2xpYyA9PT0gJ3JlZmVyZW5jZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlXzEgPSBtYXBbJ21vZHVsZSddO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuYW1lID0gbWFwWyduYW1lJ10gPyB1bmVzY2FwZUlkZW50aWZpZXIobWFwWyduYW1lJ10pIDogbWFwWyduYW1lJ107XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZmlsZVBhdGggPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGVfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGggPSBzZWxmLnJlc29sdmVNb2R1bGUobW9kdWxlXzEsIHNvdXJjZVN5bWJvbC5maWxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19zeW1ib2xpYzogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJDb3VsZCBub3QgcmVzb2x2ZSBcIiArIG1vZHVsZV8xICsgXCIgcmVsYXRpdmUgdG8gXCIgKyBzb3VyY2VTeW1ib2wuZmlsZVBhdGggKyBcIi5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRTdGF0aWNTeW1ib2woZmlsZVBhdGgsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZ1bmN0aW9uUGFyYW1zLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmZXJlbmNlIHRvIGEgZnVuY3Rpb24gcGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBfX3N5bWJvbGljOiAncmVmZXJlbmNlJywgbmFtZTogbmFtZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRvcExldmVsU3ltYm9sTmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3RhdGljU3ltYm9sKHRvcExldmVsUGF0aCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbWJpZW50IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS52aXNpdFN0cmluZ01hcC5jYWxsKHRoaXMsIG1hcCwgZnVuY3Rpb25QYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gUmVmZXJlbmNlVHJhbnNmb3JtZXI7XG4gICAgICAgIH0oVmFsdWVUcmFuc2Zvcm1lcikpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2Zvcm1lZE1ldGEgPSB2aXNpdFZhbHVlKG1ldGFkYXRhLCBuZXcgUmVmZXJlbmNlVHJhbnNmb3JtZXIoKSwgW10pO1xuICAgICAgICBpZiAodHJhbnNmb3JtZWRNZXRhIGluc3RhbmNlb2YgU3RhdGljU3ltYm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFeHBvcnQoc291cmNlU3ltYm9sLCB0cmFuc2Zvcm1lZE1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc291cmNlU3ltYm9sLCB0cmFuc2Zvcm1lZE1ldGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VTeW1ib2xcbiAgICAgKiBAcGFyYW0gez99IHRhcmdldFN5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGljU3ltYm9sUmVzb2x2ZXIucHJvdG90eXBlLmNyZWF0ZUV4cG9ydCA9IGZ1bmN0aW9uIChzb3VyY2VTeW1ib2wsIHRhcmdldFN5bWJvbCkge1xuICAgICAgICBzb3VyY2VTeW1ib2wuYXNzZXJ0Tm9NZW1iZXJzKCk7XG4gICAgICAgIHRhcmdldFN5bWJvbC5hc3NlcnROb01lbWJlcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuc3VtbWFyeVJlc29sdmVyLmlzTGlicmFyeUZpbGUoc291cmNlU3ltYm9sLmZpbGVQYXRoKSkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYXNlIGlzIGZvciBhbiBuZyBsaWJyYXJ5IGltcG9ydGluZyBzeW1ib2xzIGZyb20gYSBwbGFpbiB0cyBsaWJyYXJ5XG4gICAgICAgICAgICAvLyB0cmFuc2l0aXZlbHkuXG4gICAgICAgICAgICAvLyBOb3RlOiBXZSByZWx5IG9uIHRoZSBmYWN0IHRoYXQgd2UgZGlzY292ZXIgc3ltYm9scyBpbiB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAgICAvLyBmcm9tIHNvdXJjZSBmaWxlcyB0byBsaWJyYXJ5IGZpbGVzXG4gICAgICAgICAgICB0aGlzLmltcG9ydEFzLnNldCh0YXJnZXRTeW1ib2wsIHRoaXMuZ2V0SW1wb3J0QXMoc291cmNlU3ltYm9sKSB8fCBzb3VyY2VTeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRTdGF0aWNTeW1ib2woc291cmNlU3ltYm9sLCB0YXJnZXRTeW1ib2wpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBlcnJvclxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEBwYXJhbSB7Pz19IHBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgY29udGV4dCwgcGF0aCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvclJlY29yZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVjb3JkZXIoZXJyb3IsIChjb250ZXh0ICYmIGNvbnRleHQuZmlsZVBhdGgpIHx8IHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlIGFuIGFic29sdXRlIHBhdGggdG8gYSBtb2R1bGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRNb2R1bGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhQ2FjaGUuZ2V0KG1vZHVsZSk7XG4gICAgICAgIGlmICghbW9kdWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZU1ldGFkYXRhcyA9IHRoaXMuaG9zdC5nZXRNZXRhZGF0YUZvcihtb2R1bGUpO1xuICAgICAgICAgICAgaWYgKG1vZHVsZU1ldGFkYXRhcykge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1heFZlcnNpb25fMSA9IC0xO1xuICAgICAgICAgICAgICAgIG1vZHVsZU1ldGFkYXRhcy5mb3JFYWNoKGZ1bmN0aW9uIChtZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWRbJ3ZlcnNpb24nXSA+IG1heFZlcnNpb25fMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4VmVyc2lvbl8xID0gbWRbJ3ZlcnNpb24nXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZU1ldGFkYXRhID0gbWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbW9kdWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVNZXRhZGF0YSA9XG4gICAgICAgICAgICAgICAgICAgIHsgX19zeW1ib2xpYzogJ21vZHVsZScsIHZlcnNpb246IFNVUFBPUlRFRF9TQ0hFTUFfVkVSU0lPTiwgbW9kdWxlOiBtb2R1bGUsIG1ldGFkYXRhOiB7fSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZHVsZU1ldGFkYXRhWyd2ZXJzaW9uJ10gIT0gU1VQUE9SVEVEX1NDSEVNQV9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JNZXNzYWdlID0gbW9kdWxlTWV0YWRhdGFbJ3ZlcnNpb24nXSA9PSAyID9cbiAgICAgICAgICAgICAgICAgICAgXCJVbnN1cHBvcnRlZCBtZXRhZGF0YSB2ZXJzaW9uIFwiICsgbW9kdWxlTWV0YWRhdGFbJ3ZlcnNpb24nXSArIFwiIGZvciBtb2R1bGUgXCIgKyBtb2R1bGUgKyBcIi4gVGhpcyBtb2R1bGUgc2hvdWxkIGJlIGNvbXBpbGVkIHdpdGggYSBuZXdlciB2ZXJzaW9uIG9mIG5nY1wiIDpcbiAgICAgICAgICAgICAgICAgICAgXCJNZXRhZGF0YSB2ZXJzaW9uIG1pc21hdGNoIGZvciBtb2R1bGUgXCIgKyBtb2R1bGUgKyBcIiwgZm91bmQgdmVyc2lvbiBcIiArIG1vZHVsZU1ldGFkYXRhWyd2ZXJzaW9uJ10gKyBcIiwgZXhwZWN0ZWQgXCIgKyBTVVBQT1JURURfU0NIRU1BX1ZFUlNJT047XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhQ2FjaGUuc2V0KG1vZHVsZSwgbW9kdWxlTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVNZXRhZGF0YTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlXG4gICAgICogQHBhcmFtIHs/fSBzeW1ib2xOYW1lXG4gICAgICogQHBhcmFtIHs/PX0gY29udGFpbmluZ0ZpbGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRpY1N5bWJvbFJlc29sdmVyLnByb3RvdHlwZS5nZXRTeW1ib2xCeU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGUsIHN5bWJvbE5hbWUsIGNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZpbGVQYXRoID0gdGhpcy5yZXNvbHZlTW9kdWxlKG1vZHVsZSwgY29udGFpbmluZ0ZpbGUpO1xuICAgICAgICBpZiAoIWZpbGVQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZXNvbHZlIG1vZHVsZSBcIiArIG1vZHVsZSArIChjb250YWluaW5nRmlsZSA/IFwiIHJlbGF0aXZlIHRvICQge1xcbiAgICAgICAgICAgIGNvbnRhaW5pbmdGaWxlXFxuICAgICAgICAgIH0gXCIgOiAnJykpLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRpY1N5bWJvbChcIkVSUk9SOlwiICsgbW9kdWxlLCBzeW1ib2xOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0aWNTeW1ib2woZmlsZVBhdGgsIHN5bWJvbE5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVcbiAgICAgKiBAcGFyYW0gez99IGNvbnRhaW5pbmdGaWxlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0aWNTeW1ib2xSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZU1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGUsIGNvbnRhaW5pbmdGaWxlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ob3N0Lm1vZHVsZU5hbWVUb0ZpbGVOYW1lKG1vZHVsZSwgY29udGFpbmluZ0ZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgbW9kdWxlICdcIiArIG1vZHVsZSArIFwiJyByZWxhdGl2ZSB0byBmaWxlIFwiICsgY29udGFpbmluZ0ZpbGUpO1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihlLCBudWxsLCBjb250YWluaW5nRmlsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNTeW1ib2xSZXNvbHZlcjtcbn0oKSk7XG4vKipcbiAqIEBwYXJhbSB7P30gaWRlbnRpZmllclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGVJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllci5zdGFydHNXaXRoKCdfX18nKSA/IGlkZW50aWZpZXIuc3Vic3RyKDEpIDogaWRlbnRpZmllcjtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBBb3RTdW1tYXJ5UmVzb2x2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaG9zdFxuICAgICAqIEBwYXJhbSB7P30gc3RhdGljU3ltYm9sQ2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBb3RTdW1tYXJ5UmVzb2x2ZXIoaG9zdCwgc3RhdGljU3ltYm9sQ2FjaGUpIHtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5zdGF0aWNTeW1ib2xDYWNoZSA9IHN0YXRpY1N5bWJvbENhY2hlO1xuICAgICAgICB0aGlzLnN1bW1hcnlDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sb2FkZWRGaWxlUGF0aHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuaW1wb3J0QXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuaXNMaWJyYXJ5RmlsZSA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIHRvIHN0cmlwIHRoZSAubmdmYWN0b3J5LiBmaWxlIHBhdGgsXG4gICAgICAgIC8vIHNvIHRoaXMgbWV0aG9kIGFsc28gd29ya3MgZm9yIGdlbmVyYXRlZCBmaWxlc1xuICAgICAgICAvLyAoZm9yIHdoaWNoIGhvc3QuaXNTb3VyY2VGaWxlIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSkuXG4gICAgICAgIHJldHVybiAhdGhpcy5ob3N0LmlzU291cmNlRmlsZShzdHJpcE5nRmFjdG9yeShmaWxlUGF0aCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRMaWJyYXJ5RmlsZU5hbWUgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHsgcmV0dXJuIHRoaXMuaG9zdC5nZXRPdXRwdXRGaWxlTmFtZShmaWxlUGF0aCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZVN1bW1hcnkgPSBmdW5jdGlvbiAoc3RhdGljU3ltYm9sKSB7XG4gICAgICAgIHN0YXRpY1N5bWJvbC5hc3NlcnROb01lbWJlcnMoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3VtbWFyeSA9IHRoaXMuc3VtbWFyeUNhY2hlLmdldChzdGF0aWNTeW1ib2wpO1xuICAgICAgICBpZiAoIXN1bW1hcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRTdW1tYXJ5RmlsZShzdGF0aWNTeW1ib2wuZmlsZVBhdGgpO1xuICAgICAgICAgICAgc3VtbWFyeSA9IHRoaXMuc3VtbWFyeUNhY2hlLmdldChzdGF0aWNTeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW1tYXJ5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBmaWxlUGF0aFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRTeW1ib2xzT2YgPSBmdW5jdGlvbiAoZmlsZVBhdGgpIHtcbiAgICAgICAgdGhpcy5fbG9hZFN1bW1hcnlGaWxlKGZpbGVQYXRoKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5zdW1tYXJ5Q2FjaGUua2V5cygpKS5maWx0ZXIoZnVuY3Rpb24gKHN5bWJvbCkgeyByZXR1cm4gc3ltYm9sLmZpbGVQYXRoID09PSBmaWxlUGF0aDsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0YXRpY1N5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQW90U3VtbWFyeVJlc29sdmVyLnByb3RvdHlwZS5nZXRJbXBvcnRBcyA9IGZ1bmN0aW9uIChzdGF0aWNTeW1ib2wpIHtcbiAgICAgICAgc3RhdGljU3ltYm9sLmFzc2VydE5vTWVtYmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRBcy5nZXQoc3RhdGljU3ltYm9sKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZmlsZVBhdGhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFvdFN1bW1hcnlSZXNvbHZlci5wcm90b3R5cGUuX2xvYWRTdW1tYXJ5RmlsZSA9IGZ1bmN0aW9uIChmaWxlUGF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5sb2FkZWRGaWxlUGF0aHMuaGFzKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVkRmlsZVBhdGhzLmFkZChmaWxlUGF0aCk7XG4gICAgICAgIGlmICh0aGlzLmlzTGlicmFyeUZpbGUoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5RmlsZVBhdGggPSBzdW1tYXJ5RmlsZU5hbWUoZmlsZVBhdGgpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8ganNvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAganNvbiA9IHRoaXMuaG9zdC5sb2FkU3VtbWFyeShzdW1tYXJ5RmlsZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBzdW1tYXJ5IGZpbGUgXCIgKyBzdW1tYXJ5RmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGRlc2VyaWFsaXplU3VtbWFyaWVzKHRoaXMuc3RhdGljU3ltYm9sQ2FjaGUsIGpzb24pLCBzdW1tYXJpZXMgPSBfYS5zdW1tYXJpZXMsIGltcG9ydEFzID0gX2EuaW1wb3J0QXM7XG4gICAgICAgICAgICAgICAgc3VtbWFyaWVzLmZvckVhY2goZnVuY3Rpb24gKHN1bW1hcnkpIHsgcmV0dXJuIF90aGlzLnN1bW1hcnlDYWNoZS5zZXQoc3VtbWFyeS5zeW1ib2wsIHN1bW1hcnkpOyB9KTtcbiAgICAgICAgICAgICAgICBpbXBvcnRBcy5mb3JFYWNoKGZ1bmN0aW9uIChpbXBvcnRBcykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbXBvcnRBcy5zZXQoaW1wb3J0QXMuc3ltYm9sLCBfdGhpcy5zdGF0aWNTeW1ib2xDYWNoZS5nZXQobmdmYWN0b3J5RmlsZVBhdGgoZmlsZVBhdGgpLCBpbXBvcnRBcy5pbXBvcnRBcykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQW90U3VtbWFyeVJlc29sdmVyO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBBb3RDb21waWxlciBiYXNlZCBvbiBvcHRpb25zIGFuZCBhIGhvc3QuXG4gKiBAcGFyYW0gez99IGNvbXBpbGVySG9zdFxuICogQHBhcmFtIHs/fSBvcHRpb25zXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBb3RDb21waWxlcihjb21waWxlckhvc3QsIG9wdGlvbnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB0cmFuc2xhdGlvbnMgPSBvcHRpb25zLnRyYW5zbGF0aW9ucyB8fCAnJztcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB1cmxSZXNvbHZlciA9IGNyZWF0ZU9mZmxpbmVDb21waWxlVXJsUmVzb2x2ZXIoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xDYWNoZSA9IG5ldyBTdGF0aWNTeW1ib2xDYWNoZSgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN1bW1hcnlSZXNvbHZlciA9IG5ldyBBb3RTdW1tYXJ5UmVzb2x2ZXIoY29tcGlsZXJIb3N0LCBzeW1ib2xDYWNoZSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3ltYm9sUmVzb2x2ZXIgPSBuZXcgU3RhdGljU3ltYm9sUmVzb2x2ZXIoY29tcGlsZXJIb3N0LCBzeW1ib2xDYWNoZSwgc3VtbWFyeVJlc29sdmVyKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdGF0aWNSZWZsZWN0b3IgPSBuZXcgU3RhdGljUmVmbGVjdG9yKHN1bW1hcnlSZXNvbHZlciwgc3ltYm9sUmVzb2x2ZXIpO1xuICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmluc3RhbGwoc3RhdGljUmVmbGVjdG9yKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25zb2xlID0gbmV3IMm1Q29uc29sZSgpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGh0bWxQYXJzZXIgPSBuZXcgSTE4Tkh0bWxQYXJzZXIobmV3IEh0bWxQYXJzZXIoKSwgdHJhbnNsYXRpb25zLCBvcHRpb25zLmkxOG5Gb3JtYXQsIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmcsIGNvbnNvbGUpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbmZpZyA9IG5ldyBDb21waWxlckNvbmZpZyh7XG4gICAgICAgIGRlZmF1bHRFbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCxcbiAgICAgICAgdXNlSml0OiBmYWxzZSxcbiAgICAgICAgZW5hYmxlTGVnYWN5VGVtcGxhdGU6IG9wdGlvbnMuZW5hYmxlTGVnYWN5VGVtcGxhdGUgIT09IGZhbHNlLFxuICAgIH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vcm1hbGl6ZXIgPSBuZXcgRGlyZWN0aXZlTm9ybWFsaXplcih7IGdldDogZnVuY3Rpb24gKHVybCkgeyByZXR1cm4gY29tcGlsZXJIb3N0LmxvYWRSZXNvdXJjZSh1cmwpOyB9IH0sIHVybFJlc29sdmVyLCBodG1sUGFyc2VyLCBjb25maWcpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGV4cHJlc3Npb25QYXJzZXIgPSBuZXcgUGFyc2VyKG5ldyBMZXhlcigpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdG1wbFBhcnNlciA9IG5ldyBUZW1wbGF0ZVBhcnNlcihjb25maWcsIGV4cHJlc3Npb25QYXJzZXIsIGVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgaHRtbFBhcnNlciwgY29uc29sZSwgW10pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc29sdmVyID0gbmV3IENvbXBpbGVNZXRhZGF0YVJlc29sdmVyKGNvbmZpZywgbmV3IE5nTW9kdWxlUmVzb2x2ZXIoc3RhdGljUmVmbGVjdG9yKSwgbmV3IERpcmVjdGl2ZVJlc29sdmVyKHN0YXRpY1JlZmxlY3RvciksIG5ldyBQaXBlUmVzb2x2ZXIoc3RhdGljUmVmbGVjdG9yKSwgc3VtbWFyeVJlc29sdmVyLCBlbGVtZW50U2NoZW1hUmVnaXN0cnksIG5vcm1hbGl6ZXIsIGNvbnNvbGUsIHN5bWJvbENhY2hlLCBzdGF0aWNSZWZsZWN0b3IpO1xuICAgIC8vIFRPRE8odmljYik6IGRvIG5vdCBwYXNzIG9wdGlvbnMuaTE4bkZvcm1hdCBoZXJlXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW1wb3J0UmVzb2x2ZXIgPSB7XG4gICAgICAgIGdldEltcG9ydEFzOiBmdW5jdGlvbiAoc3ltYm9sKSB7IHJldHVybiBzeW1ib2xSZXNvbHZlci5nZXRJbXBvcnRBcyhzeW1ib2wpOyB9LFxuICAgICAgICBmaWxlTmFtZVRvTW9kdWxlTmFtZTogZnVuY3Rpb24gKGZpbGVOYW1lLCBjb250YWluaW5nRmlsZVBhdGgpIHsgcmV0dXJuIGNvbXBpbGVySG9zdC5maWxlTmFtZVRvTW9kdWxlTmFtZShmaWxlTmFtZSwgY29udGFpbmluZ0ZpbGVQYXRoKTsgfSxcbiAgICAgICAgZ2V0VHlwZUFyaXR5OiBmdW5jdGlvbiAoc3ltYm9sKSB7IHJldHVybiBzeW1ib2xSZXNvbHZlci5nZXRUeXBlQXJpdHkoc3ltYm9sKTsgfVxuICAgIH07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0NvbXBpbGVyID0gbmV3IFZpZXdDb21waWxlcihjb25maWcsIGVsZW1lbnRTY2hlbWFSZWdpc3RyeSk7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZXIgPSBuZXcgQW90Q29tcGlsZXIoY29uZmlnLCBjb21waWxlckhvc3QsIHJlc29sdmVyLCB0bXBsUGFyc2VyLCBuZXcgU3R5bGVDb21waWxlcih1cmxSZXNvbHZlciksIHZpZXdDb21waWxlciwgbmV3IE5nTW9kdWxlQ29tcGlsZXIoKSwgbmV3IFR5cGVTY3JpcHRFbWl0dGVyKGltcG9ydFJlc29sdmVyKSwgc3VtbWFyeVJlc29sdmVyLCBvcHRpb25zLmxvY2FsZSwgb3B0aW9ucy5pMThuRm9ybWF0LCBvcHRpb25zLmdlbkZpbGVQcmVhbWJsZSwgc3ltYm9sUmVzb2x2ZXIpO1xuICAgIHJldHVybiB7IGNvbXBpbGVyOiBjb21waWxlciwgcmVmbGVjdG9yOiBzdGF0aWNSZWZsZWN0b3IgfTtcbn1cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gKiBAcGFyYW0gez99IHJlc3VsdFZhcnNcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGludGVycHJldFN0YXRlbWVudHMoc3RhdGVtZW50cywgcmVzdWx0VmFycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0bXRzV2l0aFJldHVybiA9IHN0YXRlbWVudHMuY29uY2F0KFtuZXcgUmV0dXJuU3RhdGVtZW50KGxpdGVyYWxBcnIocmVzdWx0VmFycy5tYXAoZnVuY3Rpb24gKHJlc3VsdFZhcikgeyByZXR1cm4gdmFyaWFibGUocmVzdWx0VmFyKTsgfSkpKV0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChudWxsLCBudWxsLCBudWxsLCBuZXcgTWFwKCkpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHZpc2l0b3IgPSBuZXcgU3RhdGVtZW50SW50ZXJwcmV0ZXIoKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB2aXNpdG9yLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10c1dpdGhSZXR1cm4sIGN0eCk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsID8gcmVzdWx0LnZhbHVlIDogbnVsbDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSB2YXJOYW1lc1xuICogQHBhcmFtIHs/fSB2YXJWYWx1ZXNcbiAqIEBwYXJhbSB7P30gc3RhdGVtZW50c1xuICogQHBhcmFtIHs/fSBjdHhcbiAqIEBwYXJhbSB7P30gdmlzaXRvclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2V4ZWN1dGVGdW5jdGlvblN0YXRlbWVudHModmFyTmFtZXMsIHZhclZhbHVlcywgc3RhdGVtZW50cywgY3R4LCB2aXNpdG9yKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRDdHggPSBjdHguY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzKCk7XG4gICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHZhck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkQ3R4LnZhcnMuc2V0KHZhck5hbWVzW2ldLCB2YXJWYWx1ZXNbaV0pO1xuICAgIH1cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB2aXNpdG9yLnZpc2l0QWxsU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBjaGlsZEN0eCk7XG4gICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdC52YWx1ZSA6IG51bGw7XG59XG52YXIgX0V4ZWN1dGlvbkNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGFyZW50XG4gICAgICogQHBhcmFtIHs/fSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7P30gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHs/fSB2YXJzXG4gICAgICovXG4gICAgZnVuY3Rpb24gX0V4ZWN1dGlvbkNvbnRleHQocGFyZW50LCBpbnN0YW5jZSwgY2xhc3NOYW1lLCB2YXJzKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIF9FeGVjdXRpb25Db250ZXh0LnByb3RvdHlwZS5jcmVhdGVDaGlsZFdpaHRMb2NhbFZhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgX0V4ZWN1dGlvbkNvbnRleHQodGhpcywgdGhpcy5pbnN0YW5jZSwgdGhpcy5jbGFzc05hbWUsIG5ldyBNYXAoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gX0V4ZWN1dGlvbkNvbnRleHQ7XG59KCkpO1xudmFyIFJldHVyblZhbHVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmV0dXJuVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gUmV0dXJuVmFsdWU7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IF9jbGFzc1N0bXRcbiAqIEBwYXJhbSB7P30gX2N0eFxuICogQHBhcmFtIHs/fSBfdmlzaXRvclxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRHluYW1pY0NsYXNzKF9jbGFzc1N0bXQsIF9jdHgsIF92aXNpdG9yKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcGVydHlEZXNjcmlwdG9ycyA9IHt9O1xuICAgIF9jbGFzc1N0bXQuZ2V0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChnZXR0ZXIpIHtcbiAgICAgICAgLy8gTm90ZTogdXNlIGBmdW5jdGlvbmAgaW5zdGVhZCBvZiBhcnJvdyBmdW5jdGlvbiB0byBjYXB0dXJlIGB0aGlzYFxuICAgICAgICBwcm9wZXJ0eURlc2NyaXB0b3JzW2dldHRlci5uYW1lXSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0YW5jZUN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChfY3R4LCB0aGlzLCBfY2xhc3NTdG10Lm5hbWUsIF9jdHgudmFycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKFtdLCBbXSwgZ2V0dGVyLmJvZHksIGluc3RhbmNlQ3R4LCBfdmlzaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgX2NsYXNzU3RtdC5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbU5hbWVzID0gbWV0aG9kLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5uYW1lOyB9KTtcbiAgICAgICAgLy8gTm90ZTogdXNlIGBmdW5jdGlvbmAgaW5zdGVhZCBvZiBhcnJvdyBmdW5jdGlvbiB0byBjYXB0dXJlIGB0aGlzYFxuICAgICAgICBwcm9wZXJ0eURlc2NyaXB0b3JzW21ldGhvZC5uYW1lXSA9IHtcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpbnN0YW5jZUN0eCA9IG5ldyBfRXhlY3V0aW9uQ29udGV4dChfY3R4LCB0aGlzLCBfY2xhc3NTdG10Lm5hbWUsIF9jdHgudmFycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHBhcmFtTmFtZXMsIGFyZ3MsIG1ldGhvZC5ib2R5LCBpbnN0YW5jZUN0eCwgX3Zpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0b3JQYXJhbU5hbWVzID0gX2NsYXNzU3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgLy8gTm90ZTogdXNlIGBmdW5jdGlvbmAgaW5zdGVhZCBvZiBhcnJvdyBmdW5jdGlvbiB0byBjYXB0dXJlIGB0aGlzYFxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5zdGFuY2VDdHggPSBuZXcgX0V4ZWN1dGlvbkNvbnRleHQoX2N0eCwgdGhpcywgX2NsYXNzU3RtdC5uYW1lLCBfY3R4LnZhcnMpO1xuICAgICAgICBfY2xhc3NTdG10LmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkgeyBfdGhpc1tmaWVsZC5uYW1lXSA9IHVuZGVmaW5lZDsgfSk7XG4gICAgICAgIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKGN0b3JQYXJhbU5hbWVzLCBhcmdzLCBfY2xhc3NTdG10LmNvbnN0cnVjdG9yTWV0aG9kLmJvZHksIGluc3RhbmNlQ3R4LCBfdmlzaXRvcik7XG4gICAgfTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdXBlckNsYXNzID0gX2NsYXNzU3RtdC5wYXJlbnQgPyBfY2xhc3NTdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24oX3Zpc2l0b3IsIF9jdHgpIDogT2JqZWN0O1xuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSwgcHJvcGVydHlEZXNjcmlwdG9ycyk7XG4gICAgcmV0dXJuIGN0b3I7XG59XG52YXIgU3RhdGVtZW50SW50ZXJwcmV0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlbWVudEludGVycHJldGVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLmRlYnVnQXN0ID0gZnVuY3Rpb24gKGFzdCkgeyByZXR1cm4gZGVidWdPdXRwdXRBc3RBc1R5cGVTY3JpcHQoYXN0KTsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC52YXJzLnNldChzdG10Lm5hbWUsIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcml0ZVZhckV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyckN0eCA9IGN0eDtcbiAgICAgICAgd2hpbGUgKGN1cnJDdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJDdHgudmFycy5oYXMoZXhwci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGN1cnJDdHgudmFycy5zZXQoZXhwci5uYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyckN0eCA9IGN1cnJDdHgucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBkZWNsYXJlZCB2YXJpYWJsZSBcIiArIGV4cHIubmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YXJOYW1lID0gYXN0Lm5hbWU7XG4gICAgICAgIGlmIChhc3QuYnVpbHRpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFzdC5idWlsdGluKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluVmFyLlN1cGVyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmluc3RhbmNlLl9fcHJvdG9fXztcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuVGhpczpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hFcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9IENBVENIX0VSUk9SX1ZBUiQyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEJ1aWx0aW5WYXIuQ2F0Y2hTdGFjazpcbiAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSA9IENBVENIX1NUQUNLX1ZBUiQyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGJ1aWx0aW4gdmFyaWFibGUgXCIgKyBhc3QuYnVpbHRpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY3VyckN0eCA9IGN0eDtcbiAgICAgICAgd2hpbGUgKGN1cnJDdHggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN1cnJDdHgudmFycy5oYXModmFyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyckN0eC52YXJzLmdldCh2YXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJDdHggPSBjdXJyQ3R4LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgZGVjbGFyZWQgdmFyaWFibGUgXCIgKyB2YXJOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZXhwclxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRXcml0ZUtleUV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJlY2VpdmVyW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0V3JpdGVQcm9wRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjZWl2ZXIgPSBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJlY2VpdmVyW2V4cHIubmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEludm9rZU1ldGhvZEV4cHIgPSBmdW5jdGlvbiAoZXhwciwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhleHByLmFyZ3MsIGN0eCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdDtcbiAgICAgICAgaWYgKGV4cHIuYnVpbHRpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4cHIuYnVpbHRpbikge1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5Db25jYXRBcnJheTpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIuY29uY2F0LmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyLnN1YnNjcmliZSh7IG5leHQ6IGFyZ3NbMF0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQnVpbHRpbk1ldGhvZC5CaW5kOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5iaW5kLmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIG1ldGhvZCBcIiArIGV4cHIuYnVpbHRpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlcltleHByLm5hbWVdLmFwcGx5KHJlY2VpdmVyLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gYXJncyA9IHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhzdG10LmFyZ3MsIGN0eCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGZuRXhwciA9IHN0bXQuZm47XG4gICAgICAgIGlmIChmbkV4cHIgaW5zdGFuY2VvZiBSZWFkVmFyRXhwciAmJiBmbkV4cHIuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgY3R4Lmluc3RhbmNlLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5hcHBseShjdHguaW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbiQkMSA9IHN0bXQuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gZm4kJDEuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRSZXR1cm5TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IFJldHVyblZhbHVlKHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdERlY2xhcmVDbGFzc1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNsYXp6ID0gY3JlYXRlRHluYW1pY0NsYXNzKHN0bXQsIGN0eCwgdGhpcyk7XG4gICAgICAgIGN0eC52YXJzLnNldChzdG10Lm5hbWUsIGNsYXp6KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RXhwcmVzc2lvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHJldHVybiBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0SWZTdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25kaXRpb24gPSBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RtdC5mYWxzZUNhc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2hpbGRDdHggPSBjdHguY3JlYXRlQ2hpbGRXaWh0TG9jYWxWYXJzKCk7XG4gICAgICAgICAgICBjaGlsZEN0eC52YXJzLnNldChDQVRDSF9FUlJPUl9WQVIkMiwgZSk7XG4gICAgICAgICAgICBjaGlsZEN0eC52YXJzLnNldChDQVRDSF9TVEFDS19WQVIkMiwgZS5zdGFjayk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jYXRjaFN0bXRzLCBjaGlsZEN0eCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRUaHJvd1N0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIHRocm93IHN0bXQuZXJyb3IudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez89fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDb21tZW50U3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjb250ZXh0KSB7IHJldHVybiBudWxsOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEluc3RhbnRpYXRlRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBhcmdzID0gdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjbGF6eiA9IGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJldHVybiBuZXcgKGNsYXp6LmJpbmQuYXBwbHkoY2xhenosIFt2b2lkIDBdLmNvbmNhdChhcmdzKSkpKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkgeyByZXR1cm4gYXN0LnZhbHVlOyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEV4dGVybmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICByZXR1cm4gYXN0LnZhbHVlLnJlZmVyZW5jZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdENvbmRpdGlvbmFsRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBpZiAoYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGFzdC50cnVlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QuZmFsc2VDYXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Tm90RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICByZXR1cm4gIWFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRDYXN0RXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICByZXR1cm4gYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtTmFtZXMgPSBhc3QucGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLm5hbWU7IH0pO1xuICAgICAgICByZXR1cm4gX2RlY2xhcmVGbihwYXJhbU5hbWVzLCBhc3Quc3RhdGVtZW50cywgY3R4LCB0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10ID0gZnVuY3Rpb24gKHN0bXQsIGN0eCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwYXJhbU5hbWVzID0gc3RtdC5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0ubmFtZTsgfSk7XG4gICAgICAgIGN0eC52YXJzLnNldChzdG10Lm5hbWUsIF9kZWNsYXJlRm4ocGFyYW1OYW1lcywgc3RtdC5zdGF0ZW1lbnRzLCBjdHgsIHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRCaW5hcnlPcGVyYXRvckV4cHIgPSBmdW5jdGlvbiAoYXN0LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGhzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYXN0Lmxocy52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH07XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJocyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKF90aGlzLCBjdHgpOyB9O1xuICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5FcXVhbHM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpID09IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5JZGVudGljYWw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpID09PSByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAhPSByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTm90SWRlbnRpY2FsOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSAhPT0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkFuZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgJiYgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk9yOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSB8fCByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuUGx1czpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgKyByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTWludXM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIC0gcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkRpdmlkZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgLyByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpICogcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk1vZHVsbzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzKCkgJSByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpIDwgcmhzKCk7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA8PSByaHMoKTtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQmlnZ2VyOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaHMoKSA+IHJocygpO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocygpID49IHJocygpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wZXJhdG9yIFwiICsgYXN0Lm9wZXJhdG9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0UmVhZFByb3BFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3VsdDtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJlc3VsdCA9IHJlY2VpdmVyW2FzdC5uYW1lXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdFJlYWRLZXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBwcm9wID0gYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICByZXR1cm4gcmVjZWl2ZXJbcHJvcF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsQXJyYXlFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGN0eCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBTdGF0ZW1lbnRJbnRlcnByZXRlci5wcm90b3R5cGUudmlzaXRMaXRlcmFsTWFwRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyByZXN1bHQgPSB7fTtcbiAgICAgICAgYXN0LmVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuICgocmVzdWx0KSlbZW50cnkua2V5XSA9IGVudHJ5LnZhbHVlLnZpc2l0RXhwcmVzc2lvbihfdGhpcywgY3R4KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY29udGV4dFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgU3RhdGVtZW50SW50ZXJwcmV0ZXIucHJvdG90eXBlLnZpc2l0Q29tbWFFeHByID0gZnVuY3Rpb24gKGFzdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZXMgPSB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LnBhcnRzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJlc3Npb25zXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEFsbEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKGV4cHJlc3Npb25zLCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZXhwcikgeyByZXR1cm4gZXhwci52aXNpdEV4cHJlc3Npb24oX3RoaXMsIGN0eCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdGF0ZW1lbnRzXG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIFN0YXRlbWVudEludGVycHJldGVyLnByb3RvdHlwZS52aXNpdEFsbFN0YXRlbWVudHMgPSBmdW5jdGlvbiAoc3RhdGVtZW50cywgY3R4KSB7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdG10ID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbCA9IHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY3R4KTtcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBSZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVtZW50SW50ZXJwcmV0ZXI7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IHZhck5hbWVzXG4gKiBAcGFyYW0gez99IHN0YXRlbWVudHNcbiAqIEBwYXJhbSB7P30gY3R4XG4gKiBAcGFyYW0gez99IHZpc2l0b3JcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9kZWNsYXJlRm4odmFyTmFtZXMsIHN0YXRlbWVudHMsIGN0eCwgdmlzaXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9leGVjdXRlRnVuY3Rpb25TdGF0ZW1lbnRzKHZhck5hbWVzLCBhcmdzLCBzdGF0ZW1lbnRzLCBjdHgsIHZpc2l0b3IpO1xuICAgIH07XG59XG52YXIgQ0FUQ0hfRVJST1JfVkFSJDIgPSAnZXJyb3InO1xudmFyIENBVENIX1NUQUNLX1ZBUiQyID0gJ3N0YWNrJztcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZmFsc2UpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZUNsYXNzU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY3R4LnB1c2hDbGFzcyhzdG10KTtcbiAgICAgICAgdGhpcy5fdmlzaXRDbGFzc0NvbnN0cnVjdG9yKHN0bXQsIGN0eCk7XG4gICAgICAgIGlmIChzdG10LnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgc3RtdC5uYW1lICsgXCIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShcIik7XG4gICAgICAgICAgICBzdG10LnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwiLnByb3RvdHlwZSk7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN0bXQuZ2V0dGVycy5mb3JFYWNoKGZ1bmN0aW9uIChnZXR0ZXIpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzR2V0dGVyKHN0bXQsIGdldHRlciwgY3R4KTsgfSk7XG4gICAgICAgIHN0bXQubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgcmV0dXJuIF90aGlzLl92aXNpdENsYXNzTWV0aG9kKHN0bXQsIG1ldGhvZCwgY3R4KTsgfSk7XG4gICAgICAgIGN0eC5wb3BDbGFzcygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLl92aXNpdENsYXNzQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcImZ1bmN0aW9uIFwiICsgc3RtdC5uYW1lICsgXCIoXCIpO1xuICAgICAgICBpZiAoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LmNvbnN0cnVjdG9yTWV0aG9kLnBhcmFtcywgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIikge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICBpZiAoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcInZhciBzZWxmID0gdGhpcztcIik7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5jb25zdHJ1Y3Rvck1ldGhvZC5ib2R5LCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBnZXR0ZXJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc0dldHRlciA9IGZ1bmN0aW9uIChzdG10LCBnZXR0ZXIsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShcIiArIHN0bXQubmFtZSArIFwiLnByb3RvdHlwZSwgJ1wiICsgZ2V0dGVyLm5hbWUgKyBcIicsIHsgZ2V0OiBmdW5jdGlvbigpIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgaWYgKGdldHRlci5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGdldHRlci5ib2R5LCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9fSk7XCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzdG10XG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRDbGFzc01ldGhvZCA9IGZ1bmN0aW9uIChzdG10LCBtZXRob2QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgc3RtdC5uYW1lICsgXCIucHJvdG90eXBlLlwiICsgbWV0aG9kLm5hbWUgKyBcIiA9IGZ1bmN0aW9uKFwiKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMobWV0aG9kLnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCIpIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgaWYgKG1ldGhvZC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwidmFyIHNlbGYgPSB0aGlzO1wiKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKG1ldGhvZC5ib2R5LCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ9O1wiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYXN0XG4gICAgICogQHBhcmFtIHs/fSBjdHhcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwciA9IGZ1bmN0aW9uIChhc3QsIGN0eCkge1xuICAgICAgICBpZiAoYXN0LmJ1aWx0aW4gPT09IEJ1aWx0aW5WYXIuVGhpcykge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgJ3NlbGYnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QuYnVpbHRpbiA9PT0gQnVpbHRpblZhci5TdXBlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3N1cGVyJyBuZWVkcyB0byBiZSBoYW5kbGVkIGF0IGEgcGFyZW50IGFzdCBub2RlLCBub3QgYXQgdGhlIHZhcmlhYmxlIGxldmVsIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudmlzaXRSZWFkVmFyRXhwci5jYWxsKHRoaXMsIGFzdCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gc3RtdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RGVjbGFyZVZhclN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcInZhciBcIiArIHN0bXQubmFtZSArIFwiID0gXCIpO1xuICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIjtcIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdENhc3RFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwciA9IGZ1bmN0aW9uIChleHByLCBjdHgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm5FeHByID0gZXhwci5mbjtcbiAgICAgICAgaWYgKGZuRXhwciBpbnN0YW5jZW9mIFJlYWRWYXJFeHByICYmIGZuRXhwci5idWlsdGluID09PSBCdWlsdGluVmFyLlN1cGVyKSB7XG4gICAgICAgICAgICBjdHguY3VycmVudENsYXNzLnBhcmVudC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCBcIi5jYWxsKHRoaXNcIik7XG4gICAgICAgICAgICBpZiAoZXhwci5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIsIFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoZXhwci5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgXCIpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS52aXNpdEludm9rZUZ1bmN0aW9uRXhwci5jYWxsKHRoaXMsIGV4cHIsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGFzdFxuICAgICAqIEBwYXJhbSB7P30gY3R4XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RnVuY3Rpb25FeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwiZnVuY3Rpb24oXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhhc3QucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihhc3QsIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQgPSBmdW5jdGlvbiAoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBcImZ1bmN0aW9uIFwiICsgc3RtdC5uYW1lICsgXCIoXCIpO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCIpIHtcIik7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIFwifVwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHN0bXRcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyeUNhdGNoU3RtdCA9IGZ1bmN0aW9uIChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgXCJ0cnkge1wiKTtcbiAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmJvZHlTdG10cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn0gY2F0Y2ggKFwiICsgQ0FUQ0hfRVJST1JfVkFSJDEubmFtZSArIFwiKSB7XCIpO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNhdGNoU3RtdHMgPSBbLyoqIEB0eXBlIHs/fSAqLyAoQ0FUQ0hfU1RBQ0tfVkFSJDEuc2V0KENBVENIX0VSUk9SX1ZBUiQxLnByb3AoJ3N0YWNrJykpLnRvRGVjbFN0bXQobnVsbCwgW1xuICAgICAgICAgICAgICAgIFN0bXRNb2RpZmllci5GaW5hbFxuICAgICAgICAgICAgXSkpXS5jb25jYXQoc3RtdC5jYXRjaFN0bXRzKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoY2F0Y2hTdG10cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBcIn1cIik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yLnByb3RvdHlwZS5fdmlzaXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBjdHgucHJpbnQobnVsbCwgcGFyYW0ubmFtZSk7IH0sIHBhcmFtcywgY3R4LCAnLCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QnVpbHRpbk1ldGhvZE5hbWUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWU7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIEJ1aWx0aW5NZXRob2QuQ29uY2F0QXJyYXk6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdjb25jYXQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLlN1YnNjcmliZU9ic2VydmFibGU6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdzdWJzY3JpYmUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCdWlsdGluTWV0aG9kLkJpbmQ6XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdiaW5kJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBidWlsdGluIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvcjtcbn0oQWJzdHJhY3RFbWl0dGVyVmlzaXRvcikpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAcGFyYW0gez99IHNvdXJjZVVybFxuICogQHBhcmFtIHs/fSBjdHhcbiAqIEBwYXJhbSB7P30gdmFyc1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gZXZhbEV4cHJlc3Npb24oc291cmNlVXJsJCQxLCBjdHgsIHZhcnMpIHtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbkJvZHkgPSBjdHgudG9Tb3VyY2UoKSArIFwiXFxuLy8jIHNvdXJjZVVSTD1cIiArIHNvdXJjZVVybCQkMTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBmbkFyZ05hbWVzID0gW107XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZm5BcmdWYWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGFyZ05hbWUgaW4gdmFycykge1xuICAgICAgICBmbkFyZ05hbWVzLnB1c2goYXJnTmFtZSk7XG4gICAgICAgIGZuQXJnVmFsdWVzLnB1c2godmFyc1thcmdOYW1lXSk7XG4gICAgfVxuICAgIGlmIChpc0Rldk1vZGUoKSkge1xuICAgICAgICAvLyB1c2luZyBgbmV3IEZ1bmN0aW9uKC4uLilgIGdlbmVyYXRlcyBhIGhlYWRlciwgMSBsaW5lIG9mIG5vIGFyZ3VtZW50cywgMiBsaW5lcyBvdGhlcndpc2VcbiAgICAgICAgLy8gRS5nLiBgYGBcbiAgICAgICAgLy8gZnVuY3Rpb24gYW5vbnltb3VzKGEsYixjXG4gICAgICAgIC8vIC8qKi8pIHsgLi4uIH1gYGBcbiAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBoYXJkIGNvZGUgdGhpcyBmYWN0LCBzbyB3ZSBhdXRvIGRldGVjdCBpdCB2aWEgYW4gZW1wdHkgZnVuY3Rpb24gZmlyc3QuXG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVtcHR5Rm4gPSBuZXcgKEZ1bmN0aW9uLmJpbmQuYXBwbHkoRnVuY3Rpb24sIFt2b2lkIDBdLmNvbmNhdChmbkFyZ05hbWVzLmNvbmNhdCgncmV0dXJuIG51bGw7JykpKSkoKS50b1N0cmluZygpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBoZWFkZXJMaW5lcyA9IGVtcHR5Rm4uc2xpY2UoMCwgZW1wdHlGbi5pbmRleE9mKCdyZXR1cm4gbnVsbDsnKSkuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDE7XG4gICAgICAgIGZuQm9keSArPSBcIlxcblwiICsgY3R4LnRvU291cmNlTWFwR2VuZXJhdG9yKHNvdXJjZVVybCQkMSwgc291cmNlVXJsJCQxLCBoZWFkZXJMaW5lcykudG9Kc0NvbW1lbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24uYmluZC5hcHBseShGdW5jdGlvbiwgW3ZvaWQgMF0uY29uY2F0KGZuQXJnTmFtZXMuY29uY2F0KGZuQm9keSkpKSkoKS5hcHBseSh2b2lkIDAsIGZuQXJnVmFsdWVzKTtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBzb3VyY2VVcmxcbiAqIEBwYXJhbSB7P30gc3RhdGVtZW50c1xuICogQHBhcmFtIHs/fSByZXN1bHRWYXJzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBqaXRTdGF0ZW1lbnRzKHNvdXJjZVVybCQkMSwgc3RhdGVtZW50cywgcmVzdWx0VmFycykge1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbnZlcnRlciA9IG5ldyBKaXRFbWl0dGVyVmlzaXRvcigpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KHJlc3VsdFZhcnMpO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHJldHVyblN0bXQgPSBuZXcgUmV0dXJuU3RhdGVtZW50KGxpdGVyYWxBcnIocmVzdWx0VmFycy5tYXAoZnVuY3Rpb24gKHJlc3VsdFZhcikgeyByZXR1cm4gdmFyaWFibGUocmVzdWx0VmFyKTsgfSkpKTtcbiAgICBjb252ZXJ0ZXIudmlzaXRBbGxTdGF0ZW1lbnRzKHN0YXRlbWVudHMuY29uY2F0KFtyZXR1cm5TdG10XSksIGN0eCk7XG4gICAgcmV0dXJuIGV2YWxFeHByZXNzaW9uKHNvdXJjZVVybCQkMSwgY3R4LCBjb252ZXJ0ZXIuZ2V0QXJncygpKTtcbn1cbnZhciBKaXRFbWl0dGVyVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEppdEVtaXR0ZXJWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEppdEVtaXR0ZXJWaXNpdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZXZhbEFyZ05hbWVzID0gW107XG4gICAgICAgIF90aGlzLl9ldmFsQXJnVmFsdWVzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRFbWl0dGVyVmlzaXRvci5wcm90b3R5cGUuZ2V0QXJncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IDA7IGkgPCB0aGlzLl9ldmFsQXJnTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFt0aGlzLl9ldmFsQXJnTmFtZXNbaV1dID0gdGhpcy5fZXZhbEFyZ1ZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBhc3RcbiAgICAgKiBAcGFyYW0gez99IGN0eFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0RW1pdHRlclZpc2l0b3IucHJvdG90eXBlLnZpc2l0RXh0ZXJuYWxFeHByID0gZnVuY3Rpb24gKGFzdCwgY3R4KSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlID0gYXN0LnZhbHVlLnJlZmVyZW5jZTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaWQgPSB0aGlzLl9ldmFsQXJnVmFsdWVzLmluZGV4T2YodmFsdWUpO1xuICAgICAgICBpZiAoaWQgPT09IC0xKSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMuX2V2YWxBcmdWYWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ1ZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWUgPSBpZGVudGlmaWVyTmFtZShhc3QudmFsdWUpIHx8ICd2YWwnO1xuICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ05hbWVzLnB1c2goXCJqaXRfXCIgKyBuYW1lICsgaWQpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChhc3QsIHRoaXMuX2V2YWxBcmdOYW1lc1tpZF0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBKaXRFbWl0dGVyVmlzaXRvcjtcbn0oQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yKSk7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIGludGVybmFsIG1vZHVsZSBvZiB0aGUgQW5ndWxhciBjb21waWxlciB0aGF0IGJlZ2lucyB3aXRoIGNvbXBvbmVudCB0eXBlcyxcbiAqIGV4dHJhY3RzIHRlbXBsYXRlcywgYW5kIGV2ZW50dWFsbHkgcHJvZHVjZXMgYSBjb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBjb21wb25lbnRcbiAqIHJlYWR5IGZvciBsaW5raW5nIGludG8gYW4gYXBwbGljYXRpb24uXG4gKlxuICogXFxAc2VjdXJpdHkgV2hlbiBjb21waWxpbmcgdGVtcGxhdGVzIGF0IHJ1bnRpbWUsIHlvdSBtdXN0IGVuc3VyZSB0aGF0IHRoZSBlbnRpcmUgdGVtcGxhdGUgY29tZXNcbiAqIGZyb20gYSB0cnVzdGVkIHNvdXJjZS4gQXR0YWNrZXItY29udHJvbGxlZCBkYXRhIGludHJvZHVjZWQgYnkgYSB0ZW1wbGF0ZSBjb3VsZCBleHBvc2UgeW91clxuICogYXBwbGljYXRpb24gdG8gWFNTIHJpc2tzLiAgRm9yIG1vcmUgZGV0YWlsLCBzZWUgdGhlIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICovXG52YXIgSml0Q29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2luamVjdG9yXG4gICAgICogQHBhcmFtIHs/fSBfbWV0YWRhdGFSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gX3RlbXBsYXRlUGFyc2VyXG4gICAgICogQHBhcmFtIHs/fSBfc3R5bGVDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX3ZpZXdDb21waWxlclxuICAgICAqIEBwYXJhbSB7P30gX25nTW9kdWxlQ29tcGlsZXJcbiAgICAgKiBAcGFyYW0gez99IF9jb21waWxlckNvbmZpZ1xuICAgICAqIEBwYXJhbSB7P30gX2NvbnNvbGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBKaXRDb21waWxlcihfaW5qZWN0b3IsIF9tZXRhZGF0YVJlc29sdmVyLCBfdGVtcGxhdGVQYXJzZXIsIF9zdHlsZUNvbXBpbGVyLCBfdmlld0NvbXBpbGVyLCBfbmdNb2R1bGVDb21waWxlciwgX2NvbXBpbGVyQ29uZmlnLCBfY29uc29sZSkge1xuICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFSZXNvbHZlciA9IF9tZXRhZGF0YVJlc29sdmVyO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZVBhcnNlciA9IF90ZW1wbGF0ZVBhcnNlcjtcbiAgICAgICAgdGhpcy5fc3R5bGVDb21waWxlciA9IF9zdHlsZUNvbXBpbGVyO1xuICAgICAgICB0aGlzLl92aWV3Q29tcGlsZXIgPSBfdmlld0NvbXBpbGVyO1xuICAgICAgICB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyID0gX25nTW9kdWxlQ29tcGlsZXI7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVyQ29uZmlnID0gX2NvbXBpbGVyQ29uZmlnO1xuICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWREaXJlY3RpdmVXcmFwcGVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc2hhcmVkU3R5bGVzaGVldENvdW50ID0gMDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEppdENvbXBpbGVyLnByb3RvdHlwZSwgXCJpbmplY3RvclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pbmplY3RvcjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlU3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlTW9kdWxlQW5kQ29tcG9uZW50cyhtb2R1bGVUeXBlLCB0cnVlKS5zeW5jUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQXN5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZU1vZHVsZUFuZENvbXBvbmVudHMobW9kdWxlVHlwZSwgZmFsc2UpLmFzeW5jUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c1N5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHMobW9kdWxlVHlwZSwgdHJ1ZSkuc3luY1Jlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBmYWxzZSkuYXN5bmNSZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGNvbXBvbmVudFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLmdldE5nQ29udGVudFNlbGVjdG9ycyA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5fY29uc29sZS53YXJuKCdDb21waWxlci5nZXROZ0NvbnRlbnRTZWxlY3RvcnMgaXMgZGVwcmVjYXRlZC4gVXNlIENvbXBvbmVudEZhY3RvcnkubmdDb250ZW50U2VsZWN0b3JzIGluc3RlYWQhJyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlID0gdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmdldChjb21wb25lbnQpO1xuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29tcG9uZW50IFwiICsgybVzdHJpbmdpZnkoY29tcG9uZW50KSArIFwiIGlzIG5vdCB5ZXQgY29tcGlsZWQhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5jb21wTWV0YS50ZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEBwYXJhbSB7P30gaXNTeW5jXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGVBbmRDb21wb25lbnRzID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUsIGlzU3luYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2FkaW5nUHJvbWlzZSA9IHRoaXMuX2xvYWRNb2R1bGVzKG1vZHVsZVR5cGUsIGlzU3luYyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNyZWF0ZVJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9jb21waWxlQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY29tcGlsZU1vZHVsZShtb2R1bGVUeXBlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW5jQXN5bmNSZXN1bHQoY3JlYXRlUmVzdWx0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW5jQXN5bmNSZXN1bHQobnVsbCwgbG9hZGluZ1Byb21pc2UudGhlbihjcmVhdGVSZXN1bHQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcGFyYW0gez99IGlzU3luY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIChtb2R1bGVUeXBlLCBpc1N5bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9hZGluZ1Byb21pc2UgPSB0aGlzLl9sb2FkTW9kdWxlcyhtb2R1bGVUeXBlLCBpc1N5bmMpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjcmVhdGVSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wb25lbnRGYWN0b3JpZXMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLl9jb21waWxlQ29tcG9uZW50cyhtb2R1bGVUeXBlLCBjb21wb25lbnRGYWN0b3JpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bGVXaXRoQ29tcG9uZW50RmFjdG9yaWVzKF90aGlzLl9jb21waWxlTW9kdWxlKG1vZHVsZVR5cGUpLCBjb21wb25lbnRGYWN0b3JpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChjcmVhdGVSZXN1bHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5bmNBc3luY1Jlc3VsdChudWxsLCBsb2FkaW5nUHJvbWlzZS50aGVuKGNyZWF0ZVJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG1haW5Nb2R1bGVcbiAgICAgKiBAcGFyYW0gez99IGlzU3luY1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9sb2FkTW9kdWxlcyA9IGZ1bmN0aW9uIChtYWluTW9kdWxlLCBpc1N5bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9hZGluZ1Byb21pc2VzID0gW107XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5nTW9kdWxlID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1haW5Nb2R1bGUpO1xuICAgICAgICAvLyBOb3RlOiB0aGUgbG9hZGluZ1Byb21pc2UgZm9yIGEgbW9kdWxlIG9ubHkgaW5jbHVkZXMgdGhlIGxvYWRpbmcgb2YgdGhlIGV4cG9ydGVkIGRpcmVjdGl2ZXNcbiAgICAgICAgLy8gb2YgaW1wb3J0ZWQgbW9kdWxlcy5cbiAgICAgICAgLy8gSG93ZXZlciwgZm9yIHJ1bnRpbWUgY29tcGlsYXRpb24sIHdlIHdhbnQgdG8gdHJhbnNpdGl2ZWx5IGNvbXBpbGUgYWxsIG1vZHVsZXMsXG4gICAgICAgIC8vIHNvIHdlIGFsc28gbmVlZCB0byBjYWxsIGxvYWROZ01vZHVsZURpcmVjdGl2ZUFuZFBpcGVNZXRhZGF0YSBmb3IgYWxsIG5lc3RlZCBtb2R1bGVzLlxuICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxNb2R1bGVNZXRhKSB7XG4gICAgICAgICAgICBsb2FkaW5nUHJvbWlzZXMucHVzaChfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5sb2FkTmdNb2R1bGVEaXJlY3RpdmVBbmRQaXBlTWV0YWRhdGEobG9jYWxNb2R1bGVNZXRhLnJlZmVyZW5jZSwgaXNTeW5jKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobG9hZGluZ1Byb21pc2VzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVNb2R1bGUgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZUZhY3RvcnkgPSB0aGlzLl9jb21waWxlZE5nTW9kdWxlQ2FjaGUuZ2V0KG1vZHVsZVR5cGUpO1xuICAgICAgICBpZiAoIW5nTW9kdWxlRmFjdG9yeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlTWV0YV8xID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKG1vZHVsZVR5cGUpO1xuICAgICAgICAgICAgLy8gQWx3YXlzIHByb3ZpZGUgYSBib3VuZCBDb21waWxlclxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXh0cmFQcm92aWRlcnMgPSBbdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXRQcm92aWRlck1ldGFkYXRhKG5ldyBQcm92aWRlck1ldGEoQ29tcGlsZXIsIHsgdXNlRmFjdG9yeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1vZHVsZUJvdW5kQ29tcGlsZXIoX3RoaXMsIG1vZHVsZU1ldGFfMS50eXBlLnJlZmVyZW5jZSk7IH0gfSkpXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVSZXN1bHQgPSB0aGlzLl9uZ01vZHVsZUNvbXBpbGVyLmNvbXBpbGUobW9kdWxlTWV0YV8xLCBleHRyYVByb3ZpZGVycyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBpbGVyQ29uZmlnLnVzZUppdCkge1xuICAgICAgICAgICAgICAgIG5nTW9kdWxlRmFjdG9yeSA9XG4gICAgICAgICAgICAgICAgICAgIGludGVycHJldFN0YXRlbWVudHMoY29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzLCBbY29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXJdKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5nTW9kdWxlRmFjdG9yeSA9IGppdFN0YXRlbWVudHMobmdNb2R1bGVKaXRVcmwobW9kdWxlTWV0YV8xKSwgY29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzLCBbY29tcGlsZVJlc3VsdC5uZ01vZHVsZUZhY3RvcnlWYXJdKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5zZXQobW9kdWxlTWV0YV8xLnR5cGUucmVmZXJlbmNlLCBuZ01vZHVsZUZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZ01vZHVsZUZhY3Rvcnk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBcXEBpbnRlcm5hbFxuICAgICAqIEBwYXJhbSB7P30gbWFpbk1vZHVsZVxuICAgICAqIEBwYXJhbSB7P30gYWxsQ29tcG9uZW50RmFjdG9yaWVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX2NvbXBpbGVDb21wb25lbnRzID0gZnVuY3Rpb24gKG1haW5Nb2R1bGUsIGFsbENvbXBvbmVudEZhY3Rvcmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZ01vZHVsZSA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShtYWluTW9kdWxlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbW9kdWxlQnlEaXJlY3RpdmUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsTW9kdWxlU3VtbWFyeSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbG9jYWxNb2R1bGVNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0TmdNb2R1bGVNZXRhZGF0YShsb2NhbE1vZHVsZVN1bW1hcnkucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIGxvY2FsTW9kdWxlTWV0YS5kZWNsYXJlZERpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlySWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIG1vZHVsZUJ5RGlyZWN0aXZlLnNldChkaXJJZGVudGlmaWVyLnJlZmVyZW5jZSwgbG9jYWxNb2R1bGVNZXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJNZXRhID0gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZGlySWRlbnRpZmllci5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5hZGQoX3RoaXMuX2NyZWF0ZUNvbXBpbGVkVGVtcGxhdGUoZGlyTWV0YSwgbG9jYWxNb2R1bGVNZXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxDb21wb25lbnRGYWN0b3JpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHRlbXBsYXRlID0gX3RoaXMuX2NyZWF0ZUNvbXBpbGVkSG9zdFRlbXBsYXRlKGRpck1ldGEudHlwZS5yZWZlcmVuY2UsIGxvY2FsTW9kdWxlTWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZXMuYWRkKHRlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbENvbXBvbmVudEZhY3Rvcmllcy5wdXNoKC8qKiBAdHlwZSB7P30gKi8gKGRpck1ldGEuY29tcG9uZW50RmFjdG9yeSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBuZ01vZHVsZS50cmFuc2l0aXZlTW9kdWxlLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobG9jYWxNb2R1bGVTdW1tYXJ5KSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsb2NhbE1vZHVsZU1ldGEgPSBfdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXROZ01vZHVsZU1ldGFkYXRhKGxvY2FsTW9kdWxlU3VtbWFyeS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgbG9jYWxNb2R1bGVNZXRhLmRlY2xhcmVkRGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyTWV0YSA9IF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldERpcmVjdGl2ZU1ldGFkYXRhKGRpcklkZW50aWZpZXIucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyTWV0YS5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgICAgICBkaXJNZXRhLmVudHJ5Q29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeUNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZU1ldGEgPSBtb2R1bGVCeURpcmVjdGl2ZS5nZXQoZW50cnlDb21wb25lbnRUeXBlLmNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVzLmFkZChfdGhpcy5fY3JlYXRlQ29tcGlsZWRIb3N0VGVtcGxhdGUoZW50cnlDb21wb25lbnRUeXBlLmNvbXBvbmVudFR5cGUsIG1vZHVsZU1ldGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2NhbE1vZHVsZU1ldGEuZW50cnlDb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5Q29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1vZHVsZU1ldGEgPSBtb2R1bGVCeURpcmVjdGl2ZS5nZXQoZW50cnlDb21wb25lbnRUeXBlLmNvbXBvbmVudFR5cGUpO1xuICAgICAgICAgICAgICAgIHRlbXBsYXRlcy5hZGQoX3RoaXMuX2NyZWF0ZUNvbXBpbGVkSG9zdFRlbXBsYXRlKGVudHJ5Q29tcG9uZW50VHlwZS5jb21wb25lbnRUeXBlLCBtb2R1bGVNZXRhKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRlbXBsYXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZW1wbGF0ZSkgeyByZXR1cm4gX3RoaXMuX2NvbXBpbGVUZW1wbGF0ZSh0ZW1wbGF0ZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0eXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZUZvciA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuY2xlYXJDYWNoZUZvcih0eXBlKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZS5kZWxldGUodHlwZSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBpbGVkVGVtcGxhdGUgPSB0aGlzLl9jb21waWxlZFRlbXBsYXRlQ2FjaGUuZ2V0KHR5cGUpO1xuICAgICAgICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZUNhY2hlLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5jbGVhckNhY2hlKCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLl9jb21waWxlZEhvc3RUZW1wbGF0ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkTmdNb2R1bGVDYWNoZS5jbGVhcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wVHlwZVxuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY3JlYXRlQ29tcGlsZWRIb3N0VGVtcGxhdGUgPSBmdW5jdGlvbiAoY29tcFR5cGUsIG5nTW9kdWxlKSB7XG4gICAgICAgIGlmICghbmdNb2R1bGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudCBcIiArIMm1c3RyaW5naWZ5KGNvbXBUeXBlKSArIFwiIGlzIG5vdCBwYXJ0IG9mIGFueSBOZ01vZHVsZSBvciB0aGUgbW9kdWxlIGhhcyBub3QgYmVlbiBpbXBvcnRlZCBpbnRvIHlvdXIgbW9kdWxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21waWxlZFRlbXBsYXRlID0gdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZS5nZXQoY29tcFR5cGUpO1xuICAgICAgICBpZiAoIWNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGNvbXBNZXRhID0gdGhpcy5fbWV0YWRhdGFSZXNvbHZlci5nZXREaXJlY3RpdmVNZXRhZGF0YShjb21wVHlwZSk7XG4gICAgICAgICAgICBhc3NlcnRDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcG9uZW50RmFjdG9yeSA9IChjb21wTWV0YS5jb21wb25lbnRGYWN0b3J5KTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGhvc3RDbGFzcyA9IHRoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0SG9zdENvbXBvbmVudFR5cGUoY29tcFR5cGUpO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaG9zdE1ldGEgPSBjcmVhdGVIb3N0Q29tcG9uZW50TWV0YShob3N0Q2xhc3MsIGNvbXBNZXRhLCAvKiogQHR5cGUgez99ICovICjJtWdldENvbXBvbmVudFZpZXdEZWZpbml0aW9uRmFjdG9yeShjb21wb25lbnRGYWN0b3J5KSkpO1xuICAgICAgICAgICAgY29tcGlsZWRUZW1wbGF0ZSA9XG4gICAgICAgICAgICAgICAgbmV3IENvbXBpbGVkVGVtcGxhdGUodHJ1ZSwgY29tcE1ldGEudHlwZSwgaG9zdE1ldGEsIG5nTW9kdWxlLCBbY29tcE1ldGEudHlwZV0pO1xuICAgICAgICAgICAgdGhpcy5fY29tcGlsZWRIb3N0VGVtcGxhdGVDYWNoZS5zZXQoY29tcFR5cGUsIGNvbXBpbGVkVGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21waWxlZFRlbXBsYXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBjb21wTWV0YVxuICAgICAqIEBwYXJhbSB7P30gbmdNb2R1bGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEppdENvbXBpbGVyLnByb3RvdHlwZS5fY3JlYXRlQ29tcGlsZWRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb21wTWV0YSwgbmdNb2R1bGUpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZWRUZW1wbGF0ZSA9IHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5nZXQoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UpO1xuICAgICAgICBpZiAoIWNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGFzc2VydENvbXBvbmVudChjb21wTWV0YSk7XG4gICAgICAgICAgICBjb21waWxlZFRlbXBsYXRlID0gbmV3IENvbXBpbGVkVGVtcGxhdGUoZmFsc2UsIGNvbXBNZXRhLnR5cGUsIGNvbXBNZXRhLCBuZ01vZHVsZSwgbmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5kaXJlY3RpdmVzKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGVDYWNoZS5zZXQoY29tcE1ldGEudHlwZS5yZWZlcmVuY2UsIGNvbXBpbGVkVGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21waWxlZFRlbXBsYXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB0ZW1wbGF0ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXIucHJvdG90eXBlLl9jb21waWxlVGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRlbXBsYXRlLmlzQ29tcGlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb21wTWV0YSA9IHRlbXBsYXRlLmNvbXBNZXRhO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0eWxlc0NvbXBpbGVSZXN1bHQgPSB0aGlzLl9zdHlsZUNvbXBpbGVyLmNvbXBpbGVDb21wb25lbnQoY29tcE1ldGEpO1xuICAgICAgICBzdHlsZXNDb21waWxlUmVzdWx0LmV4dGVybmFsU3R5bGVzaGVldHMuZm9yRWFjaChmdW5jdGlvbiAocikgeyBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwuc2V0KHIubWV0YS5tb2R1bGVVcmwsIHIpOyB9KTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVN0eWxlc0NvbXBpbGVSZXN1bHQoc3R5bGVzQ29tcGlsZVJlc3VsdC5jb21wb25lbnRTdHlsZXNoZWV0LCBleHRlcm5hbFN0eWxlc2hlZXRzQnlNb2R1bGVVcmwpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBkaXJlY3RpdmVzID0gdGVtcGxhdGUuZGlyZWN0aXZlcy5tYXAoZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gX3RoaXMuX21ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlU3VtbWFyeShkaXIucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBpcGVzID0gdGVtcGxhdGUubmdNb2R1bGUudHJhbnNpdGl2ZU1vZHVsZS5waXBlcy5tYXAoZnVuY3Rpb24gKHBpcGUpIHsgcmV0dXJuIF90aGlzLl9tZXRhZGF0YVJlc29sdmVyLmdldFBpcGVTdW1tYXJ5KHBpcGUucmVmZXJlbmNlKTsgfSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3RlbXBsYXRlUGFyc2VyLnBhcnNlKGNvbXBNZXRhLCBjb21wTWV0YS50ZW1wbGF0ZS50ZW1wbGF0ZSwgZGlyZWN0aXZlcywgcGlwZXMsIHRlbXBsYXRlLm5nTW9kdWxlLnNjaGVtYXMsIHRlbXBsYXRlU291cmNlVXJsKHRlbXBsYXRlLm5nTW9kdWxlLnR5cGUsIHRlbXBsYXRlLmNvbXBNZXRhLCB0ZW1wbGF0ZS5jb21wTWV0YS50ZW1wbGF0ZSkpLCBwYXJzZWRUZW1wbGF0ZSA9IF9hLnRlbXBsYXRlLCB1c2VkUGlwZXMgPSBfYS5waXBlcztcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcGlsZVJlc3VsdCA9IHRoaXMuX3ZpZXdDb21waWxlci5jb21waWxlQ29tcG9uZW50KGNvbXBNZXRhLCBwYXJzZWRUZW1wbGF0ZSwgdmFyaWFibGUoc3R5bGVzQ29tcGlsZVJlc3VsdC5jb21wb25lbnRTdHlsZXNoZWV0LnN0eWxlc1ZhciksIHVzZWRQaXBlcyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRlbWVudHMgPSBzdHlsZXNDb21waWxlUmVzdWx0LmNvbXBvbmVudFN0eWxlc2hlZXQuc3RhdGVtZW50cy5jb25jYXQoY29tcGlsZVJlc3VsdC5zdGF0ZW1lbnRzKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlld0NsYXNzQW5kUmVuZGVyZXJUeXBlVmFycyA9IGNvbXBNZXRhLmlzSG9zdCA/XG4gICAgICAgICAgICBbY29tcGlsZVJlc3VsdC52aWV3Q2xhc3NWYXJdIDpcbiAgICAgICAgICAgIFtjb21waWxlUmVzdWx0LnZpZXdDbGFzc1ZhciwgY29tcGlsZVJlc3VsdC5yZW5kZXJlclR5cGVWYXJdO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2aWV3Q2xhc3M7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlbmRlcmVyVHlwZTtcbiAgICAgICAgaWYgKCF0aGlzLl9jb21waWxlckNvbmZpZy51c2VKaXQpIHtcbiAgICAgICAgICAgIF9iID0gaW50ZXJwcmV0U3RhdGVtZW50cyhzdGF0ZW1lbnRzLCB2aWV3Q2xhc3NBbmRSZW5kZXJlclR5cGVWYXJzKSwgdmlld0NsYXNzID0gX2JbMF0sIHJlbmRlcmVyVHlwZSA9IF9iWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2MgPSBqaXRTdGF0ZW1lbnRzKHRlbXBsYXRlSml0VXJsKHRlbXBsYXRlLm5nTW9kdWxlLnR5cGUsIHRlbXBsYXRlLmNvbXBNZXRhKSwgc3RhdGVtZW50cywgdmlld0NsYXNzQW5kUmVuZGVyZXJUeXBlVmFycyksIHZpZXdDbGFzcyA9IF9jWzBdLCByZW5kZXJlclR5cGUgPSBfY1sxXTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZS5jb21waWxlZCh2aWV3Q2xhc3MsIHJlbmRlcmVyVHlwZSk7XG4gICAgICAgIHZhciBfYiwgX2M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlc3VsdFxuICAgICAqIEBwYXJhbSB7P30gZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX3Jlc29sdmVTdHlsZXNDb21waWxlUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlc3VsdC5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwLCBpKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBuZXN0ZWRDb21waWxlUmVzdWx0ID0gZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsLmdldChkZXAubW9kdWxlVXJsKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5lc3RlZFN0eWxlc0FyciA9IF90aGlzLl9yZXNvbHZlQW5kRXZhbFN0eWxlc0NvbXBpbGVSZXN1bHQobmVzdGVkQ29tcGlsZVJlc3VsdCwgZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsKTtcbiAgICAgICAgICAgIGRlcC52YWx1ZVBsYWNlaG9sZGVyLnJlZmVyZW5jZSA9IG5lc3RlZFN0eWxlc0FycjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHJlc3VsdFxuICAgICAqIEBwYXJhbSB7P30gZXh0ZXJuYWxTdHlsZXNoZWV0c0J5TW9kdWxlVXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBKaXRDb21waWxlci5wcm90b3R5cGUuX3Jlc29sdmVBbmRFdmFsU3R5bGVzQ29tcGlsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlU3R5bGVzQ29tcGlsZVJlc3VsdChyZXN1bHQsIGV4dGVybmFsU3R5bGVzaGVldHNCeU1vZHVsZVVybCk7XG4gICAgICAgIGlmICghdGhpcy5fY29tcGlsZXJDb25maWcudXNlSml0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJwcmV0U3RhdGVtZW50cyhyZXN1bHQuc3RhdGVtZW50cywgW3Jlc3VsdC5zdHlsZXNWYXJdKVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBqaXRTdGF0ZW1lbnRzKHNoYXJlZFN0eWxlc2hlZXRKaXRVcmwocmVzdWx0Lm1ldGEsIHRoaXMuX3NoYXJlZFN0eWxlc2hlZXRDb3VudCsrKSwgcmVzdWx0LnN0YXRlbWVudHMsIFtyZXN1bHQuc3R5bGVzVmFyXSlbMF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBKaXRDb21waWxlcjtcbn0oKSk7XG5KaXRDb21waWxlci5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5KaXRDb21waWxlci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICB7IHR5cGU6IEluamVjdG9yLCB9LFxuICAgIHsgdHlwZTogQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIsIH0sXG4gICAgeyB0eXBlOiBUZW1wbGF0ZVBhcnNlciwgfSxcbiAgICB7IHR5cGU6IFN0eWxlQ29tcGlsZXIsIH0sXG4gICAgeyB0eXBlOiBWaWV3Q29tcGlsZXIsIH0sXG4gICAgeyB0eXBlOiBOZ01vZHVsZUNvbXBpbGVyLCB9LFxuICAgIHsgdHlwZTogQ29tcGlsZXJDb25maWcsIH0sXG4gICAgeyB0eXBlOiDJtUNvbnNvbGUsIH0sXG5dOyB9O1xudmFyIENvbXBpbGVkVGVtcGxhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaXNIb3N0XG4gICAgICogQHBhcmFtIHs/fSBjb21wVHlwZVxuICAgICAqIEBwYXJhbSB7P30gY29tcE1ldGFcbiAgICAgKiBAcGFyYW0gez99IG5nTW9kdWxlXG4gICAgICogQHBhcmFtIHs/fSBkaXJlY3RpdmVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29tcGlsZWRUZW1wbGF0ZShpc0hvc3QsIGNvbXBUeXBlLCBjb21wTWV0YSwgbmdNb2R1bGUsIGRpcmVjdGl2ZXMpIHtcbiAgICAgICAgdGhpcy5pc0hvc3QgPSBpc0hvc3Q7XG4gICAgICAgIHRoaXMuY29tcFR5cGUgPSBjb21wVHlwZTtcbiAgICAgICAgdGhpcy5jb21wTWV0YSA9IGNvbXBNZXRhO1xuICAgICAgICB0aGlzLm5nTW9kdWxlID0gbmdNb2R1bGU7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgIHRoaXMuX3ZpZXdDbGFzcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNDb21waWxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZpZXdDbGFzc1xuICAgICAqIEBwYXJhbSB7P30gcmVuZGVyZXJUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBDb21waWxlZFRlbXBsYXRlLnByb3RvdHlwZS5jb21waWxlZCA9IGZ1bmN0aW9uICh2aWV3Q2xhc3MsIHJlbmRlcmVyVHlwZSkge1xuICAgICAgICB0aGlzLl92aWV3Q2xhc3MgPSB2aWV3Q2xhc3M7XG4gICAgICAgICgodGhpcy5jb21wTWV0YS5jb21wb25lbnRWaWV3VHlwZSkpLnNldERlbGVnYXRlKHZpZXdDbGFzcyk7XG4gICAgICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gcHJvcCBpbiByZW5kZXJlclR5cGUpIHtcbiAgICAgICAgICAgICgodGhpcy5jb21wTWV0YS5yZW5kZXJlclR5cGUpKVtwcm9wXSA9IHJlbmRlcmVyVHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ29tcGlsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBpbGVkVGVtcGxhdGU7XG59KCkpO1xuLyoqXG4gKiBAcGFyYW0gez99IG1ldGFcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIGFzc2VydENvbXBvbmVudChtZXRhKSB7XG4gICAgaWYgKCFtZXRhLmlzQ29tcG9uZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb21waWxlICdcIiArIGlkZW50aWZpZXJOYW1lKG1ldGEudHlwZSkgKyBcIicgYmVjYXVzZSBpdCBpcyBub3QgYSBjb21wb25lbnQuXCIpO1xuICAgIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyBgQ29tcGlsZXJgIGJ5IGRlbGVnYXRpbmcgdG8gdGhlIEppdENvbXBpbGVyIHVzaW5nIGEga25vd24gbW9kdWxlLlxuICovXG52YXIgTW9kdWxlQm91bmRDb21waWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBfZGVsZWdhdGVcbiAgICAgKiBAcGFyYW0gez99IF9uZ01vZHVsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1vZHVsZUJvdW5kQ29tcGlsZXIoX2RlbGVnYXRlLCBfbmdNb2R1bGUpIHtcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBfZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuX25nTW9kdWxlID0gX25nTW9kdWxlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUsIFwiX2luamVjdG9yXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmluamVjdG9yOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZVN5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY29tcGlsZU1vZHVsZVN5bmMobW9kdWxlVHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwYXJhbSB7P30gbW9kdWxlVHlwZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTW9kdWxlQm91bmRDb21waWxlci5wcm90b3R5cGUuY29tcGlsZU1vZHVsZUFzeW5jID0gZnVuY3Rpb24gKG1vZHVsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvbXBpbGVNb2R1bGVBc3luYyhtb2R1bGVUeXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/fSBtb2R1bGVUeXBlXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlTW9kdWxlQW5kQWxsQ29tcG9uZW50c1N5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNTeW5jKG1vZHVsZVR5cGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0gez99IG1vZHVsZVR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVNb2R1bGVBbmRBbGxDb21wb25lbnRzQXN5bmMgPSBmdW5jdGlvbiAobW9kdWxlVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY29tcGlsZU1vZHVsZUFuZEFsbENvbXBvbmVudHNBc3luYyhtb2R1bGVUeXBlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gY29tcG9uZW50XG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5nZXROZ0NvbnRlbnRTZWxlY3RvcnMgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5nZXROZ0NvbnRlbnRTZWxlY3RvcnMoY29tcG9uZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY2FjaGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNb2R1bGVCb3VuZENvbXBpbGVyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9kZWxlZ2F0ZS5jbGVhckNhY2hlKCk7IH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjYWNoZSBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudC9uZ01vZHVsZS5cbiAgICAgKiBAcGFyYW0gez99IHR5cGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1vZHVsZUJvdW5kQ29tcGlsZXIucHJvdG90eXBlLmNsZWFyQ2FjaGVGb3IgPSBmdW5jdGlvbiAodHlwZSkgeyB0aGlzLl9kZWxlZ2F0ZS5jbGVhckNhY2hlRm9yKHR5cGUpOyB9O1xuICAgIHJldHVybiBNb2R1bGVCb3VuZENvbXBpbGVyO1xufSgpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBjb250YWluZXIgZm9yIG1lc3NhZ2UgZXh0cmFjdGVkIGZyb20gdGhlIHRlbXBsYXRlcy5cbiAqL1xudmFyIE1lc3NhZ2VCdW5kbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gX2h0bWxQYXJzZXJcbiAgICAgKiBAcGFyYW0gez99IF9pbXBsaWNpdFRhZ3NcbiAgICAgKiBAcGFyYW0gez99IF9pbXBsaWNpdEF0dHJzXG4gICAgICogQHBhcmFtIHs/PX0gX2xvY2FsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VCdW5kbGUoX2h0bWxQYXJzZXIsIF9pbXBsaWNpdFRhZ3MsIF9pbXBsaWNpdEF0dHJzLCBfbG9jYWxlKSB7XG4gICAgICAgIGlmIChfbG9jYWxlID09PSB2b2lkIDApIHsgX2xvY2FsZSA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFRhZ3MgPSBfaW1wbGljaXRUYWdzO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdEF0dHJzID0gX2ltcGxpY2l0QXR0cnM7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaHRtbFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHBhcmFtIHs/fSBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZXNzYWdlQnVuZGxlLnByb3RvdHlwZS51cGRhdGVGcm9tVGVtcGxhdGUgPSBmdW5jdGlvbiAoaHRtbCwgdXJsLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGh0bWxQYXJzZXJSZXN1bHQgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKGh0bWwsIHVybCwgdHJ1ZSwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmIChodG1sUGFyc2VyUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sUGFyc2VyUmVzdWx0LmVycm9ycztcbiAgICAgICAgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpMThuUGFyc2VyUmVzdWx0ID0gZXh0cmFjdE1lc3NhZ2VzKGh0bWxQYXJzZXJSZXN1bHQucm9vdE5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCB0aGlzLl9pbXBsaWNpdFRhZ3MsIHRoaXMuX2ltcGxpY2l0QXR0cnMpO1xuICAgICAgICBpZiAoaTE4blBhcnNlclJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaTE4blBhcnNlclJlc3VsdC5lcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fbWVzc2FnZXMpLnB1c2guYXBwbHkoX2EsIGkxOG5QYXJzZXJSZXN1bHQubWVzc2FnZXMpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1lc3NhZ2VCdW5kbGUucHJvdG90eXBlLmdldE1lc3NhZ2VzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWVzc2FnZXM7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBzZXJpYWxpemVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNZXNzYWdlQnVuZGxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVyKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1lc3NhZ2VzID0ge307XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG1hcHBlclZpc2l0b3IgPSBuZXcgTWFwUGxhY2Vob2xkZXJOYW1lcygpO1xuICAgICAgICAvLyBEZWR1cGxpY2F0ZSBtZXNzYWdlcyBiYXNlZCBvbiB0aGVpciBJRFxuICAgICAgICB0aGlzLl9tZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBpZCA9IHNlcmlhbGl6ZXIuZGlnZXN0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1tpZF0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHJhbnNmb3JtIHBsYWNlaG9sZGVyIG5hbWVzIHVzaW5nIHRoZSBzZXJpYWxpemVyIG1hcHBpbmdcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbXNnTGlzdCA9IE9iamVjdC5rZXlzKG1lc3NhZ2VzKS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXBwZXIgPSBzZXJpYWxpemVyLmNyZWF0ZU5hbWVNYXBwZXIobWVzc2FnZXNbaWRdKTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHNyYyA9IG1lc3NhZ2VzW2lkXTtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGVzID0gbWFwcGVyID8gbWFwcGVyVmlzaXRvci5jb252ZXJ0KHNyYy5ub2RlcywgbWFwcGVyKSA6IHNyYy5ub2RlcztcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShub2Rlcywge30sIHt9LCBzcmMubWVhbmluZywgc3JjLmRlc2NyaXB0aW9uLCBpZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplci53cml0ZShtc2dMaXN0LCB0aGlzLl9sb2NhbGUpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VCdW5kbGU7XG59KCkpO1xudmFyIE1hcFBsYWNlaG9sZGVyTmFtZXMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBQbGFjZWhvbGRlck5hbWVzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFBsYWNlaG9sZGVyTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBub2Rlc1xuICAgICAqIEBwYXJhbSB7P30gbWFwcGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNYXBQbGFjZWhvbGRlck5hbWVzLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKG5vZGVzLCBtYXBwZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG1hcHBlciA/IG5vZGVzLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcywgbWFwcGVyKTsgfSkgOiBub2RlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcGhcbiAgICAgKiBAcGFyYW0gez99IG1hcHBlclxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgTWFwUGxhY2Vob2xkZXJOYW1lcy5wcm90b3R5cGUudmlzaXRUYWdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChwaCwgbWFwcGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXJ0TmFtZSA9IG1hcHBlci50b1B1YmxpY05hbWUocGguc3RhcnROYW1lKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvc2VOYW1lID0gcGguY2xvc2VOYW1lID8gbWFwcGVyLnRvUHVibGljTmFtZShwaC5jbG9zZU5hbWUpIDogcGguY2xvc2VOYW1lO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobikgeyByZXR1cm4gbi52aXNpdChfdGhpcywgbWFwcGVyKTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgVGFnUGxhY2Vob2xkZXIocGgudGFnLCBwaC5hdHRycywgc3RhcnROYW1lLCBjbG9zZU5hbWUsIGNoaWxkcmVuLCBwaC5pc1ZvaWQsIHBoLnNvdXJjZVNwYW4pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBwaFxuICAgICAqIEBwYXJhbSB7P30gbWFwcGVyXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBNYXBQbGFjZWhvbGRlck5hbWVzLnByb3RvdHlwZS52aXNpdFBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKHBoLCBtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcihwaC52YWx1ZSwgbWFwcGVyLnRvUHVibGljTmFtZShwaC5uYW1lKSwgcGguc291cmNlU3Bhbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHBoXG4gICAgICogQHBhcmFtIHs/fSBtYXBwZXJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIE1hcFBsYWNlaG9sZGVyTmFtZXMucHJvdG90eXBlLnZpc2l0SWN1UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGgsIG1hcHBlcikge1xuICAgICAgICByZXR1cm4gbmV3IEljdVBsYWNlaG9sZGVyKHBoLnZhbHVlLCBtYXBwZXIudG9QdWJsaWNOYW1lKHBoLm5hbWUpLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBQbGFjZWhvbGRlck5hbWVzO1xufShDbG9uZVZpc2l0b3IpKTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogRXh0cmFjdCBpMThuIG1lc3NhZ2VzIGZyb20gc291cmNlIGNvZGVcbiAqL1xudmFyIEV4dHJhY3RvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBob3N0XG4gICAgICogQHBhcmFtIHs/fSBzdGF0aWNTeW1ib2xSZXNvbHZlclxuICAgICAqIEBwYXJhbSB7P30gbWVzc2FnZUJ1bmRsZVxuICAgICAqIEBwYXJhbSB7P30gbWV0YWRhdGFSZXNvbHZlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEV4dHJhY3Rvcihob3N0LCBzdGF0aWNTeW1ib2xSZXNvbHZlciwgbWVzc2FnZUJ1bmRsZSwgbWV0YWRhdGFSZXNvbHZlcikge1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnN0YXRpY1N5bWJvbFJlc29sdmVyID0gc3RhdGljU3ltYm9sUmVzb2x2ZXI7XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1bmRsZSA9IG1lc3NhZ2VCdW5kbGU7XG4gICAgICAgIHRoaXMubWV0YWRhdGFSZXNvbHZlciA9IG1ldGFkYXRhUmVzb2x2ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gcm9vdEZpbGVzXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBFeHRyYWN0b3IucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAocm9vdEZpbGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHByb2dyYW1TeW1ib2xzID0gZXh0cmFjdFByb2dyYW1TeW1ib2xzKHRoaXMuc3RhdGljU3ltYm9sUmVzb2x2ZXIsIHJvb3RGaWxlcywgdGhpcy5ob3N0KTtcbiAgICAgICAgdmFyIF9hID0gYW5hbHl6ZUFuZFZhbGlkYXRlTmdNb2R1bGVzKHByb2dyYW1TeW1ib2xzLCB0aGlzLmhvc3QsIHRoaXMubWV0YWRhdGFSZXNvbHZlciksIGZpbGVzID0gX2EuZmlsZXMsIG5nTW9kdWxlcyA9IF9hLm5nTW9kdWxlcztcbiAgICAgICAgcmV0dXJuIFByb21pc2VcbiAgICAgICAgICAgIC5hbGwobmdNb2R1bGVzLm1hcChmdW5jdGlvbiAobmdNb2R1bGUpIHsgcmV0dXJuIF90aGlzLm1ldGFkYXRhUmVzb2x2ZXIubG9hZE5nTW9kdWxlRGlyZWN0aXZlQW5kUGlwZU1ldGFkYXRhKG5nTW9kdWxlLnR5cGUucmVmZXJlbmNlLCBmYWxzZSk7IH0pKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXJyb3JzID0gW107XG4gICAgICAgICAgICBmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29tcE1ldGFzID0gW107XG4gICAgICAgICAgICAgICAgZmlsZS5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZGlyTWV0YSA9IF90aGlzLm1ldGFkYXRhUmVzb2x2ZXIuZ2V0RGlyZWN0aXZlTWV0YWRhdGEoZGlyZWN0aXZlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJNZXRhICYmIGRpck1ldGEuaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBNZXRhcy5wdXNoKGRpck1ldGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29tcE1ldGFzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBNZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGh0bWwgPSBjb21wTWV0YS50ZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW50ZXJwb2xhdGlvbkNvbmZpZyA9IEludGVycG9sYXRpb25Db25maWcuZnJvbUFycmF5KGNvbXBNZXRhLnRlbXBsYXRlLmludGVycG9sYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIF90aGlzLm1lc3NhZ2VCdW5kbGUudXBkYXRlRnJvbVRlbXBsYXRlKGh0bWwsIGZpbGUuc3JjVXJsLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUudG9TdHJpbmcoKTsgfSkuam9pbignXFxuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1lc3NhZ2VCdW5kbGU7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBob3N0XG4gICAgICogQHBhcmFtIHs/fSBsb2NhbGVcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEV4dHJhY3Rvci5jcmVhdGUgPSBmdW5jdGlvbiAoaG9zdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGh0bWxQYXJzZXIgPSBuZXcgSTE4Tkh0bWxQYXJzZXIobmV3IEh0bWxQYXJzZXIoKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHVybFJlc29sdmVyID0gY3JlYXRlT2ZmbGluZUNvbXBpbGVVcmxSZXNvbHZlcigpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzeW1ib2xDYWNoZSA9IG5ldyBTdGF0aWNTeW1ib2xDYWNoZSgpO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdW1tYXJ5UmVzb2x2ZXIgPSBuZXcgQW90U3VtbWFyeVJlc29sdmVyKGhvc3QsIHN5bWJvbENhY2hlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc3RhdGljU3ltYm9sUmVzb2x2ZXIgPSBuZXcgU3RhdGljU3ltYm9sUmVzb2x2ZXIoaG9zdCwgc3ltYm9sQ2FjaGUsIHN1bW1hcnlSZXNvbHZlcik7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHN0YXRpY1JlZmxlY3RvciA9IG5ldyBTdGF0aWNSZWZsZWN0b3Ioc3VtbWFyeVJlc29sdmVyLCBzdGF0aWNTeW1ib2xSZXNvbHZlcik7XG4gICAgICAgIFN0YXRpY0FuZER5bmFtaWNSZWZsZWN0aW9uQ2FwYWJpbGl0aWVzLmluc3RhbGwoc3RhdGljUmVmbGVjdG9yKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY29uZmlnID0gbmV3IENvbXBpbGVyQ29uZmlnKHsgZGVmYXVsdEVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkLCB1c2VKaXQ6IGZhbHNlIH0pO1xuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub3JtYWxpemVyID0gbmV3IERpcmVjdGl2ZU5vcm1hbGl6ZXIoeyBnZXQ6IGZ1bmN0aW9uICh1cmwpIHsgcmV0dXJuIGhvc3QubG9hZFJlc291cmNlKHVybCk7IH0gfSwgdXJsUmVzb2x2ZXIsIGh0bWxQYXJzZXIsIGNvbmZpZyk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IG5ldyBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzb2x2ZXIgPSBuZXcgQ29tcGlsZU1ldGFkYXRhUmVzb2x2ZXIoY29uZmlnLCBuZXcgTmdNb2R1bGVSZXNvbHZlcihzdGF0aWNSZWZsZWN0b3IpLCBuZXcgRGlyZWN0aXZlUmVzb2x2ZXIoc3RhdGljUmVmbGVjdG9yKSwgbmV3IFBpcGVSZXNvbHZlcihzdGF0aWNSZWZsZWN0b3IpLCBzdW1tYXJ5UmVzb2x2ZXIsIGVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgbm9ybWFsaXplciwgbmV3IMm1Q29uc29sZSgpLCBzeW1ib2xDYWNoZSwgc3RhdGljUmVmbGVjdG9yKTtcbiAgICAgICAgLy8gVE9ETyh2aWNiKTogaW1wbGljaXQgdGFncyAmIGF0dHJpYnV0ZXNcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbWVzc2FnZUJ1bmRsZSA9IG5ldyBNZXNzYWdlQnVuZGxlKGh0bWxQYXJzZXIsIFtdLCB7fSwgbG9jYWxlKTtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gZXh0cmFjdG9yID0gbmV3IEV4dHJhY3Rvcihob3N0LCBzdGF0aWNTeW1ib2xSZXNvbHZlciwgbWVzc2FnZUJ1bmRsZSwgcmVzb2x2ZXIpO1xuICAgICAgICByZXR1cm4geyBleHRyYWN0b3I6IGV4dHJhY3Rvciwgc3RhdGljUmVmbGVjdG9yOiBzdGF0aWNSZWZsZWN0b3IgfTtcbiAgICB9O1xuICAgIHJldHVybiBFeHRyYWN0b3I7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIF9OT19SRVNPVVJDRV9MT0FERVIgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBSZXNvdXJjZUxvYWRlciBpbXBsZW1lbnRhdGlvbiBoYXMgYmVlbiBwcm92aWRlZC4gQ2FuJ3QgcmVhZCB0aGUgdXJsIFxcXCJcIiArIHVybCArIFwiXFxcIlwiKTtcbiAgICB9XG59O1xudmFyIGJhc2VIdG1sUGFyc2VyID0gbmV3IEluamVjdGlvblRva2VuKCdIdG1sUGFyc2VyJyk7XG4vKipcbiAqIEEgc2V0IG9mIHByb3ZpZGVycyB0aGF0IHByb3ZpZGUgYEppdENvbXBpbGVyYCBhbmQgaXRzIGRlcGVuZGVuY2llcyB0byB1c2UgZm9yXG4gKiB0ZW1wbGF0ZSBjb21waWxhdGlvbi5cbiAqL1xudmFyIENPTVBJTEVSX1BST1ZJREVSUyA9IFtcbiAgICB7IHByb3ZpZGU6IMm1UmVmbGVjdG9yLCB1c2VWYWx1ZTogybVyZWZsZWN0b3IgfSxcbiAgICB7IHByb3ZpZGU6IMm1UmVmbGVjdG9yUmVhZGVyLCB1c2VFeGlzdGluZzogybVSZWZsZWN0b3IgfSxcbiAgICB7IHByb3ZpZGU6IFJlc291cmNlTG9hZGVyLCB1c2VWYWx1ZTogX05PX1JFU09VUkNFX0xPQURFUiB9LFxuICAgIFN1bW1hcnlSZXNvbHZlcixcbiAgICDJtUNvbnNvbGUsXG4gICAgTGV4ZXIsXG4gICAgUGFyc2VyLFxuICAgIHtcbiAgICAgICAgcHJvdmlkZTogYmFzZUh0bWxQYXJzZXIsXG4gICAgICAgIHVzZUNsYXNzOiBIdG1sUGFyc2VyLFxuICAgIH0sXG4gICAge1xuICAgICAgICBwcm92aWRlOiBJMThOSHRtbFBhcnNlcixcbiAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKHBhcnNlciwgdHJhbnNsYXRpb25zLCBmb3JtYXQsIGNvbmZpZywgY29uc29sZSkgeyByZXR1cm4gbmV3IEkxOE5IdG1sUGFyc2VyKHBhcnNlciwgdHJhbnNsYXRpb25zLCBmb3JtYXQsIGNvbmZpZy5taXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpOyB9LFxuICAgICAgICBkZXBzOiBbXG4gICAgICAgICAgICBiYXNlSHRtbFBhcnNlcixcbiAgICAgICAgICAgIFtuZXcgT3B0aW9uYWwoKSwgbmV3IEluamVjdChUUkFOU0xBVElPTlMpXSxcbiAgICAgICAgICAgIFtuZXcgT3B0aW9uYWwoKSwgbmV3IEluamVjdChUUkFOU0xBVElPTlNfRk9STUFUKV0sXG4gICAgICAgICAgICBbQ29tcGlsZXJDb25maWddLFxuICAgICAgICAgICAgW8m1Q29uc29sZV0sXG4gICAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgcHJvdmlkZTogSHRtbFBhcnNlcixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IEkxOE5IdG1sUGFyc2VyLFxuICAgIH0sXG4gICAgVGVtcGxhdGVQYXJzZXIsXG4gICAgRGlyZWN0aXZlTm9ybWFsaXplcixcbiAgICBDb21waWxlTWV0YWRhdGFSZXNvbHZlcixcbiAgICBERUZBVUxUX1BBQ0tBR0VfVVJMX1BST1ZJREVSLFxuICAgIFN0eWxlQ29tcGlsZXIsXG4gICAgVmlld0NvbXBpbGVyLFxuICAgIE5nTW9kdWxlQ29tcGlsZXIsXG4gICAgeyBwcm92aWRlOiBDb21waWxlckNvbmZpZywgdXNlVmFsdWU6IG5ldyBDb21waWxlckNvbmZpZygpIH0sXG4gICAgSml0Q29tcGlsZXIsXG4gICAgeyBwcm92aWRlOiBDb21waWxlciwgdXNlRXhpc3Rpbmc6IEppdENvbXBpbGVyIH0sXG4gICAgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LFxuICAgIHsgcHJvdmlkZTogRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCB1c2VFeGlzdGluZzogRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5IH0sXG4gICAgVXJsUmVzb2x2ZXIsXG4gICAgRGlyZWN0aXZlUmVzb2x2ZXIsXG4gICAgUGlwZVJlc29sdmVyLFxuICAgIE5nTW9kdWxlUmVzb2x2ZXIsXG5dO1xudmFyIEppdENvbXBpbGVyRmFjdG9yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBkZWZhdWx0T3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEppdENvbXBpbGVyRmFjdG9yeShkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICB2YXIgY29tcGlsZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgdXNlRGVidWc6IGlzRGV2TW9kZSgpLFxuICAgICAgICAgICAgdXNlSml0OiB0cnVlLFxuICAgICAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkLFxuICAgICAgICAgICAgbWlzc2luZ1RyYW5zbGF0aW9uOiBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5XYXJuaW5nLFxuICAgICAgICAgICAgZW5hYmxlTGVnYWN5VGVtcGxhdGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0gW2NvbXBpbGVyT3B0aW9uc10uY29uY2F0KGRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSml0Q29tcGlsZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVDb21waWxlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IFtdOyB9XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG9wdHMgPSBfbWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLmNvbmNhdChvcHRpb25zKSk7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGluamVjdG9yID0gUmVmbGVjdGl2ZUluamVjdG9yLnJlc29sdmVBbmRDcmVhdGUoW1xuICAgICAgICAgICAgQ09NUElMRVJfUFJPVklERVJTLCB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogQ29tcGlsZXJDb25maWcsXG4gICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBpbGVyQ29uZmlnKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBleHBsaWNpdCB2YWx1ZXMgZnJvbSB0aGUgY29tcGlsZXIgb3B0aW9ucyBvdmVyd3JpdGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgYXBwIHByb3ZpZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlSml0OiBvcHRzLnVzZUppdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBleHBsaWNpdCB2YWx1ZXMgZnJvbSB0aGUgY29tcGlsZXIgb3B0aW9ucyBvdmVyd3JpdGUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgYXBwIHByb3ZpZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEVuY2Fwc3VsYXRpb246IG9wdHMuZGVmYXVsdEVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nVHJhbnNsYXRpb246IG9wdHMubWlzc2luZ1RyYW5zbGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlTGVnYWN5VGVtcGxhdGU6IG9wdHMuZW5hYmxlTGVnYWN5VGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVwczogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRzLnByb3ZpZGVyc1xuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIGluamVjdG9yLmdldChDb21waWxlcik7XG4gICAgfTtcbiAgICByZXR1cm4gSml0Q29tcGlsZXJGYWN0b3J5O1xufSgpKTtcbkppdENvbXBpbGVyRmFjdG9yeS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogQ29tcGlsZXJJbmplY3RhYmxlIH0sXG5dO1xuLyoqXG4gKiBAbm9jb2xsYXBzZVxuICovXG5KaXRDb21waWxlckZhY3RvcnkuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbQ09NUElMRVJfT1BUSU9OUyxdIH0sXSB9LFxuXTsgfTtcbi8qKlxuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX2luaXRSZWZsZWN0b3IoKSB7XG4gICAgybVyZWZsZWN0b3IucmVmbGVjdGlvbkNhcGFiaWxpdGllcyA9IG5ldyDJtVJlZmxlY3Rpb25DYXBhYmlsaXRpZXMoKTtcbn1cbi8qKlxuICogQSBwbGF0Zm9ybSB0aGF0IGluY2x1ZGVkIGNvcmVQbGF0Zm9ybSBhbmQgdGhlIGNvbXBpbGVyLlxuICpcbiAqIFxcQGV4cGVyaW1lbnRhbFxuICovXG52YXIgcGxhdGZvcm1Db3JlRHluYW1pYyA9IGNyZWF0ZVBsYXRmb3JtRmFjdG9yeShwbGF0Zm9ybUNvcmUsICdjb3JlRHluYW1pYycsIFtcbiAgICB7IHByb3ZpZGU6IENPTVBJTEVSX09QVElPTlMsIHVzZVZhbHVlOiB7fSwgbXVsdGk6IHRydWUgfSxcbiAgICB7IHByb3ZpZGU6IENvbXBpbGVyRmFjdG9yeSwgdXNlQ2xhc3M6IEppdENvbXBpbGVyRmFjdG9yeSB9LFxuICAgIHsgcHJvdmlkZTogUExBVEZPUk1fSU5JVElBTElaRVIsIHVzZVZhbHVlOiBfaW5pdFJlZmxlY3RvciwgbXVsdGk6IHRydWUgfSxcbl0pO1xuLyoqXG4gKiBAcGFyYW0gez99IG9wdGlvbnNBcnJcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9tZXJnZU9wdGlvbnMob3B0aW9uc0Fycikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUppdDogX2xhc3REZWZpbmVkKG9wdGlvbnNBcnIubWFwKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBvcHRpb25zLnVzZUppdDsgfSkpLFxuICAgICAgICBkZWZhdWx0RW5jYXBzdWxhdGlvbjogX2xhc3REZWZpbmVkKG9wdGlvbnNBcnIubWFwKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBvcHRpb25zLmRlZmF1bHRFbmNhcHN1bGF0aW9uOyB9KSksXG4gICAgICAgIHByb3ZpZGVyczogX21lcmdlQXJyYXlzKG9wdGlvbnNBcnIubWFwKGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBvcHRpb25zLnByb3ZpZGVyczsgfSkpLFxuICAgICAgICBtaXNzaW5nVHJhbnNsYXRpb246IF9sYXN0RGVmaW5lZChvcHRpb25zQXJyLm1hcChmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gb3B0aW9ucy5taXNzaW5nVHJhbnNsYXRpb247IH0pKSxcbiAgICB9O1xufVxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHs/fSBhcmdzXG4gKiBAcmV0dXJuIHs/fVxuICovXG5mdW5jdGlvbiBfbGFzdERlZmluZWQoYXJncykge1xuICAgIGZvciAodmFyIC8qKiBAdHlwZSB7P30gKi8gaSA9IGFyZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGFyZ3NbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQHBhcmFtIHs/fSBwYXJ0c1xuICogQHJldHVybiB7P31cbiAqL1xuZnVuY3Rpb24gX21lcmdlQXJyYXlzKHBhcnRzKSB7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzdWx0ID0gW107XG4gICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkgeyByZXR1cm4gcGFydCAmJiByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIHBhcnQpOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBJbnRlcmZhY2UgdGhhdCBkZWZpbmVzIGhvdyBpbXBvcnQgc3RhdGVtZW50cyBzaG91bGQgYmUgZ2VuZXJhdGVkLlxuICogQGFic3RyYWN0XG4gKi9cbnZhciBJbXBvcnRSZXNvbHZlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW1wb3J0UmVzb2x2ZXIoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgZmlsZSBwYXRoIHRvIGEgbW9kdWxlIG5hbWUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBgaW1wb3J0LlxuICAgICAqIEkuZS4gYHBhdGgvdG8vaW1wb3J0ZWRGaWxlLnRzYCBzaG91bGQgYmUgaW1wb3J0ZWQgYnkgYHBhdGgvdG8vY29udGFpbmluZ0ZpbGUudHNgLlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSB7P30gaW1wb3J0ZWRGaWxlUGF0aFxuICAgICAqIEBwYXJhbSB7P30gY29udGFpbmluZ0ZpbGVQYXRoXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBJbXBvcnRSZXNvbHZlci5wcm90b3R5cGUuZmlsZU5hbWVUb01vZHVsZU5hbWUgPSBmdW5jdGlvbiAoaW1wb3J0ZWRGaWxlUGF0aCwgY29udGFpbmluZ0ZpbGVQYXRoKSB7IH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGdpdmVuIFN0YXRpY1N5bWJvbCBpbnRvIGFub3RoZXIgU3RhdGljU3ltYm9sIHRoYXQgc2hvdWxkIGJlIHVzZWRcbiAgICAgKiB0byBnZW5lcmF0ZSB0aGUgaW1wb3J0IGZyb20uXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIHs/fSBzeW1ib2xcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEltcG9ydFJlc29sdmVyLnByb3RvdHlwZS5nZXRJbXBvcnRBcyA9IGZ1bmN0aW9uIChzeW1ib2wpIHsgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGFyaXR5IG9mIGEgdHlwZS5cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcGFyYW0gez99IHN5bWJvbFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgSW1wb3J0UmVzb2x2ZXIucHJvdG90eXBlLmdldFR5cGVBcml0eSA9IGZ1bmN0aW9uIChzeW1ib2wpIHsgfTtcbiAgICByZXR1cm4gSW1wb3J0UmVzb2x2ZXI7XG59KCkpO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgQVBJcyBvZiB0aGUgY29tcGlsZXIgcGFja2FnZS5cbiAqXG4gKiA8ZGl2IGNsYXNzPVwiY2FsbG91dCBpcy1jcml0aWNhbFwiPlxuICogICA8aGVhZGVyPlVuc3RhYmxlIEFQSXM8L2hlYWRlcj5cbiAqICAgPHA+XG4gKiAgICAgQWxsIGNvbXBpbGVyIGFwaXMgYXJlIGN1cnJlbnRseSBjb25zaWRlcmVkIGV4cGVyaW1lbnRhbCBhbmQgcHJpdmF0ZSFcbiAqICAgPC9wPlxuICogICA8cD5cbiAqICAgICBXZSBleHBlY3QgdGhlIEFQSXMgaW4gdGhpcyBwYWNrYWdlIHRvIGtlZXAgb24gY2hhbmdpbmcuIERvIG5vdCByZWx5IG9uIHRoZW0uXG4gKiAgIDwvcD5cbiAqIDwvZGl2PlxuICovXG4vLyBUaGlzIGZpbGUgb25seSByZWV4cG9ydHMgY29udGVudCBvZiB0aGUgYHNyY2AgZm9sZGVyLiBLZWVwIGl0IHRoYXQgd2F5LlxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgcHVibGljIEFQSXMgb2YgdGhlIGNvbXBpbGVyIHBhY2thZ2UuXG4gKi9cbi8vIFRoaXMgZmlsZSBvbmx5IHJlZXhwb3J0cyBjb250ZW50IG9mIHRoZSBgc3JjYCBmb2xkZXIuIEtlZXAgaXQgdGhhdCB3YXkuXG5leHBvcnQgeyBWRVJTSU9OLCBURU1QTEFURV9UUkFOU0ZPUk1TLCBDb21waWxlckNvbmZpZywgSml0Q29tcGlsZXIsIERpcmVjdGl2ZVJlc29sdmVyLCBQaXBlUmVzb2x2ZXIsIE5nTW9kdWxlUmVzb2x2ZXIsIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcsIEludGVycG9sYXRpb25Db25maWcsIE5nTW9kdWxlQ29tcGlsZXIsIFZpZXdDb21waWxlciwgaXNTeW50YXhFcnJvciwgc3ludGF4RXJyb3IsIFRleHRBc3QsIEJvdW5kVGV4dEFzdCwgQXR0ckFzdCwgQm91bmRFbGVtZW50UHJvcGVydHlBc3QsIEJvdW5kRXZlbnRBc3QsIFJlZmVyZW5jZUFzdCwgVmFyaWFibGVBc3QsIEVsZW1lbnRBc3QsIEVtYmVkZGVkVGVtcGxhdGVBc3QsIEJvdW5kRGlyZWN0aXZlUHJvcGVydHlBc3QsIERpcmVjdGl2ZUFzdCwgUHJvdmlkZXJBc3QsIFByb3ZpZGVyQXN0VHlwZSwgTmdDb250ZW50QXN0LCBQcm9wZXJ0eUJpbmRpbmdUeXBlLCB0ZW1wbGF0ZVZpc2l0QWxsLCBDb21waWxlQW5pbWF0aW9uRW50cnlNZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvblN0YXRlTWV0YWRhdGEsIENvbXBpbGVBbmltYXRpb25TdGF0ZURlY2xhcmF0aW9uTWV0YWRhdGEsIENvbXBpbGVBbmltYXRpb25TdGF0ZVRyYW5zaXRpb25NZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvbk1ldGFkYXRhLCBDb21waWxlQW5pbWF0aW9uS2V5ZnJhbWVzU2VxdWVuY2VNZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvblN0eWxlTWV0YWRhdGEsIENvbXBpbGVBbmltYXRpb25BbmltYXRlTWV0YWRhdGEsIENvbXBpbGVBbmltYXRpb25XaXRoU3RlcHNNZXRhZGF0YSwgQ29tcGlsZUFuaW1hdGlvblNlcXVlbmNlTWV0YWRhdGEsIENvbXBpbGVBbmltYXRpb25Hcm91cE1ldGFkYXRhLCBpZGVudGlmaWVyTmFtZSwgaWRlbnRpZmllck1vZHVsZVVybCwgdmlld0NsYXNzTmFtZSwgcmVuZGVyZXJUeXBlTmFtZSwgaG9zdFZpZXdDbGFzc05hbWUsIGRpcldyYXBwZXJDbGFzc05hbWUsIGNvbXBvbmVudEZhY3RvcnlOYW1lLCBDb21waWxlU3VtbWFyeUtpbmQsIHRva2VuTmFtZSwgdG9rZW5SZWZlcmVuY2UsIENvbXBpbGVTdHlsZXNoZWV0TWV0YWRhdGEsIENvbXBpbGVUZW1wbGF0ZU1ldGFkYXRhLCBDb21waWxlRGlyZWN0aXZlTWV0YWRhdGEsIGNyZWF0ZUhvc3RDb21wb25lbnRNZXRhLCBDb21waWxlUGlwZU1ldGFkYXRhLCBDb21waWxlTmdNb2R1bGVNZXRhZGF0YSwgVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhLCBQcm92aWRlck1ldGEsIGZsYXR0ZW4sIHNvdXJjZVVybCwgdGVtcGxhdGVTb3VyY2VVcmwsIHNoYXJlZFN0eWxlc2hlZXRKaXRVcmwsIG5nTW9kdWxlSml0VXJsLCB0ZW1wbGF0ZUppdFVybCwgY3JlYXRlQW90Q29tcGlsZXIsIEFvdENvbXBpbGVyLCBhbmFseXplTmdNb2R1bGVzLCBhbmFseXplQW5kVmFsaWRhdGVOZ01vZHVsZXMsIGV4dHJhY3RQcm9ncmFtU3ltYm9scywgR2VuZXJhdGVkRmlsZSwgU3RhdGljUmVmbGVjdG9yLCBTdGF0aWNBbmREeW5hbWljUmVmbGVjdGlvbkNhcGFiaWxpdGllcywgU3RhdGljU3ltYm9sLCBTdGF0aWNTeW1ib2xDYWNoZSwgUmVzb2x2ZWRTdGF0aWNTeW1ib2wsIFN0YXRpY1N5bWJvbFJlc29sdmVyLCB1bmVzY2FwZUlkZW50aWZpZXIsIEFvdFN1bW1hcnlSZXNvbHZlciwgU3VtbWFyeVJlc29sdmVyLCBDT01QSUxFUl9QUk9WSURFUlMsIEppdENvbXBpbGVyRmFjdG9yeSwgcGxhdGZvcm1Db3JlRHluYW1pYywgY3JlYXRlVXJsUmVzb2x2ZXJXaXRob3V0UGFja2FnZVByZWZpeCwgY3JlYXRlT2ZmbGluZUNvbXBpbGVVcmxSZXNvbHZlciwgREVGQVVMVF9QQUNLQUdFX1VSTF9QUk9WSURFUiwgVXJsUmVzb2x2ZXIsIGdldFVybFNjaGVtZSwgUmVzb3VyY2VMb2FkZXIsIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgRXh0cmFjdG9yLCBJMThOSHRtbFBhcnNlciwgTWVzc2FnZUJ1bmRsZSwgU2VyaWFsaXplciwgWGxpZmYsIFhtYiwgWHRiLCBEaXJlY3RpdmVOb3JtYWxpemVyLCBQYXJzZXJFcnJvciwgUGFyc2VTcGFuLCBBU1QsIFF1b3RlLCBFbXB0eUV4cHIsIEltcGxpY2l0UmVjZWl2ZXIsIENoYWluLCBDb25kaXRpb25hbCwgUHJvcGVydHlSZWFkLCBQcm9wZXJ0eVdyaXRlLCBTYWZlUHJvcGVydHlSZWFkLCBLZXllZFJlYWQsIEtleWVkV3JpdGUsIEJpbmRpbmdQaXBlLCBMaXRlcmFsUHJpbWl0aXZlLCBMaXRlcmFsQXJyYXksIExpdGVyYWxNYXAsIEludGVycG9sYXRpb24sIEJpbmFyeSwgUHJlZml4Tm90LCBNZXRob2RDYWxsLCBTYWZlTWV0aG9kQ2FsbCwgRnVuY3Rpb25DYWxsLCBBU1RXaXRoU291cmNlLCBUZW1wbGF0ZUJpbmRpbmcsIFJlY3Vyc2l2ZUFzdFZpc2l0b3IsIEFzdFRyYW5zZm9ybWVyLCBUb2tlblR5cGUsIExleGVyLCBUb2tlbiwgRU9GLCBpc0lkZW50aWZpZXIsIGlzUXVvdGUsIFNwbGl0SW50ZXJwb2xhdGlvbiwgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQsIFBhcnNlciwgX1BhcnNlQVNULCBFUlJPUl9DT0xMRUNUT1JfVE9LRU4sIENvbXBpbGVNZXRhZGF0YVJlc29sdmVyLCBjb21wb25lbnRNb2R1bGVVcmwsIFRleHQsIEV4cGFuc2lvbiwgRXhwYW5zaW9uQ2FzZSwgQXR0cmlidXRlJDEgYXMgQXR0cmlidXRlLCBFbGVtZW50LCBDb21tZW50LCB2aXNpdEFsbCwgUGFyc2VUcmVlUmVzdWx0LCBUcmVlRXJyb3IsIEh0bWxQYXJzZXIsIEh0bWxUYWdEZWZpbml0aW9uLCBnZXRIdG1sVGFnRGVmaW5pdGlvbiwgVGFnQ29udGVudFR5cGUsIHNwbGl0TnNOYW1lLCBnZXROc1ByZWZpeCwgbWVyZ2VOc0FuZE5hbWUsIE5BTUVEX0VOVElUSUVTLCBJbXBvcnRSZXNvbHZlciwgZGVidWdPdXRwdXRBc3RBc1R5cGVTY3JpcHQsIFR5cGVTY3JpcHRFbWl0dGVyLCBQYXJzZUxvY2F0aW9uLCBQYXJzZVNvdXJjZUZpbGUsIFBhcnNlU291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLCBQYXJzZUVycm9yLCB0eXBlU291cmNlU3BhbiwgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBDc3NTZWxlY3RvciwgU2VsZWN0b3JNYXRjaGVyLCBTZWxlY3Rvckxpc3RDb250ZXh0LCBTZWxlY3RvckNvbnRleHQsIFN0eWxlc0NvbXBpbGVEZXBlbmRlbmN5LCBTdHlsZXNDb21waWxlUmVzdWx0LCBDb21waWxlZFN0eWxlc2hlZXQsIFN0eWxlQ29tcGlsZXIsIFRlbXBsYXRlUGFyc2VFcnJvciwgVGVtcGxhdGVQYXJzZVJlc3VsdCwgVGVtcGxhdGVQYXJzZXIsIHNwbGl0Q2xhc3NlcywgY3JlYXRlRWxlbWVudENzc1NlbGVjdG9yLCByZW1vdmVTdW1tYXJ5RHVwbGljYXRlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGlsZXIuanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlci5lczUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL2NvbXBpbGVyL0Bhbmd1bGFyL2NvbXBpbGVyLmVzNS5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),

/***/ 170:
/* exports provided: AppComponent */
/* exports used: AppComponent */
/*!******************************************!*\
  !*** ./Angular2App/app/app.component.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(/*! @angular/core */ 11);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return AppComponent; });\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\nvar AppComponent = (function () {\r\n    function AppComponent() {\r\n        this.name = 'Angular';\r\n    }\r\n    return AppComponent;\r\n}());\r\nAppComponent = __decorate([\r\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_core__[\"b\" /* Component */])({\r\n        selector: 'my-app',\r\n        template: \"<h1>Hello {{name}}</h1>\",\r\n    })\r\n], AppComponent);\r\n\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vQW5ndWxhcjJBcHAvYXBwL2FwcC5jb21wb25lbnQudHM/NDg1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdteS1hcHAnLFxyXG4gICAgdGVtcGxhdGU6IGA8aDE+SGVsbG8ge3tuYW1lfX08L2gxPmAsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgeyBuYW1lID0gJ0FuZ3VsYXInOyB9XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9Bbmd1bGFyMkFwcC9hcHAvYXBwLmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQU1BO0FBSkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),

/***/ 171:
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./Angular2App/app/main.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_platform_browser_dynamic__ = __webpack_require__(/*! @angular/platform-browser-dynamic */ 139);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__app_module__ = __webpack_require__(/*! ./app.module */ 141);\n\r\n\r\n__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__angular_platform_browser_dynamic__[\"a\" /* platformBrowserDynamic */])().bootstrapModule(__WEBPACK_IMPORTED_MODULE_1__app_module__[\"a\" /* AppModule */]);\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vQW5ndWxhcjJBcHAvYXBwL21haW4udHM/ZjczMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcclxuXHJcbmltcG9ydCB7IEFwcE1vZHVsZSB9IGZyb20gJy4vYXBwLm1vZHVsZSc7XHJcblxyXG5wbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9Bbmd1bGFyMkFwcC9hcHAvbWFpbi50cyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })

},[171]);